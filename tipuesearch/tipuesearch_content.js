var tipuesearch = {"pages":[{"title":" SPHINCS_LORENE ","text":"SPHINCS_LORENE S moothed P article H ydrodynamics IN C urved S pacetime — Interface to LORENE SPHINCS_LORENE is a modular, object-oriented, OMP parallelized FORTRAN 2018 code to produce binary neutron stars initial data to be evolved in time with the FORTRAN 2018 code SPHINCS_BSSN ( 1 ), using the C++ code LORENE ( 2 , 3 ). SPHINCS_LORENE acts as an interface between LORENE and SPHINCS_BSSN; it reads the spectral ID produced by LORENE and produces the SPH and BSSN ID to be read and evolved in time with SPHINCS_BSSN. Developer Info Francesco Torsello","tags":"home","loc":"index.html"},{"title":"convergence_test.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~convergence_test.f90~~EfferentGraph sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_particles_id.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefileconvergence_testf90EfferentGraph = svgPanZoom('#sourcefileconvergence_testf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs convergence_test Source Code convergence_test.f90 Source Code ! File:         convergence_test.f90 ! Author:       Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) PROGRAM convergence_test !***************************************************** !                                                    * ! Make a convergence test to check the validity of   * ! the code SPHINCS_LORENE.                           * !                                                    * ! FT 8.12.2020                                       * !                                                    * !***************************************************** USE sphincs_lorene IMPLICIT NONE ! Maximum length for strings, and for the number of imported binaries INTEGER , PARAMETER :: max_length = 50 ! Maximum number of binary systems INTEGER , PARAMETER :: max_n_bns = 50 ! Maximum number of particle distributions INTEGER , PARAMETER :: max_n_parts = 250 ! Loop limits for BSSN objects (for debugging; 3 is for production) INTEGER , PARAMETER :: min_bssn = 1 INTEGER , PARAMETER :: max_bssn = 3 ! Refinement level over which to compute contraints (make input parameter) INTEGER :: ref_lev ! Number of binary systems of neutron stars (BNS) to import INTEGER :: n_bns ! Export the constraints every constraints_step-th step INTEGER :: constraints_step ! Matrix storing the information on how to place particles for each bns ! object. Row i contains information about the i&#94;th bns object. INTEGER , PARAMETER :: test_int = - 112 INTEGER , DIMENSION ( max_n_bns , max_n_parts ) :: placer = test_int ! Grid spacing for the first BSSN object; the other two will have ! original_dx/2 and original_dx/4 as grid spacings DOUBLE PRECISION :: original_dx ! Rational ratio between the large grid spacing and the medium one, ! equal to the ratio between the medium grid spacing nd the small one DOUBLE PRECISION :: numerator_ratio_dx DOUBLE PRECISION :: denominator_ratio_dx DOUBLE PRECISION :: ratio_dx ! Strings storing different names for output files CHARACTER ( LEN = 500 ) :: namefile_parts , namefile_sph CHARACTER ( LEN = 500 ) :: namefile_bssn , name_logfile ! Array of strings storing the names of the LORENE BNS ID binary files CHARACTER ( LEN = max_length ), DIMENSION ( max_length ) :: filenames = \"0\" ! String storing the local path to the directory where the ! LORENE BNS ID files are stored CHARACTER ( LEN = max_length ) :: common_path ! String storing the local path to the directory where the ! SPH output is to be saved CHARACTER ( LEN = max_length ) :: sph_path ! String storing the local path to the directory where the ! spacetime output is to be saved CHARACTER ( LEN = max_length ) :: spacetime_path LOGICAL , PARAMETER :: debug = . FALSE . ! Logical variables to steer the execution LOGICAL :: export_bin , export_form , export_form_xy , export_form_x , & compute_constraints , export_constraints_xy , & export_constraints_x , export_constraints , & export_constraints_details , compute_parts_constraints , & one_lapse , zero_shift , run_sph , run_spacetime TYPE ( timer ) :: execution_timer ! Declaration of the bns (binary neutron star) object containing the ! LORENE ID TYPE ( bnslorene ) :: binary ! Declaration of the particles object containing the particle distribution TYPE ( particles ) :: particles_dist ! Declaration of the 3-component array storing the 3 bssn_id objects, ! containing the BSSN variables on the gravity grid TYPE ( bssn_id ), DIMENSION ( 3 ) :: bssn_forms ! Namelist containing parameters read from lorene_bns_id_parameters.par ! by the SUBROUTINE read_bns_id_parameters of this PROGRAM NAMELIST / bns_parameters / n_bns , common_path , filenames , placer , & export_bin , export_form , export_form_xy , & export_form_x , export_constraints_xy , & export_constraints_x , compute_constraints , & export_constraints , export_constraints_details , & constraints_step , compute_parts_constraints , & numerator_ratio_dx , denominator_ratio_dx , ref_lev , & one_lapse , zero_shift , show_progress , & run_sph , run_spacetime , sph_path , spacetime_path !---------------------------! !--  End of declarations  --! !---------------------------! ! Conversions of some polytropic constants from LORENE units to ! SPHINCS units, and vice versa !gamma= 2 !PRINT *, 0.0332278*k_lorene2hydrobase( gamma ) !PRINT * !gamma= 2.75 !PRINT *, 30000.0D0/k_lorene2hydrobase( gamma ) !gamma= 2.75 !PRINT *, 0.0332278*k_lorene2hydrobase( gamma ) !STOP CALL DATE_AND_TIME ( date , time , zone , values ) run_id = date // \"-\" // time !PRINT *, run_id !STOP execution_timer = timer ( \"execution_timer\" ) CALL execution_timer % start_timer () CALL read_bns_id_parameters () ratio_dx = numerator_ratio_dx / denominator_ratio_dx ! Check that ratio_dx > 1 IF ( ratio_dx <= 1.0D0 ) THEN PRINT * , \"** ERROR! numerator_ratio_dx has to be larger than \" , & \"denominator_ratio_dx. The current values are \" , & numerator_ratio_dx , \" and \" , denominator_ratio_dx , & \", respectively.\" PRINT * STOP ENDIF ! !-- Construct the bns object from the LORENE binary file ! binary = bnslorene ( TRIM ( common_path ) // \"/\" // TRIM ( filenames ( 1 )) ) ! Set the variables to decide on using the geodesic gauge or not ! (lapse=1, shift=0) CALL binary % set_one_lapse ( one_lapse ) CALL binary % set_zero_shift ( zero_shift ) ! !-- Construct the particles object from the bns object ! IF ( compute_parts_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Placing particles\" PRINT * , \"===================================================\" & // \"===============\" PRINT * particles_dist = particles ( binary , placer ( 1 , 1 ) ) ! !-- Compute the SPH variables ! PRINT * , \"===================================================\" & // \"=====================\" PRINT * , \" Computing SPH variables \" PRINT * , \"===================================================\" & // \"=====================\" PRINT * WRITE ( namefile_parts , \"(A1,I1,A1,I1,A1)\" ) & \"l\" , & 1 , \"-\" , 1 , \".\" particles_dist % export_bin = export_bin CALL particles_dist % compute_and_export_SPH_variables ( namefile_parts ) ! !-- Print the particle initial data to a formatted file ! IF ( export_form ) THEN WRITE ( namefile_parts , \"(A34)\" ) & \"lorene-bns-id-particles-form_1.dat\" particles_dist % export_form_xy = export_form_xy particles_dist % export_form_x = export_form_x CALL particles_dist % print_formatted_lorene_id_particles ( namefile_parts ) ENDIF ENDIF ! !-- Construct the bssn_id objects from the bns object ! construct_bssn_loop : DO itr3 = min_bssn , max_bssn , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Setting up BSSN object \" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * IF ( itr3 == 1 ) THEN bssn_forms ( itr3 ) = bssn_id ( binary ) original_dx = bssn_forms ( itr3 )% get_dx ( ref_lev ) ELSE IF ( itr3 == min_bssn ) THEN bssn_forms ( 1 ) = bssn_id ( binary ) original_dx = bssn_forms ( 1 )% get_dx ( ref_lev ) ENDIF bssn_forms ( itr3 ) = bssn_id ( binary , & original_dx / ( ratio_dx ** ( itr3 - 1 ) ), & original_dx / ( ratio_dx ** ( itr3 - 1 ) ), & original_dx / ( ratio_dx ** ( itr3 - 1 ) ) ) IF ( bssn_forms ( itr3 )% get_dx ( ref_lev ) /= & original_dx / ( ratio_dx ** ( itr3 - 1 ) ) ) THEN PRINT * , \" ** ERROR! The grid spacing #\" , itr3 , \",\" , & bssn_forms ( itr3 )% get_dx ( ref_lev ), & \" is not equal to dx/\" , ratio_dx ** ( itr3 - 1 ), \"= \" , & original_dx / ( ratio_dx ** ( itr3 - 1 ) ) STOP ENDIF ENDIF PRINT * , \"** The grid spacing is dx=\" , bssn_forms ( itr3 )% get_dx ( ref_lev ) PRINT * , \"** The number of grid points for dx is:\" , & bssn_forms ( itr3 )% get_ngrid_x ( ref_lev ), \"**3\" PRINT * ENDDO construct_bssn_loop IF ( debug ) THEN PRINT * , \"bssn_forms( 1 )% get_ngrid_x=\" , bssn_forms ( 1 )% get_ngrid_x ( ref_lev ) PRINT * , \"bssn_forms( 1 )% get_ngrid_y=\" , bssn_forms ( 1 )% get_ngrid_y ( ref_lev ) PRINT * , \"bssn_forms( 1 )% get_ngrid_z=\" , bssn_forms ( 1 )% get_ngrid_z ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_ngrid_x=\" , bssn_forms ( 2 )% get_ngrid_x ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_ngrid_y=\" , bssn_forms ( 2 )% get_ngrid_y ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_ngrid_z=\" , bssn_forms ( 2 )% get_ngrid_z ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_ngrid_x=\" , bssn_forms ( 3 )% get_ngrid_x ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_ngrid_y=\" , bssn_forms ( 3 )% get_ngrid_y ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_ngrid_z=\" , bssn_forms ( 3 )% get_ngrid_z ( ref_lev ) PRINT * PRINT * , \"bssn_forms( 1 )% get_dx \" , bssn_forms ( 1 )% get_dx ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_dy \" , bssn_forms ( 2 )% get_dx ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_dz \" , bssn_forms ( 3 )% get_dx ( ref_lev ) PRINT * !STOP ENDIF ! !-- Compute the BSSN variables ! compute_export_bssn_loop : DO itr3 = min_bssn , max_bssn , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN variables for BSSN formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A6,I1,A4)\" ) \"BSSN_l\" , itr3 , \".bin\" bssn_forms ( itr3 )% export_bin = export_bin bssn_forms ( itr3 )% export_form_xy = export_form_xy bssn_forms ( itr3 )% export_form_x = export_form_x CALL bssn_forms ( itr3 )% & compute_and_export_3p1_variables ( namefile_bssn ) ENDDO compute_export_bssn_loop ! !-- Print the BSSN initial data to a formatted file ! IF ( export_form ) THEN export_bssn_loop : DO itr3 = min_bssn , max_bssn , 1 WRITE ( namefile_bssn , \"(A24,I1,A4)\" ) & \"lorene-bns-id-bssn-form_\" , itr3 , \".dat\" bssn_forms ( itr3 )% export_form_xy = export_form_xy bssn_forms ( itr3 )% export_form_x = export_form_x CALL bssn_forms ( itr3 )% & print_formatted_lorene_id_3p1_variables ( namefile_bssn ) ENDDO export_bssn_loop ENDIF ! There doesn't seem to be a bug until here !STOP ! !-- Compute the BSSN constraints ! compute_export_bssn_constraints_loop : DO itr3 = min_bssn , max_bssn , 1 bssn_forms ( itr3 )% cons_step = constraints_step bssn_forms ( itr3 )% export_constraints = export_constraints bssn_forms ( itr3 )% export_constraints_details = & export_constraints_details bssn_forms ( itr3 )% export_constraints_xy = export_constraints_xy bssn_forms ( itr3 )% export_constraints_x = export_constraints_x IF ( compute_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN constraints for BSSN formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A17,I1,A4)\" ) \"bssn-constraints-\" , itr3 , \".dat\" WRITE ( name_logfile , \"(A28,I1,A4)\" ) & \"bssn-constraints-statistics-\" , itr3 CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( binary , & namefile_bssn , & name_logfile ) ENDIF IF ( compute_parts_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN constraints with particle data for BSSN\" , & \" formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A23,I1,A4)\" ) \"bssn-constraints-parts-\" , & itr3 , \".dat\" WRITE ( namefile_sph , \"(A12,I1,A4)\" ) \"sph-density-\" , itr3 , \".dat\" WRITE ( name_logfile , \"(A34,I1,A4)\" ) & \"bssn-constraints-parts-statistics-\" , itr3 , \".log\" CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( particles_dist , & namefile_bssn , & name_logfile ) ENDIF ENDDO compute_export_bssn_constraints_loop ! Here the bug appears. Since I am only computing the constraints with particles ! it must be in there !STOP ! !-- The BSSN formulations on grids with different resolutions are ready !-- to be used in a convergence test ! IF ( debug . AND . . FALSE . ) THEN PRINT * , bssn_forms ( 1 )% get_grid_point ( 1 + 1 , 1 + 2 , 1 + 1 , ref_lev ) PRINT * , bssn_forms ( 2 )% get_grid_point ( 1 + 2 , 1 + 4 , 1 + 2 , ref_lev ) PRINT * , bssn_forms ( 3 )% get_grid_point ( 1 + 4 , 1 + 8 , 1 + 4 , ref_lev ) PRINT * PRINT * , bssn_forms ( 1 )% get_grid_point ( 1 + 2 , 1 + 1 , 1 + 2 , ref_lev ) PRINT * , bssn_forms ( 2 )% get_grid_point ( 1 + 4 , 1 + 2 , 1 + 4 , ref_lev ) PRINT * , bssn_forms ( 3 )% get_grid_point ( 1 + 8 , 1 + 4 , 1 + 8 , ref_lev ) PRINT * PRINT * , ABS ( bssn_forms ( 1 )% get_HC ( 1 + 30 , 1 + 25 , 1 + 17 , ref_lev )) PRINT * , ABS ( bssn_forms ( 2 )% get_HC ( 1 + 2 * 30 , 1 + 2 * 25 , 1 + 2 * 17 , ref_lev )) PRINT * , ABS ( bssn_forms ( 3 )% get_HC ( 1 + 4 * 30 , 1 + 4 * 25 , 1 + 4 * 17 , ref_lev )) PRINT * PRINT * , ABS ( bssn_forms ( 1 )% get_HC ( 1 + 30 , 1 + 25 , 1 + 17 , ref_lev )) & - ABS ( bssn_forms ( 2 )% get_HC ( 1 + 2 * 30 , 1 + 2 * 25 , 1 + 2 * 17 , ref_lev )) PRINT * , ABS ( bssn_forms ( 2 )% get_HC ( 1 + 2 * 30 , 1 + 2 * 25 , 1 + 2 * 17 , ref_lev )) & - ABS ( bssn_forms ( 3 )% get_HC ( 1 + 4 * 30 , 1 + 4 * 25 , 1 + 4 * 17 , ref_lev )) STOP ENDIF ! !-- Perform the convergence test with the appropriate constraints ! IF ( compute_constraints ) THEN PRINT * , \"** Performing convergence test with constraints computed \" , & \"without particle data.\" PRINT * CALL cauchy_convergence_test_unknown ( bssn_forms ( 1 ), bssn_forms ( 2 ), & bssn_forms ( 3 ), 1 , ref_lev ) CALL cauchy_convergence_test_known ( bssn_forms ( 2 ), bssn_forms ( 3 ), 1 , ref_lev ) ENDIF IF ( compute_parts_constraints ) THEN PRINT * , \"** Performing convergence test with constraints computed \" , & \"with particle data.\" PRINT * CALL cauchy_convergence_test_unknown ( bssn_forms ( 1 ), bssn_forms ( 2 ), & bssn_forms ( 3 ), 2 , ref_lev ) CALL cauchy_convergence_test_known ( bssn_forms ( 2 ), bssn_forms ( 3 ), 2 , ref_lev ) ENDIF CALL execution_timer % stop_timer () CALL DATE_AND_TIME ( date , time , zone , values ) end_time = date // \"-\" // time !STOP ! !-- Print the timers ! PRINT * , \"** Timing.\" PRINT * PRINT * PRINT * , \" * BSSN formulation with uniform resolution:\" , & bssn_forms ( 1 )% get_dx ( ref_lev ) PRINT * , \"    and number of points:\" , bssn_forms ( 1 )% get_ngrid_x ( ref_lev ), & \"**3\" !original_dx CALL bssn_forms ( 1 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% bssn_computer_timer % print_timer ( 2 ) PRINT * PRINT * , \" * BSSN formulation with uniform resolution:\" , & bssn_forms ( 2 )% get_dx ( ref_lev ) PRINT * , \"    and number of points:\" , bssn_forms ( 2 )% get_ngrid_x ( ref_lev ), & \"**3\" !original_dx/2 CALL bssn_forms ( 2 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 2 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 2 )% bssn_computer_timer % print_timer ( 2 ) PRINT * PRINT * , \" * BSSN formulation with uniform resolution:\" , & bssn_forms ( 3 )% get_dx ( ref_lev ) PRINT * , \"    and number of points:\" , bssn_forms ( 3 )% get_ngrid_x ( ref_lev ), & \"**3\" !original_dx/4 CALL bssn_forms ( 3 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 3 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 3 )% bssn_computer_timer % print_timer ( 2 ) PRINT * PRINT * , \" * Total:\" CALL execution_timer % print_timer ( 2 ) PRINT * PRINT * PRINT * , \"** Run started on \" , run_id , \" and ended on \" , end_time PRINT * ! !-- Destruct the LORENE Bin_NS object by hand, since the pointer to it is !-- global (because it is bound to C++) and cannot be nullified by the !-- destructor of bns. In case of multiple bns objects, this would lead !-- to problems... !-- TODO: fix this ! CALL binary % destruct_binary () CONTAINS SUBROUTINE cauchy_convergence_test_known ( formul_dx , formul_dx2 , & use_constraints , ref_lev ) IMPLICIT NONE CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: formul_dx , formul_dx2 INTEGER , INTENT ( IN ) :: use_constraints , ref_lev INTEGER :: ix , iy , iz , nx , ny , nz , unit_cauchy_ct , unit_cauchy_parts_ct , & min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid DOUBLE PRECISION , PARAMETER :: tiny_real = 1 D - 30 DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: grid_dx DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx2 DOUBLE PRECISION , DIMENSION (:,:,:), ALLOCATABLE :: convergence_factor CHARACTER ( LEN = : ), ALLOCATABLE :: name_cauchy_ct , name_cauchy_parts_ct LOGICAL :: exist nx = formul_dx % get_ngrid_x ( ref_lev ) ny = formul_dx % get_ngrid_y ( ref_lev ) nz = formul_dx % get_ngrid_z ( ref_lev ) nx = FLOOR ( DBLE ( nx - 1 ) / denominator_ratio_dx ) + 1 ny = FLOOR ( DBLE ( ny - 1 ) / denominator_ratio_dx ) + 1 nz = FLOOR ( DBLE ( nz - 1 ) / denominator_ratio_dx ) + 1 ALLOCATE ( grid_dx ( 3 , nx , ny , nz ) ) ALLOCATE ( abs_grid ( 3 , nx , ny , nz ) ) ALLOCATE ( convergence_factor ( nx , ny , nz ) ) PRINT * , \"** Computing convergence factor...\" choose_constraints : SELECT CASE ( use_constraints ) CASE ( 1 ) shared_grid_loops1 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( formul_dx % get_HC ( 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ))& / ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) & + tiny_real ) & ) + tiny_real ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops1 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_ct = 3109 name_cauchy_ct = \"cauchy_convergence_test_known.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_ct) ) WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing he arrays in \" , & TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_ct ) PRINT * CASE ( 2 ) shared_grid_loops2 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( ABS ( & formul_dx % get_HC_parts ( 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev )& / ( formul_dx2 % get_HC_parts ( 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) & + tiny_real ) & ) + tiny_real ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops2 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_parts_ct = 3111 name_cauchy_parts_ct = \"cauchy_convergence_test_known_parts.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_parts_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_parts_ct) ) WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing e arrays in \" , & TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_parts_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_parts_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_parts_ct ) PRINT * CASE DEFAULT PRINT * , \"** There is no well defined algorithm \" & // \"corresponding to the number\" , use_constraints PRINT * , \" * Please set use_constraints to 1 or 2.\" STOP END SELECT choose_constraints DEALLOCATE ( grid_dx ) END SUBROUTINE cauchy_convergence_test_known SUBROUTINE cauchy_convergence_test_unknown ( formul_dx , formul_dx2 , & formul_dx4 , use_constraints , & ref_lev ) IMPLICIT NONE CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: formul_dx , formul_dx2 , formul_dx4 INTEGER , INTENT ( IN ) :: use_constraints , ref_lev INTEGER :: ix , iy , iz , nx , ny , nz , unit_cauchy_ct , unit_cauchy_parts_ct , & min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid DOUBLE PRECISION , PARAMETER :: tiny_real = 1 D - 30 DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: grid_dx DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx2 DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx4 DOUBLE PRECISION , DIMENSION (:,:,:), ALLOCATABLE :: convergence_factor CHARACTER ( LEN = : ), ALLOCATABLE :: name_cauchy_ct , name_cauchy_parts_ct LOGICAL :: exist nx = formul_dx % get_ngrid_x ( ref_lev ) ny = formul_dx % get_ngrid_y ( ref_lev ) nz = formul_dx % get_ngrid_z ( ref_lev ) nx = FLOOR ( DBLE ( nx - 1 ) / denominator_ratio_dx ** 2 ) + 1 ny = FLOOR ( DBLE ( ny - 1 ) / denominator_ratio_dx ** 2 ) + 1 nz = FLOOR ( DBLE ( nz - 1 ) / denominator_ratio_dx ** 2 ) + 1 ALLOCATE ( grid_dx ( 3 , nx , ny , nz ) ) ALLOCATE ( abs_grid ( 3 , nx , ny , nz ) ) ALLOCATE ( convergence_factor ( nx , ny , nz ) ) PRINT * , \"** Computing convergence factor...\" IF ( debug ) THEN PRINT * , \"formul_dx%  get_ngrid_x=\" , formul_dx % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx%  get_ngrid_y=\" , formul_dx % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx%  get_ngrid_z=\" , formul_dx % get_ngrid_z ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_x=\" , formul_dx2 % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_y=\" , formul_dx2 % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_z=\" , formul_dx2 % get_ngrid_z ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_x=\" , formul_dx4 % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_y=\" , formul_dx4 % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_z=\" , formul_dx4 % get_ngrid_z ( ref_lev ) PRINT * PRINT * , \"formul_dx%  get_dx=\" , formul_dx % get_dx ( ref_lev ) PRINT * , \"formul_dx2% get_dy=\" , formul_dx2 % get_dx ( ref_lev ) PRINT * , \"formul_dx4% get_dz=\" , formul_dx4 % get_dx ( ref_lev ) PRINT * !STOP ENDIF choose_constraints : SELECT CASE ( use_constraints ) CASE ( 1 ) shared_grid_loops3 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 ! grid_dx( :, 1 + ix, 1 + iy, 1 + iz ) = & !            formul_dx%  get_grid_point(  & !                             1 + ix,   1 + iy,   1 + iz   ) ! point_dx2= formul_dx2% get_grid_point( & !                             1 + 2*ix, 1 + 2*iy, 1 + 2*iz ) ! point_dx4= formul_dx4% get_grid_point( & !                             1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) ! ! IF( grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(1) & !.OR. grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(1) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(2) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(2) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(3) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(3) & grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ) point_dx4 = formul_dx4 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ), & point_dx4 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ), & point_dx4 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ), & point_dx4 ( 3 ) PRINT * STOP ENDIF !convergence_factor( 1 + ix, 1 + iy, 1 + iz )= & ! LOG( & ! ABS( & ! ( ABS(formul_dx%  get_HC( 1 + ix,   1 + iy,   1 + iz )) & ! - ABS(formul_dx2% get_HC( 1 + 2*ix, 1 + 2*iy, 1 + 2*iz )))& !/( ABS(formul_dx2% get_HC( 1 + 2*ix, 1 + 2*iy, 1 + 2*iz )) & ! - ABS(formul_dx4% get_HC( 1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) )& ! + 0*tiny_real ) & ! ) & ! )/ln2!/LOG(2.0) convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( ABS ( formul_dx % get_HC ( 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev )) & - ABS ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ))) & / ( ABS ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )) & - ABS ( formul_dx4 % get_HC ( 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) ) & + tiny_real ) & ) + tiny_real & ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops3 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_ct = 3108 name_cauchy_ct = \"cauchy_convergence_test_unknown.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_ct) ) WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_ct ) PRINT * CASE ( 2 ) shared_grid_loops4 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 ! grid_dx( :, 1 + ix, 1 + iy, 1 + iz ) = & !            formul_dx%  get_grid_point(  & !                             1 + ix,   1 + iy,   1 + iz   ) ! point_dx2= formul_dx2% get_grid_point( & !                             1 + 2*ix, 1 + 2*iy, 1 + 2*iz ) ! point_dx4= formul_dx4% get_grid_point( & !                             1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) ! ! IF( grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(1) & !.OR. grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(1) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(2) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(2) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(3) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(3) & grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ) point_dx4 = formul_dx4 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ), & point_dx4 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ), & point_dx4 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ), & point_dx4 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( ABS ( formul_dx % get_HC_parts ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev )) & - ABS ( formul_dx2 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )))& / ( ABS ( formul_dx2 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )) & - ABS ( formul_dx4 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) )& + tiny_real ) & ) + tiny_real & ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops4 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_parts_ct = 3110 name_cauchy_parts_ct = \"cauchy_convergence_test_unknown_parts.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_parts_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_parts_ct) ) WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_parts_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_parts_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_parts_ct ) PRINT * CASE DEFAULT PRINT * , \"** There is no well defined algorithm \" & // \"corresponding to the number\" , use_constraints PRINT * , \" * Please set use_constraints to 1 or 2.\" STOP END SELECT choose_constraints DEALLOCATE ( grid_dx ) END SUBROUTINE cauchy_convergence_test_unknown SUBROUTINE read_bns_id_parameters () IMPLICIT NONE INTEGER :: stat INTEGER , PARAMETER :: unit_parameters = 17 CHARACTER ( LEN = : ), ALLOCATABLE :: lorene_bns_id_parameters CHARACTER ( LEN = : ), ALLOCATABLE :: msg lorene_bns_id_parameters = 'sphincs_lorene_bns_parameters.par' INQUIRE ( FILE = lorene_bns_id_parameters , EXIST = file_exists ) IF ( file_exists ) THEN OPEN ( UNIT = unit_parameters , FILE = lorene_bns_id_parameters , & STATUS = 'OLD' ) ELSE PRINT * PRINT * , '** ERROR: ' , lorene_bns_id_parameters , \" file not found!\" PRINT * STOP ENDIF READ ( UNIT = unit_parameters , NML = bns_parameters , IOSTAT = stat , & IOMSG = msg ) IF ( stat /= 0 ) THEN PRINT * , \"** ERROR: Error in reading \" , lorene_bns_id_parameters ,& \". The IOSTAT variable is \" , stat , & \"The error message is\" , msg STOP ENDIF CLOSE ( UNIT = unit_parameters ) DO itr = 1 , max_length , 1 IF ( TRIM ( filenames ( itr )). NE . \"0\" ) THEN cnt = cnt + 1 ENDIF ENDDO IF ( cnt . NE . n_bns ) THEN PRINT * , \"** ERROR! The number of file names is\" , cnt , & \"and n_bns=\" , n_bns , \". The two should be the same.\" PRINT * STOP ENDIF !DO itr= 1, n_bns, 1 !  DO itr2= 1, max_n_parts, 1 !    IF( placer( itr, itr2 ) == test_int )THEN !      PRINT * !      PRINT *, \"** ERROR! The array placer does not have \", & !               \"enough components to specify all the desired \", & !               \"particle distributions. Specify the \", & !               \"components in file lorene_bns_id_particles.par\" !      PRINT * !      STOP !    ENDIF !  ENDDO !ENDDO END SUBROUTINE read_bns_id_parameters END PROGRAM convergence_test","tags":"","loc":"sourcefile/convergence_test.f90.html"},{"title":"write_par_eos.f90 – SPHINCS_LORENE","text":"Contents Programs write_par_eos Source Code write_par_eos.f90 Source Code ! File:         write_par_eos.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) PROGRAM write_par_eos USE constants , ONLY : lorene2hydrobase , kg2g , m2cm , & k_lorene2hydrobase_piecewisepolytrope USE pwp_EOS , ONLY : Gamma0 , K0 , select_EOS_parameters , gen_pwp_eos , & get_rho_0 , get_rho_1 , get_rho_2 , & get_Gamma1 , get_Gamma2 , get_Gamma3 , & get_K1 , get_K2 , get_K3 IMPLICIT NONE INTEGER , PARAMETER :: npoly = 4 INTEGER :: ios !DOUBLE PRECISION:: gamma1_lorene, gamma2_lorene, gamma3_lorene DOUBLE PRECISION :: kappa0_lorene , log10_p0_lorene , log10_rho0_lorene , & log10_rho1_lorene , log10_rho2_lorene LOGICAL :: exist CHARACTER ( LEN = : ), ALLOCATABLE :: namefile CHARACTER ( LEN = : ), ALLOCATABLE :: err_msg CHARACTER ( LEN = 4 ) :: eos #ifdef __INTEL_COMPILER WRITE ( * , '(\"Please write a 4 character string containing the name of the piecewise polytropic EOS: \",' ) #endif #ifdef __GFORTRAN__ WRITE ( * , '(\"Please write a 4 character string containing the name of the piecewise polytropic EOS: \")' ) #endif READ ( * , '(A)' ) eos CALL select_EOS_parameters ( eos ) kappa0_lorene = K0 / k_lorene2hydrobase_piecewisepolytrope ( Gamma0 ) log10_p0_lorene = LOG10 ( K0 / k_lorene2hydrobase_piecewisepolytrope ( Gamma0 ) & * ( get_rho_0 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) ** ( Gamma0 ) ) log10_rho0_lorene = LOG10 ( get_rho_0 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) log10_rho1_lorene = LOG10 ( get_rho_1 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) log10_rho2_lorene = LOG10 ( get_rho_2 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) namefile = \"par_eos.d\" INQUIRE ( FILE = TRIM ( namefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( namefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( namefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(A69)\" ) & \"110        Type of the EOS (cf. documentation of Eos::eos_multi_poly)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(A16,A4,A4)\" ) & \"Multipolytropic \" , eos , \" EOS\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(I1,A52)\" ) & npoly , \"npoly,         number of polytropes\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A43)\" ) & Gamma0 , \"gamma_0,       crust (here from SLy)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A69)\" ) & get_Gamma1 (), \"gamma_1,       array of adiabatic indexes (from crust to core)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A14)\" ) & get_Gamma2 (), \"gamma_2\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A14)\" ) & get_Gamma3 (), \"gamma_3\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(ES16.9E3,A73)\" ) & kappa0_lorene , & \"kappa0,        pressure coefficient for gam_0 polytrope (here from SLy)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A80)\" ) & log10_p0_lorene , & \"log10(P0/c&#94;2), log of pressure between gam_0 and gam_1 (dyne/cm&#94;2/c_cgs&#94;2)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A71)\" ) & log10_rho0_lorene , & \"log10(rho_0),  array of logs of the transition densities (g/cm&#94;3)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A18)\" ) & log10_rho1_lorene , \"log10(rho_1)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A18)\" ) & log10_rho2_lorene , \"log10(rho_2)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F3.1,A79)\" ) & 0.0 , \"decInc,        array (size npoly-1) of percentages which change \" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F3.1,A71)\" ) & 0.0 , \" the transition densities by changing the \" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F3.1,A75)\" ) & 0.0 , \" transition enthalpies (set to 0. to disable)\" CLOSE ( UNIT = 2 ) PRINT * PRINT * , \"Parameter file \" , namefile , \" written.\" PRINT * END PROGRAM write_par_eos","tags":"","loc":"sourcefile/write_par_eos.f90.html"},{"title":"sphincs_lorene_bns.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~sphincs_lorene_bns.f90~~EfferentGraph sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_particles_id.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefilesphincs_lorene_bnsf90EfferentGraph = svgPanZoom('#sourcefilesphincs_lorene_bnsf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs sphincs_lorene_bns Source Code sphincs_lorene_bns.f90 Source Code ! File:         setup_lorene_id.f90 ! Author:       Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) PROGRAM sphincs_lorene_bns !***************************************************** !                                                    * ! Use the MODULE sphincs_lorene to export binary     * ! files containing the initial data (ID) required    * ! by the evolution code in SPHINCS, and built using  * ! the binary files produced by LORENE and containing * ! the binary neutron stars (BNS) ID.                 * !                                                    * ! FT 28.10.2020                                      * !                                                    * !***************************************************** #ifdef __INTEL_COMPILER USE IFPORT , ONLY : MAKEDIRQQ #endif USE sphincs_lorene USE constants , ONLY : lorene2hydrobase , c_light2 , k_lorene2hydrobase , & k_lorene2hydrobase_piecewisepolytrope , MSun_geo , & kg2g , m2cm , m0c2 IMPLICIT NONE ! Maximum length for strings, and for the number of imported binaries INTEGER , PARAMETER :: max_length = 50 ! Maximum number of binary systems INTEGER , PARAMETER :: max_n_bns = 50 ! Maximum number of particle distributions INTEGER , PARAMETER :: max_n_parts = 250 ! Number of binary systems of neutron stars (BNS) to import INTEGER :: n_bns , ref_lev , i_matter ! Export the constraints every constraints_step-th step INTEGER :: constraints_step , last_level ! Matrix storing the information on how to place particles for each bns ! object. Row i contains information about the i&#94;th bns object. INTEGER , PARAMETER :: test_int = - 112 INTEGER , DIMENSION ( max_n_bns , max_n_parts ) :: placer = test_int ! Rational ratio between the large grid spacing and the medium one, ! equal to the ratio between the medium grid spacing nd the small one ! Not used in this PROGRAM, but needed since the PROGRAM reads the same ! parameter ile as the convergence_test PROGRAM DOUBLE PRECISION :: numerator_ratio_dx DOUBLE PRECISION :: denominator_ratio_dx ! String storing the name of the phyical system CHARACTER ( LEN = max_length ) :: system ! Strings storing different names for output files CHARACTER ( LEN = 500 ) :: namefile_parts , namefile_parts_bin , namefile_sph CHARACTER ( LEN = 500 ) :: namefile_bssn , namefile_bssn_bin , name_logfile ! Array of strings storing the names of the LORENE BNS ID binary files CHARACTER ( LEN = max_length ), DIMENSION ( max_length ) :: filenames = \"0\" ! String storing the local path to the directory where the ! LORENE BNS ID files are stored CHARACTER ( LEN = max_length ) :: common_path ! String storing the local path to the directory where the ! SPH output is to be saved CHARACTER ( LEN = max_length ) :: sph_path ! String storing the local path to the directory where the ! spacetime output is to be saved CHARACTER ( LEN = max_length ) :: spacetime_path LOGICAL :: exist LOGICAL ( 4 ) :: dir_out ! Logical variables to steer the execution LOGICAL :: export_bin , export_form , export_form_xy , export_form_x , & compute_constraints , export_constraints_xy , & export_constraints_x , export_constraints , & export_constraints_details , compute_parts_constraints , & one_lapse , zero_shift , run_sph , run_spacetime TYPE ( timer ) :: execution_timer ! Declaration of the allocatable array storing the bns objects, ! containing the LORENE ID for different BNS TYPE ( bnslorene ), DIMENSION (:), ALLOCATABLE :: binaries CLASS ( idbase ), DIMENSION (:), ALLOCATABLE :: idata ! Declaration of the allocatable array storing the particles objects, ! containing the particle distributions for each bns object. ! Multiple particle objects can contain different particle distributions ! for the same bns object. TYPE ( particles ), DIMENSION (:,:), ALLOCATABLE :: particles_dist ! Declaration of the allocatable array storing the bssn_id objects, ! containing the BSSN variables on the gravity grid ofr each bns object TYPE ( bssn_id ), DIMENSION (:), ALLOCATABLE :: bssn_forms ! Namelist containing parameters read from lorene_bns_id_parameters.par ! by the SUBROUTINE read_bns_id_parameters of this PROGRAM NAMELIST / bns_parameters / system , n_bns , common_path , filenames , placer , & export_bin , export_form , export_form_xy , & export_form_x , export_constraints_xy , & export_constraints_x , compute_constraints , & export_constraints , export_constraints_details , & constraints_step , compute_parts_constraints , & numerator_ratio_dx , denominator_ratio_dx , ref_lev , & one_lapse , zero_shift , show_progress , & run_sph , run_spacetime , sph_path , spacetime_path !---------------------------! !--  End of declarations  --! !---------------------------! !PRINT *, lorene2hydrobase !PRINT *, 2.45191D-4/lorene2hydrobase/1000 !PRINT *, LOG10(2.45191D-4/lorene2hydrobase/1000) !PRINT * !PRINT *, LOG10(10**(34.616)/c_light2) !STOP !PRINT *, \"** Polytropic constant used for gamma= 2.75 single polytrope:\" !PRINT *, \"   k used in LORENE= \", 0.01691726009823966 !PRINT *, \"   k converted in SPHINCS units= \", & !                               0.01691726009823966*k_lorene2hydrobase(2.75D0) !PRINT * !PRINT *, \"** Polytropic constant used for gamma= 2 single polytrope:\" !PRINT *, \"   k used in LORENE= \", 0.02686965902663748 !PRINT *, \"   k converted in SPHINCS units= \", & !                               0.02686965902663748*k_lorene2hydrobase(2.0D0) !PRINT * !PRINT *, \"** Polytropic constant used for the crust in PWP:\" !PRINT *, \"   k used in LORENE= \", 3.99874D-8 !PRINT *, \"   k converted in SPHINCS units= \", & !                3.99874D-8*k_lorene2hydrobase_piecewisepolytrope(1.35692395D0) !PRINT * !PRINT *, \"** Polytropic constant used for the crust in PWP:\" !PRINT *, \"   k used in LORENE= \", 8.948185D-2 !PRINT *, \"   k converted in SPHINCS units= \", & !                               8.948185D-2*k_lorene2hydrobase(1.35692395D0) !PRINT * !PRINT *, \"   k used in LORENE, corresponding to k-100 in SPHINCS units= \", & !         100/k_lorene2hydrobase(2.0D0) ! Our testbed cases are gamma= 2.75, k= 30000; and gamma=2, k= 100 ! in SPHINCS units ! 7.901e+14 density for 1.4 GRAVITATIONAL mass, poly 2 ! 1.4-1.4 systems for both ; 1.6-1.6 ; 1.2-1.8 GRAVIATIONAL masses !STOP CALL DATE_AND_TIME ( date , time , zone , values ) run_id = date // \"-\" // time execution_timer = timer ( \"execution_timer\" ) CALL execution_timer % start_timer () CALL read_bns_id_parameters () ! !-- Check that the specified subdirectories exist. If not, create them !-- TODO: this compils with ifort, but not with gfortran ! #ifdef __INTEL_COMPILER INQUIRE ( DIRECTORY = TRIM ( sph_path ), EXIST = exist ) IF ( . NOT . exist ) THEN dir_out = MAKEDIRQQ ( TRIM ( sph_path ) ) ELSE dir_out = . TRUE . ENDIF IF ( . NOT . dir_out ) THEN PRINT * , \"** ERROR! Failed to create subdirectory \" , TRIM ( sph_path ) PRINT * , \"Stopping...\" PRINT * STOP ENDIF INQUIRE ( DIRECTORY = TRIM ( spacetime_path ), EXIST = exist ) IF ( . NOT . exist ) THEN dir_out = MAKEDIRQQ ( TRIM ( spacetime_path ) ) ELSE dir_out = . TRUE . ENDIF IF ( . NOT . dir_out ) THEN PRINT * , \"** ERROR! Failed to create subdirectory \" , TRIM ( sph_path ) PRINT * , \"Stopping...\" PRINT * STOP ENDIF #endif #ifdef __GFORTRAN__ INQUIRE ( FILE = TRIM ( sph_path ) // \"/.\" , EXIST = exist ) IF ( . NOT . exist ) THEN PRINT * , \"** ERROR! Directory \" , TRIM ( sph_path ), \" does not exist!\" PRINT * , \"   Please create it and re-run the executable. Stopping...\" STOP ENDIF INQUIRE ( FILE = TRIM ( spacetime_path ) // \"/.\" , EXIST = exist ) IF ( . NOT . exist ) THEN PRINT * , \"** ERROR! Directory \" , TRIM ( spacetime_path ), \" does not exist!\" PRINT * , \"   Please create it and re-run the executable. Stopping...\" STOP ENDIF #endif ! Allocate needed memory !ALLOCATE( binaries      ( n_bns ) ) !ALLOCATE( diffrotstars  ( n_bns ) ) IF ( TRIM ( system ) == \"BNS\" ) THEN ALLOCATE ( bnslorene :: idata ( n_bns ) ) ELSEIF ( TRIM ( system ) == \"DRS\" ) THEN ALLOCATE ( diffstarlorene :: idata ( n_bns ) ) ELSE PRINT * , \"** ERROR! Unknown name for the physical system: \" , TRIM ( system ) PRINT * , \"   Set the variable 'system' in the parameter file \" , & \"sphincs_lorene_parameters.par to one of the values listed there.\" PRINT * , \"   Stopping...\" PRINT * STOP ENDIF ALLOCATE ( particles_dist ( n_bns , max_n_parts ) ) ALLOCATE ( bssn_forms ( n_bns ) ) ! !-- Construct the LORENE ID from the LORENE binary files ! ! build_bns_loop: DO itr= 1, n_bns, 1 !   binaries( itr )= bnslorene( TRIM(common_path)//TRIM(filenames( itr )) ) !   ! Set the variables to decide on using the geodesic gauge or not !   ! (lapse=1, shift=0) !   binaries( itr )% one_lapse = one_lapse !   binaries( itr )% zero_shift= zero_shift ! ENDDO build_bns_loop build_drs_loop : DO itr = 1 , n_bns , 1 idata ( itr ) = diffstarlorene ( TRIM ( common_path ) // TRIM ( filenames ( itr )) ) ! Set the variables to decide on using the geodesic gauge or not ! (lapse=1, shift=0) CALL idata ( itr )% set_one_lapse ( one_lapse ) CALL idata ( itr )% set_zero_shift ( zero_shift ) ENDDO build_drs_loop !STOP IF ( run_sph ) THEN ! !-- Construct the particles objects from the bns objects ! place_hydro_id_loops : DO itr3 = 1 , n_bns , 1 part_distribution_loop : DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT part_distribution_loop ELSE PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Placing particles for \" // TRIM ( system ), itr3 , & \", distribution\" , itr4 PRINT * , \"===================================================\" & // \"===============\" PRINT * particles_dist ( itr3 , itr4 ) = particles ( idata ( itr3 ), & placer ( itr3 , itr4 ) ) ENDIF ENDDO part_distribution_loop ENDDO place_hydro_id_loops !STOP compute_export_sph_loops : DO itr3 = 1 , n_bns , 1 part_distribution_loop2 : DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT part_distribution_loop2 ! Experimental: empty particles object !particles_dist( itr, itr2 )= particles() ELSE PRINT * , \"===================================================\" & // \"=====================\" PRINT * , \" Computing SPH variables for \" // TRIM ( system ), itr3 , & \", distribution\" , itr4 PRINT * , \"===================================================\" & // \"=====================\" PRINT * !WRITE( namefile_parts_bin, \"(A1,I1,A1,I1,A1)\" ) & !                            \"l\", & !                            itr3, \"-\", itr4, \".\" IF ( TRIM ( system ) == \"BNS\" ) WRITE ( namefile_parts_bin , \"(A5)\" ) \"NSNS.\" IF ( TRIM ( system ) == \"DRS\" ) WRITE ( namefile_parts_bin , \"(A5)\" ) \"DRSx.\" namefile_parts_bin = TRIM ( sph_path ) // TRIM ( namefile_parts_bin ) particles_dist ( itr3 , itr4 )% export_bin = export_bin particles_dist ( itr3 , itr4 )% export_form_xy = export_form_xy particles_dist ( itr3 , itr4 )% export_form_x = export_form_x CALL particles_dist ( itr3 , itr4 )% & compute_and_export_SPH_variables ( namefile_parts_bin ) !IF( particles_dist( itr3, itr4 )% export_bin )THEN !  WRITE( namefile_parts, \"(A10,I1,A1,I1,A4)\" ) & !                  \"sph_vars-\", itr3, \"-\", itr4, \".dat\" !  CALL particles_dist( itr3, itr4 )% & !                  read_sphincs_dump_print_formatted( & !                                namefile_parts_bin, namefile_parts ) !ENDIF ENDIF ENDDO part_distribution_loop2 ENDDO compute_export_sph_loops ! !-- Print the particle initial data to a formatted file ! IF ( export_form ) THEN export_sph_loops : DO itr3 = 1 , n_bns , 1 DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT ! Experimental: empty particles object !particles_dist( itr, itr2 )= particles() ELSE WRITE ( namefile_parts , \"(A29,I1,A1,I1,A4)\" ) & \"lorene-bns-id-particles-form_\" , & itr3 , \"-\" , itr4 , \".dat\" namefile_parts = TRIM ( sph_path ) // TRIM ( namefile_parts ) CALL particles_dist ( itr3 , itr4 )% & print_formatted_lorene_id_particles ( namefile_parts ) ENDIF ENDDO ENDDO export_sph_loops ENDIF !PRINT *, \"===================================================\" & !         // \"================================================\" !PRINT *, \" Timing \" !PRINT *, \"===================================================\" & !         // \"================================================\" !PRINT * !PRINT * !PRINT *, \" * SPH:\" !CALL particles_dist( 1, 1 )% placer_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% apm1_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% apm2_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% importer_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% sph_computer_timer% print_timer( 2 ) !PRINT * ENDIF IF ( run_spacetime ) THEN ! !-- Construct the bssn_id objects from the bns objects ! place_spacetime_id_loop : DO itr3 = 1 , n_bns , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Setting up BSSN object for \" // TRIM ( system ), itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * bssn_forms ( itr3 ) = bssn_id ( idata ( itr3 ) ) ENDDO place_spacetime_id_loop ! !-- Compute the BSSN initial data, optionally export it to a binary file !-- readable by SPHINCS_BSSN, and optionally read the content of such binary !-- file and print it to a formatted file (the latter for debugging) ! compute_export_bssn_loop : DO itr3 = 1 , n_bns , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN variables for \" // TRIM ( system ), itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn_bin , \"(A15)\" ) \"BSSN_vars.00000\" !\"BSSN_l\", itr3, \".bin\"\"(A6,I1,A4)\" namefile_bssn_bin = TRIM ( spacetime_path ) // TRIM ( namefile_bssn_bin ) bssn_forms ( itr3 )% export_form_xy = export_form_xy bssn_forms ( itr3 )% export_form_x = export_form_x bssn_forms ( itr3 )% export_bin = export_bin CALL bssn_forms ( itr3 )% & compute_and_export_3p1_variables ( namefile_bssn_bin ) !IF( bssn_forms( itr3 )% export_bin )THEN !  WRITE( namefile_bssn, \"(A10,I1,A4)\" ) \"bssn_vars-\", itr3, \".dat\" !  CALL bssn_forms( itr3 )% & !        read_bssn_dump_print_formatted( namefile_bssn_bin, namefile_bssn ) !ENDIF ENDDO compute_export_bssn_loop ! !-- Print the BSSN initial data to a formatted file ! IF ( export_form ) THEN export_bssn_loop : DO itr3 = 1 , n_bns , 1 WRITE ( namefile_bssn , \"(A24,I1,A4)\" ) & \"lorene-bns-id-bssn-form_\" , itr3 , \".dat\" namefile_bssn = TRIM ( spacetime_path ) // TRIM ( namefile_bssn ) CALL bssn_forms ( itr3 )% & print_formatted_lorene_id_3p1_variables ( namefile_bssn ) ENDDO export_bssn_loop ENDIF ! !-- Compute the BSSN constraints ! compute_export_bssn_constraints_loop : DO itr3 = 1 , n_bns , 1 bssn_forms ( itr3 )% cons_step = constraints_step bssn_forms ( itr3 )% export_constraints = export_constraints bssn_forms ( itr3 )% export_constraints_details = & export_constraints_details bssn_forms ( itr3 )% export_constraints_xy = export_constraints_xy bssn_forms ( itr3 )% export_constraints_x = export_constraints_x IF ( compute_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN constraints for BSSN formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A17,I1,A4)\" ) \"bssn-constraints-\" , itr3 , & \".dat\" WRITE ( name_logfile , \"(A28,I1)\" ) & \"bssn-constraints-statistics-\" , itr3 namefile_bssn = TRIM ( spacetime_path ) // TRIM ( namefile_bssn ) name_logfile = TRIM ( spacetime_path ) // TRIM ( name_logfile ) CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( idata ( itr3 ), & namefile_bssn , & name_logfile ) ENDIF part_distribution_loop3 : DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT ! Experimental: empty particles object !particles_dist( itr, itr2 )= particles() ELSE IF ( compute_parts_constraints . AND . run_sph ) THEN PRINT * , \"===================================================\" & // \"================================================\" PRINT * , \" Computing BSSN constraints for BSSN\" , & \" formulation\" , itr3 , \"with particle distribution\" , itr4 PRINT * , \"===================================================\" & // \"================================================\" PRINT * WRITE ( namefile_bssn , \"(A23,I1,A1,I1,A4)\" ) & \"bssn-constraints-parts-\" , & itr3 , \"-\" , itr4 , \".dat\" WRITE ( namefile_sph , \"(A12,I1,A1,I1,A4)\" ) \"sph-density-\" , itr3 , & \"-\" , itr4 , \".dat\" WRITE ( name_logfile , \"(A34,I1,A1,I1,A4)\" ) & \"bssn-constraints-parts-statistics-\" , itr3 , & \"-\" , itr4 namefile_bssn = TRIM ( spacetime_path ) // TRIM ( namefile_bssn ) namefile_sph = TRIM ( sph_path ) // TRIM ( namefile_sph ) name_logfile = TRIM ( spacetime_path ) // TRIM ( name_logfile ) CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( & particles_dist ( itr3 , itr4 ), & namefile_bssn , & name_logfile ) ENDIF ENDIF ENDDO part_distribution_loop3 ENDDO compute_export_bssn_constraints_loop ENDIF CALL execution_timer % stop_timer () CALL DATE_AND_TIME ( date , time , zone , values ) end_time = date // \"-\" // time ! !-- Print the timers ! PRINT * , \"===================================================\" & // \"================================================\" PRINT * , \" Timing \" PRINT * , \"===================================================\" & // \"================================================\" PRINT * PRINT * , \" * LORENE:\" CALL idata ( 1 )% construction_timer % print_timer ( 2 ) PRINT * IF ( run_sph ) THEN PRINT * , \" * SPH:\" CALL particles_dist ( 1 , 1 )% placer_timer % print_timer ( 2 ) CALL particles_dist ( 1 , 1 )% same_particle_timer % print_timer ( 2 ) DO i_matter = 1 , idata ( 1 )% get_n_matter (), 1 CALL particles_dist ( 1 , 1 )% apm_timers ( i_matter )% print_timer ( 2 ) ENDDO CALL particles_dist ( 1 , 1 )% importer_timer % print_timer ( 2 ) CALL particles_dist ( 1 , 1 )% sph_computer_timer % print_timer ( 2 ) PRINT * ENDIF IF ( run_spacetime ) THEN PRINT * , \" * Spacetime:\" CALL bssn_forms ( 1 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% bssn_computer_timer % print_timer ( 2 ) PRINT * ENDIF PRINT * , \" * Total:\" CALL execution_timer % print_timer ( 2 ) PRINT * ! !-- Print a summary ! PRINT * , \"===================================================\" & // \"================================================\" PRINT * , \" Summary \" PRINT * , \"===================================================\" & // \"================================================\" PRINT * PRINT * , \" * Binary system of neutron stars:\" PRINT * PRINT * , \"   Used binary file produced by LORENE: \" & // TRIM ( common_path ) // TRIM ( filenames ( 1 )) PRINT * !DO i_matter= 1, idata(1)% get_n_matter(), 1 !  PRINT *, \"   Baryon mass of matter object \", i_matter, \"=\", & !           idata( 1 )% return_mass(i_matter), \"Msun\" !  !PRINT *, \"   Gravitational mass of object \", i_matter, \"=\", & !  !         idata( 1 )% get_grav_mass(i_matter), \"Msun\" !ENDDO !PRINT * !PRINT *, \"   Equatorial (not areal) radius of neutron star 1 towards \" & !         // \"companion= \", & !             binaries( 1 )% get_radius1_x_comp(), \"Msun_geo\" !PRINT *, \"   Equatorial (not areal) radius of neutron star 2 towards \" & !         // \"companion= \", & !             binaries( 1 )% get_radius2_x_comp(), \"Msun_geo\" !PRINT *, \"   Equatorial (not areal) radius of neutron star 1 opposite to \" & !         // \"companion= \", & !             binaries( 1 )% get_radius1_x_opp(), \"Msun_geo\" !PRINT *, \"   Equatorial (not areal) radius of neutron star 2 opposite to \" & !         // \"companion= \", & !             binaries( 1 )% get_radius2_x_opp(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 1= \", & !             binaries( 1 )% get_radius1_y(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 2= \", & !             binaries( 1 )% get_radius2_y(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 1= \", & !             binaries( 1 )% get_radius1_z(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 2= \", & !             binaries( 1 )% get_radius2_z(), \"Msun_geo\" !PRINT * !PRINT *, \"   EOS for neutron star 1= \", & !             binaries( 1 )% get_eos1() !PRINT *, \"   EOS for neutron star 2= \", & !             binaries( 1 )% get_eos2() !PRINT * !PRINT *, \"   Central baryon mass density for star 1= \", & !             binaries( 1 )% get_rho_center1(), \"Msun/Msun_geo**3= \", & !             binaries( 1 )% get_rho_center1() & !             /lorene2hydrobase*kg2g/(m2cm**3), \"g cm&#94;{-3}\" !PRINT *, \"   Central baryon mass density for star 2= \", & !             binaries( 1 )% get_rho_center2(), \"Msun/Msun_geo**3= \", & !             binaries( 1 )% get_rho_center2() & !             /lorene2hydrobase*kg2g/(m2cm**3), \"g cm&#94;{-3}\" !PRINT * IF ( run_sph ) THEN PRINT * , \" * SPH:\" PRINT * PRINT * , \"   Total particle number= \" , particles_dist ( 1 , 1 )% get_npart () ! PRINT *, \"   Particle number on star 1: npart1=\", & !                                       particles_dist( 1, 1 )% get_npart1() ! PRINT *, \"   Particle number on star 2: npart2=\", & !                                       particles_dist( 1, 1 )% get_npart2() ! PRINT *, \"   Particle number ratio: npart1/npart2= \", & !                         DBLE(particles_dist( 1, 1 )% get_npart1()) & !                        /DBLE(particles_dist( 1, 1 )% get_npart2()) ! PRINT *, \"   Star mass ratio: mass1/mass2= \", & !                        binaries( 1 )% get_mass1()/binaries( 1 )% get_mass2() ! PRINT * ! PRINT *, \"   Baryon number ratio over both stars=\", & !          particles_dist( 1, 1 )% get_nuratio() ! PRINT *, \"   Baryon number ratio on star 1=\", & !          particles_dist( 1, 1 )% get_nuratio1() ! PRINT *, \"   Baryon number ratio on star 2=\", & !          particles_dist( 1, 1 )% get_nuratio2() ! PRINT * ENDIF IF ( run_spacetime ) THEN PRINT * , \" * Spacetime:\" PRINT * PRINT * , \"   Number of refinement levels= \" , bssn_forms ( 1 )% get_nlevels () PRINT * PRINT * , \"   Number of grid points on each level= \" , & bssn_forms ( 1 )% get_ngrid_x ( 1 ), \"**3\" PRINT * DO itr = 1 , bssn_forms ( 1 )% get_nlevels (), 1 PRINT * , \"   Resolution on level \" , itr , \"= \" , & bssn_forms ( 1 )% get_dx ( itr ) ENDDO PRINT * DO itr = 1 , bssn_forms ( 1 )% get_nlevels (), 1 PRINT * , \"   x boundary of level \" , itr , \"= \" , & bssn_forms ( 1 )% get_xR ( itr ) PRINT * , \"   y boundary of level \" , itr , \"= \" , & bssn_forms ( 1 )% get_yR ( itr ) PRINT * , \"   z boundary of level \" , itr , \"= \" , & bssn_forms ( 1 )% get_zR ( itr ) !bssn_forms( 1 )% get_dx(itr)* & !(bssn_forms( 1 )% get_ngrid_x(itr)-2.0D0)/2.0D0, \"Msun_geo= \", & !bssn_forms( 1 )% get_dx(itr)* & !(bssn_forms( 1 )% get_ngrid_x(itr)-2.0D0)/2.0D0*Msun_geo, \"km \" ENDDO PRINT * last_level = bssn_forms ( 1 )% get_nlevels () !PRINT *, \"   Number of grid points across the x-axis-diameter of star 1=\", & !         FLOOR( ( binaries( 1 )% get_radius1_x_comp() + & !         binaries( 1 )% get_radius1_x_opp() ) & !         /bssn_forms( 1 )% get_dx( last_level ) ) !PRINT *, \"   Number of grid points across the x-axis-diameter of star 2=\", & !         FLOOR( ( binaries( 1 )% get_radius2_x_comp() + & !        binaries( 1 )% get_radius2_x_opp() ) & !        /bssn_forms( 1 )% get_dx( last_level ) ) !PRINT * ENDIF PRINT * , \"** Run started on \" , run_id , \" and ended on \" , end_time PRINT * ! !-- Deallocate memory ! DO itr = 1 , n_bns , 1 ! !-- Destruct the LORENE Bin_NS object by hand, since the pointer to it is !-- global (because it is bound to C++) and cannot be nullified by the !-- destructor of bns. In case of multiple bns objects, this would lead !-- to problems... !-- TODO: fix this ! !CALL binaries( itr )% destruct_binary() ENDDO IF ( ALLOCATED ( binaries ) ) THEN DEALLOCATE ( binaries ) ENDIF IF ( ALLOCATED ( idata ) ) THEN DEALLOCATE ( idata ) ENDIF IF ( ALLOCATED ( particles_dist ) ) THEN DEALLOCATE ( particles_dist ) ENDIF IF ( ALLOCATED ( bssn_forms ) ) THEN DEALLOCATE ( bssn_forms ) ENDIF CONTAINS SUBROUTINE read_bns_id_parameters () IMPLICIT NONE INTEGER :: stat CHARACTER ( LEN = : ), ALLOCATABLE :: lorene_bns_id_parameters CHARACTER ( LEN = 100 ) :: msg lorene_bns_id_parameters = 'sphincs_lorene_bns_parameters.par' INQUIRE ( FILE = lorene_bns_id_parameters , EXIST = file_exists ) IF ( file_exists ) THEN OPEN ( 17 , FILE = lorene_bns_id_parameters , STATUS = 'OLD' ) ELSE PRINT * PRINT * , '** ERROR: ' , lorene_bns_id_parameters , \" file not found!\" PRINT * STOP ENDIF READ ( 17 , NML = bns_parameters , IOSTAT = stat , IOMSG = msg ) IF ( stat /= 0 ) THEN PRINT * , \"** ERROR: Error in reading \" , lorene_bns_id_parameters ,& \". The IOSTAT variable is \" , stat , & \"The error message is\" , msg STOP ENDIF CLOSE ( 17 ) DO itr = 1 , max_length , 1 IF ( TRIM ( filenames ( itr )). NE . \"0\" ) THEN cnt = cnt + 1 ENDIF ENDDO IF ( cnt . NE . n_bns ) THEN PRINT * , \"** ERROR! The number of file names is\" , cnt , & \"and n_bns=\" , n_bns , \". The two should be the same.\" PRINT * STOP ENDIF !DO itr= 1, n_bns, 1 !  DO itr2= 1, max_n_parts, 1 !    IF( placer( itr, itr2 ) == test_int )THEN !      PRINT * !      PRINT *, \"** ERROR! The array placer does not have \", & !               \"enough components to specify all the desired \", & !               \"particle distributions. Specify the \", & !               \"components in file lorene_bns_id_particles.par\" !      PRINT * !      STOP !    ENDIF !  ENDDO !ENDDO END SUBROUTINE END PROGRAM sphincs_lorene_bns","tags":"","loc":"sourcefile/sphincs_lorene_bns.f90.html"},{"title":"module_utility.f90 – SPHINCS_LORENE","text":"Files dependent on this one sourcefile~~module_utility.f90~~AfferentGraph sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_particles_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90 submodule_formul_3p1_standard3p1_variables.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90->sourcefile~module_utility.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~submodule_id_base_mass_profile.f90 submodule_id_base_mass_profile.f90 sourcefile~submodule_id_base_mass_profile.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~submodule_particles_apm.f90 submodule_particles_apm.f90 sourcefile~submodule_particles_apm.f90->sourcefile~module_utility.f90 sourcefile~submodule_particles_apm.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~submodule_diffstar_lorene_access.f90 submodule_diffstar_lorene_access.f90 sourcefile~submodule_diffstar_lorene_access.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_particles_memory.f90 submodule_particles_memory.f90 sourcefile~submodule_particles_memory.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_sph_variables.f90 submodule_particles_sph_variables.f90 sourcefile~submodule_particles_sph_variables.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_diffstar_lorene_import.f90 submodule_diffstar_lorene_import.f90 sourcefile~submodule_diffstar_lorene_import.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_bns_lorene_import.f90 submodule_bns_lorene_import.f90 sourcefile~submodule_bns_lorene_import.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_memory.f90 submodule_bns_lorene_memory.f90 sourcefile~submodule_bns_lorene_memory.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_particles_redistribute_nu.f90 submodule_particles_redistribute_nu.f90 sourcefile~submodule_particles_redistribute_nu.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_spherical_surfaces.f90 submodule_particles_spherical_surfaces.f90 sourcefile~submodule_particles_spherical_surfaces.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bns_lorene_constructor.f90 submodule_bns_lorene_constructor.f90 sourcefile~submodule_bns_lorene_constructor.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bssn_id_memory.f90 submodule_bssn_id_memory.f90 sourcefile~submodule_bssn_id_memory.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_diffstar_lorene_params.f90 submodule_diffstar_lorene_params.f90 sourcefile~submodule_diffstar_lorene_params.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_base_access.f90 submodule_diffstar_base_access.f90 sourcefile~submodule_diffstar_base_access.f90->sourcefile~module_diffstar_base.f90 sourcefile~submodule_diffstar_lorene_constructor.f90 submodule_diffstar_lorene_constructor.f90 sourcefile~submodule_diffstar_lorene_constructor.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_particles_access.f90 submodule_particles_access.f90 sourcefile~submodule_particles_access.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_lattices.f90 submodule_particles_lattices.f90 sourcefile~submodule_particles_lattices.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_formul_3p1_analysis.f90 submodule_formul_3p1_analysis.f90 sourcefile~submodule_formul_3p1_analysis.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_particles_compose.f90 submodule_particles_compose.f90 sourcefile~submodule_particles_compose.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bssn_id_variables.f90 submodule_bssn_id_variables.f90 sourcefile~submodule_bssn_id_variables.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_formul_3p1_access.f90 submodule_formul_3p1_access.f90 sourcefile~submodule_formul_3p1_access.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_bns_lorene_params.f90 submodule_bns_lorene_params.f90 sourcefile~submodule_bns_lorene_params.f90->sourcefile~module_bns_lorene.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~submodule_particles_constructor.f90 submodule_particles_constructor.f90 sourcefile~submodule_particles_constructor.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bns_base_mass_profile.f90 submodule_bns_base_mass_profile.f90 sourcefile~submodule_bns_base_mass_profile.f90->sourcefile~module_bns_base.f90 sourcefile~submodule_diffstar_lorene_memory.f90 submodule_diffstar_lorene_memory.f90 sourcefile~submodule_diffstar_lorene_memory.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_bssn_id_constraints.f90 submodule_bssn_id_constraints.f90 sourcefile~submodule_bssn_id_constraints.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bns_base_access.f90 submodule_bns_base_access.f90 sourcefile~submodule_bns_base_access.f90->sourcefile~module_bns_base.f90 sourcefile~submodule_bns_lorene_access.f90 submodule_bns_lorene_access.f90 sourcefile~submodule_bns_lorene_access.f90->sourcefile~module_bns_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~submodule_bssn_id_constructor.f90 submodule_bssn_id_constructor.f90 sourcefile~submodule_bssn_id_constructor.f90->sourcefile~module_bssn_id.f90 var pansourcefilemodule_utilityf90AfferentGraph = svgPanZoom('#sourcefilemodule_utilityf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules utility Source Code module_utility.f90 Source Code ! File:         module_utility.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE utility !*********************************************************************** !                                                                      * !  This module contains useful miscellaneous PROCEDURES and variables  * !                                                                      * !*********************************************************************** USE matrix , ONLY : determinant_4x4_matrix IMPLICIT NONE INTEGER :: itr , itr3 , itr4 ! iterators for loops INTEGER :: ios ! variable to store the state of I/O INTEGER :: cnt = 0 ! counter ! Variables to print progress on screen INTEGER :: perc DOUBLE PRECISION :: perc2 CHARACTER , PARAMETER :: creturn = ACHAR ( 13 ) ! Carriage return LOGICAL :: file_exists , show_progress ! String storing error messages CHARACTER ( LEN = : ), ALLOCATABLE :: err_msg ! Variables used to set the run_id CHARACTER ( 8 ) :: date CHARACTER ( 10 ) :: time CHARACTER ( 5 ) :: zone INTEGER , DIMENSION ( 8 ) :: values CHARACTER ( LEN = 19 ) :: run_id , end_time CONTAINS SUBROUTINE test_status ( io_stat , io_msg , opt_msg ) !************************************************ !                                               * ! Test if a status variable is 0 or not         * !                                               * ! FT 17.09.2020                                 * !                                               * !************************************************ IMPLICIT NONE INTEGER , INTENT ( IN ) :: io_stat CHARACTER ( LEN = 100 ), INTENT ( IN ) :: io_msg CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: opt_msg IF ( io_stat > 0 ) THEN PRINT * PRINT * , \"***** ERROR! IOSTAT > 0. \" , & \"The error message is: \" , io_msg IF ( PRESENT ( opt_msg ) ) THEN PRINT * , opt_msg ENDIF PRINT * STOP ENDIF END SUBROUTINE test_status SUBROUTINE compute_g4 ( ix , iy , iz , lapse , shift_u , g_phys3_ll , g4 ) !************************************************ !                                               * ! Computes the spacetime metric from lapse,     * ! shift and spatial metric !                                               * ! FT 27.11.2020                                 * !                                               * !************************************************ USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , n_sym3x3 , n_sym4x4 IMPLICIT NONE INTEGER :: ix , iy , iz DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: & lapse DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: & shift_u DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: & g_phys3_ll DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: g4 g4 ( ix , iy , iz , itt ) = - lapse ( ix , iy , iz ) * lapse ( ix , iy , iz ) & + g_phys3_ll ( ix , iy , iz , jxx ) & * shift_u ( ix , iy , iz , jx ) & * shift_u ( ix , iy , iz , jx ) & + 2.0D0 * g_phys3_ll ( ix , iy , iz , jxy ) & * shift_u ( ix , iy , iz , jx ) & * shift_u ( ix , iy , iz , jy ) & + 2.0D0 * g_phys3_ll ( ix , iy , iz , jxz ) & * shift_u ( ix , iy , iz , jx ) & * shift_u ( ix , iy , iz , jz ) & + g_phys3_ll ( ix , iy , iz , jyy ) & * shift_u ( ix , iy , iz , jy ) & * shift_u ( ix , iy , iz , jy ) & + 2.0D0 * g_phys3_ll ( ix , iy , iz , jyz ) & * shift_u ( ix , iy , iz , jy ) & * shift_u ( ix , iy , iz , jz ) & + g_phys3_ll ( ix , iy , iz , jzz ) & * shift_u ( ix , iy , iz , jz ) & * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , itx ) = g_phys3_ll ( ix , iy , iz , jxx ) * shift_u ( ix , iy , iz , jx ) & + g_phys3_ll ( ix , iy , iz , jxy ) * shift_u ( ix , iy , iz , jy ) & + g_phys3_ll ( ix , iy , iz , jxz ) * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , ity ) = g_phys3_ll ( ix , iy , iz , jxy ) * shift_u ( ix , iy , iz , jx ) & + g_phys3_ll ( ix , iy , iz , jyy ) * shift_u ( ix , iy , iz , jy ) & + g_phys3_ll ( ix , iy , iz , jyz ) * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , itz ) = g_phys3_ll ( ix , iy , iz , jxz ) * shift_u ( ix , iy , iz , jx ) & + g_phys3_ll ( ix , iy , iz , jyz ) * shift_u ( ix , iy , iz , jy ) & + g_phys3_ll ( ix , iy , iz , jzz ) * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , ixx ) = g_phys3_ll ( ix , iy , iz , jxx ) g4 ( ix , iy , iz , ixy ) = g_phys3_ll ( ix , iy , iz , jxy ) g4 ( ix , iy , iz , ixz ) = g_phys3_ll ( ix , iy , iz , jxz ) g4 ( ix , iy , iz , iyy ) = g_phys3_ll ( ix , iy , iz , jyy ) g4 ( ix , iy , iz , iyz ) = g_phys3_ll ( ix , iy , iz , jyz ) g4 ( ix , iy , iz , izz ) = g_phys3_ll ( ix , iy , iz , jzz ) END SUBROUTINE compute_g4 SUBROUTINE determinant_sym4x4_grid ( ix , iy , iz , A , det ) !***************************************************************** !                                                                * ! Compute the determinant of a 4x4 symmetric matrix field at a   * ! given grid point                                               * !                                                                * !***************************************************************** USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , ixz , iyy , iyz , izz , n_sym4x4 IMPLICIT NONE INTEGER :: ix , iy , iz INTEGER , DIMENSION ( 4 ) :: components DOUBLE PRECISION , INTENT ( IN ) :: A (:,:,:,:) DOUBLE PRECISION , INTENT ( OUT ) :: det components = SHAPE ( A ) IF ( components ( 4 ) /= n_sym4x4 ) THEN PRINT * , \"** ERROR in determinant_sym4x4_grid in MODULE utility.\" , & \" This subroutine needs a symmetric matrix with 10 components,\" ,& \" and a \" , components , \"component matrix was given instead.\" STOP ENDIF det = A ( ix , iy , iz , itt ) * ( A ( ix , iy , iz , ixx ) * ( A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , izz ) & - A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , iyz )) & + A ( ix , iy , iz , ixy ) * ( A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , ixz ) & - A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , izz )) & + A ( ix , iy , iz , ixz ) * ( A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , iyz ) & - A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , ixz ))) & - A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , izz ) & - A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , iyz )) & + A ( ix , iy , iz , ixy ) * ( A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , itz ) & - A ( ix , iy , iz , ity ) * A ( ix , iy , iz , izz )) & + A ( ix , iy , iz , ixz ) * ( A ( ix , iy , iz , ity ) * A ( ix , iy , iz , iyz ) & - A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , itz ))) & + A ( ix , iy , iz , ity ) * ( A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , izz ) & - A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , ixz )) & + A ( ix , iy , iz , ixx ) * ( A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , itz ) & - A ( ix , iy , iz , ity ) * A ( ix , iy , iz , izz )) & + A ( ix , iy , iz , ixz ) * ( A ( ix , iy , iz , ity ) * A ( ix , iy , iz , ixz ) & - A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , itz ))) & - A ( ix , iy , iz , itz ) * ( A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , iyz ) & - A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , ixz )) & + A ( ix , iy , iz , ixx ) * ( A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , itz ) & - A ( ix , iy , iz , ity ) * A ( ix , iy , iz , iyz )) & + A ( ix , iy , iz , ixy ) * ( A ( ix , iy , iz , ity ) * A ( ix , iy , iz , ixz ) & - A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , itz ))) END SUBROUTINE determinant_sym4x4_grid SUBROUTINE determinant_sym3x3_grid ( i , j , k , A , det ) !***************************************************************** !                                                                * ! Compute the determinant of a 3x3 symmetric matrix field at a   * ! given grid point                                               * !                                                                * ! FT 26.03.2021                                                  * !                                                                * !***************************************************************** USE tensor , ONLY : jxx , jxy , jxz , jyy , jyz , jzz , n_sym3x3 IMPLICIT NONE INTEGER :: i , j , k INTEGER , DIMENSION ( 4 ) :: components DOUBLE PRECISION , INTENT ( IN ) :: A (:,:,:,:) DOUBLE PRECISION , INTENT ( OUT ) :: det components = SHAPE ( A ) IF ( components ( 4 ) /= n_sym3x3 ) THEN PRINT * , \"** ERROR in determinant_sym3x3_grid in MODULE utility.\" , & \" This subroutine needs a symmetric matrix with 6 components,\" ,& \" and a \" , components , \"component matrix was given instead.\" STOP ENDIF det = A ( i , j , k , jxx ) * A ( i , j , k , jyy ) * A ( i , j , k , jzz ) & + A ( i , j , k , jxy ) * A ( i , j , k , jyz ) * A ( i , j , k , jxz ) & + A ( i , j , k , jxz ) * A ( i , j , k , jxy ) * A ( i , j , k , jyz ) & - A ( i , j , k , jxy ) * A ( i , j , k , jxy ) * A ( i , j , k , jzz ) & - A ( i , j , k , jxz ) * A ( i , j , k , jyy ) * A ( i , j , k , jxz ) & - A ( i , j , k , jxx ) * A ( i , j , k , jyz ) * A ( i , j , k , jyz ) END SUBROUTINE determinant_sym3x3_grid END MODULE utility","tags":"","loc":"sourcefile/module_utility.f90.html"},{"title":"module_sphincs_lorene.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_sphincs_lorene.f90~~EfferentGraph sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_particles_id.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefilemodule_sphincs_lorenef90EfferentGraph = svgPanZoom('#sourcefilemodule_sphincs_lorenef90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_sphincs_lorene.f90~~AfferentGraph sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules sphincs_lorene Source Code module_sphincs_lorene.f90 Source Code ! File:         module_sphincs_lorene.f90 ! Author:       Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE sphincs_lorene !********************************************** !                                             * ! This module uses the other                  * ! modules needed to import and set up the     * ! LORENE ID                                   * !                                             * ! FT 23.10.2020                               * !                                             * !********************************************** USE utility , ONLY : date , time , zone , values , run_id , itr , itr3 , & itr4 , ios , err_msg , file_exists , cnt , & test_status , show_progress , end_time USE timing , ONLY : timer USE id_base , ONLY : idbase USE bns_lorene , ONLY : bnslorene USE diffstar_lorene , ONLY : diffstarlorene USE particles_id , ONLY : particles USE formul_3p1_id , ONLY : formul_3p1 USE formul_bssn_id , ONLY : bssn_id IMPLICIT NONE END MODULE sphincs_lorene","tags":"","loc":"sourcefile/module_sphincs_lorene.f90.html"},{"title":"submodule_formul_3p1_access.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_formul_3p1_access.f90~~EfferentGraph sourcefile~submodule_formul_3p1_access.f90 submodule_formul_3p1_access.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~submodule_formul_3p1_access.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 var pansourcefilesubmodule_formul_3p1_accessf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_formul_3p1_accessf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules formul_3p1_access Source Code submodule_formul_3p1_access.f90 Source Code ! File:         submodule_formul_3p1_access.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( formul_3p1_id ) formul_3p1_access !**************************************************** !                                                   * ! Implementation of the methods of TYPE formul_3p1  * ! that allow to access PRIVATE members.             * !                                                   * ! FT 12.07.2021                                     * !                                                   * !**************************************************** IMPLICIT NONE CONTAINS !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE get_grid_point !************************************************* !                                                * ! Returns the array with the coordinates of the  * ! grid point                                     * !                                                * ! FT                                             * !                                                * !************************************************* USE tensor , ONLY : jx , jy , jz IMPLICIT NONE IF ( i > THIS % levels ( l )% ngrid_x ) THEN PRINT * , \"** ERROR in get_grid_point: i=\" , i , \"> ngrid_x=\" , & THIS % levels ( l )% ngrid_x , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( j > THIS % levels ( l )% ngrid_y ) THEN PRINT * , \"** ERROR in get_grid_point j=\" , j , \"> ngrid_y=\" , & THIS % levels ( l )% ngrid_y , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( k > THIS % levels ( l )% ngrid_z ) THEN PRINT * , \"** ERROR in get_grid_point k=\" , k , \"> ngrid_z=\" , & THIS % levels ( l )% ngrid_z , \"on refinement level l=\" , l PRINT * STOP ENDIF grid_point ( 1 ) = THIS % coords % levels ( l )% var ( i , j , k , jx ) grid_point ( 2 ) = THIS % coords % levels ( l )% var ( i , j , k , jy ) grid_point ( 3 ) = THIS % coords % levels ( l )% var ( i , j , k , jz ) END PROCEDURE get_grid_point MODULE PROCEDURE get_nlevels !************************************************** !                                                 * ! Returns the number of refinement levels nlevels * !                                                 * ! FT 26.03.2021                                   * !                                                 * !************************************************** IMPLICIT NONE nlevels = THIS % nlevels END PROCEDURE get_nlevels MODULE PROCEDURE get_levels !************************************************** !                                                 * ! Returns the data structure levels               * !                                                 * ! FT 26.03.2021                                   * !                                                 * !************************************************** IMPLICIT NONE levels = THIS % levels END PROCEDURE get_levels MODULE PROCEDURE get_dx !************************************************* !                                                * ! Returns the grid spacing on the x axis         * !                                                * ! FT                                             * !                                                * !************************************************* IMPLICIT NONE dx = THIS % levels ( l )% dx END PROCEDURE get_dx MODULE PROCEDURE get_dy !************************************************* !                                                * ! Returns the grid spacing on the y axis         * !                                                * ! FT 26.03.2021                                  * !                                                * !************************************************* IMPLICIT NONE dy = THIS % levels ( l )% dy END PROCEDURE get_dy MODULE PROCEDURE get_dz !************************************************* !                                                * ! Returns the grid spacing on the z axis         * !                                                * ! FT 26.03.2021                                  * !                                                * !************************************************* IMPLICIT NONE dz = THIS % levels ( l )% dz END PROCEDURE get_dz MODULE PROCEDURE get_ngrid_x !************************************************* !                                                * ! Returns the number of grid points on the x     * ! axis                                           * !                                                * ! FT                                             * !                                                * !************************************************* IMPLICIT NONE ngrid_x = THIS % levels ( l )% ngrid_x END PROCEDURE get_ngrid_x MODULE PROCEDURE get_ngrid_y !************************************************* !                                                * ! Returns the number of grid points on the y     * ! axis                                           * !                                                * ! FT                                             * !                                                * !************************************************* IMPLICIT NONE ngrid_y = THIS % levels ( l )% ngrid_y END PROCEDURE get_ngrid_y MODULE PROCEDURE get_ngrid_z !************************************************* !                                                * ! Returns the number of grid points on the z     * ! axis                                           * !                                                * ! FT                                             * !                                                * !************************************************* IMPLICIT NONE ngrid_z = THIS % levels ( l )% ngrid_z END PROCEDURE get_ngrid_z MODULE PROCEDURE get_xR !*********************************************** !                                              * ! Returns the x boundary of refinement level l * !                                              * ! FT                                           * !                                              * !*********************************************** IMPLICIT NONE xR = THIS % levels ( l )% xR END PROCEDURE get_xR MODULE PROCEDURE get_yR !*********************************************** !                                              * ! Returns the y boundary of refinement level l * !                                              * ! FT                                           * !                                              * !*********************************************** IMPLICIT NONE yR = THIS % levels ( l )% yR END PROCEDURE get_yR MODULE PROCEDURE get_zR !*********************************************** !                                              * ! Returns the z boundary of refinement level l * !                                              * ! FT                                           * !                                              * !*********************************************** IMPLICIT NONE zR = THIS % levels ( l )% zR END PROCEDURE get_zR MODULE PROCEDURE get_HC !************************************************** !                                                 * ! Returns the value of the Hamiltonian constraint * ! at the specified grid point                     * !                                                 * ! FT                                              * !                                                 * !************************************************** IMPLICIT NONE IF ( i > THIS % levels ( l )% ngrid_x ) THEN PRINT * , \"** ERROR in get_HC: i=\" , i , \"> ngrid_x=\" , & THIS % levels ( l )% ngrid_x , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( j > THIS % levels ( l )% ngrid_y ) THEN PRINT * , \"** ERROR in get_HC: j=\" , j , \"> ngrid_y=\" , & THIS % levels ( l )% ngrid_y , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( k > THIS % levels ( l )% ngrid_z ) THEN PRINT * , \"** ERROR in get_HC: k=\" , k , \"> ngrid_z=\" , & THIS % levels ( l )% ngrid_z , \"on refinement level l=\" , l PRINT * STOP ENDIF HC_value = THIS % HC % levels ( l )% var ( i , j , k ) END PROCEDURE get_HC MODULE PROCEDURE get_MC !************************************************** !                                                 * ! Returns the array of values of the momentum     * ! constraint at the specified grid point          * !                                                 * ! FT                                              * !                                                 * !************************************************** USE tensor , ONLY : jx , jy , jz IMPLICIT NONE IF ( i > THIS % levels ( l )% ngrid_x ) THEN PRINT * , \"** ERROR in get_HC: i=\" , i , \"> ngrid_x=\" , & THIS % levels ( l )% ngrid_x , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( j > THIS % levels ( l )% ngrid_y ) THEN PRINT * , \"** ERROR in get_HC: j=\" , j , \"> ngrid_y=\" , & THIS % levels ( l )% ngrid_y , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( k > THIS % levels ( l )% ngrid_z ) THEN PRINT * , \"** ERROR in get_HC: k=\" , k , \"> ngrid_z=\" , & THIS % levels ( l )% ngrid_z , \"on refinement level l=\" , l PRINT * STOP ENDIF MC_value ( 1 ) = THIS % MC % levels ( l )% var ( i , j , k , jx ) MC_value ( 2 ) = THIS % MC % levels ( l )% var ( i , j , k , jy ) MC_value ( 3 ) = THIS % MC % levels ( l )% var ( i , j , k , jz ) END PROCEDURE get_MC MODULE PROCEDURE get_HC_parts !************************************************** !                                                 * ! Returns the value of the Hamiltonian constraint * ! computed with particle data, at the specified   * ! grid point                                      * !                                                 * ! FT                                              * !                                                 * !************************************************** IMPLICIT NONE IF ( i > THIS % levels ( l )% ngrid_x ) THEN PRINT * , \"** ERROR in get_HC: i=\" , i , \"> ngrid_x=\" , & THIS % levels ( l )% ngrid_x , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( j > THIS % levels ( l )% ngrid_y ) THEN PRINT * , \"** ERROR in get_HC: j=\" , j , \"> ngrid_y=\" , & THIS % levels ( l )% ngrid_y , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( k > THIS % levels ( l )% ngrid_z ) THEN PRINT * , \"** ERROR in get_HC: k=\" , k , \"> ngrid_z=\" , & THIS % levels ( l )% ngrid_z , \"on refinement level l=\" , l PRINT * STOP ENDIF HC_value = THIS % HC_parts % levels ( l )% var ( i , j , k ) END PROCEDURE get_HC_parts MODULE PROCEDURE get_MC_parts !************************************************** !                                                 * ! Returns the value of the momentum constraint    * ! computed with particle data, at the specified   * ! grid point                                      * !                                                 * ! FT                                              * !                                                 * !************************************************** USE tensor , ONLY : jx , jy , jz IMPLICIT NONE IF ( i > THIS % levels ( l )% ngrid_x ) THEN PRINT * , \"** ERROR in get_HC: i=\" , i , \"> ngrid_x=\" , & THIS % levels ( l )% ngrid_x , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( j > THIS % levels ( l )% ngrid_y ) THEN PRINT * , \"** ERROR in get_HC: j=\" , j , \"> ngrid_y=\" , & THIS % levels ( l )% ngrid_y , \"on refinement level l=\" , l PRINT * STOP ENDIF IF ( k > THIS % levels ( l )% ngrid_z ) THEN PRINT * , \"** ERROR in get_HC: k=\" , k , \"> ngrid_z=\" , & THIS % levels ( l )% ngrid_z , \"on refinement level l=\" , l PRINT * STOP ENDIF MC_value ( 1 ) = THIS % MC_parts % levels ( l )% var ( i , j , k , jx ) MC_value ( 2 ) = THIS % MC_parts % levels ( l )% var ( i , j , k , jy ) MC_value ( 3 ) = THIS % MC_parts % levels ( l )% var ( i , j , k , jz ) END PROCEDURE get_MC_parts END SUBMODULE formul_3p1_access","tags":"","loc":"sourcefile/submodule_formul_3p1_access.f90.html"},{"title":"module_formul_3p1_id.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_formul_3p1_id.f90~~EfferentGraph sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_formul_3p1_id.f90~~AfferentGraph sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~submodule_formul_3p1_access.f90 submodule_formul_3p1_access.f90 sourcefile~submodule_formul_3p1_access.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90 submodule_formul_3p1_standard3p1_variables.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_formul_3p1_analysis.f90 submodule_formul_3p1_analysis.f90 sourcefile~submodule_formul_3p1_analysis.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_bssn_id_variables.f90 submodule_bssn_id_variables.f90 sourcefile~submodule_bssn_id_variables.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bssn_id_constraints.f90 submodule_bssn_id_constraints.f90 sourcefile~submodule_bssn_id_constraints.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bssn_id_memory.f90 submodule_bssn_id_memory.f90 sourcefile~submodule_bssn_id_memory.f90->sourcefile~module_bssn_id.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~submodule_bssn_id_constructor.f90 submodule_bssn_id_constructor.f90 sourcefile~submodule_bssn_id_constructor.f90->sourcefile~module_bssn_id.f90 var pansourcefilemodule_formul_3p1_idf90AfferentGraph = svgPanZoom('#sourcefilemodule_formul_3p1_idf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules formul_3p1_id Source Code module_formul_3p1_id.f90 Source Code ! File:         module_formul_3p1_id.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE formul_3p1_id !********************************************************************** ! !#   This module contains the definition of ABSTRACT TYPE formul_3p1 ! !********************************************************************** USE utility , ONLY : ios , err_msg , perc , creturn , run_id , & test_status , show_progress USE id_base , ONLY : idbase USE particles_id , ONLY : particles USE timing , ONLY : timer USE mesh_refinement , ONLY : grid_function_scalar , grid_function , level IMPLICIT NONE !******************************************************* !                                                      * !      Definition of abstract TYPE formul_3p1          * !                                                      * ! Abstract class for a 3+1 formulation of the Einstein * ! equations. It imports the LORENE ID on the gravity   * ! grid, in the standard 3+1 formulation, and defines   * ! DEFERRED PROCEDURES to be implemented in the derived * ! TYPES of the actual 3+1 formulations (for example,   * ! the BSSN formulation).                               * !                                                      * !******************************************************* TYPE , ABSTRACT :: formul_3p1 !# ABSTRACT TYPE representing a generic 3+1 formulation of the Einsten !  equations ! !-- Mesh variables ! INTEGER :: nlevels !! Number of refinement levels TYPE ( level ), DIMENSION (:), ALLOCATABLE :: levels !! Array containing the information on each refinement level TYPE ( grid_function ) :: coords !! Grid function storing the Cartesian coordinates TYPE ( grid_function_scalar ) :: rad_coord !! Grid scalar function storing the radial coordinates of each grid point ! !-- ADM fields ! TYPE ( grid_function_scalar ) :: lapse !! Grid scalar function storing the lapse function TYPE ( grid_function ) :: shift_u !! Grid function storing the shift vector TYPE ( grid_function ) :: g_phys3_ll !! Grid function storing the spatial metric TYPE ( grid_function ) :: K_phys3_ll !! Grid function storing the extrinsic curvature ! !-- Constraint violations ! TYPE ( grid_function_scalar ) :: HC !# Grid scalar function storing the Hamiltonian constraint (violations) !  computed using the full |lorene| ID on the mesh TYPE ( grid_function_scalar ) :: HC_parts !# Grid scalar function storing the Hamiltonian constraint (violations) !  computed using the stress-energy tensor mapped from the particles to the !  mesh TYPE ( grid_function ) :: MC !# Grid function storing the momentum constraint (violations) !  computed using the full |lorene| ID on the mesh TYPE ( grid_function ) :: MC_parts !# Grid function storing the momentum constraint (violations) !  computed using the stress-energy tensor mapped from the particles to the !  mesh ! !-- Norms of constraint violations ! DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_l2 !! \\ell_2 norm of the Hamiltonian constraint computed on the mesh DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_parts_l2 !# \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using !  the stress-energy tensor mapped from the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_loo !# \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh !  (i.e., its maximum) DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_parts_loo !# \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh, !  using the stress-energy tensor mapped from the particles !  (i.e., its maximum) DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_l2 !! \\ell_2 norm of the momentum constraint computed on the mesh DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_parts_l2 !# \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using !  the stress-energy tensor mapped from the particles DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_loo !# \\ell_\\infty norm of the momentum constraint computed on the mesh !  (i.e., its maximum) DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_parts_loo !# \\ell_\\infty norm of the momentum constraint computed on the mesh, !  using the stress-energy tensor mapped from the particles !  (i.e., its maximum) ! !-- Steering variables ! ! Variables to decide if and how to export the constraints INTEGER , PUBLIC :: cons_step !! Constraint violations are printed to file every cons_step-th grid point !  along each Cartesian direction LOGICAL , PUBLIC :: export_constraints !# `.TRUE.` if the constraint violations  are to be printed to file, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_constraints_details !# `.TRUE.` if the points at which the constraints violations are within the !  intervals [0,10&#94;{-7}],[10&#94;3,\\infty],[10&#94;n,10&#94;m], with !  n\\in\\{-7,2\\} and m=n+1, are to be printed to file; !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_constraints_xy !! `.TRUE.` if only the constrain violations on the xy plane are to be !  printed to file, `.FALSE.` otherwise LOGICAL , PUBLIC :: export_constraints_x !! `.TRUE.` if only the constrain violations on the x axis are to be !  printed to file, `.FALSE.` otherwise ! !-- Timers ! TYPE ( timer ) :: grid_timer !# Timer that times how long it takes to set up the grid and allocate !  the grid functions TYPE ( timer ) :: importer_timer !# Timer that times how long it takes to import the |lorene| ID !  on the mesh CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! !GENERIC, PUBLIC:: construct_formul_3p1 => & !                                    construct_formul_3p1_bns_ptr!, & !                                    !construct_formul_3p1_bns_spacings_ptr !PROCEDURE::       construct_formul_3p1_bns_ptr => & PROCEDURE , NON_OVERRIDABLE :: setup_standard3p1_variables !PROCEDURE::       construct_formul_3p1_bns_spacings_ptr => & !                                    construct_formul_3p1_bns_spacings PROCEDURE , NON_OVERRIDABLE :: analyze_constraint PROCEDURE ( define_allocate_fields_interface ), DEFERRED :: & define_allocate_fields PROCEDURE ( compute_and_export_3p1_variables_interface ), PUBLIC , & DEFERRED :: compute_and_export_3p1_variables PROCEDURE ( print_formatted_lorene_id_3p1_variables_interface ), PUBLIC , & DEFERRED :: print_formatted_lorene_id_3p1_variables GENERIC , PUBLIC :: compute_and_export_3p1_constraints => & compute_and_export_3p1_constraints_grid , & compute_and_export_3p1_constraints_particles PROCEDURE ( compute_and_export_3p1_constraints_grid_interface ), & DEFERRED :: compute_and_export_3p1_constraints_grid PROCEDURE ( compute_and_export_3p1_constraints_particles_interface ), & DEFERRED :: compute_and_export_3p1_constraints_particles PROCEDURE ( deallocate_fields_interface ), DEFERRED :: deallocate_fields PROCEDURE , NON_OVERRIDABLE :: deallocate_standard3p1_variables !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE :: abs_values_in PROCEDURE , PUBLIC :: get_grid_point PROCEDURE , PUBLIC :: get_nlevels PROCEDURE , PUBLIC :: get_levels PROCEDURE , PUBLIC :: get_dx PROCEDURE , PUBLIC :: get_dy PROCEDURE , PUBLIC :: get_dz PROCEDURE , PUBLIC :: get_ngrid_x PROCEDURE , PUBLIC :: get_ngrid_y PROCEDURE , PUBLIC :: get_ngrid_z PROCEDURE , PUBLIC :: get_xR PROCEDURE , PUBLIC :: get_yR PROCEDURE , PUBLIC :: get_zR PROCEDURE , PUBLIC :: get_HC PROCEDURE , PUBLIC :: get_MC PROCEDURE , PUBLIC :: get_HC_parts PROCEDURE , PUBLIC :: get_MC_parts END TYPE formul_3p1 ! !-- Interface of the cores of the constructors and destructos of TYPES !-- derived from formul_3p1 !-- Their implementations are in submodule formul_3p1_methods.f90 ! INTERFACE MODULE SUBROUTINE setup_standard3p1_variables ( f3p1 , id , dx , dy , dz ) CLASS ( idbase ), INTENT ( IN OUT ) :: id CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: f3p1 DOUBLE PRECISION , OPTIONAL :: dx , dy , dz END SUBROUTINE setup_standard3p1_variables !   MODULE SUBROUTINE construct_formul_3p1_bns_spacings( f3p1, id, & !                                                        dx, dy, dz ) ! !     CLASS(bns),        INTENT( IN OUT ):: id !     CLASS(formul_3p1), INTENT( IN OUT ):: f3p1 !     DOUBLE PRECISION,  INTENT( IN )    :: dx, dy, dz ! !   END SUBROUTINE construct_formul_3p1_bns_spacings MODULE SUBROUTINE deallocate_standard3p1_variables ( f3p1 ) CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: f3p1 END SUBROUTINE deallocate_standard3p1_variables END INTERFACE ! !-- Interface of the methods of TYPES derived from formul_3p1 !-- Their implementations are in submodule formul_3p1_methods.f90 ! INTERFACE MODULE SUBROUTINE analyze_constraint ( THIS , & l , & constraint , & name_constraint , & unit_logfile , & name_analysis , & l2_norm , & loo_norm ) CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN ) :: constraint CHARACTER ( LEN = * ), INTENT ( IN ) :: name_constraint CHARACTER ( LEN = * ), INTENT ( IN ) :: name_analysis INTEGER , INTENT ( IN ) :: unit_logfile DOUBLE PRECISION , INTENT ( OUT ) :: l2_norm DOUBLE PRECISION , INTENT ( OUT ) :: loo_norm END SUBROUTINE analyze_constraint MODULE SUBROUTINE abs_values_in ( THIS , lower_bound , upper_bound , & constraint , l , & export , unit_analysis , cnt ) CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS DOUBLE PRECISION :: lower_bound , & upper_bound DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN ) :: constraint INTEGER , INTENT ( IN ) :: l LOGICAL , INTENT ( IN ) :: export INTEGER , INTENT ( IN ) :: unit_analysis INTEGER , INTENT ( OUT ) :: cnt END SUBROUTINE abs_values_in MODULE FUNCTION get_grid_point ( THIS , i , j , k , l ) RESULT ( grid_point ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i , j , k , l ! Result DOUBLE PRECISION , DIMENSION ( 3 ) :: grid_point END FUNCTION get_grid_point MODULE FUNCTION get_nlevels ( THIS ) RESULT ( nlevels ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS ! Result DOUBLE PRECISION :: nlevels END FUNCTION get_nlevels MODULE FUNCTION get_levels ( THIS , l ) RESULT ( levels ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result TYPE ( level ), DIMENSION (:), ALLOCATABLE :: levels END FUNCTION get_levels MODULE FUNCTION get_dx ( THIS , l ) RESULT ( dx ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result DOUBLE PRECISION :: dx END FUNCTION get_dx MODULE FUNCTION get_dy ( THIS , l ) RESULT ( dy ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result DOUBLE PRECISION :: dy END FUNCTION get_dy MODULE FUNCTION get_dz ( THIS , l ) RESULT ( dz ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result DOUBLE PRECISION :: dz END FUNCTION get_dz MODULE FUNCTION get_ngrid_x ( THIS , l ) RESULT ( ngrid_x ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result INTEGER :: ngrid_x END FUNCTION get_ngrid_x MODULE FUNCTION get_ngrid_y ( THIS , l ) RESULT ( ngrid_y ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result INTEGER :: ngrid_y END FUNCTION get_ngrid_y MODULE FUNCTION get_ngrid_z ( THIS , l ) RESULT ( ngrid_z ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result INTEGER :: ngrid_z END FUNCTION get_ngrid_z MODULE FUNCTION get_xR ( THIS , l ) RESULT ( xR ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result INTEGER :: xR END FUNCTION get_xR MODULE FUNCTION get_yR ( THIS , l ) RESULT ( yR ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result INTEGER :: yR END FUNCTION get_yR MODULE FUNCTION get_zR ( THIS , l ) RESULT ( zR ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: l ! Result INTEGER :: zR END FUNCTION get_zR MODULE FUNCTION get_HC ( THIS , i , j , k , l ) RESULT ( HC_value ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i , j , k , l ! Result DOUBLE PRECISION :: HC_value END FUNCTION get_HC MODULE FUNCTION get_MC ( THIS , i , j , k , l ) RESULT ( MC_value ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i , j , k , l ! Result DOUBLE PRECISION , DIMENSION ( 3 ) :: MC_value END FUNCTION get_MC MODULE FUNCTION get_HC_parts ( THIS , i , j , k , l ) RESULT ( HC_value ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i , j , k , l ! Result DOUBLE PRECISION :: HC_value END FUNCTION get_HC_parts MODULE FUNCTION get_MC_parts ( THIS , i , j , k , l ) RESULT ( MC_value ) ! Arguments CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i , j , k , l ! Result DOUBLE PRECISION , DIMENSION ( 3 ) :: MC_value END FUNCTION get_MC_parts END INTERFACE ! !-- Interfaces of the deferred methods of TYPE formul_3p1 !-- Their implementations are deferred to derived TYPES ! ABSTRACT INTERFACE SUBROUTINE define_allocate_fields_interface ( THIS ) IMPORT :: formul_3p1 CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS END SUBROUTINE define_allocate_fields_interface SUBROUTINE compute_and_export_3p1_variables_interface ( THIS , namefile ) IMPORT :: formul_3p1 CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE compute_and_export_3p1_variables_interface SUBROUTINE print_formatted_lorene_id_3p1_variables_interface & ( THIS , namefile ) IMPORT :: formul_3p1 CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE print_formatted_lorene_id_3p1_variables_interface SUBROUTINE compute_and_export_3p1_constraints_grid_interface ( THIS , & id , & namefile , & name_logfile ) IMPORT :: formul_3p1 IMPORT :: idbase CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS CLASS ( idbase ), INTENT ( IN OUT ) :: id CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: namefile CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: name_logfile END SUBROUTINE compute_and_export_3p1_constraints_grid_interface SUBROUTINE compute_and_export_3p1_constraints_particles_interface ( THIS , & parts_obj , & namefile , & name_logfile ) IMPORT :: formul_3p1 IMPORT :: particles CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS CLASS ( particles ), INTENT ( IN OUT ) :: parts_obj CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: namefile CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: name_logfile END SUBROUTINE compute_and_export_3p1_constraints_particles_interface SUBROUTINE deallocate_fields_interface ( THIS ) IMPORT :: formul_3p1 CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: THIS END SUBROUTINE deallocate_fields_interface END INTERFACE END MODULE formul_3p1_id","tags":"","loc":"sourcefile/module_formul_3p1_id.f90.html"},{"title":"submodule_formul_3p1_standard3p1_variables.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_formul_3p1_standard3p1_variables.f90~~EfferentGraph sourcefile~submodule_formul_3p1_standard3p1_variables.f90 submodule_formul_3p1_standard3p1_variables.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_formul_3p1_standard3p1_variablesf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_formul_3p1_standard3p1_variablesf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules formul_3p1_standard3p1_variables Source Code submodule_formul_3p1_standard3p1_variables.f90 Source Code ! File:         submodule_formul_3p1_standard3p1_variables.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( formul_3p1_id ) formul_3p1_standard3p1_variables !**************************************************** !                                                   * !# Implementation of the methods of TYPE formul_3p1 * !  that are called from the constructors and        * !  destructors of its EXTENDED TYPES                * !                                                   * !  FT 22.10.2020                                    * !                                                   * !**************************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE setup_standard3p1_variables !************************************************* !                                                * !# Read the gravity grid parameters, computes    * !  gravity grid coordinates, imports the LORENE  * !  spacetime ID on the gravity grid, and         * !  performs some checks on it.                   * !  Its input includes the numbers of grid points * !  per axis, contrary to                         * !  construct_formul_3p1_bns_grid                 * !  where those numbers are replaced by the grid  * !  spacings.                                     * !                                                * !  FT 22.10.2020                                 * !                                                * !************************************************* USE mesh_refinement , ONLY : levels , nlevels , initialize_grid , & allocate_grid_function , & deallocate_grid_function , & coords , rad_coord !USE NaNChecker, ONLY: Check_Grid_Function_for_NAN USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , n_sym3x3 USE utility , ONLY : determinant_sym3x3_grid IMPLICIT NONE ! Index running over the refinement levels INTEGER :: l ! Indices running over the grids INTEGER :: i , j , k ! Determinant of the standard 3+1 spatial metric DOUBLE PRECISION :: detg DOUBLE PRECISION , DIMENSION ( 6 ) :: system_size ! !-- Initialize timers ! f3p1 % grid_timer = timer ( \"grid_timer\" ) f3p1 % importer_timer = timer ( \"importer_timer\" ) CALL f3p1 % grid_timer % start_timer () IF ( PRESENT ( dx ) . AND . PRESENT ( dy ) . AND . PRESENT ( dz ) ) THEN CALL initialize_grid ( dx , dy , dz ) ELSE CALL initialize_grid () ENDIF !PRINT *, ABS(id% get_center1_x()) + id% get_radius1_x_opp() !PRINT *, ABS(id% get_center2_x()) + id% get_radius2_x_opp() !PRINT *, ABS(levels(nlevels)% xR) ! !-- Check that the stars are inside the finest refinement lvel ! system_size = id % get_total_spatial_extent () IF ( MAXVAL ( ABS ( system_size ) ) > ABS ( levels ( nlevels )% xR ) ) THEN PRINT * PRINT * , \"** The innermost, finest refinement level does not contain \" , & \"the entire system.\" PRINT * , \"   Boundary of the innermost, finest level: \" , & ABS ( levels ( nlevels )% xR ), \" Msun_geo\" PRINT * , \"   Size of the system: \" , MAXVAL ( ABS ( system_size ) ), & \" Msun_geo\" PRINT * , \"   Please make the boundary of the innermost, finest level, \" , & \"larger than \" , MAXVAL ( ABS ( system_size ) ), & \" Msun_geo\" PRINT * , \"   Stopping...\" PRINT * STOP ENDIF CALL allocate_grid_function ( f3p1 % coords , \"coords_id\" , 3 ) CALL allocate_grid_function ( f3p1 % rad_coord , 'rad_coord_id' , 1 ) f3p1 % nlevels = nlevels f3p1 % levels = levels ref_levels : DO l = 1 , f3p1 % nlevels f3p1 % coords % levels ( l )% var = coords % levels ( l )% var f3p1 % rad_coord % levels ( l )% var = rad_coord % levels ( l )% var ENDDO ref_levels CALL deallocate_grid_function ( coords , 'coords' ) CALL deallocate_grid_function ( rad_coord , 'rad_coord' ) ! !-- Allocating the memory for the grid functions !-- storing the LORENE spacetime ID at the grid points ! CALL allocate_grid_function ( f3p1 % lapse , \"lapse_id\" , 1 ) CALL allocate_grid_function ( f3p1 % shift_u , \"shift_u_id\" , 3 ) CALL allocate_grid_function ( f3p1 % g_phys3_ll , \"g_phys3_ll_id\" , 6 ) CALL allocate_grid_function ( f3p1 % K_phys3_ll , \"K_phys3_ll_id\" , 6 ) CALL f3p1 % grid_timer % stop_timer () ! !-- Import the LORENE spacetime ID on the refined mesh, !-- and time the process ! PRINT * PRINT * , \"** Importing the LORENE spacetime ID on the refined mesh...\" PRINT * CALL f3p1 % importer_timer % start_timer () !PRINT *, \"nlevels=\", f3p1% nlevels ref_levels2 : DO l = 1 , f3p1 % nlevels , 1 PRINT * , \" * Importing on refinement level l=\" , l , \"...\" !PRINT *, \"get_ngrid_x=\", f3p1% get_ngrid_x(l) !PRINT *, \"get_ngrid_y=\", f3p1% get_ngrid_y(l) !PRINT *, \"get_ngrid_z=\", f3p1% get_ngrid_z(l) !PRINT * !PRINT *, f3p1% coords% levels(l)% var CALL id % read_id_spacetime ( f3p1 % get_ngrid_x ( l ), & f3p1 % get_ngrid_y ( l ), & f3p1 % get_ngrid_z ( l ), & f3p1 % coords % levels ( l )% var , & f3p1 % lapse % levels ( l )% var , & f3p1 % shift_u % levels ( l )% var , & f3p1 % g_phys3_ll % levels ( l )% var , & f3p1 % K_phys3_ll % levels ( l )% var ) ENDDO ref_levels2 CALL f3p1 % importer_timer % stop_timer () PRINT * , \" * LORENE spacetime ID imported on the gravity grid.\" ! !-- Check that the imported ID does not contain NaNs ! !CALL Check_Grid_Function_for_NAN( f3p1% lapse, \"lapse\" ) !CALL Check_Grid_Function_for_NAN( f3p1% shift_u(:,:,:,jx), & !                                                    \"shift_u_x\" ) !CALL Check_Grid_Function_for_NAN( f3p1% shift_u(:,:,:,jy), & !                                                    \"shift_u_y\" ) !CALL Check_Grid_Function_for_NAN( f3p1% shift_u(:,:,:,jz), & !                                                    \"shift_u_z\" ) !CALL Check_Grid_Function_for_NAN( f3p1% g_phys3_ll(:,:,:,jxx), & !                                                    \"g_phys3_ll_jxx\" ) !CALL Check_Grid_Function_for_NAN( f3p1% g_phys3_ll(:,:,:,jxy), & !                                                    \"g_phys3_ll_jxy\" ) !CALL Check_Grid_Function_for_NAN( f3p1% g_phys3_ll(:,:,:,jxz), & !                                                    \"g_phys3_ll_jxz\" ) !CALL Check_Grid_Function_for_NAN( f3p1% g_phys3_ll(:,:,:,jyy), & !                                                    \"g_phys3_ll_jyy\" ) !CALL Check_Grid_Function_for_NAN( f3p1% g_phys3_ll(:,:,:,jyz), & !                                                    \"g_phys3_ll_jyz\" ) !CALL Check_Grid_Function_for_NAN( f3p1% g_phys3_ll(:,:,:,jzz), & !                                                    \"g_phys3_ll_jzz\" ) !CALL Check_Grid_Function_for_NAN( f3p1% K_phys3_ll(:,:,:,jxx), & !                                                    \"K_phys3_ll_jxx\" ) !CALL Check_Grid_Function_for_NAN( f3p1% K_phys3_ll(:,:,:,jxy), & !                                                    \"K_phys3_ll_jxy\" ) !CALL Check_Grid_Function_for_NAN( f3p1% K_phys3_ll(:,:,:,jxz), & !                                                    \"K_phys3_ll_jxz\" ) !CALL Check_Grid_Function_for_NAN( f3p1% K_phys3_ll(:,:,:,jyy), & !                                                    \"K_phys3_ll_jyy\" ) !CALL Check_Grid_Function_for_NAN( f3p1% K_phys3_ll(:,:,:,jyz), & !                                                    \"K_phys3_ll_jyz\" ) !CALL Check_Grid_Function_for_NAN( f3p1% K_phys3_ll(:,:,:,jzz), & !                                                    \"K_phys3_ll_jzz\" ) ! !-- Check that the determinant of the spatial metric is !-- strictly positive ! DO l = 1 , f3p1 % nlevels , 1 DO k = 1 , f3p1 % get_ngrid_z ( l ), 1 DO j = 1 , f3p1 % get_ngrid_y ( l ), 1 DO i = 1 , f3p1 % get_ngrid_x ( l ), 1 CALL determinant_sym3x3_grid ( i , j , k , & f3p1 % g_phys3_ll % levels ( l )% var , & detg ) IF ( detg < 1 D - 10 ) THEN PRINT * , \"** ERROR! construct_formul_3p1_bns: The \" & // \"determinant of the spatial metric is \" & // \"effectively 0 at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \"), \" & // \"(x,y,z)= \" , \"(\" , & f3p1 % coords % levels ( l )% var ( i , j , k , 1 ), \",\" , & f3p1 % coords % levels ( l )% var ( i , j , k , 2 ), \",\" , & f3p1 % coords % levels ( l )% var ( i , j , k , 3 ), \").\" PRINT * PRINT * , f3p1 % get_ngrid_x ( l ), f3p1 % get_ngrid_y ( l ), & f3p1 % get_ngrid_z ( l ) PRINT * PRINT * , \"detg=\" , detg PRINT * PRINT * , \"g_xx=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jxx ) PRINT * , \"g_xy=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jxy ) PRINT * , \"g_xz=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jxz ) PRINT * , \"g_yy=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jyy ) PRINT * , \"g_yz=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jyz ) PRINT * , \"g_zz=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jzz ) STOP ELSEIF ( detg < 0 ) THEN PRINT * , \"** ERROR! construct_formul_3p1_bns: The \" & // \"determinant of the spatial metric is \" & // \"negative at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \"), \" & // \"(x,y,z)= \" , \"(\" , & f3p1 % coords % levels ( l )% var ( i , j , k , 1 ), \",\" , & f3p1 % coords % levels ( l )% var ( i , j , k , 2 ), \",\" , & f3p1 % coords % levels ( l )% var ( i , j , k , 3 ), \").\" PRINT * PRINT * , f3p1 % get_ngrid_x ( l ), f3p1 % get_ngrid_y ( l ), & f3p1 % get_ngrid_z ( l ) PRINT * PRINT * , \"detg=\" , detg PRINT * PRINT * , \"g_xx=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jxx ) PRINT * , \"g_xy=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jxy ) PRINT * , \"g_xz=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jxz ) PRINT * , \"g_yy=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jyy ) PRINT * , \"g_yz=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jyz ) PRINT * , \"g_zz=\" , f3p1 % g_phys3_ll % levels ( l )% var ( i , j , k , jzz ) STOP ENDIF ENDDO ENDDO ENDDO ENDDO PRINT * , \" * Checked that the determinant of the spatial metric is\" , & \" strictly positive.\" PRINT * END PROCEDURE setup_standard3p1_variables MODULE PROCEDURE deallocate_standard3p1_variables !*************************************************** !                                                  * !# Core of the destructors of TYPES derived from   * !  formul_3p1. Their destructors should call this  * !  SUBROUTINE. It deallocates memory.              * !                                                  * !  FT                                              * !                                                  * !*************************************************** USE mesh_refinement , ONLY : deallocate_grid_function IMPLICIT NONE IF ( ALLOCATED ( f3p1 % coords % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % coords , \"coords_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % rad_coord % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % rad_coord , \"rad_coord_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % lapse % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % lapse , \"lapse_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % shift_u % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % shift_u , \"shift_u_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % g_phys3_ll % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % g_phys3_ll , \"g_phys3_ll_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % K_phys3_ll % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % K_phys3_ll , \"K_phys3_ll_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % HC % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % HC , \"HC_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % HC_parts % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % HC_parts , \"HC_parts_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % MC % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % MC , \"MC_id\" ) ENDIF IF ( ALLOCATED ( f3p1 % MC_parts % levels ) ) THEN CALL deallocate_grid_function ( f3p1 % MC_parts , \"MC_parts_id\" ) ENDIF END PROCEDURE deallocate_standard3p1_variables END SUBMODULE formul_3p1_standard3p1_variables","tags":"","loc":"sourcefile/submodule_formul_3p1_standard3p1_variables.f90.html"},{"title":"submodule_formul_3p1_analysis.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_formul_3p1_analysis.f90~~EfferentGraph sourcefile~submodule_formul_3p1_analysis.f90 submodule_formul_3p1_analysis.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~submodule_formul_3p1_analysis.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 var pansourcefilesubmodule_formul_3p1_analysisf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_formul_3p1_analysisf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules formul_3p1_analysis Source Code submodule_formul_3p1_analysis.f90 Source Code ! File:         submodule_formul_3p1_analysis.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( formul_3p1_id ) formul_3p1_analysis !**************************************************** !                                                   * ! Implementation of the methods of TYPE formul_3p1  * ! that analyze a grid function.                     * !                                                   * ! FT 12.07.2021                                     * !                                                   * !**************************************************** IMPLICIT NONE CONTAINS MODULE PROCEDURE analyze_constraint IMPLICIT NONE INTEGER :: cnt_m7 , cnt_m6 , cnt_m5 , cnt_m4 , cnt_m3 , cnt_m2 , cnt_m1 , cnt_0 , & cnt_p1 , cnt_p2 , cnt_p3 , cnt_oo , grid_points , i , j , k , & unit_analysis , nx , ny , nz DOUBLE PRECISION :: tmp , total LOGICAL :: exist LOGICAL , PARAMETER :: DEBUG = . FALSE . IF ( THIS % export_constraints_details ) THEN ! !-- Export the constraint analysis to a formatted file ! unit_analysis = 20120 INQUIRE ( FILE = TRIM ( name_analysis ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_analysis , FILE = TRIM ( name_analysis ), & STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_analysis , FILE = TRIM ( name_analysis ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"... error when opening \" // TRIM ( name_analysis ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_analysis) ) WRITE ( UNIT = unit_analysis , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_analysis , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# The rows contain the points (l,x,y,z), with l refinement level, \" , & \"at which \" , name_constraint , & \" has values in: (-oo,1D-7], [1D-7,1D-6], [1D-6,1D-5], [1D-5,1D-4]\" & // \", [1D-4,1D-3], [1D-3,1D-2], [1D-2,1D-1], [1D-1,1], [1,1D+1]\" & // \", [1D+1,1D+2], [1D+2,1D+3], [1D+3,+oo)\" ENDIF CALL THIS % abs_values_in ( 0.0D0 , 1.0D-7 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_m7 ) CALL THIS % abs_values_in ( 1.0D-7 , 1.0D-6 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_m6 ) CALL THIS % abs_values_in ( 1.0D-6 , 1.0D-5 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_m5 ) CALL THIS % abs_values_in ( 1.0D-5 , 1.0D-4 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_m4 ) CALL THIS % abs_values_in ( 1.0D-4 , 1.0D-3 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_m3 ) CALL THIS % abs_values_in ( 1.0D-3 , 1.0D-2 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_m2 ) CALL THIS % abs_values_in ( 1.0D-2 , 1.0D-1 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_m1 ) CALL THIS % abs_values_in ( 1.0D-1 , 1.0D0 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_0 ) CALL THIS % abs_values_in ( 1.0D0 , 1 D + 1 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_p1 ) CALL THIS % abs_values_in ( 1.0D+1 , 1.0D+2 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_p2 ) CALL THIS % abs_values_in ( 1.0D+2 , 1.0D+3 , constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_p3 ) CALL THIS % abs_values_in ( 1.0D+3 , HUGE ( DBLE ( 1.0D0 )), constraint , l , & THIS % export_constraints_details , & unit_analysis , cnt_oo ) CLOSE ( UNIT = unit_analysis ) IF ( THIS % export_constraints_details ) THEN PRINT * , \" * The details about the absolute values of \" , & name_constraint , \" are printed to \" , name_analysis ENDIF nx = THIS % get_ngrid_x ( l ) ny = THIS % get_ngrid_y ( l ) nz = THIS % get_ngrid_z ( l ) grid_points = nx * ny * nz ! !-- Compute the l2 norm of the constraints ! l2_norm = 0.0D0 DO k = 1 , nz , 1 DO j = 1 , ny , 1 DO i = 1 , nx , 1 l2_norm = l2_norm + constraint ( i , j , k ) * constraint ( i , j , k ) ENDDO ENDDO ENDDO l2_norm = SQRT ( l2_norm / grid_points ) ! !-- Compute the loo norm (supremum norm) of the constraints ! loo_norm = 0.0D0 DO k = 1 , nz , 1 DO j = 1 , ny , 1 DO i = 1 , nx , 1 tmp = ABS ( constraint ( i , j , k ) ) IF ( tmp > loo_norm ) THEN loo_norm = tmp ENDIF ENDDO ENDDO ENDDO ! !-- Write a summary of the results to the logfile ! WRITE ( UNIT = unit_logfile , FMT = * ) \"# The absolute values of \" , & name_constraint , & \" on the gravity grid are in the following intervals, on the \" , & \"given percentage of grid points:\" WRITE ( UNIT = unit_logfile , FMT = * ) \"\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (-oo,1D-7]: \" , & 10 0.0D0 * DBLE ( cnt_m7 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D-7,1D-6]: \" , & 10 0.0D0 * DBLE ( cnt_m6 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D-6,1D-5]: \" , & 10 0.0D0 * DBLE ( cnt_m5 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D-5,1D-4]: \" , & 10 0.0D0 * DBLE ( cnt_m4 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D-4,1D-3]: \" , & 10 0.0D0 * DBLE ( cnt_m3 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D-3,1D-2]: \" , & 10 0.0D0 * DBLE ( cnt_m2 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D-2,1D-1]: \" , & 10 0.0D0 * DBLE ( cnt_m1 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D-1,1]: \" , & 10 0.0D0 * DBLE ( cnt_0 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1,10]: \" , & 10 0.0D0 * DBLE ( cnt_p1 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (10,1D+2]: \" , & 10 0.0D0 * DBLE ( cnt_p2 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D+2,1D+3]: \" , & 10 0.0D0 * DBLE ( cnt_p3 ) / DBLE ( grid_points ) , \"%\" WRITE ( UNIT = unit_logfile , FMT = \"(A15,F5.1,A1)\" ) \"  (1D+3,+oo]: \" , & 10 0.0D0 * DBLE ( cnt_oo ) / DBLE ( grid_points ), \"%\" WRITE ( UNIT = unit_logfile , FMT = * ) WRITE ( UNIT = unit_logfile , FMT = * ) \"# l2-norm of \" , name_constraint ,& \" over the gravity grid= \" , l2_norm WRITE ( UNIT = unit_logfile , FMT = * ) WRITE ( UNIT = unit_logfile , FMT = * ) & \"# loo-norm (supremum of the absolute values) of \" , & name_constraint ,& \" over the gravity grid= \" , loo_norm WRITE ( UNIT = unit_logfile , FMT = * ) total = 10 0.0D0 * DBLE ( cnt_m7 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_m6 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_m5 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_m4 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_m3 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_m2 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_m1 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_0 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_p1 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_p2 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_p3 ) / DBLE ( grid_points ) + & 10 0.0D0 * DBLE ( cnt_oo ) / DBLE ( grid_points ) IF ( total - DBLE ( 100 ) > 1.0D-4 ) THEN PRINT * , \" * WARNING! The percentages of the absolute values of \" , & name_constraint , & \" in the given intervals do not sum up to 100%. \" , & \" They sum up to\" , total , \"%\" PRINT * , \"Check what happens in the SUBROUTINES analyze_constraint \" , & \"and abs_values_in.\" ENDIF END PROCEDURE analyze_constraint MODULE PROCEDURE abs_values_in !************************************************** !                                                 * ! Set \"cnt\" equal to the number of times that the * ! absolute value of \"constraint\" is in            * ! (lower_bound,upper_bound].                      * ! Depending on \"export\", it prints to file the    * ! grid points at which this happens.              * !                                                 * ! FT 24.03.2021                                   * !                                                 * !************************************************** USE tensor , ONLY : jx , jy , jz IMPLICIT NONE INTEGER :: i , j , k , nx , ny , nz nx = THIS % get_ngrid_x ( l ) ny = THIS % get_ngrid_y ( l ) nz = THIS % get_ngrid_z ( l ) cnt = 0 DO k = 1 , nz , 1 DO j = 1 , ny , 1 DO i = 1 , nx , 1 IF ( ABS ( constraint ( i , j , k ) ) >= lower_bound . AND . & ABS ( constraint ( i , j , k ) ) < upper_bound ) THEN cnt = cnt + 1 IF ( export ) THEN WRITE ( UNIT = unit_analysis , IOSTAT = ios , & IOMSG = err_msg , FMT = \"(F17.13)\" , & ADVANCE = \"NO\" ) & !\"(E15.6)\" & l WRITE ( UNIT = unit_analysis , IOSTAT = ios , & IOMSG = err_msg , FMT = \"(F17.13)\" , & ADVANCE = \"NO\" ) & !\"(E15.6)\" & THIS % coords % levels ( l )% var ( i , j , k , jx ) WRITE ( UNIT = unit_analysis , FMT = \"(A2)\" , & ADVANCE = \"NO\" ) \"  \" WRITE ( UNIT = unit_analysis , IOSTAT = ios , & IOMSG = err_msg , FMT = \"(F17.13)\" , & ADVANCE = \"NO\" ) & THIS % coords % levels ( l )% var ( i , j , k , jy ) WRITE ( UNIT = unit_analysis , FMT = \"(A2)\" , & ADVANCE = \"NO\" ) \"  \" WRITE ( UNIT = unit_analysis , IOSTAT = ios , & IOMSG = err_msg , FMT = \"(F17.13)\" , & ADVANCE = \"NO\" ) & THIS % coords % levels ( l )% var ( i , j , k , jz ) WRITE ( UNIT = unit_analysis , FMT = \"(A2)\" , & ADVANCE = \"NO\" ) \"  \" ENDIF ENDIF ENDDO ENDDO ENDDO IF ( export . AND . cnt == 0 ) THEN WRITE ( UNIT = unit_analysis , FMT = \"(I1)\" , ADVANCE = \"NO\" ) 0 WRITE ( UNIT = unit_analysis , FMT = \"(I1)\" , ADVANCE = \"NO\" ) 0 WRITE ( UNIT = unit_analysis , FMT = \"(I1)\" , ADVANCE = \"NO\" ) 0 ENDIF WRITE ( UNIT = unit_analysis , FMT = * ) \"\" END PROCEDURE abs_values_in END SUBMODULE formul_3p1_analysis","tags":"","loc":"sourcefile/submodule_formul_3p1_analysis.f90.html"},{"title":"module_bssn_id.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_bssn_id.f90~~EfferentGraph sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_bssn_id.f90~~AfferentGraph sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~submodule_bssn_id_variables.f90 submodule_bssn_id_variables.f90 sourcefile~submodule_bssn_id_variables.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bssn_id_constraints.f90 submodule_bssn_id_constraints.f90 sourcefile~submodule_bssn_id_constraints.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bssn_id_memory.f90 submodule_bssn_id_memory.f90 sourcefile~submodule_bssn_id_memory.f90->sourcefile~module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bssn_id_constructor.f90 submodule_bssn_id_constructor.f90 sourcefile~submodule_bssn_id_constructor.f90->sourcefile~module_bssn_id.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules formul_bssn_id Source Code module_bssn_id.f90 Source Code ! File:         module_bssn_id.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE formul_bssn_id !*********************************************************** !                                                          * !   This module contains the definition of TYPE bssn_id    * !                                                          * !*********************************************************** USE utility , ONLY : ios , err_msg , perc , creturn , run_id , & test_status , compute_g4 , & determinant_sym4x4_grid , show_progress USE id_base , ONLY : idbase USE formul_3p1_id , ONLY : formul_3p1 USE particles_id , ONLY : particles USE timing , ONLY : timer USE mesh_refinement , ONLY : grid_function_scalar , grid_function IMPLICIT NONE !******************************************************** !                                                       * !              Definition of TYPE bssn_id               * !                                                       * ! This class extends the ABSTRACT TYPE formul_3p1 by    * ! implementing its deferred methods such that the BSSN  * ! variable sare computed on the grid for the LORENE ID, * ! stored, exported to a binary file for evolution and   * ! to a formatted file. The BSSN constraints can also    * ! be computed in different ways, analyzed, and exported * ! in different ways.                                    * !                                                       * !******************************************************** TYPE , EXTENDS ( formul_3p1 ) :: bssn_id INTEGER :: call_flag = 0 ! Flag set to a value different than 0 if the SUBROUTINE ! compute_and_export_bssn_variables is called ! !-- Arrays storing the BSSN variables for the LORENE ID on the grid ! TYPE ( grid_function ) :: Gamma_u !! Conformal connection TYPE ( grid_function_scalar ) :: phi !! Conformal factor TYPE ( grid_function_scalar ) :: trK !! Trace of extrinsic curvature TYPE ( grid_function ) :: A_BSSN3_ll !! Conformal traceless extrinsic curvature TYPE ( grid_function ) :: g_BSSN3_ll !! Conformal spatial metric ! !-- Connection constraints and its l2 norm and loo norm ! TYPE ( grid_function ) :: GC TYPE ( grid_function ) :: GC_parts DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_l2 DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_parts_l2 DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_loo DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_parts_loo LOGICAL , PUBLIC :: export_bin LOGICAL , PUBLIC :: export_form_xy , export_form_x TYPE ( timer ) :: bssn_computer_timer CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: define_allocate_fields => allocate_bssn_fields PROCEDURE :: compute_and_export_3p1_variables & => compute_and_export_bssn_variables PROCEDURE , PUBLIC :: read_bssn_dump_print_formatted PROCEDURE :: print_formatted_lorene_id_3p1_variables & => print_formatted_lorene_id_bssn_variables PROCEDURE :: compute_and_export_3p1_constraints_grid & => compute_and_export_bssn_constraints_grid PROCEDURE :: compute_and_export_3p1_constraints_particles & => compute_and_export_bssn_constraints_particles PROCEDURE :: deallocate_fields => deallocate_bssn_fields PROCEDURE :: destruct_bssn_id !# Finalizer for members of the extended class bssn_id, not the !  primitive class formul_3p1 FINAL :: destructor !# Destructor; finalizes members from both CLASSES formul_3p1, and bssn_id, !  by calling destruct_formul_3p1 and destruct_bssn_id END TYPE bssn_id ! !-- Interface of the TYPE bssn_id !-- (i.e., declaration of the overloaded constructor) ! INTERFACE bssn_id MODULE PROCEDURE :: construct_bssn_id !# Constructs the bssn_id object from the number of grid points !  along each axis END INTERFACE bssn_id ! !-- Interface of the constructor of TYPE bssn_id !-- Its implementation is in submodule_BSSN_id_constructor.f90 ! INTERFACE MODULE FUNCTION construct_bssn_id ( id , dx , dy , dz ) RESULT ( bssnid ) !# Constructs the bssn_id object from the number of grid points !  along each axis CLASS ( idbase ), INTENT ( IN OUT ) :: id TYPE ( bssn_id ) :: bssnid DOUBLE PRECISION , OPTIONAL :: dx , dy , dz END FUNCTION construct_bssn_id END INTERFACE ! !-- Interfaces of the methods of TYPE bssn_id !-- Their implementations are in submodule_BSSN_id_methods.f90 ! INTERFACE MODULE SUBROUTINE allocate_bssn_fields ( THIS ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS END SUBROUTINE allocate_bssn_fields MODULE SUBROUTINE compute_and_export_bssn_variables ( THIS , namefile ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE compute_and_export_bssn_variables MODULE SUBROUTINE read_bssn_dump_print_formatted ( THIS , namefile_bin , & namefile ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile_bin CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE read_bssn_dump_print_formatted MODULE SUBROUTINE print_formatted_lorene_id_bssn_variables ( THIS , & namefile ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE print_formatted_lorene_id_bssn_variables MODULE SUBROUTINE compute_and_export_bssn_constraints_grid ( THIS , & id , & namefile , & name_logfile ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS CLASS ( idbase ), INTENT ( IN OUT ) :: id CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: namefile CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: name_logfile END SUBROUTINE compute_and_export_bssn_constraints_grid MODULE SUBROUTINE compute_and_export_bssn_constraints_particles ( THIS , & parts_obj , & namefile , & name_logfile ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS CLASS ( particles ), INTENT ( IN OUT ) :: parts_obj CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: namefile CHARACTER ( LEN = * ), INTENT ( IN OUT ) :: name_logfile END SUBROUTINE compute_and_export_bssn_constraints_particles MODULE SUBROUTINE deallocate_bssn_fields ( THIS ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS END SUBROUTINE deallocate_bssn_fields MODULE SUBROUTINE destruct_bssn_id ( THIS ) CLASS ( bssn_id ), INTENT ( IN OUT ) :: THIS END SUBROUTINE destruct_bssn_id MODULE SUBROUTINE destructor ( THIS ) TYPE ( bssn_id ), INTENT ( IN OUT ) :: THIS END SUBROUTINE destructor END INTERFACE END MODULE formul_bssn_id","tags":"","loc":"sourcefile/module_bssn_id.f90.html"},{"title":"submodule_bssn_id_variables.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bssn_id_variables.f90~~EfferentGraph sourcefile~submodule_bssn_id_variables.f90 submodule_bssn_id_variables.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~submodule_bssn_id_variables.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 var pansourcefilesubmodule_bssn_id_variablesf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bssn_id_variablesf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bssn_id_variables Source Code submodule_bssn_id_variables.f90 Source Code ! File:         submodule_BSSN_id_variables.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( formul_bssn_id ) bssn_id_variables !************************************************ !                                               * ! Implementation of the methods of TYPE bssn_id * ! that compute, print and read the BSSN         * ! variables                                     * !                                               * ! FT 23.10.2020                                 * !                                               * ! Updated to mesh refinement                    * !                                               * ! FT 26.03.2021                                 * !                                               * ! Renamed from bssn_id_methods to               * ! bssn_id_variables upon improving modularity   * !                                               * ! FT 12.07.2021                                 * !                                               * !************************************************ IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE compute_and_export_bssn_variables !************************************************ !                                               * ! Compute, stores and export the BSSN variables * ! to a binary file to be read by the evolution  * ! code in SPHINCS                               * !                                               * ! FT 23.10.2020                                 * !                                               * !************************************************ !USE NaNChecker,          ONLY: Check_Grid_Function_for_NAN USE mesh_refinement , ONLY : nlevels , levels , rad_coord , & allocate_grid_function , & deallocate_grid_function USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , n_sym3x3 USE ADM_refine , ONLY : lapse , dt_lapse , shift_u , dt_shift_u , & K_phys3_ll , g_phys3_ll , & allocate_ADM , deallocate_ADM USE McLachlan_refine , ONLY : allocate_Ztmp , deallocate_Ztmp , & ADM_to_BSSN USE Tmunu_refine , ONLY : allocate_Tmunu , deallocate_Tmunu , & Tmunu_ll USE GravityAcceleration_refine , ONLY : allocate_GravityAcceleration , & deallocate_GravityAcceleration USE constants , ONLY : Msun_geo ! !-- Use the arrays from the MODULE BSSN to store the BSSN variables !-- for the LORENE ID on the grid, and the SUBROUTINE write_BSSN_dump !-- to export them to the binary file needed by the evolution code !-- in SPHINCS ! USE BSSN_refine , ONLY : allocate_BSSN , deallocate_BSSN , & Gamma_u , & ! Conformal connection phi , & ! Conformal factor trK , & ! Trace of extrinsic curvature A_BSSN3_ll , & ! Conformal traceless ! extrinsic curvature g_BSSN3_ll , & ! Conformal metric !Theta_Z4,         & ! Vector in the CCZ4 formulation ! Used because ADM_TO_BSSN ! calls SUBROUTINES that need it ! as input; however, it is not ! evolved in BSSN !lapse_A_BSSN,     & ! Time derivative of lapse !shift_B_BSSN_u,   & ! Time derivativeof shift write_BSSN_dump IMPLICIT NONE ! The flag call_flag is set different than 0 if the SUBROUTINE ! compute_and_export_SPH_variables is called INTEGER , SAVE :: call_flag = 0 INTEGER :: l PRINT * , \"** Computing and exporting BSSN ID...\" ! Allocate memory for the ADM MODULE variables (this has to be done since ! the MODULE SUBROUTINES need them; not allocating it results in a ! segmentation fault) PRINT * PRINT * , \" * Allocating needed memory...\" PRINT * ALLOCATE ( levels ( THIS % nlevels ), STAT = ios ) IF ( ios > 0 ) THEN PRINT * , '...allocation error for levels' STOP ENDIF levels = THIS % levels nlevels = THIS % nlevels !DO l= 1, THIS% nlevels, 1 !  levels(l)% ngrid_x= THIS% levels(l)% ngrid_x !  levels(l)% ngrid_x= THIS% levels(l)% ngrid_x !  levels(l)% ngrid_x= THIS% levels(l)% ngrid_x !ENDDO CALL allocate_ADM () CALL allocate_BSSN () ! Allocate temporary memory for time integration CALL allocate_Ztmp () ! Allocate memory for the stress-energy tensor (used in write_BSSN_dump) CALL allocate_Tmunu () ! Allocate memory for the derivatives of the ADM variables CALL allocate_GravityAcceleration () CALL allocate_grid_function ( rad_coord , 'rad_coord' ) ! Assign values to the MODULE variables, in order to call ADM_to_BSSN ref_levels : DO l = 1 , THIS % nlevels Tmunu_ll % levels ( l )% var = 0.0D0 dt_lapse % levels ( l )% var = 0.0D0 dt_shift_u % levels ( l )% var = 0.0D0 rad_coord % levels ( l )% var = THIS % rad_coord % levels ( l )% var lapse % levels ( l )% var = THIS % lapse % levels ( l )% var shift_u % levels ( l )% var = THIS % shift_u % levels ( l )% var g_phys3_ll % levels ( l )% var = THIS % g_phys3_ll % levels ( l )% var K_phys3_ll % levels ( l )% var = THIS % K_phys3_ll % levels ( l )% var ENDDO ref_levels ! !-- Compute BSSN variables, and time the process !-- The BSSN variables are stored in the MODULE variables since !-- write_BSSN_dump need them ! PRINT * , \" * Computing BSSN variables...\" PRINT * CALL THIS % bssn_computer_timer % start_timer () CALL ADM_to_BSSN () !CALL ADM_to_BSSN_args( & !  THIS% dx, THIS% dy, THIS% dz, & !  ! ADM variables (input) !  THIS% g_phys3_ll(:,:,:,jxx), THIS% g_phys3_ll(:,:,:,jxy), & !  THIS% g_phys3_ll(:,:,:,jxz), THIS% g_phys3_ll(:,:,:,jyy), & !  THIS% g_phys3_ll(:,:,:,jyz), THIS% g_phys3_ll(:,:,:,jzz), & !  THIS% K_phys3_ll(:,:,:,jxx), THIS% K_phys3_ll(:,:,:,jxy), & !  THIS% K_phys3_ll(:,:,:,jxz), THIS% K_phys3_ll(:,:,:,jyy), & !  THIS% K_phys3_ll(:,:,:,jyz), THIS% K_phys3_ll(:,:,:,jzz), & !  THIS% lapse(:,:,:), & !  THIS% shift_u(:,:,:,jx), & !  THIS% shift_u(:,:,:,jy), & !  THIS% shift_u(:,:,:,jz), & !  dt_lapse(:,:,:), & !  dt_shift_u(:,:,:,jx), dt_shift_u(:,:,:,jy), dt_shift_u(:,:,:,jz), & !  ! BSSN variables (output) !  g_BSSN3_ll(:,:,:,jxx), g_BSSN3_ll(:,:,:,jxy), & !  g_BSSN3_ll(:,:,:,jxz), g_BSSN3_ll(:,:,:,jyy), & !  g_BSSN3_ll(:,:,:,jyz), g_BSSN3_ll(:,:,:,jzz), & !  A_BSSN3_ll(:,:,:,jxx), A_BSSN3_ll(:,:,:,jxy), & !  A_BSSN3_ll(:,:,:,jxz), A_BSSN3_ll(:,:,:,jyy), & !  A_BSSN3_ll(:,:,:,jyz), A_BSSN3_ll(:,:,:,jzz), & !  phi(:,:,:), trK(:,:,:), Theta_Z4(:,:,:), & !  lapse_A_BSSN(:,:,:), & !  shift_B_BSSN_u(:,:,:,jx), shift_B_BSSN_u(:,:,:,jy), & !  shift_B_BSSN_u(:,:,:,jz), & !  Gamma_u(:,:,:,jx), Gamma_u(:,:,:,jy), & !  Gamma_u(:,:,:,jz) & !) CALL THIS % bssn_computer_timer % stop_timer () ! Set the MODULE variables equal to the TYPE variables !lapse= THIS% lapse !shift_u= THIS% shift_u ! !-- Check the BSSN MODULE variables for NaNs ! !CALL Check_Grid_Function_for_NAN( lapse, \"lapse\" ) !CALL Check_Grid_Function_for_NAN( shift_u(:,:,:,jx), \"shift_u_x\" ) !CALL Check_Grid_Function_for_NAN( shift_u(:,:,:,jy), \"shift_u_y\" ) !CALL Check_Grid_Function_for_NAN( shift_u(:,:,:,jz), \"shift_u_z\" ) !CALL Check_Grid_Function_for_NAN( g_BSSN3_ll(:,:,:,jxx), & !                                                    \"g_BSSN3_ll_jxx\" ) !CALL Check_Grid_Function_for_NAN( g_BSSN3_ll(:,:,:,jxy), & !                                                    \"g_BSSN3_ll_jxy\" ) !CALL Check_Grid_Function_for_NAN( g_BSSN3_ll(:,:,:,jxz), & !                                                    \"g_BSSN3_ll_jxz\" ) !CALL Check_Grid_Function_for_NAN( g_BSSN3_ll(:,:,:,jyy), & !                                                    \"g_BSSN3_ll_jyy\" ) !CALL Check_Grid_Function_for_NAN( g_BSSN3_ll(:,:,:,jyz), & !                                                    \"g_BSSN3_ll_jyz\" ) !CALL Check_Grid_Function_for_NAN( g_BSSN3_ll(:,:,:,jzz), & !                                                    \"g_BSSN3_ll_jzz\" ) !CALL Check_Grid_Function_for_NAN( A_BSSN3_ll(:,:,:,jxx), & !                                                    \"A_BSSN3_ll_jxx\" ) !CALL Check_Grid_Function_for_NAN( A_BSSN3_ll(:,:,:,jxy), & !                                                    \"A_BSSN3_ll_jxy\" ) !CALL Check_Grid_Function_for_NAN( A_BSSN3_ll(:,:,:,jxz), & !                                                    \"A_BSSN3_ll_jxz\" ) !CALL Check_Grid_Function_for_NAN( A_BSSN3_ll(:,:,:,jyy), & !                                                    \"A_BSSN3_ll_jyy\" ) !CALL Check_Grid_Function_for_NAN( A_BSSN3_ll(:,:,:,jyz), & !                                                    \"A_BSSN3_ll_jyz\" ) !CALL Check_Grid_Function_for_NAN( A_BSSN3_ll(:,:,:,jzz), & !                                                    \"A_BSSN3_ll_jzz\" ) !CALL Check_Grid_Function_for_NAN( phi, \"phi\" ) !CALL Check_Grid_Function_for_NAN( trK, \"trK\" ) !CALL Check_Grid_Function_for_NAN( Gamma_u(:,:,:,jx), \"Gamma_u_x\" ) !CALL Check_Grid_Function_for_NAN( Gamma_u(:,:,:,jy), \"Gamma_u_y\" ) !CALL Check_Grid_Function_for_NAN( Gamma_u(:,:,:,jz), \"Gamma_u_z\" ) ! !-- Setting the TYPE variables equal to the MODULE variables ! ref_levels2 : DO l = 1 , THIS % nlevels THIS % Gamma_u % levels ( l )% var = Gamma_u % levels ( l )% var THIS % phi % levels ( l )% var = phi % levels ( l )% var THIS % trK % levels ( l )% var = trK % levels ( l )% var THIS % g_BSSN3_ll % levels ( l )% var = g_BSSN3_ll % levels ( l )% var THIS % A_BSSN3_ll % levels ( l )% var = A_BSSN3_ll % levels ( l )% var ENDDO ref_levels2 ! Write BSSN ID to a binary file to be read by the evolution code ! in SPHINCS IF ( THIS % export_bin ) THEN IF ( PRESENT ( namefile ) ) THEN CALL write_BSSN_dump ( namefile ) !CALL write_BSSN_dump() ELSE CALL write_BSSN_dump () ENDIF ENDIF ! !-- Deallocate MODULE variables ! CALL deallocate_ADM () CALL deallocate_Ztmp () CALL deallocate_Tmunu () CALL deallocate_GravityAcceleration () CALL deallocate_BSSN () CALL deallocate_grid_function ( rad_coord , 'rad_coord' ) !CALL deallocate_gravity_grid() DEALLOCATE ( levels ) call_flag = call_flag + 1 THIS % call_flag = call_flag PRINT * , \"** BSSN ID computed.\" PRINT * END PROCEDURE compute_and_export_bssn_variables MODULE PROCEDURE read_bssn_dump_print_formatted !************************************************ !                                               * ! Read the BSSN ID from the binary file output  * ! by write_BSSN_dump, and print it to a         * ! formatted file                                * !                                               * ! FT 08.02.2021                                 * !                                               * !************************************************ USE mesh_refinement , ONLY : levels , nlevels USE tensor , ONLY : jxx , jxy , jxz , jyy , jyz , jzz , jx , jy , jz USE ADM_refine , ONLY : lapse , shift_u , & allocate_ADM , deallocate_ADM USE BSSN_refine , ONLY : allocate_BSSN , deallocate_BSSN , & Gamma_u , & ! Conformal connection phi , & ! Conformal factor trK , & ! Trace of extrinsic curvature A_BSSN3_ll , & ! Conformal traceless ! extrinsic curvature g_BSSN3_ll , & ! Conformal metric !Theta_Z4,       & ! Vector in the CCZ4 formulation. ! Loaded here because ADM_TO_BSSN ! calls SUBROUTINES that need it ! as input; however, it is not ! evolved in BSSN !lapse_A_BSSN,   & ! Time derivative of lapse !shift_B_BSSN_u, & ! Time derivativeof shift read_BSSN_dump IMPLICIT NONE INTEGER :: i , j , k , l , min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z LOGICAL :: exist CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile PRINT * , \"** Executing the read_bssn_dump_print_formatted subroutine...\" levels = THIS % levels nlevels = THIS % nlevels CALL allocate_ADM () CALL allocate_BSSN () CALL read_BSSN_dump ( 00000 , namefile_bin ) IF ( THIS % call_flag == 0 ) THEN PRINT * , \"** The SUBROUTINE print_formatted_lorene_id_bssn_variables \" , & \" must be called after compute_and_export_bssn_variables, otherwise\" , & \" there are no bssn fields to export to the formatted file.\" PRINT * , \"   Aborting.\" PRINT * STOP ENDIF IF ( PRESENT ( namefile ) ) THEN finalnamefile = namefile ELSE finalnamefile = \"bssn_vars.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 20 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 20 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(finalnamefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Values of the fields (including coordinates) exported by LORENE \" & // \"on each grid point\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 1 in \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !         // TRIM(finalnamefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4       5\" , & \"       6       7       8\" , & \"       9       10      11\" , & \"       12      13      14\" , & \"       15      16      17      18      19\" , & \"       20      21      22\" , & \"       23      24\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 2 in \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !        // TRIM(finalnamefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      refinement level    x [km]       y [km]       z [km]       lapse\" , & \"       shift_x [c]    shift_y [c]    shift_z [c]\" , & \"       conformal factor phi        trace of extr. curv. trK\" , & \"       g_BSSN_xx       g_BSSN_xy      g_BSSN_xz\" , & \"       g_BSSN_yy       g_BSSN_yz      g_BSSN_zz\" , & \"       A_BSSN_xx       A_BSSN_xy      A_BSSN_xz    \" , & \"       A_BSSN_yy       A_BSSN_yz      A_BSSN_zz\" , & \"       Gamma_u_x       Gamma_u_y      Gamma_u_z\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 3 in \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !        // TRIM(finalnamefile) ) DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( lapse => lapse % levels ( l )% var , & shift_u => shift_u % levels ( l )% var , & g_BSSN3_ll => g_BSSN3_ll % levels ( l )% var , & A_BSSN3_ll => A_BSSN3_ll % levels ( l )% var , & phi => phi % levels ( l )% var , & trK => trK % levels ( l )% var , & Gamma_u => Gamma_u % levels ( l )% var & ) min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) & < min_abs_y ) THEN min_abs_y = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) min_ix_y = i min_iy_y = j min_iz_y = k ENDIF IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) & < min_abs_z ) THEN min_abs_z = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) min_ix_z = i min_iy_z = j min_iz_z = k ENDIF ENDDO ENDDO ENDDO DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( THIS % export_form_xy . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) ) ) THEN CYCLE ENDIF IF ( THIS % export_form_x . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) & . OR . & THIS % coords % levels ( l )% var ( i , j , k , jy ) /= & THIS % coords % levels ( l )% var ( min_ix_y , min_iy_y , & min_iz_y , jy ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * )& l , & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & lapse ( i , j , k ), & shift_u ( i , j , k , jx ), & shift_u ( i , j , k , jy ), & shift_u ( i , j , k , jz ), & phi ( i , j , k ), & trK ( i , j , k ), & g_BSSN3_ll ( i , j , k , jxx ), & g_BSSN3_ll ( i , j , k , jxy ), & g_BSSN3_ll ( i , j , k , jxz ), & g_BSSN3_ll ( i , j , k , jyy ), & g_BSSN3_ll ( i , j , k , jyz ), & g_BSSN3_ll ( i , j , k , jzz ), & A_BSSN3_ll ( i , j , k , jxx ), & A_BSSN3_ll ( i , j , k , jxy ), & A_BSSN3_ll ( i , j , k , jxz ), & A_BSSN3_ll ( i , j , k , jyy ), & A_BSSN3_ll ( i , j , k , jyz ), & A_BSSN3_ll ( i , j , k , jzz ), & Gamma_u ( i , j , k , jx ), & Gamma_u ( i , j , k , jy ), & Gamma_u ( i , j , k , jz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( finalnamefile ), \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing \" & !                  // \"the arrays in \" // TRIM(namefile) ) ENDDO ENDDO ENDDO END ASSOCIATE ENDDO CLOSE ( UNIT = 20 ) ! !-- Deallocate MODULE variables ! CALL deallocate_ADM () CALL deallocate_BSSN () PRINT * , \" * LORENE BSSN ID on the refined mesh, to be supplied to \" , & \"SPHINCS_BSSN, printed to formatted file \" , TRIM ( namefile ) PRINT * , \"** Subroutine read_bssn_dump_print_formatted \" & // \"executed.\" PRINT * END PROCEDURE read_bssn_dump_print_formatted MODULE PROCEDURE print_formatted_lorene_id_bssn_variables !************************************************ !                                               * ! Print the BSSN ID, computed on the gravity    * ! grid from the LORENE ID, in a formatted file  * !                                               * ! FT 26.10.2020                                 * !                                               * !************************************************ USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz IMPLICIT NONE INTEGER :: i , j , k , l , min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z LOGICAL :: exist CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile ! Being abs_grid a local array, it is good practice to allocate it on the ! heap, otherwise it will be stored on the stack which has a very limited ! size. This results in a segmentation fault. !ALLOCATE( abs_grid( 3, THIS% ngrid_x, THIS% ngrid_y, THIS% ngrid_z ) ) PRINT * , \"** Executing the print_formatted_lorene_id_BSSN_variables \" & // \"subroutine...\" IF ( THIS % call_flag == 0 ) THEN PRINT * , \"** The SUBROUTINE print_formatted_lorene_id_bssn_variables \" , & \" must be called after compute_and_export_bssn_variables, otherwise\" , & \" there are no bssn fields to export to the formatted file.\" PRINT * , \"   Aborting.\" PRINT * STOP ENDIF IF ( PRESENT ( namefile ) ) THEN finalnamefile = namefile ELSE finalnamefile = \"lorene-bns-id-bssn-form.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 20 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 20 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(finalnamefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Values of the fields (including coordinates) exported by LORENE \" & // \"on each grid point\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 1 in \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !         // TRIM(finalnamefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4       5\" , & \"       6       7       8\" , & \"       9       10      11\" , & \"       12      13      14\" , & \"       15      16      17      18      19\" , & \"       20      21      22\" , & \"       23      24    25\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 2 in \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !        // TRIM(finalnamefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      refinement level    x [km]       y [km]       z [km]       lapse\" , & \"       shift_x [c]    shift_y [c]    shift_z [c]\" , & \"       conformal factor phi        trace of extr. curv. trK\" , & \"       g_BSSN_xx       g_BSSN_xy      g_BSSN_xz\" , & \"       g_BSSN_yy       g_BSSN_yz      g_BSSN_zz\" , & \"       A_BSSN_xx       A_BSSN_xy      A_BSSN_xz    \" , & \"       A_BSSN_yy       A_BSSN_yz      A_BSSN_zz\" , & \"       Gamma_u_x       Gamma_u_y      Gamma_u_z\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 3 in \" , TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !        // TRIM(finalnamefile) ) DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & phi => THIS % phi % levels ( l )% var , & trK => THIS % trK % levels ( l )% var , & g_BSSN3_ll => THIS % g_BSSN3_ll % levels ( l )% var , & A_BSSN3_ll => THIS % A_BSSN3_ll % levels ( l )% var , & Gamma_u => THIS % Gamma_u % levels ( l )% var & ) !DO iz= 1, THIS% ngrid_z, 1 !  DO iy= 1, THIS% ngrid_y, 1 !    DO ix= 1, THIS% ngrid_x, 1 !      abs_grid( 1, ix, iy, iz )= ABS( THIS% grid( 1, ix, iy, iz ) ) !      abs_grid( 2, ix, iy, iz )= ABS( THIS% grid( 2, ix, iy, iz ) ) !      abs_grid( 3, ix, iy, iz )= ABS( THIS% grid( 3, ix, iy, iz ) ) !    ENDDO !  ENDDO !ENDDO min_abs_y = HUGE ( 1.0D0 ) min_abs_z = HUGE ( 1.0D0 ) DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) & < min_abs_y ) THEN min_abs_y = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) min_ix_y = i min_iy_y = j min_iz_y = k ENDIF IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) & < min_abs_z ) THEN min_abs_z = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) min_ix_z = i min_iy_z = j min_iz_z = k ENDIF ENDDO ENDDO ENDDO DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( THIS % export_form_xy . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) ) ) THEN CYCLE ENDIF IF ( THIS % export_form_x . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) & . OR . & THIS % coords % levels ( l )% var ( i , j , k , jy ) /= & THIS % coords % levels ( l )% var ( min_ix_y , min_iy_y , & min_iz_y , jy ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * )& l , & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & lapse ( i , j , k ), & shift_u ( i , j , k , jx ), & shift_u ( i , j , k , jy ), & shift_u ( i , j , k , jz ), & phi ( i , j , k ), & trK ( i , j , k ), & g_BSSN3_ll ( i , j , k , jxx ), & g_BSSN3_ll ( i , j , k , jxy ), & g_BSSN3_ll ( i , j , k , jxz ), & g_BSSN3_ll ( i , j , k , jyy ), & g_BSSN3_ll ( i , j , k , jyz ), & g_BSSN3_ll ( i , j , k , jzz ), & A_BSSN3_ll ( i , j , k , jxx ), & A_BSSN3_ll ( i , j , k , jxy ), & A_BSSN3_ll ( i , j , k , jxz ), & A_BSSN3_ll ( i , j , k , jyy ), & A_BSSN3_ll ( i , j , k , jyz ), & A_BSSN3_ll ( i , j , k , jzz ), & Gamma_u ( i , j , k , jx ), & Gamma_u ( i , j , k , jy ), & Gamma_u ( i , j , k , jz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( finalnamefile ), \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing \" & !                  // \"the arrays in \" // TRIM(finalnamefile) ) ENDDO ENDDO ENDDO END ASSOCIATE ENDDO CLOSE ( UNIT = 20 ) PRINT * , \" * LORENE BSSN ID on the gravity grid saved to formatted \" & // \"file \" , TRIM ( finalnamefile ) PRINT * , \"** Subroutine print_formatted_lorene_id_BSSN_variables \" & // \"executed.\" PRINT * END PROCEDURE print_formatted_lorene_id_bssn_variables END SUBMODULE bssn_id_variables","tags":"","loc":"sourcefile/submodule_bssn_id_variables.f90.html"},{"title":"submodule_bssn_id_memory.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bssn_id_memory.f90~~EfferentGraph sourcefile~submodule_bssn_id_memory.f90 submodule_bssn_id_memory.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~submodule_bssn_id_memory.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 var pansourcefilesubmodule_bssn_id_memoryf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bssn_id_memoryf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bssn_id_memory Source Code submodule_bssn_id_memory.f90 Source Code ! File:         submodule_bssn_id_memory.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( formul_bssn_id ) bssn_id_memory !************************************************ !                                               * ! Implementation of the methods of TYPE bssn_id * ! that (de)allocate memory                      * !                                               * ! FT 9.07.2021                                  * !                                               * !************************************************ IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE allocate_bssn_fields !*********************************************** !                                              * ! Allocate memory for the BSSN variables.      * !                                              * ! FT 23.10.2020                                * !                                              * ! Updated to mesh refinement                   * !                                              * ! FT 26.03.2021                                * !                                              * !*********************************************** USE mesh_refinement , ONLY : allocate_grid_function IMPLICIT NONE IF ( . NOT . ALLOCATED ( THIS % Gamma_u % levels ) ) THEN CALL allocate_grid_function ( THIS % Gamma_u , \"Gamma_u_id\" , 3 ) ENDIF IF ( . NOT . ALLOCATED ( THIS % phi % levels ) ) THEN CALL allocate_grid_function ( THIS % phi , \"phi_id\" , 1 ) ENDIF IF ( . NOT . ALLOCATED ( THIS % trK % levels ) ) THEN CALL allocate_grid_function ( THIS % trK , \"trK_id\" , 1 ) ENDIF IF ( . NOT . ALLOCATED ( THIS % A_BSSN3_ll % levels ) ) THEN CALL allocate_grid_function ( THIS % A_BSSN3_ll , \"A_BSSN3_ll_id\" , 6 ) ENDIF IF ( . NOT . ALLOCATED ( THIS % g_BSSN3_ll % levels ) ) THEN CALL allocate_grid_function ( THIS % g_BSSN3_ll , \"g_BSSN3_ll_id\" , 6 ) ENDIF END PROCEDURE allocate_bssn_fields MODULE PROCEDURE deallocate_bssn_fields !************************************************** !                                                 * ! Deallocate BSSN memory                          * !                                                 * ! FT                                              * !                                                 * !************************************************** USE mesh_refinement , ONLY : deallocate_grid_function IMPLICIT NONE IF ( ALLOCATED ( THIS % Gamma_u % levels ) ) THEN CALL deallocate_grid_function ( THIS % Gamma_u , \"Gamma_u_id\" ) ENDIF IF ( ALLOCATED ( THIS % phi % levels ) ) THEN CALL deallocate_grid_function ( THIS % phi , \"phi_id\" ) ENDIF IF ( ALLOCATED ( THIS % trK % levels ) ) THEN CALL deallocate_grid_function ( THIS % trK , \"trK_id\" ) ENDIF IF ( ALLOCATED ( THIS % A_BSSN3_ll % levels ) ) THEN CALL deallocate_grid_function ( THIS % A_BSSN3_ll , \"A_BSSN3_ll_id\" ) ENDIF IF ( ALLOCATED ( THIS % g_BSSN3_ll % levels ) ) THEN CALL deallocate_grid_function ( THIS % g_BSSN3_ll , \"g_BSSN3_ll_id\" ) ENDIF IF ( ALLOCATED ( THIS % GC % levels ) ) THEN CALL deallocate_grid_function ( THIS % GC , \"GC_id\" ) ENDIF END PROCEDURE deallocate_bssn_fields END SUBMODULE bssn_id_memory","tags":"","loc":"sourcefile/submodule_bssn_id_memory.f90.html"},{"title":"submodule_bssn_id_constraints.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bssn_id_constraints.f90~~EfferentGraph sourcefile~submodule_bssn_id_constraints.f90 submodule_bssn_id_constraints.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~submodule_bssn_id_constraints.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 var pansourcefilesubmodule_bssn_id_constraintsf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bssn_id_constraintsf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bssn_id_constraints Source Code submodule_bssn_id_constraints.f90 Source Code ! File:         submodule_bssn_id_constraints.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( formul_bssn_id ) bssn_id_constraints !************************************************ !                                               * ! Implementation of the methods of TYPE bssn_id * ! that compute the constraints                  * !                                               * ! FT 9.07.2021                                  * !                                               * !************************************************ IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE compute_and_export_bssn_constraints_grid !*************************************************** !                                                  * ! Compute, store, analyze and export the BSSN      * ! constraints to a formatted file. The computation * ! is done by importing the LORENE hydro ID on the  * ! gravity grid, without any information on the     * ! particles.                                       * !                                                  * ! FT 1.02.2021                                     * !                                                  * !*************************************************** USE constants , ONLY : c_light2 , cm2m , MSun , g2kg , m2cm , & lorene2hydrobase , MSun_geo , pi USE matrix , ONLY : invert_4x4_matrix USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , & it , ix , iy , iz , n_sym3x3 , n_sym4x4 USE mesh_refinement , ONLY : allocate_grid_function , & levels , nlevels USE McLachlan_refine , ONLY : BSSN_CONSTRAINTS_INTERIOR IMPLICIT NONE INTEGER :: i , j , k , fd_lim , l INTEGER , DIMENSION ( 3 ) :: imin , imax INTEGER :: unit_logfile , & min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid TYPE ( grid_function_scalar ) :: baryon_density TYPE ( grid_function_scalar ) :: energy_density TYPE ( grid_function_scalar ) :: specific_energy TYPE ( grid_function_scalar ) :: pressure TYPE ( grid_function ) :: v_euler TYPE ( grid_function ) :: v_euler_l TYPE ( grid_function ) :: u_euler_l TYPE ( grid_function_scalar ) :: lorentz_factor DOUBLE PRECISION :: u_euler_norm = 0.0D0 DOUBLE PRECISION :: detg4 ! Spacetime metric TYPE ( grid_function ) :: g4 ! Stress-energy tensor TYPE ( grid_function ) :: Tmunu_ll ! Spacetime metric as a 4x4 matrix DOUBLE PRECISION , DIMENSION ( 4 , 4 ) :: g4temp ! Inverse spacetime metric as a 4x4 matrix DOUBLE PRECISION , DIMENSION ( 4 , 4 ) :: ig4 ! Declaration of debug variables needed to compute the Hamiltonian ! constraint directly, without calling the Cactus-bound SUBROUTINE ! BSSN_CONSTRAINTS_INTERIOR TYPE ( grid_function_scalar ) :: HC_hand TYPE ( grid_function_scalar ) :: HC_rho TYPE ( grid_function_scalar ) :: HC_trK TYPE ( grid_function_scalar ) :: HC_A TYPE ( grid_function_scalar ) :: HC_derphi CHARACTER ( LEN = : ), ALLOCATABLE :: name_constraint CHARACTER ( LEN = : ), ALLOCATABLE :: name_analysis CHARACTER ( LEN = : ), ALLOCATABLE :: finalname_logfile CHARACTER ( LEN = 2 ) :: n_reflev LOGICAL :: exist LOGICAL , PARAMETER :: debug = . FALSE . ALLOCATE ( levels ( THIS % nlevels ), STAT = ios ) IF ( ios > 0 ) THEN PRINT * , '...allocation error for levels' STOP ENDIF levels = THIS % levels nlevels = THIS % nlevels CALL allocate_grid_function ( baryon_density , \"baryon_density\" , 1 ) CALL allocate_grid_function ( energy_density , \"energy_density\" , 1 ) CALL allocate_grid_function ( specific_energy , \"specific_energy\" , 1 ) CALL allocate_grid_function ( pressure , \"pressure\" , 1 ) CALL allocate_grid_function ( v_euler , \"v_euler\" , 3 ) CALL allocate_grid_function ( v_euler_l , \"v_euler_l\" , 3 ) CALL allocate_grid_function ( u_euler_l , \"u_euler_l\" , 4 ) CALL allocate_grid_function ( lorentz_factor , \"lorentz_factor\" , 1 ) CALL allocate_grid_function ( g4 , \"g4\" , n_sym4x4 ) CALL allocate_grid_function ( Tmunu_ll , \"Tmunu_ll\" , n_sym4x4 ) CALL allocate_grid_function ( HC_hand , \"HC_hand\" , 1 ) CALL allocate_grid_function ( HC_rho , \"HC_rho\" , 1 ) CALL allocate_grid_function ( HC_trK , \"HC_trK\" , 1 ) CALL allocate_grid_function ( HC_A , \"HC_A\" , 1 ) CALL allocate_grid_function ( HC_derphi , \"HC_derphi\" , 1 ) CALL allocate_grid_function ( THIS % HC , \"HC_id\" , 1 ) CALL allocate_grid_function ( THIS % MC , \"MC_id\" , 3 ) CALL allocate_grid_function ( THIS % GC , \"GC_id\" , 3 ) ! !-- Import the hydro LORENE ID on the gravity grid ! PRINT * , \"** Importing LORENE hydro ID on the gravity grid...\" PRINT * ref_levels : DO l = 1 , THIS % nlevels , 1 PRINT * , \" * Importing on refinement level l=\" , l , \"...\" CALL id % read_id_hydro ( THIS % get_ngrid_x ( l ), & THIS % get_ngrid_y ( l ), & THIS % get_ngrid_z ( l ), & THIS % coords % levels ( l )% var , & baryon_density % levels ( l )% var , & energy_density % levels ( l )% var , & specific_energy % levels ( l )% var , & pressure % levels ( l )% var , & v_euler % levels ( l )% var ) ENDDO ref_levels PRINT * , \" * LORENE hydro ID imported.\" PRINT * !---------------------------! !--  Compute constraints  --! !---------------------------! ! !-- Compute the fluid 4-velocity in the coordinate frame ! PRINT * , \"** Computing fluid 4-velocity wrt Eulerian observer...\" !    !$OMP PARALLEL DEFAULT( NONE ) & !    !$OMP          SHARED( THIS, v_euler_l, u_euler_l, lorentz_factor, & !    !$OMP                  v_euler, Tmunu_ll, energy_density, pressure, & !    !$OMP                  show_progress, l ) & !    !$OMP          PRIVATE( i, j, k, g4, detg4, g4temp, ig4, u_euler_norm, & !    !$OMP                   perc ) ref_levels2 : DO l = 1 , THIS % nlevels #ifdef __INTEL_COMPILER ASSOCIATE ( v_euler_l => v_euler_l % levels ( l )% var , & u_euler_l => u_euler_l % levels ( l )% var , & v_euler => v_euler % levels ( l )% var , & lorentz_factor => lorentz_factor % levels ( l )% var , & lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & g_phys3_ll => THIS % g_phys3_ll % levels ( l )% var , & g4 => g4 % levels ( l )% var , & Tmunu_ll => Tmunu_ll % levels ( l )% var , & energy_density => energy_density % levels ( l )% var , & pressure => pressure % levels ( l )% var & ) #endif !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP          SHARED( THIS, v_euler_l, u_euler_l, lorentz_factor, & !$OMP                  v_euler, Tmunu_ll, energy_density, pressure, & !$OMP                  show_progress, l ) & !$OMP          PRIVATE( i, j, k, g4, detg4, g4temp, ig4, u_euler_norm, & !$OMP                   perc ) DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 #ifdef __GFORTRAN__ ASSOCIATE ( v_euler_l => v_euler_l % levels ( l )% var , & u_euler_l => u_euler_l % levels ( l )% var , & v_euler => v_euler % levels ( l )% var , & lorentz_factor => lorentz_factor % levels ( l )% var , & lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & g_phys3_ll => THIS % g_phys3_ll % levels ( l )% var , & g4 => g4 % levels ( l )% var , & Tmunu_ll => Tmunu_ll % levels ( l )% var , & energy_density => energy_density % levels ( l )% var , & pressure => pressure % levels ( l )% var & ) #endif !energy_density( i, j, k )= baryon_density( i, j, k ) & !                            + ( specific_energy(i,j,k) + 1.0 ) & !                                 *baryon_density( i, j, k ) v_euler_l ( i , j , k , jx ) = g_phys3_ll ( i , j , k , jxx ) * v_euler ( i , j , k , jx ) & + g_phys3_ll ( i , j , k , jxy ) * v_euler ( i , j , k , jy ) & + g_phys3_ll ( i , j , k , jxz ) * v_euler ( i , j , k , jz ) v_euler_l ( i , j , k , jy ) = g_phys3_ll ( i , j , k , jxy ) * v_euler ( i , j , k , jx ) & + g_phys3_ll ( i , j , k , jyy ) * v_euler ( i , j , k , jy ) & + g_phys3_ll ( i , j , k , jyz ) * v_euler ( i , j , k , jz ) v_euler_l ( i , j , k , jz ) = g_phys3_ll ( i , j , k , jxz ) * v_euler ( i , j , k , jx ) & + g_phys3_ll ( i , j , k , jyz ) * v_euler ( i , j , k , jy ) & + g_phys3_ll ( i , j , k , jzz ) * v_euler ( i , j , k , jz ) lorentz_factor ( i , j , k ) = 1.0D0 / SQRT ( 1.0D0 & - ( v_euler_l ( i , j , k , jx ) * v_euler ( i , j , k , jx ) & + v_euler_l ( i , j , k , jy ) * v_euler ( i , j , k , jy ) & + v_euler_l ( i , j , k , jz ) * v_euler ( i , j , k , jz ) ) ) u_euler_l ( i , j , k , it ) = lorentz_factor ( i , j , k ) & * ( - lapse ( i , j , k ) & + v_euler_l ( i , j , k , jx ) * shift_u ( i , j , k , jx ) & + v_euler_l ( i , j , k , jy ) * shift_u ( i , j , k , jy ) & + v_euler_l ( i , j , k , jz ) * shift_u ( i , j , k , jz ) ) u_euler_l ( i , j , k , ix ) = lorentz_factor ( i , j , k ) & * v_euler_l ( i , j , k , jx ) u_euler_l ( i , j , k , iy ) = lorentz_factor ( i , j , k ) & * v_euler_l ( i , j , k , jy ) u_euler_l ( i , j , k , iz ) = lorentz_factor ( i , j , k ) & * v_euler_l ( i , j , k , jz ) CALL compute_g4 ( i , j , k , lapse , shift_u , g_phys3_ll , g4 ) CALL determinant_sym4x4_grid ( i , j , k , g4 , detg4 ) IF ( ABS ( detg4 ) < 1.0D-10 ) THEN PRINT * , \"The determinant of the spacetime metric \" & // \"is effectively 0 at the grid point \" & // \"(i,j,k)= (\" , i , \",\" , j , \",\" , k , & \").\" PRINT * , \"detg4=\" , detg4 PRINT * STOP ELSEIF ( detg4 > 0.0D0 ) THEN PRINT * , \"The determinant of the spacetime metric \" & // \"is positive at the grid point \" & // \"(i,j,k)= (\" , i , \",\" , j , \",\" , k , & \").\" PRINT * , \"detg4=\" , detg4 PRINT * STOP ENDIF g4temp ( 1 , 1 ) = g4 ( i , j , k , itt ) g4temp ( 1 , 2 ) = g4 ( i , j , k , itx ) g4temp ( 1 , 3 ) = g4 ( i , j , k , ity ) g4temp ( 1 , 4 ) = g4 ( i , j , k , itz ) g4temp ( 2 , 1 ) = g4 ( i , j , k , itx ) g4temp ( 2 , 2 ) = g4 ( i , j , k , ixx ) g4temp ( 2 , 3 ) = g4 ( i , j , k , ixy ) g4temp ( 2 , 4 ) = g4 ( i , j , k , ixz ) g4temp ( 3 , 1 ) = g4 ( i , j , k , ity ) g4temp ( 3 , 2 ) = g4 ( i , j , k , ixy ) g4temp ( 3 , 3 ) = g4 ( i , j , k , iyy ) g4temp ( 3 , 4 ) = g4 ( i , j , k , iyz ) g4temp ( 4 , 1 ) = g4 ( i , j , k , itz ) g4temp ( 4 , 2 ) = g4 ( i , j , k , ixz ) g4temp ( 4 , 3 ) = g4 ( i , j , k , iyz ) g4temp ( 4 , 4 ) = g4 ( i , j , k , izz ) CALL invert_4x4_matrix ( g4temp , ig4 ) u_euler_norm = ig4 ( it , it ) * & u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , it ) & + 2.0D0 * ig4 ( it , ix ) * & u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , ix ) & + 2.0D0 * ig4 ( it , iy ) * & u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , iy ) & + 2.0D0 * ig4 ( it , iz ) * & u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , iz ) & + ig4 ( ix , ix ) * & u_euler_l ( i , j , k , ix ) * u_euler_l ( i , j , k , ix ) & + 2.0D0 * ig4 ( ix , iy ) * & u_euler_l ( i , j , k , ix ) * u_euler_l ( i , j , k , iy ) & + 2.0D0 * ig4 ( ix , iz ) * & u_euler_l ( i , j , k , ix ) * u_euler_l ( i , j , k , iz ) & + ig4 ( iy , iy ) * & u_euler_l ( i , j , k , iy ) * u_euler_l ( i , j , k , iy ) & + 2.0D0 * ig4 ( iy , iz ) * & u_euler_l ( i , j , k , iy ) * u_euler_l ( i , j , k , iz ) & + 2.0D0 * ig4 ( iz , iz ) * & u_euler_l ( i , j , k , iz ) * u_euler_l ( i , j , k , iz ) IF ( ABS ( u_euler_norm + 1.0D0 ) > 1.0D-4 ) THEN PRINT * , \"** ERROR! The fluid 4-velocity in the \" & // \"coordinate frame does not have norm -1. \" & // \"The norm is\" , u_euler_norm STOP ENDIF ! Print progress on screen perc = 100 * ( THIS % get_ngrid_x ( l ) * THIS % get_ngrid_y ( l ) * ( k - 1 ) & + THIS % get_ngrid_x ( l ) * ( j - 1 ) + i ) & / ( THIS % get_ngrid_x ( l ) * THIS % get_ngrid_y ( l ) * & THIS % get_ngrid_z ( l ) ) IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) creturn // \" \" , perc , \"%\" ENDIF #ifdef __GFORTRAN__ END ASSOCIATE #endif ENDDO ENDDO ENDDO !$OMP END PARALLEL DO WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \" * Fluid 4-velocity wrt Eulerian observer computed.\" PRINT * ! Note that the units used in the spacetime part of SPHINCS are the ! same units as in the HydroBase thorn in the Einstein Toolkit. ! Such units can be found here, https://einsteintoolkit.org/thornguide/EinsteinBase/HydroBase/documentation.html ! The order of magnitude of the energy density can be found in ! https://www.ias.ac.in/article/fulltext/pram/084/05/0927-0941, ! and it is 150 MeV fm&#94;{-3} ~ (2.4*10&#94;{-11}J) / (10&#94;{-45}m&#94;3) !                           = 2.4*10&#94;34 J m&#94;{-3} ! !-- Compute the stress-energy tensor ! PRINT * , \"** Computing stress-energy tensor...\" #ifdef __INTEL_COMPILER Tmunu_ll = 0.0 #endif #ifdef __GFORTRAN__ Tmunu_ll % levels ( l )% var = 0.0 #endif !        !$OMP DO !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP          SHARED( THIS, v_euler_l, u_euler_l, lorentz_factor, & !$OMP                  v_euler, Tmunu_ll, energy_density, pressure, & !$OMP                  show_progress, l ) & !$OMP          PRIVATE( i, j, k, g4, detg4, g4temp, ig4, u_euler_norm, & !$OMP                   perc ) DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 #ifdef __GFORTRAN__ ASSOCIATE ( v_euler_l => v_euler_l % levels ( l )% var , & u_euler_l => u_euler_l % levels ( l )% var , & v_euler => v_euler % levels ( l )% var , & lorentz_factor => lorentz_factor % levels ( l )% var , & lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & g_phys3_ll => THIS % g_phys3_ll % levels ( l )% var , & g4 => g4 % levels ( l )% var , & Tmunu_ll => Tmunu_ll % levels ( l )% var , & energy_density => energy_density % levels ( l )% var , & pressure => pressure % levels ( l )% var & ) #endif Tmunu_ll ( i , j , k , itt ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , it ) & + pressure ( i , j , k ) * g4 ( i , j , k , itt ) & ) Tmunu_ll ( i , j , k , itx ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , ix ) & + pressure ( i , j , k ) * g4 ( i , j , k , itx ) & ) Tmunu_ll ( i , j , k , ity ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , iy ) & + pressure ( i , j , k ) * g4 ( i , j , k , ity ) & ) Tmunu_ll ( i , j , k , itz ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , it ) * u_euler_l ( i , j , k , iz ) & + pressure ( i , j , k ) * g4 ( i , j , k , itz ) & ) Tmunu_ll ( i , j , k , ixx ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , ix ) * u_euler_l ( i , j , k , ix ) & + pressure ( i , j , k ) * g4 ( i , j , k , ixx ) & ) Tmunu_ll ( i , j , k , ixy ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , ix ) * u_euler_l ( i , j , k , iy ) & + pressure ( i , j , k ) * g4 ( i , j , k , ixy ) & ) Tmunu_ll ( i , j , k , ixz ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , ix ) * u_euler_l ( i , j , k , iz ) & + pressure ( i , j , k ) * g4 ( i , j , k , ixz ) & ) Tmunu_ll ( i , j , k , iyy ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , iy ) * u_euler_l ( i , j , k , iy ) & + pressure ( i , j , k ) * g4 ( i , j , k , iyy ) & ) Tmunu_ll ( i , j , k , iyz ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , iy ) * u_euler_l ( i , j , k , iz ) & + pressure ( i , j , k ) * g4 ( i , j , k , iyz ) & ) Tmunu_ll ( i , j , k , izz ) = lorene2hydrobase * ( & ( energy_density ( i , j , k ) + pressure ( i , j , k ) ) & * u_euler_l ( i , j , k , iz ) * u_euler_l ( i , j , k , iz ) & + pressure ( i , j , k ) * g4 ( i , j , k , izz ) & ) ! Print progress on screen perc = 100 * ( THIS % get_ngrid_x ( l ) * THIS % get_ngrid_y ( l ) * ( k - 1 ) & + THIS % get_ngrid_x ( l ) * ( j - 1 ) + i ) & / ( THIS % get_ngrid_x ( l ) * THIS % get_ngrid_y ( l ) * & THIS % get_ngrid_z ( l ) ) IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF #ifdef __GFORTRAN__ END ASSOCIATE #endif ENDDO ENDDO ENDDO !$OMP END PARALLEL DO !        !$OMP END DO #ifdef __INTEL_COMPILER END ASSOCIATE #endif ENDDO ref_levels2 !    !$OMP END PARALLEL WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \" * Stress-energy tensor computed.\" PRINT * ! In debug mode, compute the Hamiltonian constraint by hand IF ( debug ) THEN DO l = 1 , THIS % nlevels , 1 #ifdef __INTEL_COMPILER ASSOCIATE ( HC_rho => HC_rho % levels ( l )% var , & HC_trK => HC_trK % levels ( l )% var , & HC_A => HC_A % levels ( l )% var , & HC_derphi => HC_derphi % levels ( l )% var , & HC_hand => HC_hand % levels ( l )% var , & phi => THIS % phi % levels ( l )% var , & trK => THIS % trK % levels ( l )% var , & A_BSSN3_ll => THIS % A_BSSN3_ll % levels ( l )% var , & energy_density => energy_density % levels ( l )% var , & pressure => pressure % levels ( l )% var & ) HC_rho = 0.0D0 HC_trK = 0.0D0 HC_A = 0.0D0 HC_derphi = 0.0D0 HC_hand = 0.0D0 #endif #ifdef __GFORTRAN__ HC_rho % levels ( l )% var = 0.0D0 HC_trK % levels ( l )% var = 0.0D0 HC_A % levels ( l )% var = 0.0D0 HC_derphi % levels ( l )% var = 0.0D0 HC_hand % levels ( l )% var = 0.0D0 #endif fd_lim = 5 DO k = fd_lim , THIS % get_ngrid_z ( l ) - fd_lim , 1 DO j = fd_lim , THIS % get_ngrid_y ( l ) - fd_lim , 1 DO i = fd_lim , THIS % get_ngrid_x ( l ) - fd_lim , 1 #ifdef __GFORTRAN__ ASSOCIATE ( HC_rho => HC_rho % levels ( l )% var , & HC_trK => HC_trK % levels ( l )% var , & HC_A => HC_A % levels ( l )% var , & HC_derphi => HC_derphi % levels ( l )% var , & HC_hand => HC_hand % levels ( l )% var , & phi => THIS % phi % levels ( l )% var , & trK => THIS % trK % levels ( l )% var , & A_BSSN3_ll => THIS % A_BSSN3_ll % levels ( l )% var , & energy_density => energy_density % levels ( l )% var , & pressure => pressure % levels ( l )% var & ) #endif ! The following works with both compilers !                ASSOCIATE( HC_rho => HC_rho% levels(l)%var( i, j, k ) & !                ) HC_rho ( i , j , k ) = 2.0D0 * pi * EXP ( 5.0D0 * phi ( i , j , k )) & * lorene2hydrobase * energy_density ( i , j , k ) HC_trK ( i , j , k ) = - EXP ( 5.0D0 * phi ( i , j , k )) / 1 2.0D0 & * trK ( i , j , k ) ** 2 HC_A ( i , j , k ) = EXP ( 5.0D0 * phi ( i , j , k )) / 8.0D0 & * ( A_BSSN3_ll ( i , j , k , jxx ) * A_BSSN3_ll ( i , j , k , jxx ) & + A_BSSN3_ll ( i , j , k , jxy ) * A_BSSN3_ll ( i , j , k , jxy ) & + A_BSSN3_ll ( i , j , k , jxz ) * A_BSSN3_ll ( i , j , k , jxz ) & + A_BSSN3_ll ( i , j , k , jxy ) * A_BSSN3_ll ( i , j , k , jxy ) & + A_BSSN3_ll ( i , j , k , jyy ) * A_BSSN3_ll ( i , j , k , jyy ) & + A_BSSN3_ll ( i , j , k , jyz ) * A_BSSN3_ll ( i , j , k , jyz ) & + A_BSSN3_ll ( i , j , k , jxz ) * A_BSSN3_ll ( i , j , k , jxz ) & + A_BSSN3_ll ( i , j , k , jyz ) * A_BSSN3_ll ( i , j , k , jyz ) & + A_BSSN3_ll ( i , j , k , jzz ) * A_BSSN3_ll ( i , j , k , jzz ) & ) ! Second derivative of conformal factor with fourth-order FD !HC_derphi( ix, iy, iz )= & !                   ( -      EXP(THIS% phi( ix + 2, iy, iz )) & !                     + 16.0*EXP(THIS% phi( ix + 1, iy, iz )) & !                     - 30.0*EXP(THIS% phi( ix    , iy, iz )) & !                     + 16.0*EXP(THIS% phi( ix - 1, iy, iz )) & !                     -      EXP(THIS% phi( ix - 2, iy, iz )) & !                     -      EXP(THIS% phi( ix, iy + 2, iz )) & !                     + 16.0*EXP(THIS% phi( ix, iy + 1, iz )) & !                     - 30.0*EXP(THIS% phi( ix, iy, iz )) & !                     + 16.0*EXP(THIS% phi( ix, iy - 1, iz )) & !                     -      EXP(THIS% phi( ix, iy - 2, iz )) & !                     -      EXP(THIS% phi( ix, iy, iz + 2 )) & !                     + 16.0*EXP(THIS% phi( ix, iy, iz + 1 )) & !                     - 30.0*EXP(THIS% phi( ix, iy, iz )) & !                     + 16.0*EXP(THIS% phi( ix, iy, iz - 1 )) & !                     -      EXP(THIS% phi( ix, iy, iz - 2 )) )& !                     /(12.0*THIS% dx**2) ! Second derivative of conformal factor with eighth-order FD HC_derphi ( i , j , k ) = ( & - DBLE ( 1.0 / 56 0.0 ) * EXP ( phi ( i + 4 , j , k )) & + DBLE ( 8.0 / 31 5.0 ) * EXP ( phi ( i + 3 , j , k )) & - DBLE ( 1.0 / 5.0 ) * EXP ( phi ( i + 2 , j , k )) & + DBLE ( 8.0 / 5.0 ) * EXP ( phi ( i + 1 , j , k )) & - DBLE ( 20 5.0 / 7 2.0 ) * EXP ( phi ( i , j , k )) & + DBLE ( 8.0 / 5.0 ) * EXP ( phi ( i - 1 , j , k )) & - DBLE ( 1.0 / 5.0 ) * EXP ( phi ( i - 2 , j , k )) & + DBLE ( 8.0 / 31 5.0 ) * EXP ( phi ( i - 3 , j , k )) & - DBLE ( 1.0 / 56 0.0 ) * EXP ( phi ( i - 4 , j , k )) & - DBLE ( 1.0 / 56 0.0 ) * EXP ( phi ( i , j + 4 , k )) & + DBLE ( 8.0 / 31 5.0 ) * EXP ( phi ( i , j + 3 , k )) & - DBLE ( 1.0 / 5.0 ) * EXP ( phi ( i , j + 2 , k )) & + DBLE ( 8.0 / 5.0 ) * EXP ( phi ( i , j + 1 , k )) & - DBLE ( 20 5.0 / 7 2.0 ) * EXP ( phi ( i , j , k )) & + DBLE ( 8.0 / 5.0 ) * EXP ( phi ( i , j - 1 , k )) & - DBLE ( 1.0 / 5.0 ) * EXP ( phi ( i , j - 2 , k )) & + DBLE ( 8.0 / 31 5.0 ) * EXP ( phi ( i , j - 3 , k )) & - DBLE ( 1.0 / 56 0.0 ) * EXP ( phi ( i , j - 4 , k )) & - DBLE ( 1.0 / 56 0.0 ) * EXP ( phi ( i , j , k + 4 )) & + DBLE ( 8.0 / 31 5.0 ) * EXP ( phi ( i , j , k + 3 )) & - DBLE ( 1.0 / 5.0 ) * EXP ( phi ( i , j , k + 2 )) & + DBLE ( 8.0 / 5.0 ) * EXP ( phi ( i , j , k + 1 )) & - DBLE ( 20 5.0 / 7 2.0 ) * EXP ( phi ( i , j , k )) & + DBLE ( 8.0 / 5.0 ) * EXP ( phi ( i , j , k - 1 )) & - DBLE ( 1.0 / 5.0 ) * EXP ( phi ( i , j , k - 2 )) & + DBLE ( 8.0 / 31 5.0 ) * EXP ( phi ( i , j , k - 3 )) & - DBLE ( 1.0 / 56 0.0 ) * EXP ( phi ( i , j , k - 4 )) )& / ( THIS % levels ( l )% dx ** 2 ) HC_hand ( i , j , k ) = HC_rho ( i , j , k ) + & HC_trK ( i , j , k ) + & HC_A ( i , j , k ) + & HC_derphi ( i , j , k ) #ifdef __GFORTRAN__ END ASSOCIATE #endif ENDDO ENDDO ENDDO #ifdef __INTEL_COMPILER END ASSOCIATE #endif ENDDO ENDIF ! !-- Compute the BSSN constraints by calling the Cactus-bound procedure !-- BSSN_CONSTRAINTS_INTERIOR ! PRINT * , \"** Computing contraints...\" !    !$OMP PARALLEL DO DEFAULT( NONE ) & !    !$OMP          SHARED( THIS, Tmunu_ll ) & !    !$OMP          PRIVATE( l, imin, imax ) DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & phi => THIS % phi % levels ( l )% var , & trK => THIS % trK % levels ( l )% var , & g_BSSN3_ll => THIS % g_BSSN3_ll % levels ( l )% var , & A_BSSN3_ll => THIS % A_BSSN3_ll % levels ( l )% var , & Gamma_u => THIS % Gamma_u % levels ( l )% var , & Tmunu_ll => Tmunu_ll % levels ( l )% var , & HC => THIS % HC % levels ( l )% var , & MC => THIS % MC % levels ( l )% var , & GC => THIS % GC % levels ( l )% var & ) imin ( 1 ) = THIS % levels ( l )% nghost_x imin ( 2 ) = THIS % levels ( l )% nghost_y imin ( 3 ) = THIS % levels ( l )% nghost_z imax ( 1 ) = THIS % get_ngrid_x ( l ) - THIS % levels ( l )% nghost_x - 1 imax ( 2 ) = THIS % get_ngrid_y ( l ) - THIS % levels ( l )% nghost_y - 1 imax ( 3 ) = THIS % get_ngrid_z ( l ) - THIS % levels ( l )% nghost_z - 1 HC = 0.0D0 MC = 0.0D0 GC = 0.0D0 CALL BSSN_CONSTRAINTS_INTERIOR ( & ! !-- Input ! THIS % get_ngrid_x ( l ), THIS % get_ngrid_y ( l ), THIS % get_ngrid_z ( l ), & imin , imax , & THIS % get_dx ( l ), THIS % get_dy ( l ), THIS % get_dz ( l ), & g_BSSN3_ll (:,:,:, jxx ), g_BSSN3_ll (:,:,:, jxy ), & g_BSSN3_ll (:,:,:, jxz ), g_BSSN3_ll (:,:,:, jyy ), & g_BSSN3_ll (:,:,:, jyz ), g_BSSN3_ll (:,:,:, jzz ), & A_BSSN3_ll (:,:,:, jxx ), A_BSSN3_ll (:,:,:, jxy ), & A_BSSN3_ll (:,:,:, jxz ), A_BSSN3_ll (:,:,:, jyy ), & A_BSSN3_ll (:,:,:, jyz ), A_BSSN3_ll (:,:,:, jzz ), & trK (:,:,:), phi (:,:,:), & Gamma_u (:,:,:, jx ), & Gamma_u (:,:,:, jy ), & Gamma_u (:,:,:, jz ), & Tmunu_ll (:,:,:, itt ), & Tmunu_ll (:,:,:, itx ), & Tmunu_ll (:,:,:, ity ), & Tmunu_ll (:,:,:, itz ), & Tmunu_ll (:,:,:, ixx ), & Tmunu_ll (:,:,:, ixy ), & Tmunu_ll (:,:,:, ixz ), & Tmunu_ll (:,:,:, iyy ), & Tmunu_ll (:,:,:, iyz ), & Tmunu_ll (:,:,:, izz ), & lapse (:,:,:), & shift_u (:,:,:, jx ), & shift_u (:,:,:, jy ), & shift_u (:,:,:, jz ), & ! !-- Output ! ! Connection constraints GC (:,:,:, jx ), & GC (:,:,:, jy ), & GC (:,:,:, jz ), & ! Hamiltonian and momentum constraints HC (:,:,:), & MC (:,:,:, jx ), & MC (:,:,:, jy ), & MC (:,:,:, jz ) & ) END ASSOCIATE ENDDO !    !$OMP END PARALLEL DO PRINT * , \" * Constraints computed.\" PRINT * !---------------------------------------------------------! !--  Analyze constraints, and print to formatted files  --! !---------------------------------------------------------! DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( HC => THIS % HC % levels ( l )% var , & MC => THIS % MC % levels ( l )% var , & GC => THIS % GC % levels ( l )% var & ) ! !-- Export the constraint statistics to a formatted file ! unit_logfile = 2891 IF ( l > 9 ) THEN WRITE ( n_reflev , \"(I2)\" ) l ELSE WRITE ( n_reflev , \"(I1)\" ) l ENDIF finalname_logfile = TRIM ( name_logfile ) // \"-reflev\" // TRIM ( n_reflev ) // \".log\" INQUIRE ( FILE = TRIM ( finalname_logfile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_logfile , FILE = TRIM ( finalname_logfile ), & STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_logfile , FILE = TRIM ( finalname_logfile ), & STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( finalname_logfile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_logfile) ) IF ( . NOT . ALLOCATED ( THIS % HC_l2 )) THEN ALLOCATE ( THIS % HC_l2 ( THIS % nlevels ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array HC_l2. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % MC_l2 )) THEN ALLOCATE ( THIS % MC_l2 ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array MC_l2. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % GC_l2 )) THEN ALLOCATE ( THIS % GC_l2 ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array GC_l2. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % HC_loo )) THEN ALLOCATE ( THIS % HC_loo ( THIS % nlevels ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array HC_loo. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % MC_loo )) THEN ALLOCATE ( THIS % MC_loo ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array MC_loo. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % GC_loo )) THEN ALLOCATE ( THIS % GC_loo ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array GC_loo. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF WRITE ( UNIT = unit_logfile , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id PRINT * , \"** Analyzing constraints on refinement level \" , l , \"...\" name_analysis = \"bssn-hc-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the Hamiltonian constraint\" CALL THIS % analyze_constraint ( & l , & HC , name_constraint , unit_logfile , name_analysis , & THIS % HC_l2 ( l ), THIS % HC_loo ( l ) ) name_analysis = \"bssn-mc1-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the first component of the momentum constraint\" CALL THIS % analyze_constraint ( & l , & MC (:,:,:, jx ), name_constraint , unit_logfile , name_analysis , & THIS % MC_l2 ( l , jx ), THIS % MC_loo ( l , jx ) ) name_analysis = \"bssn-mc2-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the second component of the momentum constraint\" CALL THIS % analyze_constraint ( & l , & MC (:,:,:, jy ), name_constraint , unit_logfile , name_analysis , & THIS % MC_l2 ( l , jy ), THIS % MC_loo ( l , jy ) ) name_analysis = \"bssn-mc3-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the third component of the momentum constraint\" CALL THIS % analyze_constraint ( & l , & MC (:,:,:, jz ), name_constraint , unit_logfile , name_analysis , & THIS % MC_l2 ( l , jz ), THIS % MC_loo ( l , jz ) ) name_analysis = \"bssn-gc1-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the first component of the connection constraint\" CALL THIS % analyze_constraint ( & l , & GC (:,:,:, jx ), name_constraint , unit_logfile , name_analysis , & THIS % GC_l2 ( l , jx ), THIS % GC_loo ( l , jx ) ) name_analysis = \"bssn-gc2-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the second component of the connection constraint\" CALL THIS % analyze_constraint ( & l , & GC (:,:,:, jy ), name_constraint , unit_logfile , name_analysis , & THIS % GC_l2 ( l , jy ), THIS % GC_loo ( l , jy ) ) name_analysis = \"bssn-gc3-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the third component of the connection constraint\" CALL THIS % analyze_constraint ( & l , & GC (:,:,:, jz ), name_constraint , unit_logfile , name_analysis , & THIS % GC_l2 ( l , jz ), THIS % GC_loo ( l , jz ) ) CLOSE ( UNIT = unit_logfile ) PRINT * , \" * Constraints analyzed. Summary of results saved to \" , & finalname_logfile PRINT * END ASSOCIATE ENDDO IF ( THIS % export_constraints ) THEN PRINT * , \"** Printing constraints to file \" , TRIM ( namefile ), \"...\" ! !-- Export the constraints to a formatted file ! INQUIRE ( FILE = TRIM ( namefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 20 , FILE = TRIM ( namefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 20 , FILE = TRIM ( namefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(namefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Values of the stress-energy tensor and the BSSN constraints\" & // \" for the LORENE ID \" & // \"on selected grid points\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 1 in \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !         // TRIM(namefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4       5\" , & \"       6       7       8       9       10\" , & \"       11       12       13       14       15\" , & \"       16       17       18       19       20\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 2 in \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !        // TRIM(namefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      refinement level    x   y   z   Stress-energy (10 components)   \" & // \"Hamiltonian constraint       \" & // \"Momentum constraint (three components)       \" & // \"Connection constraint (three components)\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 3 in \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !        // TRIM(namefile) ) DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & phi => THIS % phi % levels ( l )% var , & trK => THIS % trK % levels ( l )% var , & g_BSSN3_ll => THIS % g_BSSN3_ll % levels ( l )% var , & A_BSSN3_ll => THIS % A_BSSN3_ll % levels ( l )% var , & g_phys3_ll => THIS % g_phys3_ll % levels ( l )% var , & k_phys3_ll => THIS % k_phys3_ll % levels ( l )% var , & Gamma_u => THIS % Gamma_u % levels ( l )% var , & Tmunu_ll => Tmunu_ll % levels ( l )% var , & v_euler_l => v_euler_l % levels ( l )% var , & u_euler_l => u_euler_l % levels ( l )% var , & v_euler => v_euler % levels ( l )% var , & lorentz_factor => lorentz_factor % levels ( l )% var , & HC => THIS % HC % levels ( l )% var , & MC => THIS % MC % levels ( l )% var , & GC => THIS % GC % levels ( l )% var , & HC_rho => HC_rho % levels ( l )% var , & HC_trK => HC_trK % levels ( l )% var , & HC_A => HC_A % levels ( l )% var , & HC_derphi => HC_derphi % levels ( l )% var , & HC_hand => HC_hand % levels ( l )% var , & g4 => g4 % levels ( l )% var , & baryon_density => baryon_density % levels ( l )% var , & specific_energy => specific_energy % levels ( l )% var , & energy_density => energy_density % levels ( l )% var , & pressure => pressure % levels ( l )% var & ) ! Being abs_grid a local array, it is good practice to allocate it on ! the heap, otherwise it will be stored on the stack which has a very ! limited size. This results in a segmentation fault. IF ( ALLOCATED ( abs_grid ) ) THEN DEALLOCATE ( abs_grid ) ENDIF ALLOCATE ( abs_grid ( THIS % get_ngrid_x ( l ), THIS % get_ngrid_y ( l ), & THIS % get_ngrid_z ( l ), 3 ) ) DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 abs_grid ( i , j , k , jx ) = & ABS ( THIS % coords % levels ( l )% var ( i , j , k , jx ) ) abs_grid ( i , j , k , jy ) = & ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) abs_grid ( i , j , k , jz ) = & ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) & < min_abs_y ) THEN min_abs_y = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) min_ix_y = i min_iy_y = j min_iz_y = k ENDIF IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) & < min_abs_z ) THEN min_abs_z = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) min_ix_z = i min_iy_z = j min_iz_z = k ENDIF ENDDO ENDDO ENDDO DO k = 1 , THIS % get_ngrid_z ( l ), 1 IF ( MOD ( k , THIS % cons_step ) /= 0 ) CYCLE DO j = 1 , THIS % get_ngrid_y ( l ), 1 IF ( MOD ( j , THIS % cons_step ) /= 0 ) CYCLE DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( MOD ( i , THIS % cons_step ) /= 0 ) CYCLE IF ( THIS % export_constraints_xy . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) ) ) THEN CYCLE ENDIF IF ( THIS % export_constraints_x . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) & . OR . & THIS % coords % levels ( l )% var ( i , j , k , jy ) /= & THIS % coords % levels ( l )% var ( min_ix_y , min_iy_y , & min_iz_y , jy ) ) ) THEN CYCLE ENDIF IF ( debug ) THEN WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , & FMT = * )& l , & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & baryon_density ( i , j , k ), & energy_density ( i , j , k ), & specific_energy ( i , j , k ), & pressure ( ix , iy , iz ), & u_euler_l ( i , j , k , it ), & u_euler_l ( i , j , k , ix ), & u_euler_l ( i , j , k , iy ), & u_euler_l ( i , j , k , iz ), & u_euler_l ( i , j , k , it ), & u_euler_l ( i , j , k , ix ), & u_euler_l ( i , j , k , iy ), & u_euler_l ( i , j , k , iz ), & v_euler ( i , j , k , jx ), & v_euler ( i , j , k , jy ), & v_euler ( i , j , k , jz ), & Tmunu_ll ( i , j , k , itt ), & Tmunu_ll ( i , j , k , itx ), & Tmunu_ll ( i , j , k , ity ), & Tmunu_ll ( i , j , k , itz ), & Tmunu_ll ( i , j , k , ixx ), & Tmunu_ll ( i , j , k , ixy ), & Tmunu_ll ( i , j , k , ixz ), & Tmunu_ll ( i , j , k , iyy ), & Tmunu_ll ( i , j , k , iyz ), & Tmunu_ll ( i , j , k , izz ), & HC ( i , j , k ), & HC_hand ( i , j , k ), & HC_rho ( i , j , k ), & HC_trK ( i , j , k ), & HC_A ( i , j , k ), & HC_derphi ( i , j , k ), & lorentz_factor ( i , j , k ), & lapse ( ix , iy , iz ), & shift_u ( i , j , k , jx ), & shift_u ( i , j , k , jy ), & shift_u ( i , j , k , jz ), & g4 ( i , j , k , ixx ), & g4 ( i , j , k , ixy ), & g4 ( i , j , k , ixz ), & g4 ( i , j , k , iyy ), & g4 ( i , j , k , iyz ), & g4 ( i , j , k , izz ), & !g_BSSN3_ll( i, j, k, jxx ), & !g_BSSN3_ll( i, j, k, jxy ), & !g_BSSN3_ll( i, j, k, jxz ), & !g_BSSN3_ll( i, j, k, jyy ), & !g_BSSN3_ll( i, j, k, jyz ), & !g_BSSN3_ll( i, j, k, jzz ), & k_phys3_ll ( i , j , k , jxx ), & k_phys3_ll ( i , j , k , jxy ), & k_phys3_ll ( i , j , k , jxz ), & k_phys3_ll ( i , j , k , jyy ), & k_phys3_ll ( i , j , k , jyz ), & k_phys3_ll ( i , j , k , jzz ), & A_BSSN3_ll ( i , j , k , jxx ), & A_BSSN3_ll ( i , j , k , jxy ), & A_BSSN3_ll ( i , j , k , jxz ), & A_BSSN3_ll ( i , j , k , jyy ), & A_BSSN3_ll ( i , j , k , jyz ), & A_BSSN3_ll ( i , j , k , jzz ), & trK ( i , j , k ), & phi ( i , j , k ), & Gamma_u ( i , j , k , 1 ), & Gamma_u ( i , j , k , 2 ), & Gamma_u ( i , j , k , 3 ) ELSE WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * )& l , & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & Tmunu_ll ( i , j , k , itt ), & Tmunu_ll ( i , j , k , itx ), & Tmunu_ll ( i , j , k , ity ), & Tmunu_ll ( i , j , k , itz ), & Tmunu_ll ( i , j , k , ixx ), & Tmunu_ll ( i , j , k , ixy ), & Tmunu_ll ( i , j , k , ixz ), & Tmunu_ll ( i , j , k , iyy ), & Tmunu_ll ( i , j , k , iyz ), & Tmunu_ll ( i , j , k , izz ), & HC ( i , j , k ), & MC ( i , j , k , jx ), & MC ( i , j , k , jy ), & MC ( i , j , k , jz ), & GC ( i , j , k , jx ), & GC ( i , j , k , jy ), & GC ( i , j , k , jz ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !          \"...error in writing \" & !          // \"the arrays in \" // TRIM(namefile) ) ENDDO ENDDO ENDDO END ASSOCIATE ENDDO CLOSE ( UNIT = 20 ) PRINT * , \" * Printed.\" PRINT * ENDIF !DEALLOCATE( baryon_density ) !DEALLOCATE( energy_density ) !DEALLOCATE( specific_energy ) !DEALLOCATE( pressure ) !DEALLOCATE( v_euler ) !!DEALLOCATE( u_coord ) !!DEALLOCATE( u_coord_l ) !DEALLOCATE( g4 ) !DEALLOCATE( g4temp ) !DEALLOCATE( ig4 ) !DEALLOCATE( Tmunu_ll ) DEALLOCATE ( levels ) END PROCEDURE compute_and_export_bssn_constraints_grid MODULE PROCEDURE compute_and_export_bssn_constraints_particles !************************************************** !                                                 * ! Compute, store and export the BSSN constraints  * ! to a formatted file. The computaton is done     * ! mapping the physical metric from the gravity    * ! to the particles, computing e stress-energy     * ! tensor on the particles, and mapping it to the  * ! gravity grid.                                   * ! TODO: use the SPH density to compute the        * !       stress-energy tensor, rather than the     * !       LORENE density                            * !                                                 * ! FT 1.02.2021                                    * !                                                 * !************************************************** USE constants , ONLY : c_light2 , cm2m , MSun , g2kg , m2cm , Msun_geo USE units , ONLY : set_units USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , & n_sym3x3 , n_sym4x4 USE mesh_refinement , ONLY : allocate_grid_function , levels , & rad_coord , nlevels , & deallocate_grid_function , coords USE ADM_refine , ONLY : lapse , shift_u , & g_phys3_ll , & allocate_ADM , deallocate_ADM USE BSSN_refine , ONLY : allocate_BSSN , deallocate_BSSN USE Tmunu_refine , ONLY : Tmunu_ll , allocate_Tmunu , & deallocate_Tmunu USE McLachlan_refine , ONLY : BSSN_CONSTRAINTS_INTERIOR , & allocate_Ztmp , deallocate_Ztmp USE GravityAcceleration_refine , ONLY : allocate_GravityAcceleration , & deallocate_GravityAcceleration USE input_output , ONLY : read_options USE options , ONLY : ndes USE sph_variables , ONLY : npart , & ! particle number pos_u , & ! particle positions vel_u , & ! particle velocities in ! coordinate frame nlrf , & ! baryon number density in ! local rest frame !ehat,  &  ! canonical energy per baryon nu , & ! canonical baryon number per ! particle Theta , & ! Generalized Lorentz factor h , & ! Smoothing length Pr , & ! Pressure u , & ! Internal energy in local rest ! frame (no kinetic energy) !temp,  &  ! Temperature !av,    &  ! Dissipation !Ye,    &  ! Electron fraction !divv,  &  ! Divergence of velocity vel_u !Nstar, &  ! Comput.frame baryon number ! density allocate_SPH_memory , & deallocate_SPH_memory USE RCB_tree_3D , ONLY : allocate_RCB_tree_memory_3D ,& deallocate_RCB_tree_memory_3D , iorig USE kernel_table , ONLY : ktable USE gradient , ONLY : allocate_gradient , deallocate_gradient USE sphincs_sph , ONLY : density , flag_dead_ll_cells USE set_h , ONLY : exact_nei_tree_update USE alive_flag , ONLY : alive USE map_particles_2_grid , ONLY : map_2_grid_hash USE metric_on_particles , ONLY : allocate_metric_on_particles , & deallocate_metric_on_particles , & get_metric_on_particles USE particle_mesh , ONLY : deallocate_all_lists , & deallocate_flag_nei_cell , & deallocate_pp_g USE particle_mesh_hash , ONLY : deallocate_hash_memory IMPLICIT NONE INTEGER :: i , j , k , l , a , allocation_status INTEGER , DIMENSION ( 3 ) :: imin , imax INTEGER :: unit_logfile , min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z INTEGER , SAVE :: counter = 1 DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nlrf_loc DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nu_loc DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: u_loc DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_loc DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pos_loc DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: vel_loc DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: theta_loc DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: sph_density CHARACTER ( LEN = : ), ALLOCATABLE :: name_constraint CHARACTER ( LEN = : ), ALLOCATABLE :: name_analysis CHARACTER ( LEN = : ), ALLOCATABLE :: finalname_logfile CHARACTER ( 2 ) :: n_reflev LOGICAL :: exist LOGICAL , PARAMETER :: debug = . FALSE . ALLOCATE ( levels ( THIS % nlevels ), STAT = ios ) IF ( ios > 0 ) THEN PRINT * , '...allocation error for levels' STOP ENDIF nlevels = THIS % nlevels levels = THIS % levels coords = THIS % coords DO l = 1 , THIS % nlevels , 1 levels ( l )% ngrid_x = THIS % levels ( l )% ngrid_x levels ( l )% ngrid_x = THIS % levels ( l )% ngrid_x levels ( l )% ngrid_x = THIS % levels ( l )% ngrid_x ENDDO IF ( debug ) PRINT * , \"ngrid_x=\" , THIS % levels ( 1 )% ngrid_x IF ( debug ) PRINT * , \"ngrid_y=\" , THIS % levels ( 1 )% ngrid_y IF ( debug ) PRINT * , \"ngrid_z=\" , THIS % levels ( 1 )% ngrid_z IF ( debug ) PRINT * CALL allocate_grid_function ( THIS % HC_parts , \"HC_parts_ID\" , 1 ) CALL allocate_grid_function ( THIS % MC_parts , \"MC_parts_ID\" , 3 ) CALL allocate_grid_function ( THIS % GC_parts , \"GC_parts_ID\" , 3 ) PRINT * , \"Mapping hydro fields from particles to grid...\" CALL allocate_ADM () CALL allocate_BSSN () ! Allocate temporary memory for time integration CALL allocate_Ztmp () ! Allocate memory for the stress-energy tensor (used in write_BSSN_dump) CALL allocate_Tmunu () ! Allocate memory for the derivatives of the ADM variables CALL allocate_GravityAcceleration () CALL allocate_grid_function ( rad_coord , 'rad_coord' , 1 ) ! Initialize the stress-energy tensor to 0 DO l = 1 , THIS % nlevels , 1 Tmunu_ll % levels ( l )% var = 0.0D0 rad_coord % levels ( l )% var = THIS % rad_coord % levels ( l )% var g_phys3_ll % levels ( l )% var = THIS % g_phys3_ll % levels ( l )% var shift_u % levels ( l )% var = THIS % shift_u % levels ( l )% var lapse % levels ( l )% var = THIS % lapse % levels ( l )% var ENDDO npart = parts_obj % get_npart () IF ( . NOT . ALLOCATED ( nlrf_loc ) ) THEN ALLOCATE ( nlrf_loc ( npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for nlrf_loc' STOP ENDIF IF ( . NOT . ALLOCATED ( nu_loc ) ) THEN ALLOCATE ( nu_loc ( npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for nu_loc' STOP ENDIF IF ( . NOT . ALLOCATED ( u_loc ) ) THEN ALLOCATE ( u_loc ( npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for u_loc' STOP ENDIF IF ( . NOT . ALLOCATED ( pressure_loc ) ) THEN ALLOCATE ( pressure_loc ( npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for pressure_loc' STOP ENDIF IF ( . NOT . ALLOCATED ( theta_loc ) ) THEN ALLOCATE ( theta_loc ( npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for theta_loc' STOP ENDIF IF ( . NOT . ALLOCATED ( pos_loc ) ) THEN ALLOCATE ( pos_loc ( 3 , npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for pos_loc' STOP ENDIF IF ( . NOT . ALLOCATED ( vel_loc ) ) THEN ALLOCATE ( vel_loc ( 3 , npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for vel_loc' STOP ENDIF IF ( . NOT . ALLOCATED ( sph_density ) ) THEN ALLOCATE ( sph_density ( npart ), STAT = allocation_status ) ENDIF IF ( allocation_status > 0 ) THEN PRINT * , '...allocation error for sph_density' STOP ENDIF ! Set the SPH density to 0 by default sph_density = 0.0D0 CALL set_units ( 'NSM' ) CALL read_options CALL allocate_SPH_memory IF ( debug ) PRINT * , \"-2\" CALL allocate_RCB_tree_memory_3D ( npart ) iorig ( 1 : npart ) = ( / ( a , a = 1 , npart ) / ) IF ( debug ) PRINT * , \"-1\" h = parts_obj % get_h () !IF( counter == 1 )THEN !  ! tabulate kernel, get ndes !  CALL ktable(ikernel,ndes) !ENDIF IF ( debug ) PRINT * , \"0\" nu_loc = parts_obj % get_nu () pos_loc = parts_obj % get_pos () vel_loc = parts_obj % get_vel () u_loc = parts_obj % get_u () nlrf_loc = parts_obj % get_nlrf () theta_loc = parts_obj % get_theta () pressure_loc = parts_obj % get_pressure_cu () IF ( debug ) PRINT * , \"1\" PRINT * , \" * Allocating needed memory...\" PRINT * ! flag that particles are 'alive' IF ( . NOT . ALLOCATED ( alive ) ) ALLOCATE ( alive ( npart ) ) alive ( 1 : npart ) = 1 CALL allocate_gradient ( npart ) IF ( debug ) PRINT * , \"2\" CALL allocate_metric_on_particles ( npart ) IF ( debug ) PRINT * , \"3\" !---------------------------! !--  Compute constraints  --! !---------------------------! PRINT * , \" * Mapping metric from the grid to the particles...\" PRINT * CALL get_metric_on_particles ( npart , & pos_loc ) IF ( debug ) PRINT * , \"4\" ! !-- Seems like computing neighbors and SPH density is not needed to map !-- the stress-energy tensor from the particles to the grid ! PRINT * , \" * Computing neighbours...\" PRINT * CALL exact_nei_tree_update ( ndes , & npart , & pos_loc , & nu_loc ) !IF( debug ) PRINT *, \"5\" ! !PRINT *, \" * Computing SPH density...\" !PRINT * nu = nu_loc pos_u = pos_loc vel_u = vel_loc u = u_loc nlrf = nlrf_loc Theta = theta_loc Pr = pressure_loc !CALL density( npart,   & !              pos_loc, & !              sph_density ) IF ( debug ) PRINT * , \"6\" IF ( debug . AND . . TRUE . ) PRINT * , \"npart= \" , npart IF ( debug . AND . . TRUE . ) PRINT * , \"nu_loc= \" , nu_loc ( npart / 2 ) IF ( debug . AND . . TRUE . ) PRINT * , \"pos_loc= \" , pos_loc ( 2 , npart / 2 ) IF ( debug . AND . . TRUE . ) PRINT * , \"vel_loc= \" , vel_loc ( 2 , npart / 2 ) IF ( debug . AND . . TRUE . ) PRINT * , \"u_loc= \" , u_loc ( npart / 2 ) IF ( debug . AND . . TRUE . ) PRINT * , \"nlrf_loc= \" , nlrf_loc ( npart / 2 ) IF ( debug . AND . . TRUE . ) PRINT * , \"theta_loc= \" , theta_loc ( npart / 2 ) IF ( debug . AND . . TRUE . ) PRINT * , \"pressure_loc= \" , pressure_loc ( npart / 2 ) IF ( debug . AND . . TRUE . ) PRINT * !IF( counter == 2 ) STOP PRINT * , \" * Mapping stress-energy tensor from the particles to the grid...\" PRINT * CALL map_2_grid_hash ( npart , & nu_loc , & pos_loc , & vel_loc , & u_loc , & nlrf_loc , & theta_loc , & pressure_loc ) !IF( counter == 2 )THEN !  STOP !ENDIF IF ( debug ) PRINT * , \"6.5\" !IF( counter == 2 ) STOP IF ( debug ) PRINT * , \"7\" ! !-- Deallocate SPH MODULE variables ! CALL deallocate_grid_function ( rad_coord , 'rad_coord' ) CALL deallocate_flag_nei_cell CALL deallocate_pp_g CALL deallocate_all_lists CALL deallocate_hash_memory CALL deallocate_metric_on_particles CALL deallocate_gradient DEALLOCATE ( alive ) !DEALLOCATE(W_no_norm) !DEALLOCATE(dWdv_no_norm) !DEALLOCATE(fmass) !DEALLOCATE(fpoten) !DEALLOCATE(dphidh) CALL deallocate_RCB_tree_memory_3D CALL deallocate_SPH_memory IF ( debug ) PRINT * , \"8.1\" ! !-- Compute the BSSN constraints by calling the Cactus-bound procedure !-- BSSN_CONSTRAINTS_INTERIOR ! PRINT * , \" * Computing constraints using particle data...\" !    !$OMP PARALLEL DO DEFAULT( NONE ) & !    !$OMP          SHARED( THIS, Tmunu_ll ) & !    !$OMP          PRIVATE( l, imin, imax ) DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & phi => THIS % phi % levels ( l )% var , & trK => THIS % trK % levels ( l )% var , & g_BSSN3_ll => THIS % g_BSSN3_ll % levels ( l )% var , & A_BSSN3_ll => THIS % A_BSSN3_ll % levels ( l )% var , & Gamma_u => THIS % Gamma_u % levels ( l )% var , & Tmunu_ll => Tmunu_ll % levels ( l )% var , & HC_parts => THIS % HC_parts % levels ( l )% var , & MC_parts => THIS % MC_parts % levels ( l )% var , & GC_parts => THIS % GC_parts % levels ( l )% var & ) imin ( 1 ) = THIS % levels ( l )% nghost_x imin ( 2 ) = THIS % levels ( l )% nghost_y imin ( 3 ) = THIS % levels ( l )% nghost_z imax ( 1 ) = THIS % get_ngrid_x ( l ) - THIS % levels ( l )% nghost_x - 1 imax ( 2 ) = THIS % get_ngrid_y ( l ) - THIS % levels ( l )% nghost_y - 1 imax ( 3 ) = THIS % get_ngrid_z ( l ) - THIS % levels ( l )% nghost_z - 1 HC_parts = 0.0D0 MC_parts = 0.0D0 GC_parts = 0.0D0 CALL BSSN_CONSTRAINTS_INTERIOR ( & ! !-- Input ! THIS % get_ngrid_x ( l ), THIS % get_ngrid_y ( l ), THIS % get_ngrid_z ( l ), & imin , imax , & THIS % get_dx ( l ), THIS % get_dy ( l ), THIS % get_dz ( l ), & g_BSSN3_ll (:,:,:, jxx ), g_BSSN3_ll (:,:,:, jxy ), & g_BSSN3_ll (:,:,:, jxz ), g_BSSN3_ll (:,:,:, jyy ), & g_BSSN3_ll (:,:,:, jyz ), g_BSSN3_ll (:,:,:, jzz ), & A_BSSN3_ll (:,:,:, jxx ), A_BSSN3_ll (:,:,:, jxy ), & A_BSSN3_ll (:,:,:, jxz ), A_BSSN3_ll (:,:,:, jyy ), & A_BSSN3_ll (:,:,:, jyz ), A_BSSN3_ll (:,:,:, jzz ), & trK (:,:,:), phi (:,:,:), & Gamma_u (:,:,:, jx ), & Gamma_u (:,:,:, jy ), & Gamma_u (:,:,:, jz ), & Tmunu_ll (:,:,:, itt ), & Tmunu_ll (:,:,:, itx ), & Tmunu_ll (:,:,:, ity ), & Tmunu_ll (:,:,:, itz ), & Tmunu_ll (:,:,:, ixx ), & Tmunu_ll (:,:,:, ixy ), & Tmunu_ll (:,:,:, ixz ), & Tmunu_ll (:,:,:, iyy ), & Tmunu_ll (:,:,:, iyz ), & Tmunu_ll (:,:,:, izz ), & lapse (:,:,:), & shift_u (:,:,:, jx ), & shift_u (:,:,:, jy ), & shift_u (:,:,:, jz ), & ! !-- Output ! ! Connection constraints GC_parts (:,:,:, jx ), & GC_parts (:,:,:, jy ), & GC_parts (:,:,:, jz ), & ! Hamiltonian and momentum constraints HC_parts (:,:,:), & MC_parts (:,:,:, jx ), & MC_parts (:,:,:, jy ), & MC_parts (:,:,:, jz ) & ) END ASSOCIATE ENDDO !    !$OMP END PARALLEL DO PRINT * , \" * Constraints computed.\" PRINT * IF ( debug ) PRINT * , \"0\" !---------------------------------------------------------! !--  Analyze constraints, and print to formatted files  --! !---------------------------------------------------------! DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( HC_parts => THIS % HC_parts % levels ( l )% var , & MC_parts => THIS % MC_parts % levels ( l )% var , & GC_parts => THIS % GC_parts % levels ( l )% var & ) unit_logfile = 2791 IF ( l > 9 ) THEN WRITE ( n_reflev , \"(I2)\" ) l ELSE WRITE ( n_reflev , \"(I1)\" ) l ENDIF finalname_logfile = TRIM ( name_logfile ) // \"-reflev\" // TRIM ( n_reflev ) // \".log\" INQUIRE ( FILE = TRIM ( finalname_logfile ), EXIST = exist ) IF ( debug ) PRINT * , \"1\" IF ( exist ) THEN OPEN ( UNIT = unit_logfile , FILE = TRIM ( finalname_logfile ), & STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_logfile , FILE = TRIM ( finalname_logfile ), & STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( finalname_logfile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !                  // TRIM(name_logfile) ) IF ( debug ) PRINT * , \"2\" IF ( . NOT . ALLOCATED ( THIS % HC_parts_l2 )) THEN ALLOCATE ( THIS % HC_parts_l2 ( THIS % nlevels ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array HC_parts_l2. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % MC_parts_l2 )) THEN ALLOCATE ( THIS % MC_parts_l2 ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array MC_parts_l2. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % GC_parts_l2 )) THEN ALLOCATE ( THIS % GC_parts_l2 ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array GC_parts_l2. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % HC_parts_loo )) THEN ALLOCATE ( THIS % HC_parts_loo ( THIS % nlevels ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array HC_parts_loo. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % MC_parts_loo )) THEN ALLOCATE ( THIS % MC_parts_loo ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array MC_parts_loo. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF IF ( . NOT . ALLOCATED ( THIS % GC_parts_loo )) THEN ALLOCATE ( THIS % GC_parts_loo ( THIS % nlevels , 3 ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array GC_parts_loo. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array HC\" ) ENDIF WRITE ( UNIT = unit_logfile , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id PRINT * , \"** Analyzing constraints on refinement level \" , l , \"...\" name_analysis = \"bssn-hc-parts-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the Hamiltonian constraint\" CALL THIS % analyze_constraint ( & l , & HC_parts , name_constraint , unit_logfile , name_analysis , & THIS % HC_parts_l2 ( l ), THIS % HC_parts_loo ( l ) ) name_analysis = \"bssn-mc1-parts-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the first component of the momentum constraint\" CALL THIS % analyze_constraint ( & l , & MC_parts (:,:,:, jx ), name_constraint , unit_logfile , name_analysis , & THIS % MC_parts_l2 ( l , jx ), THIS % MC_parts_loo ( l , jx ) ) name_analysis = \"bssn-mc2-parts-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the second component of the momentum constraint\" CALL THIS % analyze_constraint ( & l , & MC_parts (:,:,:, jy ), name_constraint , unit_logfile , name_analysis , & THIS % MC_parts_l2 ( l , jy ), THIS % MC_parts_loo ( l , jy ) ) name_analysis = \"bssn-mc3-parts-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the third component of the momentum constraint\" CALL THIS % analyze_constraint ( & l , & MC_parts (:,:,:, jz ), name_constraint , unit_logfile , name_analysis , & THIS % MC_parts_l2 ( l , jz ), THIS % MC_parts_loo ( l , jz ) ) name_analysis = \"bssn-gc1-parts-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the first component of the connection constraint\" CALL THIS % analyze_constraint ( & l , & GC_parts (:,:,:, jx ), name_constraint , unit_logfile , name_analysis , & THIS % GC_parts_l2 ( l , jx ), THIS % GC_parts_loo ( l , jx ) ) name_analysis = \"bssn-gc2-parts-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the second component of the connection constraint\" CALL THIS % analyze_constraint ( & l , & GC_parts (:,:,:, jy ), name_constraint , unit_logfile , name_analysis , & THIS % GC_parts_l2 ( l , jy ), THIS % GC_parts_loo ( l , jy ) ) name_analysis = \"bssn-gc3-parts-analysis-reflev\" // TRIM ( n_reflev ) // \".dat\" name_constraint = \"the third component of the connection constraint\" CALL THIS % analyze_constraint ( & l , & GC_parts (:,:,:, jz ), name_constraint , unit_logfile , name_analysis , & THIS % GC_parts_l2 ( l , jz ), THIS % GC_parts_loo ( l , jz ) ) CLOSE ( UNIT = unit_logfile ) PRINT * , \" * Constraints analyzed. Summary of results saved to \" , & finalname_logfile PRINT * END ASSOCIATE ENDDO IF ( THIS % export_constraints ) THEN PRINT * , \" * Printing constraints to file \" , TRIM ( namefile ), \"...\" ! !-- Export the constraints to a formatted file ! INQUIRE ( FILE = TRIM ( namefile ), EXIST = exist ) IF ( debug ) PRINT * , \"1\" IF ( exist ) THEN OPEN ( UNIT = 21 , FILE = TRIM ( namefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 21 , FILE = TRIM ( namefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(namefile) ) IF ( debug ) PRINT * , \"2\" WRITE ( UNIT = 21 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = 21 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Values of the BSSN constraints computed with the mapping routines \" , & \"for the LORENE ID on selected grid points\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 1 in \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !         // TRIM(namefile) ) WRITE ( UNIT = 21 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4       5\" , & \"       6       7       8       9       10\" , & \"       11       12       13       14       15\" , & \"       16       17       18       19       20\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 2 in \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !        // TRIM(namefile) ) WRITE ( UNIT = 21 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      refinement level    x   y   z   Stress-energy (10 components)   \" & // \"Hamiltonian constraint       \" & // \"Momentum constraint (three components)       \" & // \"Connection constraint (three components)\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 3 in \" , TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !        // TRIM(namefile) ) IF ( debug ) PRINT * , \"3\" DO l = 1 , THIS % nlevels , 1 ASSOCIATE ( lapse => THIS % lapse % levels ( l )% var , & shift_u => THIS % shift_u % levels ( l )% var , & phi => THIS % phi % levels ( l )% var , & trK => THIS % trK % levels ( l )% var , & g_BSSN3_ll => THIS % g_BSSN3_ll % levels ( l )% var , & A_BSSN3_ll => THIS % A_BSSN3_ll % levels ( l )% var , & g_phys3_ll => THIS % g_phys3_ll % levels ( l )% var , & k_phys3_ll => THIS % k_phys3_ll % levels ( l )% var , & Gamma_u => THIS % Gamma_u % levels ( l )% var , & Tmunu_ll => Tmunu_ll % levels ( l )% var , & HC_parts => THIS % HC_parts % levels ( l )% var , & MC_parts => THIS % MC_parts % levels ( l )% var , & GC_parts => THIS % GC_parts % levels ( l )% var & ) ! Being abs_grid a local array, it is good practice to allocate it on ! the heap, otherwise it will be stored on the stack which has a very ! limited size. This results in a segmentation fault. IF ( ALLOCATED ( abs_grid ) ) THEN DEALLOCATE ( abs_grid ) ENDIF ALLOCATE ( abs_grid ( THIS % get_ngrid_x ( l ), THIS % get_ngrid_y ( l ), & THIS % get_ngrid_z ( l ), 3 ) ) DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 abs_grid ( i , j , k , jx ) = & ABS ( THIS % coords % levels ( l )% var ( i , j , k , jx ) ) abs_grid ( i , j , k , jy ) = & ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) abs_grid ( i , j , k , jz ) = & ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO k = 1 , THIS % get_ngrid_z ( l ), 1 DO j = 1 , THIS % get_ngrid_y ( l ), 1 DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) & < min_abs_y ) THEN min_abs_y = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jy ) ) min_ix_y = i min_iy_y = j min_iz_y = k ENDIF IF ( ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) & < min_abs_z ) THEN min_abs_z = ABS ( THIS % coords % levels ( l )% var ( i , j , k , jz ) ) min_ix_z = i min_iy_z = j min_iz_z = k ENDIF ENDDO ENDDO ENDDO DO k = 1 , THIS % get_ngrid_z ( l ), 1 IF ( MOD ( k , THIS % cons_step ) /= 0 ) CYCLE DO j = 1 , THIS % get_ngrid_y ( l ), 1 IF ( MOD ( j , THIS % cons_step ) /= 0 ) CYCLE DO i = 1 , THIS % get_ngrid_x ( l ), 1 IF ( MOD ( i , THIS % cons_step ) /= 0 ) CYCLE IF ( THIS % export_constraints_xy . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) ) ) THEN CYCLE ENDIF IF ( THIS % export_constraints_x . AND . & ( THIS % coords % levels ( l )% var ( i , j , k , jz ) /= & THIS % coords % levels ( l )% var ( min_ix_z , min_iy_z , & min_iz_z , jz ) & . OR . & THIS % coords % levels ( l )% var ( i , j , k , jy ) /= & THIS % coords % levels ( l )% var ( min_ix_y , min_iy_y , & min_iz_y , jy ) ) ) THEN CYCLE ENDIF IF ( debug ) THEN WRITE ( UNIT = 21 , IOSTAT = ios , IOMSG = err_msg , FMT = * )& l , & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & ! columns 18 !pos_loc( 1, ix, iy, iz ), & !pos_loc( 2, ix, iy, iz ), & !pos_loc( 3, ix, iy, iz ), & !vel_loc( 1, ix, iy, iz ), & !vel_loc( 2, ix, iy, iz ), & !vel_loc( 3, ix, iy, iz ), & !nu_loc( ix, iy, iz ), & !u_loc( ix, iy, iz ), & !nlrf_loc( ix, iy, iz ), & !theta_loc( ix, iy, iz ), & !pressure_loc( ix, iy, iz ), & Tmunu_ll ( i , j , k , itt ), & Tmunu_ll ( i , j , k , itx ), & Tmunu_ll ( i , j , k , ity ), & Tmunu_ll ( i , j , k , itz ), & Tmunu_ll ( i , j , k , ixx ), & Tmunu_ll ( i , j , k , ixy ), & Tmunu_ll ( i , j , k , ixz ), & Tmunu_ll ( i , j , k , iyy ), & Tmunu_ll ( i , j , k , iyz ), & Tmunu_ll ( i , j , k , izz ), & HC_parts ( i , j , k ), & MC_parts ( i , j , k , jx ), & MC_parts ( i , j , k , jy ), & MC_parts ( i , j , k , jz ), & GC_parts ( i , j , k , jx ), & GC_parts ( i , j , k , jy ), & GC_parts ( i , j , k , jz ), & lapse ( i , j , k ), & shift_u ( i , j , k , jx ), & shift_u ( i , j , k , jy ), & shift_u ( i , j , k , jz ), & g_BSSN3_ll ( i , j , k , jxx ), & g_BSSN3_ll ( i , j , k , jxy ), & g_BSSN3_ll ( i , j , k , jxz ), & g_BSSN3_ll ( i , j , k , jyy ), & g_BSSN3_ll ( i , j , k , jyz ), & g_BSSN3_ll ( i , j , k , jzz ), & k_phys3_ll ( i , j , k , jxx ), & k_phys3_ll ( i , j , k , jxy ), & k_phys3_ll ( i , j , k , jxz ), & k_phys3_ll ( i , j , k , jyy ), & k_phys3_ll ( i , j , k , jyz ), & k_phys3_ll ( i , j , k , jzz ), & A_BSSN3_ll ( i , j , k , jxx ), & A_BSSN3_ll ( i , j , k , jxy ), & A_BSSN3_ll ( i , j , k , jxz ), & A_BSSN3_ll ( i , j , k , jyy ), & A_BSSN3_ll ( i , j , k , jyz ), & A_BSSN3_ll ( i , j , k , jzz ), & trK ( i , j , k ), & phi ( i , j , k ), & Gamma_u ( i , j , k , 1 ), & Gamma_u ( i , j , k , 2 ), & Gamma_u ( i , j , k , 3 ) ELSE WRITE ( UNIT = 21 , IOSTAT = ios , IOMSG = err_msg , FMT = * )& l , & THIS % coords % levels ( l )% var ( i , j , k , jx ), & THIS % coords % levels ( l )% var ( i , j , k , jy ), & THIS % coords % levels ( l )% var ( i , j , k , jz ), & Tmunu_ll ( i , j , k , itt ), & Tmunu_ll ( i , j , k , itx ), & Tmunu_ll ( i , j , k , ity ), & Tmunu_ll ( i , j , k , itz ), & Tmunu_ll ( i , j , k , ixx ), & Tmunu_ll ( i , j , k , ixy ), & Tmunu_ll ( i , j , k , ixz ), & Tmunu_ll ( i , j , k , iyy ), & Tmunu_ll ( i , j , k , iyz ), & Tmunu_ll ( i , j , k , izz ), & HC_parts ( i , j , k ), & MC_parts ( i , j , k , jx ), & MC_parts ( i , j , k , jy ), & MC_parts ( i , j , k , jz ), & GC_parts ( i , j , k , jx ), & GC_parts ( i , j , k , jy ), & GC_parts ( i , j , k , jz ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                  \"...error in writing \" & !                  // \"the arrays in \" // TRIM(namefile) ) ENDDO ENDDO ENDDO END ASSOCIATE ENDDO IF ( debug ) PRINT * , \"4\" CLOSE ( UNIT = 21 ) PRINT * , \" * Printed.\" PRINT * ENDIF ! !-- Deallocate spacetime MODULE variables ! CALL deallocate_ADM () CALL deallocate_Ztmp () CALL deallocate_Tmunu () CALL deallocate_GravityAcceleration () CALL deallocate_BSSN () !CALL deallocate_gravity_grid() DEALLOCATE ( levels ) ! Count the number of times that this SUBROUTINE is called, since the ! kernel has to be tabulated only once in the present implementation counter = counter + 1 END PROCEDURE compute_and_export_bssn_constraints_particles END SUBMODULE bssn_id_constraints","tags":"","loc":"sourcefile/submodule_bssn_id_constraints.f90.html"},{"title":"submodule_bssn_id_constructor.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bssn_id_constructor.f90~~EfferentGraph sourcefile~submodule_bssn_id_constructor.f90 submodule_bssn_id_constructor.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~submodule_bssn_id_constructor.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bssn_id.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_utility.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 var pansourcefilesubmodule_bssn_id_constructorf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bssn_id_constructorf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bssn_id_constructor Source Code submodule_bssn_id_constructor.f90 Source Code ! File:         submodule_BSSN_id_constructor.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( formul_bssn_id ) bssn_id_constructor !************************************************ !                                               * !# Implementation of the constructor and        * !  destructor of TYPE bssn_id                   * !                                               * !  FT 23.10.2020                                * !                                               * !  Updated to mesh refinement                   * !                                               * !  FT 26.03.2021                                * !                                               * !************************************************ IMPLICIT NONE CONTAINS MODULE PROCEDURE construct_bssn_id !**************************************************** !                                                   * !# This constructor of TYPE bssn_id calls the       * !  SUBROUTINES that rely on an bns object, and      * !  allocates memory. It constructs the grid         * !  using the number of grid points along each axis. * !                                                   * !  FT 23.10.2020                                    * !                                                   * !**************************************************** USE McLachlan_refine , ONLY : initialize_BSSN , deallocate_BSSN USE mesh_refinement , ONLY : levels USE Extract_Mass , ONLY : radius2 IMPLICIT NONE ! Initialize the timer bssnid % bssn_computer_timer = timer ( \"bssn_computer_timer\" ) ! Construct the gravity grid and import the LORENE ID on it, ! in standard 3+1 formulation IF ( PRESENT ( dx ) . AND . PRESENT ( dy ) . AND . PRESENT ( dz ) ) THEN CALL bssnid % setup_standard3p1_variables ( id , dx , dy , dz ) ELSE CALL bssnid % setup_standard3p1_variables ( id ) ENDIF ! Read and store the BSSN parameters CALL initialize_BSSN () CALL deallocate_BSSN () ! The construct_formul_3p1 SUBROUTINE constructs the grid, ! hence the dimensions of the arrays imported from the module BSSN ! are know and the arrays can be allocated CALL allocate_bssn_fields ( bssnid ) DEALLOCATE ( levels ) ! radius2 is the extraction radius. If not set here, then it is 0 by default ! and the metric is not interpolate on the particle in ! get_metric_on_particles radius2 = HUGE ( DBLE ( 1.0D0 )) PRINT * PRINT * , \" * Ready to compute BSSN variables.\" PRINT * END PROCEDURE construct_bssn_id ! !-- Keeping the following two SUBROUTINES separate in case it is needed !-- to add other PROCEDURES to the destructor (probably superfluous...) ! MODULE PROCEDURE destruct_bssn_id !************************************************** !                                                 * ! Finalizer for members of the extended class     * ! bssn_id, not the primitive class formul_3p1     * !                                                 * ! FT                                              * !                                                 * !************************************************** IMPLICIT NONE CALL deallocate_bssn_fields ( THIS ) END PROCEDURE destruct_bssn_id MODULE PROCEDURE destructor !************************************************** !                                                 * ! Destructor of TYPE bssn_id                      * !                                                 * ! FT                                              * !                                                 * !************************************************** IMPLICIT NONE CALL destruct_bssn_id ( THIS ) #ifdef __INTEL_COMPILER CALL deallocate_standard3p1_variables ( THIS ) #endif #ifdef __GFORTRAN__ CALL THIS % deallocate_standard3p1_variables #endif END PROCEDURE destructor END SUBMODULE bssn_id_constructor","tags":"","loc":"sourcefile/submodule_bssn_id_constructor.f90.html"},{"title":"module_ccz4_id.f90 – SPHINCS_LORENE","text":"Contents Source Code module_ccz4_id.f90 Source Code","tags":"","loc":"sourcefile/module_ccz4_id.f90.html"},{"title":"submodule_particles_memory.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_memory.f90~~EfferentGraph sourcefile~submodule_particles_memory.f90 submodule_particles_memory.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_memory.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_memory Source Code submodule_particles_memory.f90 Source Code ! File:         submodule_particles_memory.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_memory !*************************************************** ! !# This SUBMODULE contains the implementation of !  the methods of TYPE particles !  that place particles on 1 or 2 lattices around !  the stars. ! !  FT 12.07.2021 ! !*************************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE allocate_lorene_id_parts_memory !************************************************ ! !# Allocate memory for the LORENE ID on the !  particles ! !  FT 10.11.2020 ! !************************************************ IMPLICIT NONE PRINT * , \"** Executing allocate_lorene_id_parts_memory.\" IF (. NOT . ALLOCATED ( THIS % pos )) THEN ALLOCATE ( THIS % pos ( 3 , THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array pos\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % lapse_parts )) THEN ALLOCATE ( THIS % lapse_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array lapse_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array lapse_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_parts_x )) THEN ALLOCATE ( THIS % shift_parts_x ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_parts_x \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for shift_parts_x\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_parts_y )) THEN ALLOCATE ( THIS % shift_parts_y ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_parts_y \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for shift_parts_y\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_parts_z )) THEN ALLOCATE ( THIS % shift_parts_z ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_parts_z \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for shift_parts_z\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xx_parts )) THEN ALLOCATE ( THIS % g_xx_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xx_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array g_xx_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xy_parts )) THEN ALLOCATE ( THIS % g_xy_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xy_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for array g_xy_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xz_parts )) THEN ALLOCATE ( THIS % g_xz_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xz_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array g_xz_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_yy_parts )) THEN ALLOCATE ( THIS % g_yy_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_yy_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for array g_yy_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_yz_parts )) THEN ALLOCATE ( THIS % g_yz_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_yz_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array g_yz_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_zz_parts )) THEN ALLOCATE ( THIS % g_zz_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_zz_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array g_zz_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % baryon_density_parts )) THEN ALLOCATE ( THIS % baryon_density_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array baryon_density_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !     \"...allocation error for array baryon_density_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % energy_density_parts )) THEN ALLOCATE ( THIS % energy_density_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array energy_density_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !             \"...allocation error for array energy_density_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % specific_energy_parts )) THEN ALLOCATE ( THIS % specific_energy_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array specific_energy_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !    \"...allocation error for array specific_energy_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % pressure_parts )) THEN ALLOCATE ( THIS % pressure_parts ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pressure_parts \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array pressure_parts\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % pressure_parts_cu )) THEN ALLOCATE ( THIS % pressure_parts_cu ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pressure_parts_cu \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array pressure_parts_cu\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_parts_x )) THEN ALLOCATE ( THIS % v_euler_parts_x ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_parts_x \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array v_euler_parts_x\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_parts_y )) THEN ALLOCATE ( THIS % v_euler_parts_y ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_parts_y \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for array v_euler_parts_y\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_parts_z )) THEN ALLOCATE ( THIS % v_euler_parts_z ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_parts_z \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for array v_euler_parts_z\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % nstar )) THEN ALLOCATE ( THIS % nstar ( THIS % npart ), STAT = ios ) ENDIF IF ( ios > 0 ) THEN PRINT * , '...allocation error for nstar' STOP ENDIF IF (. NOT . ALLOCATED ( THIS % nstar_int )) THEN ALLOCATE ( THIS % nstar_int ( THIS % npart ), STAT = ios ) ENDIF IF ( ios > 0 ) THEN PRINT * , '...allocation error for nstar_int' STOP ENDIF IF (. NOT . ALLOCATED ( THIS % particle_density )) THEN ALLOCATE ( THIS % particle_density ( THIS % npart ), STAT = ios ) ENDIF IF ( ios > 0 ) THEN PRINT * , '...allocation error for particle_density' STOP ENDIF IF (. NOT . ALLOCATED ( THIS % particle_density_int )) THEN ALLOCATE ( THIS % particle_density_int ( THIS % npart ), STAT = ios ) ENDIF IF ( ios > 0 ) THEN PRINT * , '...allocation error for particle_density_int' STOP ENDIF IF (. NOT . ALLOCATED ( THIS % pmass )) THEN ALLOCATE ( THIS % pmass ( THIS % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pmass in SUBROUTINE\" & // \" allocate_lorene_id_parts_memory. \" , & \"The STAT variable is\" , ios , \". \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( THIS % u_pwp )) THEN ALLOCATE ( THIS % u_pwp ( THIS % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array u_pwp in SUBROUTINE\" & // \"allocate_lorene_id_parts_memory. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( THIS % nlrf_int )) THEN ALLOCATE ( THIS % nlrf_int ( THIS % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nlrf_int in SUBROUTINE\" & // \"allocate_lorene_id_parts_memory. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF PRINT * , \"** Subroutine allocate_lorene_id_parts_memory executed.\" PRINT * END PROCEDURE allocate_lorene_id_parts_memory MODULE PROCEDURE deallocate_lorene_id_parts_memory !************************************************* ! !# Deallocate memory for the LORENE ID on the !  particles ! !  FT 12.07.2021 (this was part of the destructor !                 of TYPE [[particles]] !                 before this date) ! !************************************************* IMPLICIT NONE IF ( ALLOCATED ( THIS % pos )) THEN DEALLOCATE ( THIS % pos , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array pos. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array pos in SUBROUTINE\"& !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % baryon_density_parts )) THEN DEALLOCATE ( THIS % baryon_density_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array baryon_density_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"baryon_density_parts in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % energy_density_parts )) THEN DEALLOCATE ( THIS % energy_density_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array energy_density_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"energy_density_parts in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % specific_energy_parts )) THEN DEALLOCATE ( THIS % specific_energy_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array specific_energy_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"specific_energy_parts in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % pressure_parts )) THEN DEALLOCATE ( THIS % pressure_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array pressure_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"pressure_parts in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % pressure_parts_cu )) THEN DEALLOCATE ( THIS % pressure_parts_cu , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array pressure_parts_cu. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"pressure_parts_cu in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_parts_x )) THEN DEALLOCATE ( THIS % v_euler_parts_x , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_parts_x. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"v_euler_parts_x in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_parts_y )) THEN DEALLOCATE ( THIS % v_euler_parts_y , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_parts_y. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"v_euler_parts_y in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_parts_z )) THEN DEALLOCATE ( THIS % v_euler_parts_z , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_parts_z. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array \" & !                // \"v_euler_parts_z in SUBROUTINE \" & !                // \"destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % lapse_parts )) THEN DEALLOCATE ( THIS % lapse_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array lapse_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array lapse_parts in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % shift_parts_x )) THEN DEALLOCATE ( THIS % shift_parts_x , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_parts_x. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_parts_x in \"& !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % shift_parts_y )) THEN DEALLOCATE ( THIS % shift_parts_y , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_parts_y. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_parts_y in \"& !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % shift_parts_z )) THEN DEALLOCATE ( THIS % shift_parts_z , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_parts_z. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_parts_z in \"& !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % g_xx_parts )) THEN DEALLOCATE ( THIS % g_xx_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xx_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_xx_parts in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % g_xy_parts )) THEN DEALLOCATE ( THIS % g_xy_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xy_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_xy_parts in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % g_xz_parts )) THEN DEALLOCATE ( THIS % g_xz_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xz_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_xz_parts in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % g_yy_parts )) THEN DEALLOCATE ( THIS % g_yy_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_yy_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_yy_parts in \" & !                // \"SUBROUTINE estruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % g_yz_parts )) THEN DEALLOCATE ( THIS % g_yz_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_yz_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_yz_parts in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % g_zz_parts )) THEN DEALLOCATE ( THIS % g_zz_parts , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_zz_parts. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_zz_parts in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % nlrf )) THEN DEALLOCATE ( THIS % nlrf , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array nlrf. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array nlrf in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % nu )) THEN DEALLOCATE ( THIS % nu , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array nu. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array nu in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % Theta )) THEN DEALLOCATE ( THIS % Theta , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array Theta. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array Theta in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % h )) THEN DEALLOCATE ( THIS % h , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array h. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array h in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % v )) THEN DEALLOCATE ( THIS % v , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % Ye )) THEN DEALLOCATE ( THIS % Ye , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array Ye. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % nstar )) THEN DEALLOCATE ( THIS % nstar , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array nstar. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % nstar_int )) THEN DEALLOCATE ( THIS % nstar_int , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array nstar_int. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % particle_density )) THEN DEALLOCATE ( THIS % particle_density , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array particle_density. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % particle_density_int )) THEN DEALLOCATE ( THIS % particle_density_int , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array particle_density_int. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % pmass )) THEN DEALLOCATE ( THIS % pmass , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array pmass. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % u_pwp )) THEN DEALLOCATE ( THIS % u_pwp , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array u_pwp. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF IF ( ALLOCATED ( THIS % nlrf_int )) THEN DEALLOCATE ( THIS % nlrf_int , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array u_pwp. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v in \" & !                // \"SUBROUTINE destruct_particles.\" ) ENDIF END PROCEDURE deallocate_lorene_id_parts_memory END SUBMODULE particles_memory","tags":"","loc":"sourcefile/submodule_particles_memory.f90.html"},{"title":"submodule_particles_spherical_surfaces.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_spherical_surfaces.f90~~EfferentGraph sourcefile~submodule_particles_spherical_surfaces.f90 submodule_particles_spherical_surfaces.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_spherical_surfaces.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules spherical_surfaces Source Code submodule_particles_spherical_surfaces.f90 Source Code !& File:         submodule_particles_constructor.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) spherical_surfaces !************************************************ ! !# This SUBMODULE contains the implementation !  of the method of TYPE particles that places !  particles on spherical surfaces inside !  a star ! !  FT 19.04.2021 ! !************************************************ IMPLICIT NONE ! Be careful! if you define quantities here, they will be global ! If you call the SUBROUTINES multiple times, they will use the SAME variables !PRIVATE !DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE:: shell_radii CONTAINS MODULE PROCEDURE place_particles_spherical_surfaces !********************************************** ! !# Places particles on spherical surfaces !  inside a star ! !  FT 19.04.2021 ! !********************************************** !$ USE OMP_LIB USE constants , ONLY : pi , MSun , MSun_geo , km2m , kg2g , lorene2hydrobase , & golden_ratio , third , half , amu , g2kg , sixth USE matrix , ONLY : determinant_4x4_matrix USE NR , ONLY : indexx USE APM , ONLY : assign_h IMPLICIT NONE INTEGER :: n_shells , itr2 , cnt , & r , th , phi , i_shell , npart_test , npart_shell_tmp , & cnt2 , rel_sign , dim_seed , r_cnt , prev_shell , & npart_discard , npart_shell_cnt , size_pos_shell !INTEGER, PARAMETER:: max_length= 5D+6 INTEGER , DIMENSION (:), ALLOCATABLE :: mass_profile_idx , seed INTEGER , DIMENSION (:), ALLOCATABLE :: npart_shell , npart_shelleq DOUBLE PRECISION :: xtemp , ytemp , ztemp , m_p , & dr , dth , dphi , phase , phase_th , mass , & dr_shells , dth_shells , dphi_shells , col , long , rad , & proper_volume , mass_test , mass_test2 ,& proper_volume_test , npart_shell_kept , & rand_num , rand_num2 , delta_r , shell_thickness , & upper_bound_tmp , lower_bound_tmp , col_tmp DOUBLE PRECISION , PARAMETER :: huge_real = 1.0D30 !ABS( HUGE(0.0D0) ) DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: mass_profile DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shell_radii , shell_masses , & alpha , m_parts , vol_shell , & vol_shell2 , mass_shell , & mass_shell2 , shell_scales LOGICAL :: exist , high_mass , low_mass , kept_all CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile , finalnamefile2 TYPE :: colatitude_pos_shell DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: colatitudes END TYPE TYPE ( colatitude_pos_shell ), DIMENSION (:), ALLOCATABLE :: colatitude_pos TYPE :: pos_on_shells DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pos_shell DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pos_th DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pos_phi DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pvol_shell DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pvol_shell2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xx DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: baryon_density DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: gamma_euler END TYPE TYPE ( pos_on_shells ), DIMENSION (:), ALLOCATABLE :: pos_shells DOUBLE PRECISION , DIMENSION (:,:,:), ALLOCATABLE :: pos_shell_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: g_xx_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: bar_density_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: gam_euler_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pvol_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: npart_surface_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: npart_discarded LOGICAL , PARAMETER :: debug = . FALSE . PRINT * , \"** Executing the place_particles_spherical_surfaces SUBROUTINE...\" PRINT * CALL RANDOM_SEED ( SIZE = dim_seed ) ALLOCATE ( seed ( dim_seed ) ) seed ( 1 ) = 0 seed ( 2 ) = 1 DO itr = 3 , dim_seed seed ( itr ) = seed ( itr - 1 ) + seed ( itr - 2 ) ENDDO CALL RANDOM_SEED ( PUT = seed ) !-----------------------------------! !-- Compute desired particle mass --! !-----------------------------------! m_p = mass_star / npart_approx !------------------------------------------! !-- Compute number of spherical surfaces --! !------------------------------------------! n_shells = number_surfaces ( m_p , center , radius , get_density ) !------------------------------------------------! !-- Allocate memory for the spherical surfaces --! !------------------------------------------------! IF (. NOT . ALLOCATED ( shell_radii )) THEN ALLOCATE ( shell_radii ( n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shell_radii in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( shell_masses )) THEN ALLOCATE ( shell_masses ( n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shell_masses in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( shell_scales )) THEN ALLOCATE ( shell_scales ( n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shell_scales in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( vol_shell )) THEN ALLOCATE ( vol_shell ( n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array vol_shell in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( vol_shell2 )) THEN ALLOCATE ( vol_shell2 ( n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array vol_shell2 in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( mass_shell )) THEN ALLOCATE ( mass_shell ( n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array vol_shell in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( mass_shell2 )) THEN ALLOCATE ( mass_shell2 ( n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array vol_shell2 in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( m_parts )) THEN ALLOCATE ( m_parts ( 1 : n_shells ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array m_parts in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF !-------------------------------------------------------! !-- Place surfaces based on mass density a that point --! !-------------------------------------------------------! CALL place_surfaces ( central_density , center , radius , m_p , n_shells , & shell_radii , last_r , get_density ) ! Printout PRINT * , \" * Number of the spherical surfaces= \" , n_shells PRINT * , \" * Radii of the surfaces in units of the equatorial radius\" , & \" of the star, towards the companion= \" PRINT * , shell_radii / radius PRINT * !---------------------------------! !-- Compute radial mass profile --! !---------------------------------! PRINT * , \" * Integrating the baryon mass density to get the mass profile...\" PRINT * dr = radius / 30 0.0D0 dth = pi / 2.0D0 / 20 0.0D0 dphi = 2.0D0 * pi / 20 0.0D0 CALL integrate_density ( center , radius , & central_density , & dr , dth , dphi , & mass , mass_profile , & mass_profile_idx ) mass_profile ( 2 : 3 , : ) = mass_profile ( 2 : 3 , : ) * mass_star / mass !---------------------------------------------! !-- Assign masses to each spherical surface --! !---------------------------------------------! CALL assign_surfaces_mass ( shell_masses , shell_radii , radius , dr , & n_shells , mass_profile_idx , mass_profile , & mass_star ) !----------------------------------------------------! !-- Print mass profile and surfaces' radii to file --! !----------------------------------------------------! IF ( PRESENT ( filename_mass_profile ) ) THEN finalnamefile = filename_mass_profile ELSE finalnamefile = \"mass_profile.dat\" ENDIF IF ( PRESENT ( filename_shells_radii ) ) THEN finalnamefile2 = filename_shells_radii ELSE finalnamefile2 = \"shell_radii.dat\" ENDIF CALL print_mass_profile_surface_radii ( mass_profile , mass_profile_idx , & shell_radii , radius , dr , & n_shells , & filename_mass_profile , & filename_shells_radii ) !---------------------------------------------------------! !-- Initialize quantities before starting the iteration --! !---------------------------------------------------------! PRINT * , \" * Initializing quantities before starting the iteration...\" PRINT * ALLOCATE ( npart_shell ( n_shells ) ) ALLOCATE ( npart_shelleq ( n_shells ) ) ALLOCATE ( alpha ( n_shells ) ) ALLOCATE ( colatitude_pos ( n_shells ) ) ALLOCATE ( pos_shells ( n_shells ) ) initialization : DO r = 1 , n_shells , 1 IF ( ALLOCATED ( pos_shells ( r )% pos_shell ) ) & DEALLOCATE ( pos_shells ( r )% pos_shell ) IF ( ALLOCATED ( pos_shells ( r )% pvol_shell ) ) & DEALLOCATE ( pos_shells ( r )% pvol_shell ) IF ( ALLOCATED ( pos_shells ( r )% pvol_shell2 ) ) & DEALLOCATE ( pos_shells ( r )% pvol_shell2 ) IF ( ALLOCATED ( pos_shells ( r )% g_xx ) )& DEALLOCATE ( pos_shells ( r )% g_xx ) IF ( ALLOCATED ( pos_shells ( r )% baryon_density ) ) & DEALLOCATE ( pos_shells ( r )% baryon_density ) IF ( ALLOCATED ( pos_shells ( r )% gamma_euler ) ) & DEALLOCATE ( pos_shells ( r )% gamma_euler ) IF ( ALLOCATED ( pos_shells ( r )% pos_th ) ) & DEALLOCATE ( pos_shells ( r )% pos_th ) IF ( ALLOCATED ( pos_shells ( r )% pos_phi ) ) & DEALLOCATE ( pos_shells ( r )% pos_phi ) ALLOCATE ( pos_shells ( r )% pos_shell ( 3 , npart_approx ) ) ALLOCATE ( pos_shells ( r )% pvol_shell ( npart_approx ) ) ALLOCATE ( pos_shells ( r )% pvol_shell2 ( npart_approx ) ) ALLOCATE ( pos_shells ( r )% g_xx ( npart_approx ) ) ALLOCATE ( pos_shells ( r )% baryon_density ( npart_approx ) ) ALLOCATE ( pos_shells ( r )% gamma_euler ( npart_approx ) ) ALLOCATE ( pos_shells ( r )% pos_th ( npart_approx ) ) ALLOCATE ( pos_shells ( r )% pos_phi ( npart_approx ) ) pos_shells ( r )% pos_shell = 0.0D0 pos_shells ( r )% pos_phi = - 1.0D0 pos_shells ( r )% pos_th = - 1.0D0 pos_shells ( r )% pvol_shell = 0.0D0 pos_shells ( r )% pvol_shell2 = 0.0D0 pos_shells ( r )% g_xx = 0.0D0 pos_shells ( r )% baryon_density = 0.0D0 pos_shells ( r )% gamma_euler = 0.0D0 m_parts ( r ) = m_p npart_shelleq ( r ) = CEILING ( SQRT ( DBLE ( 2 * shell_masses ( r ) / m_parts ( r )))) ENDDO initialization pos = 0.0D0 pmass = 0.0D0 phase = 0.0D0 proper_volume = 0.0D0 vol_shell = 0.0D0 vol_shell2 = 0.0D0 dr_shells = radius / n_shells npart_out = 0 upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound r = CEILING ( DBLE ( n_shells ) / 2.0D0 ) cnt2 = 0 r_cnt = 1 ! These array are needed to be able to parallelize the loops on each surface ALLOCATE ( pos_shell_tmp ( 3 , 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))), & 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))) ) ) ALLOCATE ( g_xx_tmp ( 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))), & 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))) ) ) ALLOCATE ( bar_density_tmp ( 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))), & 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))) ) ) ALLOCATE ( gam_euler_tmp ( 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))), & 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))) ) ) ALLOCATE ( pvol_tmp ( 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))), & 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))) ) ) ALLOCATE ( npart_discarded ( 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))), & 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))) ) ) ALLOCATE ( npart_surface_tmp ( 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))), & 5 * CEILING ( SQRT ( DBLE ( 2 * npart_approx ))) ) ) !--------------------------------------------------! !--  Main iteration over the spherical surfaces  --! !--------------------------------------------------! PRINT * , \" * Assigning first half of particle positions...\" PRINT * place_particles_on_northern_emispheres : DO ! Correct npart_shelleq to be divisible by 4 IF ( MOD ( npart_shelleq ( r ), 2 ) /= 0 ) THEN CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 >= half ) rel_sign = 1 IF ( rand_num2 < half ) rel_sign = - 1 npart_shelleq ( r ) = npart_shelleq ( r ) + rel_sign ENDIF IF ( MOD ( npart_shelleq ( r ) / 2 , 2 ) /= 0 ) THEN CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 >= half ) rel_sign = 1 IF ( rand_num2 < half ) rel_sign = - 1 npart_shelleq ( r ) = 2 * ( npart_shelleq ( r ) / 2 + rel_sign ) ENDIF IF ( MOD ( npart_shelleq ( r ), 4 ) /= 0 ) THEN PRINT * , \" * ERROR! npart_shelleq(\" , r , \")=\" , npart_shelleq ( r ), & \" is not divisible by 4 in the main iteration. \" , & \" Check the algorithm. Stopping...\" STOP ENDIF ! Compute number of particles on the spherical surface npart_shell ( r ) = ( npart_shelleq ( r ) ** 2.0D0 ) / 2.0D0 ! Compute angular step in azimuth phi (constant on each shell) IF ( npart_shelleq ( r ) == 0 ) THEN alpha ( r ) = 0.0D0 ELSE alpha ( r ) = 2.0D0 * pi / DBLE ( npart_shelleq ( r )) ENDIF ! Compute angular positions in colatitude theta, ! according to https://mathworld.wolfram.com/SpherePointPicking.html IF ( ALLOCATED ( colatitude_pos ( r )% colatitudes ) ) & DEALLOCATE ( colatitude_pos ( r )% colatitudes ) ALLOCATE ( colatitude_pos ( r )% colatitudes ( npart_shelleq ( r ) / 4 ) ) IF ( shell_radii ( r ) < 0.95D0 * last_r * radius ) THEN CALL compute_colatitudes_uniformly_in ( pi / 2.0D0 , 9.5D0 / 1 0.0D0 * pi , & colatitude_pos ( r )% colatitudes ( : ) ) ELSE CALL compute_colatitudes_uniformly_in ( pi / 2.0D0 , 9.5D0 / 1 0.0D0 * pi , & colatitude_pos ( r )% colatitudes ( : ) ) !CALL compute_colatitudes_uniformly_in( pi/2.0D0, 2.0D0/3.0D0*pi, & !                              colatitude_pos( r )% colatitudes( : ) ) ENDIF !            alpha( r )*1.0D0/2.0D0 + ( itr2 - 1 )*alpha( r ) !  ACOS( 2.0D0*( 1.0D0 - COS( pi/3.0D0*( 2.0D0/3.0D0 + DBLE(itr2 - 1)*DBLE(npart_shelleq( r )/4 + 1.0D0 -(1.0D0/2.0D0)-(2.0D0/3.0D0) )/DBLE(npart_shelleq( r )/4 - 1.0D0 ) ) & !                   /DBLE(npart_shelleq( r )/4 + 1.0D0 ) ) ) & !      - 1.0D0 ) !5.0D0/12.0D0 !colatitude_pos( r )% colatitudes( itr2 )= & !              colatitude_pos( r )% colatitudes( itr2 ) & !              *( 1 + rel_sign*0.05D0*phase_th ) DO itr2 = 1 , npart_shelleq ( r ) / 4 , 1 IF ( colatitude_pos ( r )% colatitudes ( itr2 ) <= pi / 2.0D0 . OR . & colatitude_pos ( r )% colatitudes ( itr2 ) >= pi & ) THEN PRINT * , \"** ERROR! \" , & \"The colatitudes are not in the OPEN interval (pi/2,pi). \" , & \"Stopping...\" STOP ENDIF ENDDO npart_discard = 0 npart_shell_cnt = 0 npart_shell_tmp = npart_shell ( r ) ! Initialize te  mporary arrays pos_shell_tmp = huge_real g_xx_tmp = 0.0D0 bar_density_tmp = 0.0D0 gam_euler_tmp = 0.0D0 pvol_tmp = 0.0D0 npart_discarded = 0.0D0 npart_surface_tmp = 0.0D0 IF ( debug ) PRINT * , \"Right before OMP, shell \" , r , \"iteration \" , cnt2 + 1 dphi_shells = alpha ( r ) !$OMP PARALLEL DO DEFAULT(NONE), & !$OMP             PRIVATE( phase, col, col_tmp, xtemp, ytemp, ztemp, & !$OMP                      dth_shells, delta_r, long, & !$OMP                      th, phi, rand_num2, phase_th, rel_sign ), & !$OMP             SHARED( r, npart_shelleq, center, rad, alpha, & !$OMP                     pos_shells, colatitude_pos, n_shells, & !$OMP                     dr_shells, shell_radii, shell_thickness, THIS, & !$OMP                     g_xx_tmp, bar_density_tmp, gam_euler_tmp, & !$OMP                     pos_shell_tmp, pvol_tmp, dphi_shells, radius, & !$OMP                     npart_discarded, npart_surface_tmp, last_r ) DO phi = 1 , npart_shelleq ( r ), 1 IF ( debug ) PRINT * , \"Right before loop over phi\" DO th = 1 , npart_shelleq ( r ) / 4 , 1 !npart_shelleq( r ) is even, see above ! !-- Randomize positions, if specified by the user in the !-- parameter file lorene_bns_id_particles.par ! IF ( THIS % randomize_phi ) THEN CALL RANDOM_NUMBER ( phase ) phase = phase * alpha ( r ) ENDIF !  IF( shell_radii(r) < 0.95D0*last_r*radius )THEN ! !    long= phase + phi*alpha(r) ! !  ELSE ! !    long= phase + phi*alpha(r)/3.0D0 - pi/3.0D0 ! !  ENDIF long = phase + phi * alpha ( r ) col = colatitude_pos ( r )% colatitudes ( th ) IF ( THIS % randomize_theta ) THEN CALL RANDOM_NUMBER ( phase_th ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 >= half ) rel_sign = 1 IF ( rand_num2 < half ) rel_sign = - 1 col_tmp = col * ( 1.0D0 + rel_sign * 0.05D0 * phase_th ) IF ( col_tmp < pi . AND . col_tmp > pi / 2.0D0 ) THEN col = col_tmp ENDIF ENDIF rad = shell_radii ( r ) IF ( THIS % randomize_r ) THEN CALL RANDOM_NUMBER ( delta_r ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 >= half ) rel_sign = 1 IF ( rand_num2 < half ) rel_sign = - 1 IF ( r / n_shells < 0.95D0 ) THEN rad = rad + rel_sign * delta_r * 0.35D0 * dr_shells ELSE !rad= rad - ( 1.0D0 + delta_r )*0.35D0*dr_shells rad = rad + ( - delta_r * 0.35D0 - 0.5D0 ) * dr_shells ENDIF ENDIF IF ( rad < 0 ) THEN PRINT * , \" * ERROR! rad < 0. Check the computation of the radial\" , & \" coordinates of the particles. Stopping..\" STOP ENDIF ! !-- Compute Cartesian coordinates of the candidate particle positions ! xtemp = rad * COS ( long ) * SIN ( col ) + center ytemp = rad * SIN ( long ) * SIN ( col ) ztemp = rad * COS ( col ) IF ( ISNAN ( xtemp ) ) THEN PRINT * , \"** ERROR when placing first half of the particles! \" , & \"xtemp is a NaN. Stopping..\" STOP ENDIF IF ( ISNAN ( ytemp ) ) THEN PRINT * , \"** ERROR when placing first half of the particles! \" , & \"ytemp is a NaN. Stopping..\" STOP ENDIF IF ( ISNAN ( ztemp ) ) THEN PRINT * , \"** ERROR when placing first half of the particles! \" , & \"ztemp is a NaN. Stopping..\" STOP ENDIF ! Import ID needed to compute the particle masses CALL get_id ( xtemp , ytemp , ztemp , & g_xx_tmp ( th , phi ), & bar_density_tmp ( th , phi ), & gam_euler_tmp ( th , phi ) ) ! Place a particle at a given position only if the hydro ! computed by LORENE is acceptable IF ( bar_density_tmp ( th , phi ) > 0.0D0 & !pos_shells(r)% baryon_density( itr + 1 ) > 0.0D0 & . AND . & validate_position_final ( xtemp , ytemp , ztemp ) == 0 ) THEN !npart_shell_cnt= npart_shell_cnt + 1 npart_surface_tmp ( th , phi ) = 1 pos_shell_tmp ( 1 , th , phi ) = xtemp pos_shell_tmp ( 2 , th , phi ) = ytemp pos_shell_tmp ( 3 , th , phi ) = ztemp ! Compute particle volume pvol_tmp ( th , phi ) = particle_volume ( rad , col , dr_shells , & dth_shells , dphi_shells , th , & colatitude_pos ( r )% colatitudes , & npart_shelleq ( r ) ) ! Safety check IF ( pvol_tmp ( th , phi ) <= 0 ) THEN ! pos_shells(r)% pvol_shell2( itr + 1 ) <= 0 )THEN PRINT * , \"When placing first half of particles\" PRINT * , \"pvol_tmp( \" , r , \",\" , th , \",\" , phi , \" ) =\" , & pvol_tmp ( th , phi ) PRINT * , \"dr_shells=\" , dr_shells , & \"dth_shells=\" , dth_shells , & \"dphi_shells=\" , dphi_shells STOP ENDIF ELSE ! If the hydro is not positive, or the position is outside the star, ! discard the position and count the number of discarded positions !npart_discard= npart_discard + 2 npart_discarded ( th , phi ) = 2 ENDIF ENDDO ENDDO !$OMP END PARALLEL DO npart_discard = SUM ( SUM ( npart_discarded , DIM = 1 ), DIM = 1 ) npart_shell_cnt = SUM ( SUM ( npart_surface_tmp , DIM = 1 ), DIM = 1 ) npart_shell ( r ) = npart_shell ( r ) - npart_discard npart_out = npart_out + npart_shell ( r ) / 2 IF ( debug ) PRINT * , \"Right after OMP\" ! Safety check IF ( npart_shell_cnt /= npart_shell ( r ) / 2 ) THEN PRINT * , \"** ERROR! Mismatch in the particle counters on shell \" , r PRINT * , \" * npart_shell_cnt=\" , npart_shell_cnt , & \"npart_shell( r )/2=\" , npart_shell ( r ) / 2 PRINT * , \" * npart_shell_cnt should be equal to npart_shell( r )/2. \" & // \"Stopping...\" PRINT * STOP ENDIF ! Set up the next step in pathological cases IF ( npart_shell ( r ) < 0 ) npart_shell ( r ) = 0 IF ( npart_shell ( r ) == 0 ) THEN m_parts ( r ) = m_parts ( prev_shell ) PRINT * , \" * Placed\" , npart_shell ( r ) / 2 , & \" particles on one emisphere of spherical shell \" , r , & \" out of \" , n_shells IF ( r == 1 ) THEN EXIT ELSEIF ( r < CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) THEN !PRINT *, \"r=\", r r = r - 1 cnt2 = 0 upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound CYCLE ELSEIF ( r == n_shells ) THEN !PRINT *, \"r=\", r r = CEILING ( DBLE ( n_shells ) / 2.0D0 ) - 1 r_cnt = r_cnt + 1 cnt2 = 0 upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound CYCLE ELSEIF ( r >= CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) THEN !PRINT *, \"r=\", r r = r + 1 cnt2 = 0 upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound CYCLE ENDIF ELSE m_parts ( r ) = shell_masses ( r ) / DBLE ( npart_shell ( r )) ENDIF IF ( debug ) PRINT * , \" * Before storing the particles\" IF ( debug ) PRINT * , \"11\" IF ( debug ) PRINT * , \"Right before correction of particle number\" IF ( debug ) PRINT * , \"npart_out=\" , npart_out ! If it's not the first populated surface not_first_populated_surface : IF ( r /= CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) THEN ! Identify the previous surface IF ( r < CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) THEN prev_shell = r + 1 ELSEIF ( r > CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) THEN prev_shell = r - 1 ELSEIF ( r == 1 ) THEN EXIT ENDIF ! Logical variables that steer the iteration ! This speeds up the iteration considerably, since the inner layers ! seem to always want a larger tolerance IF ( r <= 0.45D0 * n_shells ) THEN upper_bound_tmp = upper_bound_tmp * 1.1D0 lower_bound_tmp = lower_bound_tmp * 0.9D0 ENDIF ! Is the particle mass too high? high_mass = m_parts ( r ) / m_parts ( prev_shell ) > upper_bound_tmp ! Is the particle mass too low? low_mass = m_parts ( r ) / m_parts ( prev_shell ) < lower_bound_tmp ! How many positions were kept, placing a particle on them? npart_shell_kept = DBLE ( npart_shell ( r )) / DBLE ( npart_shell_tmp ) ! Were all the positions kept? kept_all = npart_shell_kept == 1.0D0 ! If the particle mass is too high and all positions were kept adjust_particle_number_surface : IF ( high_mass . AND . kept_all ) THEN IF ( debug ) PRINT * , \"Case 1\" cnt2 = cnt2 + 1 ! If this is the (max_steps + 1)st step too_many_steps : IF ( cnt2 > max_steps ) THEN ! Allow for a bit more different particle mass upper_bound_tmp = upper_bound_tmp * upper_factor lower_bound_tmp = lower_bound_tmp * lower_factor ! !-- Special treatment for the positions near the surface ! ! If the range of particle masses is getting too generous ! near the surface IF ( r > 0.8D0 * n_shells . AND . & m_parts ( r ) / m_parts ( prev_shell ) > 1.1D0 * upper_bound & ) THEN ! Increase the number of positions on this surface ! by a factor between 5 and 10 CALL RANDOM_NUMBER ( rand_num2 ) rand_num = NINT ( 5.0D0 * ( rand_num2 + 1.0D0 ) ) npart_shelleq ( r ) = rand_num * npart_shelleq ( r ) !  npart_shelleq( r - 1 ) & !+ rel_sign*NINT( 1 + rand_num ) ! Reset the particle mass tolerance range upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound ! Reset total particle number npart_out = npart_out - npart_shell ( r ) / 2 ! Reset counter cnt2 = 1 ! Replace particles on this surface CYCLE ENDIF ! Reset counter cnt2 = 1 ENDIF too_many_steps ! If this is not yet the (max_steps + 1)st step ! Reset total particle number npart_out = npart_out - npart_shell ( r ) / 2 ! Increase randomly particle number on the equator which determines ! the particle number on the surface ! More particles = lower particle mass, with fixed surface mass CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) npart_shelleq ( r ) = npart_shelleq ( r ) + 1 * NINT ( 1 + 1.0 * rand_num ) & + 1 * NINT ( 1 + 1.0 * rand_num2 ) ! Treat pathological cases IF ( npart_shelleq ( r ) == 0 . OR . npart_shell ( r ) == 0 ) THEN CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 npart_shelleq ( r ) = npart_shelleq ( r - 1 ) & + rel_sign * NINT ( 1 + rand_num ) ENDIF ! Replace particles on this surace CYCLE ! The cases below do similar things to the one above, so there are no ! comments on each line. See the case above for explanations ELSEIF ( low_mass . AND . kept_all ) THEN IF ( debug ) PRINT * , \"Case 2\" cnt2 = cnt2 + 1 IF ( cnt2 > max_steps ) THEN upper_bound_tmp = upper_bound_tmp * upper_factor lower_bound_tmp = lower_bound_tmp * lower_factor IF ( r > 0.8D0 * n_shells . AND . & m_parts ( r ) / m_parts ( prev_shell ) < 0.9D0 * lower_bound & ) THEN CALL RANDOM_NUMBER ( rand_num2 ) rand_num = NINT ( 5.0D0 * ( rand_num2 + 1.0D0 ) ) npart_shelleq ( r ) = npart_shelleq ( r ) / rand_num !  npart_shelleq( r - 1 ) & !+ rel_sign*NINT( 1 + rand_num ) upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound npart_out = npart_out - npart_shell ( r ) / 2 cnt2 = 1 CYCLE ENDIF cnt2 = 1 ENDIF npart_out = npart_out - npart_shell ( r ) / 2 CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) npart_shelleq ( r ) = npart_shelleq ( r ) - 1 * NINT ( 1 + 1.0 * rand_num ) & - 1 * NINT ( 1 + 1.0 * rand_num2 ) IF ( npart_shelleq ( r ) == 0 . OR . npart_shell ( r ) == 0 ) THEN CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 npart_shelleq ( r ) = npart_shelleq ( r - 1 ) & + rel_sign * NINT ( 1 + rand_num ) ENDIF CYCLE ELSEIF ( high_mass . AND . . NOT . kept_all ) THEN IF ( debug ) PRINT * , \"Case 3\" cnt2 = cnt2 + 1 IF ( cnt2 > max_steps ) THEN upper_bound_tmp = upper_bound_tmp * upper_factor lower_bound_tmp = lower_bound_tmp * lower_factor IF ( r > 0.8D0 * n_shells . AND . & m_parts ( r ) / m_parts ( prev_shell ) > 1.1D0 * upper_bound & !upper_bound_tmp > 1.1D0*upper_bound & ) THEN CALL RANDOM_NUMBER ( rand_num2 ) rand_num = NINT ( 5.0D0 * ( rand_num2 + 1.0D0 ) ) npart_shelleq ( r ) = rand_num * npart_shelleq ( r ) !  npart_shelleq( r - 1 ) & !+ rel_sign*NINT( 1 + rand_num ) upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound npart_out = npart_out - npart_shell ( r ) / 2 cnt2 = 1 CYCLE ENDIF cnt2 = 1 ENDIF npart_out = npart_out - npart_shell ( r ) / 2 CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 ! If x% of the positions were kept, divide the old particle number ! on the equator by x, and adjust with some other random and ! non-random factors which turn out to work well a posteriori npart_shelleq ( r ) = CEILING ( SQRT ( & 2 * ( shell_masses ( r ) / m_parts ( prev_shell )) & / npart_shell_kept & ) ) + rel_sign * NINT ( 1 + rand_num ) IF ( npart_shelleq ( r ) == 0 . OR . npart_shell ( r ) == 0 ) THEN CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 npart_shelleq ( r ) = npart_shelleq ( prev_shell ) & + rel_sign * NINT ( 1 + rand_num ) ENDIF CYCLE ELSEIF ( low_mass . AND . . NOT . kept_all ) THEN IF ( debug ) PRINT * , \"Case 4\" cnt2 = cnt2 + 1 IF ( cnt2 > max_steps ) THEN upper_bound_tmp = upper_bound_tmp * upper_factor lower_bound_tmp = lower_bound_tmp * lower_factor IF ( r > 0.8D0 * n_shells . AND . & m_parts ( r ) / m_parts ( prev_shell ) < 0.9D0 * lower_bound & !lower_bound_tmp < 0.9D0*lower_bound & ) THEN CALL RANDOM_NUMBER ( rand_num2 ) rand_num = NINT ( 5.0D0 * ( rand_num2 + 1.0D0 ) ) npart_shelleq ( r ) = npart_shelleq ( r ) / rand_num !  npart_shelleq( r - 1 ) & !+ rel_sign*NINT( 1 + rand_num ) upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound npart_out = npart_out - npart_shell ( r ) / 2 cnt2 = 1 CYCLE ENDIF cnt2 = 1 ENDIF npart_out = npart_out - npart_shell ( r ) / 2 CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 ! If x% of the positions were kept, divide the old particle number ! on the equator by x, and adjust with some other random and ! non-random factors which turn out to work well a posteriori npart_shelleq ( r ) = CEILING ( SQRT ( & 2 * ( shell_masses ( r ) / m_parts ( prev_shell )) & / npart_shell_kept & ) ) + rel_sign * NINT ( 1 + rand_num ) IF ( npart_shelleq ( r ) == 0 . OR . npart_shell ( r ) == 0 ) THEN CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 npart_shelleq ( r ) = npart_shelleq ( prev_shell ) & + rel_sign * NINT ( 1 + rand_num ) ENDIF IF ( debug ) PRINT * , \"Right after correction of particle number\" ! Replace particle on this surface CYCLE ENDIF adjust_particle_number_surface ENDIF not_first_populated_surface ! >TODO: Safety check to be updated !IF( r_cnt > 1 )THEN !  npart_test= 0 !  DO itr= 1, r, 1 !    npart_test= npart_test + npart_shell( itr ) !  ENDDO !  IF( npart_test/2 /= npart_out )THEN !    PRINT *, \"** ERROR! The sum of the particles on the shells is not \", & !             \"equal to the total number of particles. Stopping..\" !    PRINT *, \"npart_test=\", npart_test/2, \", npart_out=\", npart_out !    PRINT * !    STOP !  ENDIF !ENDIF IF ( debug ) PRINT * , \"10\" ! At this point, the particles are placed on this surface ! Print out the result PRINT * , \" * Placed\" , npart_shell ( r ) / 2 , & \" particles on one emisphere of spherical shell \" , r , & \" out of \" , n_shells PRINT * , \"   Shell radius= \" , shell_radii ( r ) / radius * 10 0.0D0 , & \"% of the radius of the star\" PRINT * , \"   Placed\" , npart_out , \" particles overall, so far.\" IF ( r /= CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) PRINT * , & \"   Ratio of particle masses on last 2 shells: \" , & \"   m_parts(\" , r , \")/m_parts(\" , prev_shell , \")= \" , & m_parts ( r ) / m_parts ( prev_shell ) ! Save particles to non-temporary variables size_pos_shell = SIZE ( pos_shells ( r )% pos_shell ( 1 , : ) ) IF ( npart_shelleq ( r ) * npart_shelleq ( r ) / 4 > size_pos_shell ) THEN CALL reallocate_array_2d ( pos_shells ( r )% pos_shell , 3 , & npart_shelleq ( r ) * npart_shelleq ( r ) / 4 ) CALL reallocate_array_1d ( pos_shells ( r )% g_xx , & npart_shelleq ( r ) * npart_shelleq ( r ) / 4 ) CALL reallocate_array_1d ( pos_shells ( r )% baryon_density , & npart_shelleq ( r ) * npart_shelleq ( r ) / 4 ) CALL reallocate_array_1d ( pos_shells ( r )% gamma_euler , & npart_shelleq ( r ) * npart_shelleq ( r ) / 4 ) CALL reallocate_array_1d ( pos_shells ( r )% pvol_shell2 , & npart_shelleq ( r ) * npart_shelleq ( r ) / 4 ) ENDIF itr = 0 DO th = 1 , npart_shelleq ( r ) / 4 , 1 DO phi = 1 , npart_shelleq ( r ), 1 IF ( pos_shell_tmp ( 1 , th , phi ) /= huge_real & !pos_shell_tmp( 1, th, phi ) < center + 1.2D0*radius & !.AND. & !pos_shell_tmp( 1, th, phi ) > center - 1.2D0*radius ) THEN itr = itr + 1 pos_shells ( r )% pos_shell ( 1 , itr ) = pos_shell_tmp ( 1 , th , phi ) pos_shells ( r )% pos_shell ( 2 , itr ) = pos_shell_tmp ( 2 , th , phi ) pos_shells ( r )% pos_shell ( 3 , itr ) = pos_shell_tmp ( 3 , th , phi ) pos_shells ( r )% g_xx ( itr ) = g_xx_tmp ( th , phi ) pos_shells ( r )% baryon_density ( itr ) = bar_density_tmp ( th , phi ) pos_shells ( r )% gamma_euler ( itr ) = gam_euler_tmp ( th , phi ) pos_shells ( r )% pvol_shell2 ( itr ) = pvol_tmp ( th , phi ) ENDIF ENDDO ENDDO ! Safety check IF ( npart_shell_cnt /= itr ) THEN PRINT * , \"** ERROR! Mismatch in the particle counters on shell \" , r PRINT * , \" * npart_shell_cnt=\" , npart_shell_cnt , & \", itr=\" , itr , \". npart_shell_cnt should be equal to itr. \" PRINT * , \" * npart_shell( r )/2=\" , npart_shell ( r ) / 2 STOP ENDIF ! Set up next step IF ( r == n_shells ) THEN r = CEILING ( DBLE ( n_shells ) / 2.0D0 ) - 1 r_cnt = r_cnt + 1 cnt2 = 0 upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound IF ( debug ) PRINT * , \"last shell\" ELSEIF ( r == 1 ) THEN IF ( debug ) PRINT * , \"exit\" EXIT ELSEIF ( r < CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) THEN r = r - 1 r_cnt = r_cnt + 1 cnt2 = 0 upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound IF ( debug ) PRINT * , \"inner layers\" ELSEIF ( r >= CEILING ( DBLE ( n_shells ) / 2.0D0 ) ) THEN r = r + 1 r_cnt = r_cnt + 1 cnt2 = 0 upper_bound_tmp = upper_bound lower_bound_tmp = lower_bound IF ( debug ) PRINT * , \"outer layers\" ENDIF IF ( debug ) PRINT * , \"12\" ENDDO place_particles_on_northern_emispheres !-----------------------------! !--  End of main iteration  --! !-----------------------------! ! Print out the total number of particles on the northern emispheres, ! and the final mass ratio PRINT * , \" * Particles on the northern emispheres=\" , npart_out PRINT * , \" * Particle mass ratio= \" , MAXVAL ( m_parts ) / MINVAL ( m_parts ) PRINT * ! Safety check npart_test = SUM ( npart_shell , DIM = 1 ) IF ( npart_test / 2 /= npart_out ) THEN PRINT * , \"** ERROR! The sum of the particles on the shells is not \" , & \"equal to the total number of particles. Stopping..\" PRINT * , \" * npart_test/2=\" , npart_test / 2 , \", npart_out=\" , npart_out PRINT * , \" * Array npart_shell=\" , npart_shell PRINT * STOP ENDIF IF ( debug ) PRINT * , \"13\" ! Deallocate temporary arrays IF ( ALLOCATED ( pos_shell_tmp ) ) THEN DEALLOCATE ( pos_shell_tmp , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array m_parts in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF ( ALLOCATED ( g_xx_tmp ) ) THEN DEALLOCATE ( g_xx_tmp , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array m_parts in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF ( ALLOCATED ( bar_density_tmp ) ) THEN DEALLOCATE ( bar_density_tmp , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array m_parts in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF ( ALLOCATED ( gam_euler_tmp ) ) THEN DEALLOCATE ( gam_euler_tmp , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array m_parts in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF ( ALLOCATED ( pvol_tmp ) ) THEN DEALLOCATE ( pvol_tmp , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array m_parts in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF ( ALLOCATED ( npart_discarded ) ) THEN DEALLOCATE ( npart_discarded , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array npart_discarded in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF ( ALLOCATED ( npart_surface_tmp ) ) THEN DEALLOCATE ( npart_surface_tmp , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array m_parts in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF ( debug ) PRINT * , \"14\" ! !-- Mirror particles from the northern emispheres to the southern ones ! PRINT * , \" * Mirroring particles from the northern emispheres to the\" , & \" southern ones...\" PRINT * IF ( debug ) PRINT * , \" * npart/2=\" , npart_out DO r = 1 , n_shells , 1 DO itr = 1 , npart_shell ( r ) / 2 , 1 npart_out = npart_out + 1 pos_shells ( r )% pos_shell ( 1 , npart_shell ( r ) / 2 + itr ) = & pos_shells ( r )% pos_shell ( 1 , itr ) pos_shells ( r )% pos_shell ( 2 , npart_shell ( r ) / 2 + itr ) = & pos_shells ( r )% pos_shell ( 2 , itr ) pos_shells ( r )% pos_shell ( 3 , npart_shell ( r ) / 2 + itr ) = & - pos_shells ( r )% pos_shell ( 3 , itr ) pos_shells ( r )% g_xx ( npart_shell ( r ) / 2 + itr ) = & pos_shells ( r )% g_xx ( itr ) pos_shells ( r )% baryon_density ( npart_shell ( r ) / 2 + itr ) = & pos_shells ( r )% baryon_density ( itr ) pos_shells ( r )% gamma_euler ( npart_shell ( r ) / 2 + itr ) = & pos_shells ( r )% gamma_euler ( itr ) pos_shells ( r )% pvol_shell2 ( npart_shell ( r ) / 2 + itr ) = & pos_shells ( r )% pvol_shell2 ( itr ) ! Safety checks IF ( pos_shells ( r )% baryon_density ( itr ) == 0 ) THEN PRINT * , \"When mirroring particles\" PRINT * , r , itr , pos_shells ( r )% pos_shell ( 1 , itr ), & pos_shells ( r )% pos_shell ( 2 , itr ), & pos_shells ( r )% pos_shell ( 3 , itr ), & pos_shells ( r )% baryon_density ( itr ) STOP ENDIF IF ( pos_shells ( r )% pvol_shell2 ( itr ) < 0 ) THEN PRINT * , \"When mirroring particles\" PRINT * , \"pos_shells(\" , r , \")% pvol_shell2( \" , itr , \" ) =\" , & pos_shells ( r )% pvol_shell2 ( itr ) STOP ENDIF ENDDO ENDDO PRINT * , \" * Final number of particles=\" , npart_out PRINT * ! Safety checks (maybe redundant at this point, but better to be paranoid) npart_test = 0 DO r = 1 , n_shells , 1 npart_test = npart_test + npart_shell ( r ) ENDDO IF ( npart_test /= npart_out ) THEN PRINT * , \"** ERROR! The sum of the particles on the shells is not \" , & \"equal to the total number of particles. Stopping..\" PRINT * , \" * npart_test\" , npart_test , \", npart_out=\" , npart_out PRINT * STOP ENDIF IF ( SUM ( npart_shell , DIM = 1 ) /= npart_out ) THEN PRINT * , \"** ERROR! The sum of the particles on the shells is not \" , & \"equal to the total number of particles. Stopping..\" PRINT * , \" * SUM( npart_shell )\" , SUM ( npart_shell , DIM = 1 ), & \", npart_out=\" , npart_out PRINT * STOP ENDIF debug_if : IF ( debug ) THEN mass_test = 0.0D0 mass_test2 = 0.0D0 proper_volume_test = 0.0D0 proper_volume = 0.0D0 i_shell = 1 DO r = 1 , n_shells , 1 !DO itr= i_shell, (i_shell - 1) + (npart_shelleq(r)**2.0D0)/2.0D0, 1 !  CALL bns_obj% import_id( & !           pos( 1, itr ), pos( 2, itr ), pos( 3, itr ), & !           g_xx, baryon_density, gamma_euler ) ! !  pvol( itr )= m_parts( r )/( baryon_density*g_xx*SQRT(g_xx)*gamma_euler ) ! !  proper_volume_test= proper_volume_test + 2.0D0*pvol( itr )*g_xx*SQRT(g_xx) !  mass_test= mass_test + & !              2.0D0*baryon_density*pvol( itr )*g_xx*SQRT(g_xx)*gamma_euler !ENDDO !i_shell= i_shell + (npart_shelleq(r)**2.0D0)/2.0D0 DO itr = 1 , npart_shell ( r ), 1 IF ( pos_shells ( r )% baryon_density ( itr ) == 0 ) THEN PRINT * , \"When computing particle volume\" PRINT * , r , itr , pos_shells ( r )% pos_shell ( 1 , itr ), & pos_shells ( r )% pos_shell ( 2 , itr ), & pos_shells ( r )% pos_shell ( 3 , itr ), & pos_shells ( r )% baryon_density ( itr ) ENDIF !IF( pos_shells(r)% pvol_shell2( itr ) <= 0.0D0 )THEN !  PRINT *, \"When computing particle volume\" !  PRINT *, \"pos_shells(\", r, \")% pvol_shell2( \", itr, \" ) =\", & !           pos_shells(r)% pvol_shell2( itr ) !  STOP !ENDIF pos_shells ( r )% pvol_shell ( itr ) = m_parts ( r ) & / ( pos_shells ( r )% baryon_density ( itr ) & * pos_shells ( r )% g_xx ( itr ) & * SQRT ( pos_shells ( r )% g_xx ( itr )) & * pos_shells ( r )% gamma_euler ( itr ) ) proper_volume_test = proper_volume_test + & pos_shells ( r )% pvol_shell ( itr ) ! & !*pos_shells(r)% g_xx( itr ) & !*SQRT(pos_shells(r)% g_xx( itr )) proper_volume = proper_volume + pos_shells ( r )% pvol_shell2 ( itr ) !PRINT *, proper_volume mass_test = mass_test + pos_shells ( r )% baryon_density ( itr ) & * pos_shells ( r )% pvol_shell ( itr ) & * pos_shells ( r )% g_xx ( itr ) & * SQRT ( pos_shells ( r )% g_xx ( itr )) & * pos_shells ( r )% gamma_euler ( itr ) mass_test2 = mass_test2 + pos_shells ( r )% baryon_density ( itr ) & * pos_shells ( r )% pvol_shell2 ( itr ) & * pos_shells ( r )% g_xx ( itr ) & * SQRT ( pos_shells ( r )% g_xx ( itr )) & * pos_shells ( r )% gamma_euler ( itr ) ENDDO ENDDO PRINT * , mass_test , mass_test2 , mass_star , proper_volume_test , proper_volume PRINT * mass_test = 0.0D0 mass_test2 = 0.0D0 proper_volume_test = 0.0D0 proper_volume = 0.0D0 vol_shell ( r ) = 0.0D0 vol_shell2 ( r ) = 0.0D0 mass_shell ( r ) = 0.0D0 mass_shell2 ( r ) = 0.0D0 DO r = 1 , n_shells , 1 DO itr = 1 , npart_shell ( r ), 1 !IF( pos_shells(r)% pvol_shell2( itr ) <= 0 )THEN !  PRINT *, \"When computing shell volumes and masses\" !  PRINT *, \"pos_shells(\", r, \")% pvol_shell2( \", itr, \" ) =\", & !           pos_shells(r)% pvol_shell2( itr ) !  STOP !ENDIF vol_shell ( r ) = vol_shell ( r ) + pos_shells ( r )% pvol_shell ( itr ) vol_shell2 ( r ) = vol_shell2 ( r ) + pos_shells ( r )% pvol_shell2 ( itr ) mass_shell ( r ) = mass_shell ( r ) + & pos_shells ( r )% baryon_density ( itr ) & * pos_shells ( r )% pvol_shell ( itr ) & * pos_shells ( r )% g_xx ( itr ) & * SQRT ( pos_shells ( r )% g_xx ( itr )) & * pos_shells ( r )% gamma_euler ( itr ) mass_shell2 ( r ) = mass_shell2 ( r ) + & pos_shells ( r )% baryon_density ( itr ) & * pos_shells ( r )% pvol_shell2 ( itr ) & * pos_shells ( r )% g_xx ( itr ) & * SQRT ( pos_shells ( r )% g_xx ( itr )) & * pos_shells ( r )% gamma_euler ( itr ) ENDDO mass_test = mass_test + mass_shell ( r ) mass_test2 = mass_test2 + mass_shell2 ( r ) proper_volume = proper_volume + vol_shell ( r ) proper_volume_test = proper_volume_test + vol_shell2 ( r ) IF ( r > 1 ) THEN PRINT * , \"shell\" , r PRINT * , \"  shell volumes:\" , vol_shell ( r ), vol_shell2 ( r ), & 4.0D0 / 3.0D0 * pi * & ( shell_radii ( r ) ** 3.0D0 - shell_radii ( r - 1 ) ** 3.0D0 ) PRINT * , \"  shell masses:\" , mass_shell ( r ), mass_shell2 ( r ), & shell_masses ( r ) PRINT * ENDIF ENDDO PRINT * PRINT * , \"masses of the star:\" , mass_test , mass_test2 , mass_star PRINT * , \"volumes of the star:\" , proper_volume , proper_volume_test , & 4.0D0 / 3.0D0 * pi * radius ** 3.0D0 PRINT * !STOP !DO r= 1, n_shells, 1 !  DO itr= 1, npart_shell( r ), 1 ! !    PRINT*, (m_parts( r )*MSun/amu)/pos_shells(r)% pvol_shell( itr ) & !            /(pos_shells(r)% g_xx( itr ) & !              *SQRT(pos_shells(r)% g_xx( itr )) & !              *pos_shells(r)% gamma_euler( itr )), & !            pos_shells(r)% baryon_density( itr )*MSun/amu !  ENDDO !ENDDO !STOP ENDIF debug_if !---------------------------------------! !--  Save particles to output arrays  --! !---------------------------------------! IF (. NOT . ALLOCATED ( pos )) THEN ALLOCATE ( pos ( 3 , npart_out ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( pvol )) THEN ALLOCATE ( pvol ( npart_out ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pvol in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( pmass )) THEN ALLOCATE ( pmass ( npart_out ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pmass in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF cnt = 0 npart_shell_tmp = 0 DO r = 1 , n_shells , 1 DO itr = 1 , npart_shell ( r ), 1 pos ( 1 , itr + npart_shell_tmp ) = pos_shells ( r )% pos_shell ( 1 , itr ) pos ( 2 , itr + npart_shell_tmp ) = pos_shells ( r )% pos_shell ( 2 , itr ) pos ( 3 , itr + npart_shell_tmp ) = pos_shells ( r )% pos_shell ( 3 , itr ) pvol ( itr + npart_shell_tmp ) = pos_shells ( r )% pvol_shell2 ( itr ) pmass ( itr + npart_shell_tmp ) = m_parts ( r ) cnt = cnt + 1 ENDDO npart_shell_tmp = cnt ENDDO ! Safety check IF ( cnt /= npart_out ) THEN PRINT * , \"** ERROR! The sum of the particles on the shells is not \" , & \"equal to the total number of particles. Stopping..\" PRINT * , \"cnt\" , cnt , \", npart_out=\" , npart_out PRINT * STOP ENDIF !-------------------------------------------------------------------! !--  Print particle positions to file (TODO: make this optional)  --! !-------------------------------------------------------------------! PRINT * , \" * Printing particle positions to file...\" PRINT * IF ( PRESENT ( filename_shells_pos ) ) THEN finalnamefile = filename_shells_pos ELSE finalnamefile = \"spherical_surfaces_pos.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !DO itr = 1, npart_out, 1 ! !  WRITE( UNIT = 2, IOSTAT = ios, IOMSG = err_msg, FMT = * ) & !    pos( 1, itr ), pos( 2, itr ), pos( 3, itr ) ! !  IF( ios > 0 )THEN !    PRINT *, \"...error when writing the arrays in \" & !             // TRIM(finalnamefile), \". The error message is\", err_msg !    STOP !  ENDIF ! !ENDDO DO r = 1 , n_shells , 1 DO itr = 1 , npart_shell ( r ), 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & r , pos_shells ( r )% pos_shell ( 1 , itr ), & pos_shells ( r )% pos_shell ( 2 , itr ), & pos_shells ( r )% pos_shell ( 3 , itr ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" & // TRIM ( finalnamefile ), \". The error message is\" , err_msg STOP ENDIF ENDDO ENDDO CLOSE ( UNIT = 2 ) PRINT * , \" * SUBROUTINE place_particles_spherical_surfaces executed.\" PRINT * IF ( debug ) PRINT * , \"20\" CONTAINS FUNCTION validate_position_final ( x , y , z ) RESULT ( answer ) !******************************************************* ! !# Returns validate_position( x, y, z ) if the latter !  is present, 0 otherwise ! !  FT 22.09.2021 ! !******************************************************* IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point INTEGER :: answer !! validate_position( x, y, z ) if the latter is present, 0 otherwise IF ( PRESENT ( validate_position ) ) THEN answer = validate_position ( x , y , z ) ELSE answer = 0 ENDIF END FUNCTION validate_position_final END PROCEDURE place_particles_spherical_surfaces FUNCTION number_surfaces ( m_p , center , radius , get_dens ) & RESULT ( n_shells_tmp ) !************************************************ ! !# Compute the number of spherical surfaces !  by integrating the linear particle density !  along the larger equatorial radius ! !  FT 22.07.2021 ! !************************************************ USE constants , ONLY : third IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: m_p , center , radius INTERFACE FUNCTION get_dens ( x , y , z ) RESULT ( density ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION :: density !> Baryon mass density at (x,y,z) END FUNCTION get_dens END INTERFACE DOUBLE PRECISION :: n_shells_tmp INTEGER :: r !  DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: particle_profile ! !  IF(.NOT.ALLOCATED( particle_profile ))THEN !    ALLOCATE( particle_profile( 2, 500 ), STAT= ios, & !              ERRMSG= err_msg ) !    IF( ios > 0 )THEN !       PRINT *, \"...allocation error for array particle_profile in\" & !                // \"FUNCTION number_surfaces. \", & !                \"The error message is\", err_msg !       STOP !    ENDIF !  ENDIF n_shells_tmp = 0.0D0 !  particle_profile= 0.0D0 DO r = 1 , 500 , 1 n_shells_tmp = n_shells_tmp + & radius / 500 * ( ( get_dens ( & center + r * radius / 500 , 0.0D0 , 0.0D0 ) & ) / m_p ) ** third !particle_profile( 1, r )= r*radius/500 !particle_profile( 2, r )= n_shells_tmp ENDDO n_shells_tmp = NINT ( n_shells_tmp ) END FUNCTION number_surfaces SUBROUTINE reallocate_array_1d ( array , new_dim ) !************************************ ! !# Reallocate a 1-dimensional array ! !  FT 22.07.2021 ! !************************************ IMPLICIT NONE DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( IN OUT ) :: array INTEGER , INTENT ( IN ) :: new_dim DEALLOCATE ( array , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF ALLOCATE ( array ( new_dim ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF END SUBROUTINE reallocate_array_1d SUBROUTINE reallocate_array_2d ( array , new_dim , new_dim2 ) !************************************ ! !# Reallocate a 2-dimensional array ! !  FT 22.07.2021 ! !************************************ IMPLICIT NONE DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( IN OUT ) :: array INTEGER , INTENT ( IN ) :: new_dim , new_dim2 DEALLOCATE ( array , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF ALLOCATE ( array ( new_dim , new_dim2 ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF END SUBROUTINE reallocate_array_2d SUBROUTINE place_surfaces ( central_dens , center , radius , m_p , n_shells , & shell_radii , last_r , get_dens ) !************************************************ ! !# Place the spherical surface, according to !  the baryon mass density of the star !  along the larger equatorial radius ! !  FT 23.07.2021 ! !************************************************ USE constants , ONLY : third IMPLICIT NONE INTEGER , INTENT ( IN ) :: n_shells DOUBLE PRECISION , INTENT ( IN ) :: central_dens , center , radius , m_p , last_r DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN OUT ) :: shell_radii INTERFACE FUNCTION get_dens ( x , y , z ) RESULT ( density ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION :: density !> Baryon mass density at (x,y,z) END FUNCTION get_dens END INTERFACE DOUBLE PRECISION :: rho_tmp !central_density= bns_obj% get_rho_center1() shell_radii = 0.0D0 shell_radii ( 1 ) = ( central_dens / m_p ) ** ( - third ) DO itr = 2 , n_shells , 1 rho_tmp = get_dens ( center + shell_radii ( itr - 1 ), & 0.0D0 , 0.0D0 ) IF ( rho_tmp == 0 ) THEN shell_radii = shell_radii * itr / n_shells ENDIF shell_radii ( itr ) = shell_radii ( itr - 1 ) + ( rho_tmp / m_p ) ** ( - third ) ENDDO shell_radii = shell_radii * ( radius * last_r / shell_radii ( n_shells )) END SUBROUTINE place_surfaces SUBROUTINE assign_surfaces_mass ( shell_masses , shell_radii , radius , dr , & n_shells , mass_profile_idx , mass_profile , & mass_star ) !************************************************* ! !# Assign a mass to each spherical surface, !  based on the radial mass profile of the star !  (computed along the larger equatorial radius) ! !  FT 23.07.2021 ! !************************************************* USE constants , ONLY : third IMPLICIT NONE INTEGER , INTENT ( IN ) :: n_shells DOUBLE PRECISION , INTENT ( IN ) :: radius , dr , mass_star INTEGER , DIMENSION ( : ), INTENT ( IN ) :: mass_profile_idx DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN ) :: shell_radii DOUBLE PRECISION , DIMENSION ( :, : ), INTENT ( IN ) :: mass_profile DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN OUT ) :: shell_masses INTEGER shell_index , itr2 shell_index = 1 itr2 = 1 shell_masses = 0.0D0 assign_masses_to_surfaces : DO itr = 1 , NINT ( radius / dr ), 1 IF ( shell_index == n_shells ) THEN shell_masses ( shell_index ) = SUM ( mass_profile ( 2 , & mass_profile_idx ( itr2 ): mass_profile_idx ( NINT ( radius / dr ) - 1 ) ), DIM = 1 ) EXIT ENDIF IF ( mass_profile ( 1 , mass_profile_idx ( itr ) ) & >= shell_radii ( shell_index ) & !+ radius/DBLE(2*n_shells) ) THEN shell_masses ( shell_index ) = SUM ( mass_profile ( 2 , & mass_profile_idx ( itr2 ): mass_profile_idx ( itr ) ), DIM = 1 ) itr2 = itr + 1 shell_index = shell_index + 1 ENDIF ENDDO assign_masses_to_surfaces ! Safety check IF ( ABS ( SUM ( shell_masses , DIM = 1 ) - mass_star ) / mass_star > 5.0D-3 ) THEN PRINT * , \" ** The masses of the shells do not add up to the \" , & \"mass of the star. Stopping...\" PRINT * , \" * SUM( shell_masses )= \" , SUM ( shell_masses , DIM = 1 ) PRINT * , \" * Baryon mass of the star= \" , mass_star PRINT * , \" * Array shell_masses=\" , shell_masses PRINT * STOP ENDIF END SUBROUTINE assign_surfaces_mass SUBROUTINE print_mass_profile_surface_radii ( mass_profile , mass_profile_idx , & shell_radii , radius , dr , & n_shells , & filename_mass_profile , & filename_shells_radii ) !************************************************* ! !# Print star's radial mass profile and radii of !  spherical surfaces to different ASCII files ! !  FT 23.07.2021 ! !************************************************* USE constants , ONLY : third IMPLICIT NONE INTEGER , INTENT ( IN ) :: n_shells DOUBLE PRECISION , INTENT ( IN ) :: radius , dr INTEGER , DIMENSION ( : ), INTENT ( IN ) :: mass_profile_idx DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN ) :: shell_radii DOUBLE PRECISION , DIMENSION ( :, : ), INTENT ( IN ) :: mass_profile CHARACTER ( LEN = * ), INTENT ( IN ) :: filename_mass_profile , & filename_shells_radii LOGICAL :: exist PRINT * , \" * Print mass profile to file...\" PRINT * INQUIRE ( FILE = TRIM ( filename_mass_profile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( filename_mass_profile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( filename_mass_profile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( filename_mass_profile ), & \". The error message is\" , err_msg STOP ENDIF write_data_loop : DO itr = 1 , NINT ( radius / dr ) - 1 , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & mass_profile ( 1 , mass_profile_idx ( itr ) ), & mass_profile ( 2 , mass_profile_idx ( itr ) ), & mass_profile ( 3 , mass_profile_idx ( itr ) ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" & // TRIM ( filename_mass_profile ), \". The error message is\" , & err_msg STOP ENDIF ENDDO write_data_loop CLOSE ( UNIT = 2 ) PRINT * , \" * Print surfaces' radii to file...\" PRINT * INQUIRE ( FILE = TRIM ( filename_shells_radii ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( filename_shells_radii ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( filename_shells_radii ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( filename_shells_radii ), & \". The error message is\" , err_msg STOP ENDIF DO itr = 1 , n_shells , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & shell_radii ( itr ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" & // TRIM ( filename_shells_radii ), \". The error message is\" , & err_msg STOP ENDIF ENDDO CLOSE ( UNIT = 2 ) END SUBROUTINE print_mass_profile_surface_radii FUNCTION particle_volume ( rad , col , dr_shells , dth_shells , dphi_shells , th , & colatitudes , npart_equator ) RESULT ( pvol ) !******************************************* ! !# Compute the geometrical particle volume !  not the proper particle volume. ! !  FT 23.07.2021 ! !******************************************* USE constants , ONLY : pi IMPLICIT NONE INTEGER , INTENT ( IN ) :: th , npart_equator DOUBLE PRECISION , INTENT ( IN ) :: rad , col , dr_shells , dphi_shells DOUBLE PRECISION , INTENT ( IN OUT ) :: dth_shells DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: colatitudes DOUBLE PRECISION :: pvol IF ( th == 1 ) THEN !dth_shells= pi - ( col + colatitude_pos(r)% colatitudes(th+1) )/2.0D0 IF ( npart_equator == 4 ) THEN dth_shells = pi ELSE dth_shells = 2.0D0 * ABS ( col - & ( col + colatitudes ( th + 1 ) ) / 2.0D0 ) ENDIF ELSEIF ( th == npart_equator / 4 ) THEN !dth_shells= ( colatitude_pos(r)% colatitudes(th-1) + col - pi )/2.0D0 dth_shells = 2.0D0 * ABS ( ( colatitudes ( th - 1 ) & + col ) / 2.0D0 - col ) ELSE dth_shells = ABS ( & ( colatitudes ( th + 1 ) + col ) / 2.0D0 & - ( col + colatitudes ( th - 1 ) ) / 2.0D0 ) ENDIF pvol = rad ** 2.0D0 * SIN ( col ) * dr_shells * dth_shells * dphi_shells ! & END FUNCTION particle_volume SUBROUTINE compute_colatitudes_uniformly_in ( alpha , beta , colatitudes ) !************************************************** ! !# Compute the colatitudes according to a !  uniform distribution over a spherical !  surface, between alpha and beta, with !  pi/2 < alpha < beta < pi. !  The values are stored in the array colatitudes !  See https://mathworld.wolfram.com/SpherePointPicking.html ! !  FT 6.10.2021 ! !************************************************** USE constants , ONLY : pi IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: alpha , beta DOUBLE PRECISION , DIMENSION (:), INTENT ( INOUT ) :: colatitudes INTEGER :: n , size_col , i IF ( alpha < pi / 2 . OR . alpha > pi ) THEN PRINT * , \"ERROR in SUBROUTINE compute_colatitudes_uniformly_in!\" , & \" Argument alpha should lie in [pi/2,pi]. Stopping...\" PRINT * STOP ENDIF IF ( beta < pi / 2 . OR . beta > pi ) THEN PRINT * , \"** ERROR in SUBROUTINE compute_colatitudes_uniformly_in!\" , & \" Argument beta should lie in [pi/2,pi]. Stopping...\" PRINT * STOP ENDIF IF ( alpha > beta ) THEN PRINT * , \"** ERROR in SUBROUTINE compute_colatitudes_uniformly_in!\" , & \" Argument alpha should be less than argument beta. Stopping...\" PRINT * STOP ENDIF size_col = SIZE ( colatitudes ) n = 4 * size_col DO i = 1 , size_col , 1 colatitudes ( i ) = ACOS ( 2.0D0 * ( DBLE ( i + 1 ) * ( COS ( alpha ) + 1.0D0 ) / 2.0D0 & + ( ( COS ( beta ) + 1.0D0 ) / 2.0D0 & - ( DBLE ( n + 1 ) / 4.0D0 + 1.0D0 ) * ( COS ( alpha ) + 1.0D0 ) / 2.0D0 ) & * 4.0D0 * DBLE ( i ) / DBLE ( n + 1 ) ) - 1.0D0 ) !PRINT *, \"colatitudes(\", i, \")\", colatitudes(i)/pi, \"pi\" IF ( ISNAN ( colatitudes ( i ) ) ) THEN PRINT * , \"** ERROR in SUBROUTINE compute_colatitudes_uniformly_in! \" , & \"colatitudes(\" , i , \") is a NaN! Stopping..\" PRINT * , DBLE ( i + 1 ) * ( COS ( alpha ) + 1.0D0 ) / 2.0D0 PRINT * , ( COS ( beta ) + 1.0D0 ) / 2.0D0 PRINT * , DBLE ( size_col ) + 1.0D0 PRINT * , DBLE ( i ) / DBLE ( size_col ) PRINT * STOP ENDIF ENDDO END SUBROUTINE END SUBMODULE spherical_surfaces","tags":"","loc":"sourcefile/submodule_particles_spherical_surfaces.f90.html"},{"title":"submodule_particles_constructor.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_constructor.f90~~EfferentGraph sourcefile~submodule_particles_constructor.f90 submodule_particles_constructor.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_constructor.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_constructor Source Code submodule_particles_constructor.f90 Source Code ! File:         submodule_particles_constructor.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_constructor !************************************************ ! !# This SUBMODULE contains the implementation !  of the constructor and the !  destructor of TYPE particles. ! !  FT 16.10.2020 ! !************************************************ IMPLICIT NONE CONTAINS !MODULE PROCEDURE construct_particles_idase_empty ! !    !************************************************ !    ! !    !# The constructor of an empty particle object. !    ! !    !  FT 02.11.2020 !    ! !    !************************************************ ! ! !    IMPLICIT NONE ! ! !    parts% empty_object= .TRUE. ! !    parts% npart_temp= 0 ! !END PROCEDURE construct_particles_idase_empty MODULE PROCEDURE construct_particles !************************************************** ! !# The constructor performs all the tasks needed !  to set up the particle distribution with the !  |lorene| ID on it. It calls all the PROCEDURES !  that rely on an object of TYPE bns. ! !  @todo assign sub-tasks to separate SUBROUTINES !        CONTAINED in this SUBMODULE ! !  FT 17.10.2020 ! !************************************************** !USE NaNChecker, ONLY: Check_Array_for_NAN USE constants , ONLY : Msun_geo , km2m , amu USE NR , ONLY : indexx USE kernel_table , ONLY : ktable USE input_output , ONLY : read_options USE units , ONLY : set_units USE options , ONLY : ikernel , ndes USE alive_flag , ONLY : alive USE tensor , ONLY : jx , jy , jz IMPLICIT NONE ! The variable counter counts how many times the PROCEDURE ! construct_particles_idase is called INTEGER , SAVE :: counter = 1 INTEGER :: npart_des , & !nx, ny, nz, npart_des_l, npart_des_ss, & !npart_approx, npart2_approx, max_steps , & nlines , header_lines , n_cols , npart_tmp , npart1_tmp , npart2_tmp , & nx_gh , ny_gh , nz_gh , i_matter ! Maximum length for strings, and for the number of imported binaries INTEGER , PARAMETER :: max_length = 50 ! APM parameters INTEGER :: apm_max_it , max_inc !, n_particles_first_shell INTEGER , PARAMETER :: unit_pos = 2289 ! Variable storing the number of column where nu is written INTEGER :: column_nu ! Array storing the columns of the file parts_pos (defined below) that ! contain the particle positions INTEGER , DIMENSION ( 3 ) :: columns INTEGER , DIMENSION ( id % get_n_matter ()) :: npart_des_i DOUBLE PRECISION :: thres , nu_ratio DOUBLE PRECISION :: xmin , xmax , ymin , ymax , zmin , zmax , stretch !DOUBLE PRECISION:: xmin1, xmax1, ymin1, ymax1, zmin1, zmax1 !DOUBLE PRECISION:: xmin2, xmax2, ymin2, ymax2, zmin2, zmax2 !DOUBLE PRECISION:: center1, center2, radius1, radius2!, com1, com2 !DOUBLE PRECISION:: central_density1, central_density2 DOUBLE PRECISION :: upper_bound , lower_bound , upper_factor , lower_factor , & last_r DOUBLE PRECISION :: pvol_tmp DOUBLE PRECISION :: max_mass , total_mass !DOUBLE PRECISION, DIMENSION(id% get_n_matter()):: mass DOUBLE PRECISION , DIMENSION ( id % get_n_matter ()) :: central_density DOUBLE PRECISION , DIMENSION ( id % get_n_matter (), 3 ) :: center DOUBLE PRECISION , DIMENSION ( id % get_n_matter (), 3 ) :: barycenter DOUBLE PRECISION , DIMENSION ( id % get_n_matter (), 6 ) :: sizes DOUBLE PRECISION , DIMENSION ( :, : ), ALLOCATABLE :: tmp_pos DOUBLE PRECISION , DIMENSION ( :, : ), ALLOCATABLE :: tmp_pos2 !DOUBLE PRECISION, DIMENSION( : ),    ALLOCATABLE:: pvol_tmp2 DOUBLE PRECISION :: nuratio_thres , nuratio_des TYPE parts_i DOUBLE PRECISION , DIMENSION ( :, : ), ALLOCATABLE :: pos_i DOUBLE PRECISION , DIMENSION ( : ), ALLOCATABLE :: pvol_i DOUBLE PRECISION , DIMENSION ( : ), ALLOCATABLE :: pmass_i END TYPE TYPE ( parts_i ), DIMENSION ( id % get_n_matter ()) :: parts_all ! String storing the name of the directory storing the files containing ! the particle distributions CHARACTER ( LEN = max_length ) :: parts_pos_path ! String storing the name of the file containing the particle positions CHARACTER ( LEN = max_length ) :: parts_pos ! Final name for the file containing the particle positions CHARACTER ( LEN = : ), ALLOCATABLE :: parts_pos_namefile CHARACTER ( LEN = 3 ) :: str_i ! String storing the local path to the directory where the ! |lorene| BNS ID files are stored CHARACTER ( LEN = max_length ) :: compose_path ! String storing the names of the |lorene| BNS ID binary files CHARACTER ( LEN = max_length ) :: compose_filename CHARACTER ( LEN = max_length ) :: filename_apm_pos_id , filename_apm_pos , & filename_apm_results CHARACTER ( LEN = max_length ) :: filename_mass_profile , & filename_shells_radii , filename_shells_pos LOGICAL :: file_exists , use_thres , redistribute_nu , correct_nu , & compose_eos , exist , randomize_phi , randomize_theta , & randomize_r , mass_it , & read_nu , reflect_particles_x LOGICAL , PARAMETER :: debug = . FALSE . LOGICAL , DIMENSION ( id % get_n_matter ()) :: apm_iterate NAMELIST / bns_particles / & parts_pos_path , parts_pos , columns , header_lines , n_cols , & read_nu , column_nu , & stretch , & use_thres , thres , nu_ratio , redistribute_nu , correct_nu , & compose_eos , compose_path , compose_filename , & npart_des , last_r , upper_bound , lower_bound , & upper_factor , lower_factor , max_steps , & randomize_phi , randomize_theta , randomize_r , & apm_iterate , apm_max_it , max_inc , mass_it , & nuratio_thres , reflect_particles_x , nx_gh , ny_gh , nz_gh , & nuratio_des ! Get the number of matter objects in the physical system parts % n_matter = id % get_n_matter () ALLOCATE ( parts % apm_timers ( parts % n_matter ) ) ! !-- Initialize the timers ! parts % placer_timer = timer ( \"placer_timer\" ) !parts% apm1_timer         = timer( \"apm_star1_timer\" ) !parts% apm2_timer         = timer( \"apm_star2_timer\" ) parts % importer_timer = timer ( \"importer_timer\" ) parts % sph_computer_timer = timer ( \"sph_computer_timer\" ) parts % same_particle_timer = timer ( \"same_particle_timer\" ) DO itr = 1 , parts % n_matter , 1 IF ( parts % n_matter <= 9 ) WRITE ( str_i , \"(I1)\" ), itr IF ( parts % n_matter >= 10 . AND . parts % n_matter <= 99 ) & WRITE ( str_i , \"(I2)\" ), itr IF ( parts % n_matter >= 100 . AND . parts % n_matter <= 999 ) & WRITE ( str_i , \"(I3)\" ), itr parts % apm_timers ( itr ) = timer ( \"apm_timer\" // TRIM ( str_i ) ) ENDDO ! Declare this object as non-empty (experimental) parts % empty_object = . FALSE . ! !-- Read needed data from the idbase object ! !  center1               = id% get_center1_x() !  center2               = id% get_center2_x() !  central_density1      = id% get_rho_center1() !  central_density2      = id% get_rho_center2() !  com1                  = id% get_barycenter1_x() !  com2                  = id% get_barycenter2_x() !  radius1               = id% get_radius1_x_comp() !  radius2               = id% get_radius2_x_comp() parts % nbar_tot = 0.0D0 !parts% nbar1          = 0.0D0 !parts% nbar2          = 0.0D0 parts % npart = 0.0D0 parts % distribution_id = dist !  parts% eos1= id% get_eos1() !  parts% eos2= id% get_eos2() ! !  parts% eos1_id= id% get_eos1_id() !  parts% eos2_id= id% get_eos2_id() ! !  parts% gamma_sp1= id% get_gamma_1() !  parts% kappa_sp1= id% get_kappa_1() !  parts% gamma_sp2= id% get_gamma_2() !  parts% kappa_sp2= id% get_kappa_2() ALLOCATE ( parts % masses ( parts % n_matter ) ) !ALLOCATE( parts% masses (parts% n_matter) ) ALLOCATE ( parts % all_eos ( parts % n_matter ) ) ALLOCATE ( parts % npart_i ( 0 : parts % n_matter ) ) ALLOCATE ( parts % nbar_i ( parts % n_matter ) ) ALLOCATE ( parts % nuratio_i ( parts % n_matter ) ) ALLOCATE ( parts % mass_ratios ( parts % n_matter ) ) ALLOCATE ( parts % mass_fractions ( parts % n_matter ) ) parts % npart_i ( 0 ) = 0 parts % nbar_i = 0.0D0 parts % nuratio_i = 0.0D0 DO itr = 1 , parts % n_matter , 1 parts % masses ( itr ) = id % return_mass ( itr ) center ( itr ,:) = id % return_center ( itr ) central_density ( itr ) = id % read_mass_density ( center ( itr , 1 ), & center ( itr , 2 ), & center ( itr , 3 ) ) barycenter ( itr ,:) = id % return_barycenter ( itr ) sizes ( itr , :) = id % return_spatial_extent ( itr ) parts % all_eos ( itr )% eos_name = id % return_eos_name ( itr ) CALL id % return_eos_parameters ( itr , & parts % all_eos ( itr )% eos_parameters ) ENDDO ! !-- Read the parameters of the particle distributions ! parts % lorene_bns_id_parfile = 'sphincs_lorene_bns_particles.par' INQUIRE ( FILE = parts % lorene_bns_id_parfile , EXIST = file_exists ) IF ( file_exists ) THEN OPEN ( 10 , FILE = parts % lorene_bns_id_parfile , STATUS = 'OLD' ) ELSE PRINT * PRINT * , \"** ERROR: \" , parts % lorene_bns_id_parfile , & \" file not found!\" PRINT * STOP ENDIF READ ( 10 , NML = bns_particles ) CLOSE ( 10 ) parts % use_thres = use_thres parts % correct_nu = correct_nu parts % compose_eos = compose_eos parts % compose_path = compose_path parts % compose_filename = compose_filename parts % redistribute_nu = redistribute_nu parts % nu_ratio = nu_ratio parts % reflect_particles_x = reflect_particles_x parts % randomize_phi = randomize_phi parts % randomize_theta = randomize_theta parts % randomize_r = randomize_r ! APM parameters ALLOCATE ( parts % apm_iterate ( parts % n_matter ) ) parts % apm_iterate = apm_iterate parts % read_nu = read_nu parts_pos_namefile = TRIM ( parts_pos_path ) // TRIM ( parts_pos ) ! Compute desired particle numbers based on mass ratios max_mass = MAXVAL ( parts % masses ) total_mass = SUM ( parts % masses ) DO itr = 1 , parts % n_matter , 1 parts % mass_ratios ( itr ) = parts % masses ( itr ) / max_mass parts % mass_fractions ( itr ) = parts % masses ( itr ) / total_mass npart_des_i ( itr ) = parts % mass_fractions ( itr ) * npart_des ENDDO !   IF( parts% redistribute_nu )THEN !     thres= 100.0D0*parts% nu_ratio !   ENDIF ! !-- Check that the parameters are acceptable ! IF ( upper_bound <= lower_bound ) THEN PRINT * PRINT * , \"** ERROR in lorene_bns_id_particles.par: \" , & \"upper_bound should be greater than lower_bound!\" PRINT * STOP ENDIF IF ( upper_factor < 1.0D0 ) THEN PRINT * PRINT * , \"** ERROR in lorene_bns_id_particles.par: \" , & \"upper_factor should be greater than or equal to 1!\" PRINT * STOP ENDIF IF ( lower_factor > 1 ) THEN PRINT * PRINT * , \"** ERROR in lorene_bns_id_particles.par: \" , & \"lower_factor should be smaller than or equal to 1!\" PRINT * STOP ENDIF IF ( max_steps < 10 ) THEN PRINT * PRINT * , \"** ERROR in lorene_bns_id_particles.par: \" , & \"max_steps should be an integer greater than or equal to 10!\" PRINT * STOP ENDIF IF ( last_r < 0.95D0 . OR . last_r > 1.0D0 ) THEN PRINT * PRINT * , \"** ERROR in lorene_bns_id_particles.par: \" , & \"last_r should be greater than or equal to 0.95, \" , & \"and lower than or equal to 1!\" PRINT * STOP ENDIF IF ( apm_max_it < 0 . OR . max_inc < 0 . OR . nuratio_thres < 0 & . OR . nuratio_des < 0 . OR . nx_gh < 0 . OR . ny_gh < 0 . OR . nz_gh < 0 ) THEN PRINT * PRINT * , \"** ERROR in lorene_bns_id_particles.par: \" , & \"the numeric parameters for the APM method should be positive!\" PRINT * STOP ENDIF IF ( nuratio_des >= nuratio_thres ) THEN PRINT * PRINT * , \"** ERROR in lorene_bns_id_particles.par: \" , & \"nuratio_des has to be stricly lower than nuratio_thres!\" PRINT * STOP ENDIF ! setup unit system CALL set_units ( 'NSM' ) CALL read_options ! tabulate kernel, get ndes CALL ktable ( ikernel , ndes ) ! TODO: Add check that the number of rows in placer is the same as the !       number of bns objects, and that all bns have a value for placer !  DO itr= 1, id% get_n_matter(), 1 !    IF(.NOT.ALLOCATED( pvol_i(id% get_n_matter(), ) ))THEN !      ALLOCATE( pvol_i( parts% npart2 ), & !                STAT= ios, ERRMSG= err_msg ) !      IF( ios > 0 )THEN !         PRINT *, \"...allocation error for array pvol in SUBROUTINE\" & !                  // \"place_particles_. \", & !                  \"The error message is\", err_msg !         STOP !      ENDIF !    ENDIF !  ENDDO ! !-- Choose particle placer ! choose_particle_placer : SELECT CASE ( dist ) CASE ( 0 ) PRINT * , \" * Reading particle positions from formatted file \" & // TRIM ( parts_pos_namefile ) PRINT * INQUIRE ( FILE = TRIM ( parts_pos_namefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_pos , FILE = TRIM ( parts_pos_namefile ), & FORM = \"FORMATTED\" , ACTION = \"READ\" , IOSTAT = ios , & IOMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( parts_pos_namefile ), & \". The error message is\" , err_msg STOP ENDIF ELSE PRINT * , \"** ERROR! Unable to find file \" // TRIM ( parts_pos_namefile ) STOP ENDIF nlines = 0 DO READ ( unit_pos , * , IOSTAT = ios ) IF ( ios /= 0 ) EXIT nlines = nlines + 1 ENDDO CLOSE ( UNIT = unit_pos ) npart_tmp = nlines - header_lines !PRINT *, \"nlines=\", nlines !PRINT *, \"header_lines=\", header_lines !PRINT *, \"npart_tmp=\", npart_tmp !PRINT * OPEN ( UNIT = unit_pos , FILE = TRIM ( parts_pos_namefile ), & FORM = \"FORMATTED\" , ACTION = \"READ\" ) ! Skip header DO itr = 1 , header_lines , 1 READ ( unit_pos , * ) ENDDO ! Allocate the temporary array to store data ALLOCATE ( tmp_pos ( n_cols , 2 * npart_tmp ) ) tmp_pos = 0.0D0 ! Read the data into the temporary array DO itr = 1 , npart_tmp , 1 READ ( UNIT = unit_pos , FMT = * , IOSTAT = ios , IOMSG = err_msg ) & tmp_pos ( :, itr ) IF ( ios > 0 ) THEN PRINT * , \"...error when reading \" // TRIM ( parts_pos_namefile ), & \" at particle \" , itr , \". The status variable is \" , ios , & \". The error message is\" , err_msg STOP ENDIF ENDDO CLOSE ( UNIT = unit_pos ) ! Allocate the temporary array to store data IF ( read_nu ) THEN ALLOCATE ( tmp_pos2 ( 4 , 2 * npart_tmp ) ) ELSE ALLOCATE ( tmp_pos2 ( 3 , 2 * npart_tmp ) ) ENDIF tmp_pos2 = 0.0D0 ! Separate particle positions on star 1 and star 2, ! and compute the temporary npart1 and npart2 (before mirroring) npart1_tmp = 0 DO itr = 1 , npart_tmp , 1 IF ( tmp_pos ( columns ( 1 ), itr ) < 0.0D0 ) THEN npart1_tmp = npart1_tmp + 1 tmp_pos2 ( 1 , npart1_tmp ) = tmp_pos ( columns ( 1 ), itr ) tmp_pos2 ( 2 , npart1_tmp ) = tmp_pos ( columns ( 2 ), itr ) tmp_pos2 ( 3 , npart1_tmp ) = tmp_pos ( columns ( 3 ), itr ) IF ( read_nu ) tmp_pos2 ( 4 , npart1_tmp ) = tmp_pos ( column_nu , itr ) ENDIF ENDDO npart2_tmp = 0 DO itr = 1 , npart_tmp , 1 IF ( tmp_pos ( columns ( 1 ), itr ) > 0.0D0 ) THEN npart2_tmp = npart2_tmp + 1 tmp_pos2 ( 1 , npart1_tmp + npart2_tmp ) = tmp_pos ( columns ( 1 ), itr ) tmp_pos2 ( 2 , npart1_tmp + npart2_tmp ) = tmp_pos ( columns ( 2 ), itr ) tmp_pos2 ( 3 , npart1_tmp + npart2_tmp ) = tmp_pos ( columns ( 3 ), itr ) IF ( read_nu ) tmp_pos2 ( 4 , npart1_tmp + npart2_tmp ) = tmp_pos ( column_nu , itr ) ENDIF ENDDO IF ( npart1_tmp + npart2_tmp /= npart_tmp ) THEN PRINT * , \"** ERROR! npart1_tmp + npart2_tmp /= npart_tmp\" PRINT * PRINT * , \"   npart1_tmp= \" , npart1_tmp PRINT * , \"   npart2_tmp= \" , npart2_tmp PRINT * , \"   npart1_tmp + npart2_tmp= \" , npart1_tmp + npart2_tmp PRINT * , \"   npart_tmp= \" , npart_tmp PRINT * STOP ENDIF ! Check that the positions are within the stars read from the |lorene| ! binary file. This checks that the positions read from the formatted ! file are compatible with the binary file read ! Star 1 DO itr = 1 , parts % n_matter , 1 ASSOCIATE ( npart_in => npart1_tmp * ( itr - 1 ) + 1 , & npart_fin => npart1_tmp + npart2_tmp * ( itr - 1 ) ) ! PRINT *, MINVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ) < ABS(center(itr,1)) - & !                                  sizes(itr, 1) ! PRINT *, MAXVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ) > ABS(center(itr,1)) + & !                                  sizes(itr, 2) ! PRINT *, ABS( MINVAL( tmp_pos2(2,npart_in:npart_fin) ) ) > ABS(center(itr,2)) + & !                                  sizes(itr, 3) ! PRINT *, ABS( MAXVAL( tmp_pos2(2,npart_in:npart_fin) ) ) > ABS(center(itr,2)) + & !                                  sizes(itr, 4) ! PRINT *, ABS( MINVAL( tmp_pos2(3,npart_in:npart_fin) ) ) > ABS(center(itr,3)) + & ! sizes(itr, 5) ! PRINT *, ABS( MAXVAL( tmp_pos2(3,npart_in:npart_fin) ) ) > ABS(center(itr,3)) + & ! sizes(itr, 6) ! PRINT *, MINVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ) > ABS(center(itr,1)) - & !                                  0.95*sizes(itr, 1) ! PRINT *, MAXVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ) < ABS(center(itr,1)) + & !                                  0.95*sizes(itr, 2) ! PRINT *, ABS( MINVAL( tmp_pos2(2,npart_in:npart_fin) ) ) < ABS(center(itr,2)) - & !             0.95*sizes(itr, 3) ! PRINT *, ABS( MAXVAL( tmp_pos2(2,npart_in:npart_fin) ) ) < ABS(center(itr,2)) + & !             0.95*sizes(itr, 4) ! PRINT *, ABS( MINVAL( tmp_pos2(3,npart_in:npart_fin) ) ) < ABS(center(itr,3)) - & !             0.95*sizes(itr, 5) ! PRINT *, ABS( MAXVAL( tmp_pos2(3,npart_in:npart_fin) ) ) < ABS(center(itr,3)) + & !             0.95*sizes(itr, 6) ! ! PRINT *, MINVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ), ABS(center(itr,1)) - & !                                sizes(itr, 1) ! PRINT *, MAXVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ), ABS(center(itr,1)) + & !                                sizes(itr, 2) ! PRINT *, ABS( MINVAL( tmp_pos2(2,npart_in:npart_fin) ) ), ABS(center(itr,2)) + & !                                sizes(itr, 3) ! PRINT *, ABS( MAXVAL( tmp_pos2(2,npart_in:npart_fin) ) ), ABS(center(itr,2)) + & !                                sizes(itr, 4) ! PRINT *, ABS( MINVAL( tmp_pos2(3,npart_in:npart_fin) ) ), ABS(center(itr,3)) + & ! sizes(itr, 5) ! PRINT *, ABS( MAXVAL( tmp_pos2(3,npart_in:npart_fin) ) ), ABS(center(itr,3)) + & ! sizes(itr, 6) ! PRINT *, MINVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ), ABS(center(itr,1)) - & !                                0.95*sizes(itr, 1) ! PRINT *, MAXVAL( ABS( tmp_pos2(1,npart_in:npart_fin) ) ), ABS(center(itr,1)) + & !                                0.95*sizes(itr, 2) ! PRINT *, ABS( MINVAL( tmp_pos2(2,npart_in:npart_fin) ) ), ABS(center(itr,2)) + & !           0.95*sizes(itr, 3) ! PRINT *, ABS( MAXVAL( tmp_pos2(2,npart_in:npart_fin) ) ), ABS(center(itr,2)) + & !           0.95*sizes(itr, 4) ! PRINT *, ABS( MINVAL( tmp_pos2(3,npart_in:npart_fin) ) ), ABS(center(itr,3)) + & !           0.95*sizes(itr, 5) ! PRINT *, ABS( MAXVAL( tmp_pos2(3,npart_in:npart_fin) ) ), ABS(center(itr,3)) + & !           0.95*sizes(itr, 6) IF ( MINVAL ( ABS ( tmp_pos2 ( 1 , npart_in : npart_fin ) ) ) < ABS ( center ( itr , 1 )) - & sizes ( itr , 1 ) & . OR . & MAXVAL ( ABS ( tmp_pos2 ( 1 , npart_in : npart_fin ) ) ) > ABS ( center ( itr , 1 )) + & sizes ( itr , 2 ) & . OR . & ABS ( MINVAL ( tmp_pos2 ( 2 , npart_in : npart_fin ) ) ) > ABS ( center ( itr , 2 )) + & sizes ( itr , 3 ) & . OR . & ABS ( MAXVAL ( tmp_pos2 ( 2 , npart_in : npart_fin ) ) ) > ABS ( center ( itr , 2 )) + & sizes ( itr , 4 ) & . OR . & ABS ( MINVAL ( tmp_pos2 ( 3 , npart_in : npart_fin ) ) ) > ABS ( center ( itr , 3 )) + & sizes ( itr , 5 ) & . OR . & ABS ( MAXVAL ( tmp_pos2 ( 3 , npart_in : npart_fin ) ) ) > ABS ( center ( itr , 3 )) + & sizes ( itr , 6 ) & . OR . & MINVAL ( ABS ( tmp_pos2 ( 1 , npart_in : npart_fin ) ) ) > ABS ( center ( itr , 1 )) - & 0.95 * sizes ( itr , 1 ) & . OR . & MAXVAL ( ABS ( tmp_pos2 ( 1 , npart_in : npart_fin ) ) ) < ABS ( center ( itr , 1 )) + & 0.95 * sizes ( itr , 2 ) & . OR . & ABS ( MINVAL ( tmp_pos2 ( 2 , npart_in : npart_fin ) ) ) < ABS ( center ( itr , 2 )) + & 0.95 * sizes ( itr , 3 ) & . OR . & ABS ( MAXVAL ( tmp_pos2 ( 2 , npart_in : npart_fin ) ) ) < ABS ( center ( itr , 2 )) + & 0.95 * sizes ( itr , 4 ) & . OR . & ABS ( MINVAL ( tmp_pos2 ( 3 , npart_in : npart_fin ) ) ) < ABS ( center ( itr , 3 )) + & 0.95 * sizes ( itr , 5 ) & . OR . & ABS ( MAXVAL ( tmp_pos2 ( 3 , npart_in : npart_fin ) ) ) < ABS ( center ( itr , 3 )) + & 0.95 * sizes ( itr , 6 ) & ) THEN PRINT * , \"** ERROR! The positions of the particles on object \" , itr , & \", read from file \" & // TRIM ( parts_pos_namefile ), \" are not compatible with the \" , & \"physical system read from file. Stopping...\" PRINT * STOP ENDIF END ASSOCIATE ENDDO ! Star 2 !      IF( MINVAL( ABS( tmp_pos2(1,npart1_tmp+1:npart_tmp) ) ) < ABS(center2) - & !                                           id% get_radius2_x_comp() & !          .OR. & !          MAXVAL( ABS( tmp_pos2(1,npart1_tmp+1:npart_tmp) ) ) > ABS(center2) + & !                                           id% get_radius2_x_opp() & !          .OR. & !          ABS( MINVAL( tmp_pos2(2,npart1_tmp+1:npart_tmp) ) ) > & !                      id% get_radius2_y() & !          .OR. & !          ABS( MAXVAL( tmp_pos2(2,npart1_tmp+1:npart_tmp) ) ) > & !                      id% get_radius2_y() & !          .OR. & !          ABS( MINVAL( tmp_pos2(3,npart1_tmp+1:npart_tmp) ) ) > & !                      id% get_radius2_z() & !          .OR. & !          ABS( MAXVAL( tmp_pos2(3,npart1_tmp+1:npart_tmp) ) ) > & !                      id% get_radius2_z() & !          .OR. & !          MINVAL( ABS( tmp_pos2(1,npart1_tmp+1:npart_tmp) ) ) > ABS(center2) - & !                                           0.95*id% get_radius2_x_comp() & !          .OR. & !          MAXVAL( ABS( tmp_pos2(1,npart1_tmp+1:npart_tmp) ) ) < ABS(center2) + & !                                           0.95*id% get_radius2_x_opp() & !          .OR. & !          ABS( MINVAL( tmp_pos2(2,npart1_tmp+1:npart_tmp) ) ) < & !                      0.95*id% get_radius2_y() & !          .OR. & !          ABS( MAXVAL( tmp_pos2(2,npart1_tmp+1:npart_tmp) ) ) < & !                      0.95*id% get_radius2_y() & !          .OR. & !          ABS( MINVAL( tmp_pos2(3,npart1_tmp+1:npart_tmp) ) ) < & !                      0.95*id% get_radius2_z() & !          .OR. & !          ABS( MAXVAL( tmp_pos2(3,npart1_tmp+1:npart_tmp) ) ) < & !                      0.95*id% get_radius2_z() & ! !      )THEN ! !        PRINT *, \"** ERROR! The positions of the particles on star 2, \", & !                 \"read from file \" & !                 // TRIM(parts_pos_namefile), \" are not compatible with the \", & !                 \"binary system read from the |lorene| binary file. Stopping...\" !        PRINT * !        STOP ! !      ENDIF !DO itr= 1, npart1_tmp, 1 !  IF( tmp_pos2(1,itr) <  ) !ENDDO ! Mirror the particles on star 1 tmp_pos ( columns ( 1 ),:) = tmp_pos2 ( 1 ,:) tmp_pos ( columns ( 2 ),:) = tmp_pos2 ( 2 ,:) tmp_pos ( columns ( 3 ),:) = tmp_pos2 ( 3 ,:) IF ( read_nu ) tmp_pos ( column_nu ,:) = tmp_pos2 ( 4 ,:) parts % npart_i ( 1 ) = 0 DO itr = 1 , npart1_tmp , 1 IF ( tmp_pos ( columns ( 3 ), itr ) > 0 ) THEN parts % npart_i ( 1 ) = parts % npart_i ( 1 ) + 1 tmp_pos2 ( 1 , parts % npart_i ( 1 )) = tmp_pos ( columns ( 1 ), itr ) tmp_pos2 ( 2 , parts % npart_i ( 1 )) = tmp_pos ( columns ( 2 ), itr ) tmp_pos2 ( 3 , parts % npart_i ( 1 )) = tmp_pos ( columns ( 3 ), itr ) IF ( read_nu ) tmp_pos2 ( 4 , parts % npart_i ( 1 )) = tmp_pos ( column_nu , itr ) ENDIF ENDDO DO itr = 1 , parts % npart_i ( 1 ), 1 tmp_pos2 ( 1 , parts % npart_i ( 1 ) + itr ) = tmp_pos2 ( 1 , itr ) tmp_pos2 ( 2 , parts % npart_i ( 1 ) + itr ) = tmp_pos2 ( 2 , itr ) tmp_pos2 ( 3 , parts % npart_i ( 1 ) + itr ) = - tmp_pos2 ( 3 , itr ) IF ( read_nu ) tmp_pos2 ( 4 , parts % npart_i ( 1 ) + itr ) = tmp_pos2 ( 4 , itr ) ENDDO parts % npart_i ( 1 ) = 2 * parts % npart_i ( 1 ) parts % npart_i ( 2 ) = 0 DO itr = npart1_tmp + 1 , npart_tmp , 1 IF ( tmp_pos ( columns ( 3 ), itr ) > 0 ) THEN parts % npart_i ( 2 ) = parts % npart_i ( 2 ) + 1 tmp_pos2 ( 1 , parts % npart_i ( 1 ) + parts % npart_i ( 2 )) = tmp_pos ( columns ( 1 ), itr ) tmp_pos2 ( 2 , parts % npart_i ( 1 ) + parts % npart_i ( 2 )) = tmp_pos ( columns ( 2 ), itr ) tmp_pos2 ( 3 , parts % npart_i ( 1 ) + parts % npart_i ( 2 )) = tmp_pos ( columns ( 3 ), itr ) IF ( read_nu ) tmp_pos2 ( 4 , parts % npart_i ( 1 ) + parts % npart_i ( 2 )) = tmp_pos ( column_nu , itr ) ENDIF ENDDO DO itr = 1 , parts % npart_i ( 2 ), 1 tmp_pos2 ( 1 , parts % npart_i ( 1 ) + parts % npart_i ( 2 ) + itr ) = & tmp_pos2 ( 1 , parts % npart_i ( 1 ) + itr ) tmp_pos2 ( 2 , parts % npart_i ( 1 ) + parts % npart_i ( 2 ) + itr ) = & tmp_pos2 ( 2 , parts % npart_i ( 1 ) + itr ) tmp_pos2 ( 3 , parts % npart_i ( 1 ) + parts % npart_i ( 2 ) + itr ) = & - tmp_pos2 ( 3 , parts % npart_i ( 1 ) + itr ) IF ( read_nu ) tmp_pos2 ( 4 , parts % npart_i ( 1 ) + parts % npart_i ( 2 ) + itr ) = & tmp_pos2 ( 4 , parts % npart_i ( 1 ) + itr ) ENDDO parts % npart_i ( 2 ) = 2 * parts % npart_i ( 2 ) parts % npart = parts % npart_i ( 1 ) + parts % npart_i ( 2 ) !PRINT *, tmp_pos(:,1) ! Allocating the memory for the array pos( 3, npart ) IF (. NOT . ALLOCATED ( parts % pos )) THEN ALLOCATE ( parts % pos ( 3 , parts % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos in SUBROUTINE\" & // \". \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF IF ( read_nu . AND . . NOT . ALLOCATED ( parts % nu )) THEN ALLOCATE ( parts % nu ( parts % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nu in SUBROUTINE\" & // \". \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF IF ( read_nu . AND . . NOT . ALLOCATED ( parts % pmass )) THEN ALLOCATE ( parts % pmass ( parts % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pmass in SUBROUTINE\" & // \". \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF !---------------------------------------------------------! !--  Storing the particle positions into the array pos  --! !--  symmetrically w.r.t. the xy plane                  --! !---------------------------------------------------------! !    ! Particles with z > 0 for star 1 !    parts% pos(:,1:parts% npart1/2)= & !                                  tmp_pos2(:,1:parts% npart1/2) ! !    ! Particles with z < 0 for star 1 !    parts% pos(1:2,parts% npart1/2+1:parts% npart1)= & !                                  tmp_pos2(1:2,1:parts% npart1/2) ! !    parts% pos(3,parts% npart1/2+1:parts% npart1)= & !                                - tmp_pos2(3,1:parts% npart1/2) ! !    ! Particles with z > 0 for star 2 !    parts% pos(:,parts% npart1+1: & !                     parts% npart1+parts% npart2/2)= & !    tmp_pos2(:,parts% npart1/2+1:parts% npart1/2+parts% npart2/2) ! !    ! Particles with z < 0 for star 2 !    parts% pos(1:2,parts% npart1+parts% npart2/2+1: & !                     parts% npart)= & !    tmp_pos2(1:2,parts% npart1/2+1:parts% npart1/2+parts% npart2/2) ! !    parts% pos(3,parts% npart1+parts% npart2/2+1: & !                     parts% npart)= & !    tmp_pos2(3,parts% npart1/2+1:parts% npart1/2+parts% npart2/2) parts % pos = tmp_pos2 ( 1 : 3 , 1 : parts % npart ) IF ( read_nu ) parts % nu = tmp_pos2 ( 4 , 1 : parts % npart ) PRINT * , \" * Particle positions read. Number of particles=\" , & parts % npart PRINT * PRINT * , \" * Number of particles on NS 1=\" , parts % npart_i ( 1 ) PRINT * , \" * Number of particles on NS 2=\" , parts % npart_i ( 2 ) PRINT * ! !-- Computing volume per particle ! IF (. NOT . ALLOCATED ( parts % pvol )) THEN ALLOCATE ( parts % pvol ( parts % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pvol \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for array v_euler_parts_z\" ) ENDIF ! First guess of the particle volume (it will be computed exactly later) pvol_tmp = 0.0D0 DO itr = 1 , parts % npart - 1 , 1 pvol_tmp = pvol_tmp + ABS ( parts % pos ( 3 , itr + 1 ) & - parts % pos ( 3 , itr ) ) ENDDO pvol_tmp = pvol_tmp / ( parts % npart - 1 ) parts % pvol = 2.0D0 * pvol_tmp ** 3.0D0 !   IF( parts% masses(1) > parts% masses(2) )THEN ! !     ! mass_ratio < 1 !     parts% mass_ratio= parts% masses(2)/parts% masses(1) ! !   ELSE ! !     ! mass_ratio < 1 !     parts% mass_ratio= parts% masses(1)/parts% masses(2) ! !   ENDIF parts % pmass = parts % nu * amu !STOP CASE ( 1 ) PRINT * , \" * Placing particles on lattices, \" , & \"one around each matter object.\" PRINT * ! !-- Determine boundaries of the single lattice around the stars (Msun_geo) ! !  xmin=   id% get_center1_x() - & !                            stretch*MAX( id% get_radius1_x_comp(), & !                                         id% get_radius1_x_opp() ) !  xmax=   id% get_center2_x() + & !                            stretch*MAX( id% get_radius2_x_comp(), & !                                         id% get_radius2_x_opp() ) !  ymin= - stretch*id% get_radius1_y() !  ymax=   stretch*id% get_radius2_y() !  zmin= - stretch*id% get_radius1_z() !  zmax=   stretch*id% get_radius2_z() ! Place particles, and time the proces CALL parts % placer_timer % start_timer () DO itr = 1 , parts % n_matter , 1 xmin = center ( itr , 1 ) - stretch * sizes ( itr , 1 ) xmax = center ( itr , 1 ) + stretch * sizes ( itr , 2 ) ymin = center ( itr , 2 ) - stretch * sizes ( itr , 3 ) ymax = center ( itr , 2 ) + stretch * sizes ( itr , 4 ) zmin = center ( itr , 3 ) - stretch * sizes ( itr , 5 ) zmax = center ( itr , 3 ) + stretch * sizes ( itr , 6 ) central_density ( itr ) = id % read_mass_density ( center ( itr , 1 ), & center ( itr , 2 ), & center ( itr , 3 ) ) !   PRINT *, xmin !   PRINT *, xmax !   PRINT *, ymin !   PRINT *, ymax !   PRINT *, zmin !   PRINT *, zmax !   PRINT *, central_density(itr) !   STOP CALL parts % place_particles_lattice ( central_density ( itr ), & xmin , xmax , ymin , & ymax , zmin , zmax , & npart_des_i ( itr ), & parts % npart_i ( itr ), & stretch , thres , & parts_all ( itr )% pos_i , & parts_all ( itr )% pvol_i , & import_density , & check_negative_hydro ) parts_all ( itr )% pos_i = & parts_all ( itr )% pos_i ( :, 1 : parts % npart_i ( itr ) ) parts_all ( itr )% pvol_i = & parts_all ( itr )% pvol_i ( 1 : parts % npart_i ( itr ) ) ENDDO CALL parts % placer_timer % stop_timer () parts % npart = SUM ( parts % npart_i ) IF ( debug ) PRINT * , \"10\" ! !-- Assign TYPE member variables ! IF (. NOT . ALLOCATED ( parts % pos )) THEN ALLOCATE ( parts % pos ( 3 , parts % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF !parts% pos( :, 1:parts% npart1 )= pos1 !parts% pos( :, parts% npart1 + 1:parts% npart )= pos2 DO itr = 1 , parts % n_matter , 1 parts % pos ( :, parts % npart_i ( itr - 1 ) + 1 : & parts % npart_i ( itr - 1 ) + parts % npart_i ( itr ) ) = & parts_all ( itr )% pos_i ENDDO IF (. NOT . ALLOCATED ( parts % pvol )) THEN ALLOCATE ( parts % pvol ( parts % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pvol in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF !parts% pvol( 1:parts% npart1 )= pvol1 !parts% pvol( parts% npart1 + 1:parts% npart )= pvol2 DO itr = 1 , parts % n_matter , 1 parts % pvol ( parts % npart_i ( itr - 1 ) + 1 : & parts % npart_i ( itr - 1 ) + parts % npart_i ( itr ) ) = & parts_all ( itr )% pvol_i ENDDO !CASE(2) !    PRINT *, \" * Placing particles on two lattices, \" & !             // \"one around each star.\" !    PRINT * !parts% nx= nx !parts% ny= ny !parts% nz= nz ! !-- Determine boundaries of the two lattices around the stars (Msun_geo) ! !   xmin1=   id% get_center1_x() - & !                             stretch*MAX( id% get_radius1_x_comp(), & !                                          id% get_radius1_x_opp() ) !   xmax1=   id% get_center1_x() + & !                             stretch*MAX( id% get_radius1_x_comp(), & !                                          id% get_radius1_x_opp() ) !   ymin1= - stretch*id% get_radius1_y() !   ymax1=   stretch*id% get_radius1_y() !   zmin1= - stretch*id% get_radius1_z() !   zmax1=   stretch*id% get_radius1_z() ! !   xmin2=   id% get_center2_x() - & !                             stretch*MAX( id% get_radius2_x_comp(), & !                                          id% get_radius2_x_opp() ) !   xmax2=   id% get_center2_x() + & !                             stretch*MAX( id% get_radius2_x_comp(), & !                                          id% get_radius2_x_opp() ) !   ymin2= - stretch*id% get_radius2_y() !   ymax2=   stretch*id% get_radius2_y() !   zmin2= - stretch*id% get_radius2_z() !   zmax2=   stretch*id% get_radius2_z() ! !   ! Place particles, and time the process !   CALL parts% placer_timer% start_timer() !   CALL parts% place_particles_lattices( xmin1, xmax1, ymin1, & !                                               ymax1, zmin1, zmax1, & !                                               xmin2, xmax2, ymin2, & !                                               ymax2, zmin2, zmax2, & !                                               nx, ny, nz, & !                                               thres, id ) !   CALL parts% placer_timer% stop_timer() CASE ( 2 ) PRINT * , \"** Placing equal-mass particles on spherical surfaces, \" & // \"taking into account the mass profile of the stars.\" PRINT * ! Here the particle mass is computed using the radial mass profile ! of the star, so nu should not be redistributed to achieve a given ! particle mass ratio !    IF( parts% redistribute_nu .EQV. .TRUE. )THEN !        parts% redistribute_nu= .FALSE. !    ENDIF CALL parts % placer_timer % start_timer () DO i_matter = 1 , parts % n_matter , 1 IF ( i_matter <= 9 ) WRITE ( str_i , '(I1)' ), i_matter IF ( i_matter >= 10 . AND . parts % n_matter <= 99 ) WRITE ( str_i , '(I2)' ), i_matter IF ( i_matter >= 100 . AND . parts % n_matter <= 999 ) & WRITE ( str_i , '(I3)' ), i_matter filename_mass_profile = \"spherical_surfaces_mass_profile\" // TRIM ( str_i ) // & \".dat\" filename_shells_radii = \"spherical_surfaces_radii\" // TRIM ( str_i ) // \".dat\" filename_shells_pos = \"spherical_surfaces_pos\" // TRIM ( str_i ) // \".dat\" ! Place particles, and time the process CALL parts % place_particles_spherical_surfaces ( parts % masses ( i_matter ), & MAXVAL ( sizes ( i_matter , 1 : 2 )), & center ( i_matter , 1 ), & central_density ( i_matter ), & npart_des_i ( i_matter ), & parts % npart_i ( i_matter ), & parts_all ( i_matter )% pos_i , & parts_all ( i_matter )% pvol_i , & parts_all ( i_matter )% pmass_i , & last_r , & upper_bound , lower_bound , & upper_factor , lower_factor ,& max_steps , & filename_mass_profile , & filename_shells_radii , & filename_shells_pos , & import_density , & integrate_mass_density , & import_id , & check_negative_hydro ) ! mass_ratio < 1 !    parts% mass_ratio= parts% masses(2)/parts% masses(1) equal_masses : IF ( i_matter == 1 . AND . parts % n_matter == 2 ) THEN IF ( ABS ( parts % mass_ratios ( 1 ) - parts % mass_ratios ( 2 )) & / parts % mass_ratios ( 2 ) <= 0.005 . AND . & !parts% mass_ratios(1) >= 0.995 .AND. & !parts% mass_ratios <= 1.005 .AND. & reflect_particles_x ) THEN IF (. NOT . ALLOCATED ( parts_all ( 2 )% pos_i )) THEN ALLOCATE ( parts_all ( 2 )% pos_i ( 3 , parts % npart_i ( 1 ) ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( parts_all ( 2 )% pvol_i )) THEN ALLOCATE ( parts_all ( 2 )% pvol_i ( parts % npart_i ( 1 ) ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pvol in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( parts_all ( 2 )% pmass_i )) THEN ALLOCATE ( parts_all ( 2 )% pmass_i ( parts % npart_i ( 1 ) ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pmass in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF ENDIF parts_all ( 2 )% pos_i ( 1 ,:) = - parts_all ( 1 )% pos_i ( 1 ,:) parts_all ( 2 )% pos_i ( 2 ,:) = parts_all ( 1 )% pos_i ( 2 ,:) parts_all ( 2 )% pos_i ( 3 ,:) = parts_all ( 1 )% pos_i ( 3 ,:) parts_all ( 2 )% pvol_i = parts_all ( 1 )% pvol_i parts_all ( 2 )% pmass_i = parts_all ( 1 )% pmass_i parts % npart_i ( 2 ) = parts % npart_i ( 1 ) EXIT !   ELSE ! !     IF( parts% mass_ratio >= 0.95 .AND. & !         parts% mass_ratio <= 1.05 )THEN !       npart2_approx= npart_approx/parts% mass_ratio !     ELSE !       npart2_approx= parts% npart1/parts% mass_ratio !     ENDIF ! !     filename_mass_profile= \"spherical_surfaces_mass_profile1.dat\" !     filename_shells_radii= \"spherical_surfaces_radii1.dat\" !     filename_shells_pos  = \"spherical_surfaces_pos1.dat\" ! !     CALL parts% place_particles_spherical_surfaces( parts% masses(1),& !                                           radius1, center1, & !                                           central_density1, & !                                           npart2_approx, & !                                           parts% npart1, & !                                           pos1, pvol1, pmass1, & !                                           last_r, & !                                           upper_bound, lower_bound, & !                                           upper_factor, lower_factor,& !                                           max_steps, & !                                           filename_mass_profile, & !                                           filename_shells_radii, & !                                           filename_shells_pos, & !                                           import_density, & !                                           integrate_mass_density, & !                                           import_id, & !                                           check_negative_hydro ) ENDIF ENDIF equal_masses CALL parts % placer_timer % stop_timer () parts_all ( i_matter )% pos_i = & parts_all ( i_matter )% pos_i ( :, 1 : parts % npart_i ( i_matter ) ) parts_all ( i_matter )% pvol_i = & parts_all ( i_matter )% pvol_i ( 1 : parts % npart_i ( i_matter ) ) !   ELSE ! !     filename_mass_profile= \"spherical_surfaces_mass_profile1.dat\" !     filename_shells_radii= \"spherical_surfaces_radii1.dat\" !     filename_shells_pos  = \"spherical_surfaces_pos1.dat\" ! !     ! Place particles, and time the process !     CALL parts% placer_timer% start_timer() ! !     !DO ! !     CALL parts% place_particles_spherical_surfaces( parts% masses(1), & !                                           radius1, center1, & !                                           central_density1, & !                                           npart_approx, & !                                           parts% npart1, & !                                           pos1, pvol1, pmass1, & !                                           last_r, & !                                           upper_bound, lower_bound, & !                                           upper_factor, lower_factor,& !                                           max_steps, & !                                           filename_mass_profile, & !                                           filename_shells_radii, & !                                           filename_shells_pos, & !                                           import_density, & !                                           integrate_mass_density, & !                                           import_id, & !                                           check_negative_hydro ) ! !     IF( debug ) PRINT *, \"30\" ! !     ! mass_ratio < 1 !     parts% mass_ratio= parts% masses(1)/parts% masses(2) ! !     IF( debug ) PRINT *, \"31\" ! !     equal_masses2: IF( parts% mass_ratio >= 0.995 .AND. & !         parts% mass_ratio <= 1.005 .AND. reflect_particles_x )THEN ! !       IF(.NOT.ALLOCATED( pos2 ))THEN !         ALLOCATE( pos2( 3, parts% npart1 ), & !                   STAT= ios, ERRMSG= err_msg ) !         IF( ios > 0 )THEN !            PRINT *, \"...allocation error for array pos in SUBROUTINE\" & !                     // \"place_particles_. \", & !                     \"The error message is\", err_msg !            STOP !         ENDIF !       ENDIF !       IF(.NOT.ALLOCATED( pvol2 ))THEN !         ALLOCATE( pvol2( parts% npart1 ), & !                   STAT= ios, ERRMSG= err_msg ) !         IF( ios > 0 )THEN !            PRINT *, \"...allocation error for array pvol in SUBROUTINE\" & !                     // \"place_particles_. \", & !                     \"The error message is\", err_msg !            STOP !         ENDIF !       ENDIF !       IF(.NOT.ALLOCATED( pmass2 ))THEN !         ALLOCATE( pmass2( parts% npart1 ), & !                   STAT= ios, ERRMSG= err_msg ) !         IF( ios > 0 )THEN !            PRINT *, \"...allocation error for array pmass in SUBROUTINE\" & !                     // \"place_particles_. \", & !                     \"The error message is\", err_msg !            STOP !         ENDIF !       ENDIF !       pos2(1,:)= - pos1(1,:) !       pos2(2,:)=   pos1(2,:) !       pos2(3,:)=   pos1(3,:) !       pvol2 = pvol1 !       pmass2= pmass1 !       parts% npart2= parts% npart1 ! !     ELSE ! !       IF( parts% mass_ratio >= 0.95 .AND. & !           parts% mass_ratio <= 1.05 )THEN !         npart2_approx= npart_approx/parts% mass_ratio !       ELSE !         npart2_approx= parts% npart1/parts% mass_ratio !       ENDIF ! !       filename_mass_profile= \"spherical_surfaces_mass_profile2.dat\" !       filename_shells_radii= \"spherical_surfaces_radii2.dat\" !       filename_shells_pos  = \"spherical_surfaces_pos2.dat\" ! !       IF( debug ) PRINT *, \"32\" ! !       CALL parts% place_particles_spherical_surfaces( parts% masses(2),& !                                             radius2, center2, & !                                             central_density2, & !                                             npart2_approx, & !                                             parts% npart2, & !                                             pos2, pvol2, pmass2, & !                                             last_r, & !                                             upper_bound, lower_bound, & !                                             upper_factor, lower_factor,& !                                             max_steps, & !                                             filename_mass_profile, & !                                             filename_shells_radii, & !                                             filename_shells_pos, & !                                             import_density, & !                                             integrate_mass_density, & !                                             import_id, & !                                             check_negative_hydro ) ! !     ENDIF equal_masses2 ! !     CALL parts% placer_timer% stop_timer() ! !     parts% npart= parts% npart1 + parts% npart2 ! !   ENDIF first_star_more_massive ENDDO parts % npart = SUM ( parts % npart_i ) ! !-- Assign TYPE member variables ! IF (. NOT . ALLOCATED ( parts % pos )) THEN ALLOCATE ( parts % pos ( 3 , parts % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF !parts% pos( :, 1:parts% npart1 )= pos1 !parts% pos( :, parts% npart1 + 1:parts% npart )= pos2 DO itr = 1 , parts % n_matter , 1 parts % pos ( :, parts % npart_i ( itr - 1 ) + 1 : & parts % npart_i ( itr - 1 ) + parts % npart_i ( itr ) ) = & parts_all ( itr )% pos_i ENDDO IF (. NOT . ALLOCATED ( parts % pvol )) THEN ALLOCATE ( parts % pvol ( parts % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pvol in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF !parts% pvol( 1:parts% npart1 )= pvol1 !parts% pvol( parts% npart1 + 1:parts% npart )= pvol2 DO itr = 1 , parts % n_matter , 1 parts % pvol ( parts % npart_i ( itr - 1 ) + 1 : & parts % npart_i ( itr - 1 ) + parts % npart_i ( itr ) ) = & parts_all ( itr )% pvol_i ENDDO IF (. NOT . ALLOCATED ( parts % pmass )) THEN ALLOCATE ( parts % pmass ( parts % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pmass in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF !parts% pmass( 1:parts% npart1 )= pmass1 !parts% pmass( parts% npart1 + 1:parts% npart )= pmass2 DO itr = 1 , parts % n_matter , 1 parts % pmass ( parts % npart_i ( itr - 1 ) + 1 : & parts % npart_i ( itr - 1 ) + parts % npart_i ( itr ) ) = & parts_all ( itr )% pmass_i ENDDO PRINT * , \" * Particles placed. Number of particles=\" , parts % npart !PRINT *, \" * Number of particles on NS 1=\", parts% npart1 !PRINT *, \" * Number of particles on NS 2=\", parts% npart2 DO itr = 1 , parts % n_matter , 1 PRINT * , \" * Number of particles on object \" , itr , \"=\" , & parts % npart_i ( itr ) ENDDO PRINT * !STOP CASE DEFAULT PRINT * , \"** There is no implemented particle placer \" & // \"corresponding to the number\" , dist PRINT * , \" * Stopping...\" STOP END SELECT choose_particle_placer !----------------------------------------------! !--  At this point,the particles are placed  --! !----------------------------------------------! ! Reshape the arrays pos and pvol by deleting the unnecessary elements parts % pos = parts % pos ( :, 1 : parts % npart ) parts % pvol = parts % pvol ( 1 : parts % npart ) ! Check that there aren't particles with the same coordinates CALL parts % same_particle_timer % start_timer () CALL check_particle_positions ( parts % npart , parts % pos ) CALL parts % same_particle_timer % stop_timer () ! !-- APM iteration ! matter_objects_loop : DO i_matter = 1 , parts % n_matter , 1 ASSOCIATE ( npart_in => parts % npart_i ( i_matter - 1 ) + 1 , & npart_fin => parts % npart_i ( i_matter - 1 ) + & parts % npart_i ( i_matter ) ) IF ( apm_iterate ( i_matter ) ) THEN IF (. NOT . ALLOCATED ( parts % h )) THEN ALLOCATE ( parts % h ( parts % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array h in SUBROUTINE \" , & \"construct_particles_idase. The error message is\" ,& err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( parts % nu )) THEN ALLOCATE ( parts % nu ( parts % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nu in SUBROUTINE \" , & \"construct_particles_idase. The error message is\" ,& err_msg STOP ENDIF ENDIF PRINT * PRINT * , \"** Placing particles on star 1 using the APM...\" PRINT * IF ( i_matter <= 9 ) WRITE ( str_i , '(I1)' ), i_matter IF ( i_matter >= 10 . AND . parts % n_matter <= 99 ) WRITE ( str_i , '(I2)' ), i_matter IF ( i_matter >= 100 . AND . parts % n_matter <= 999 ) & WRITE ( str_i , '(I3)' ), i_matter filename_apm_pos_id = \"apm_pos_id\" // TRIM ( str_i ) // \".dat\" filename_apm_pos = \"apm_pos\" // TRIM ( str_i ) // \".dat\" filename_apm_results = \"apm_results\" // TRIM ( str_i ) // \".dat\" ! Matter object 1 CALL parts % apm_timers ( i_matter )% start_timer () CALL parts % perform_apm ( & import_density , get_nstar_p , & parts % pos (:, npart_in : npart_fin ), & parts % pvol ( npart_in : npart_fin ), & parts % h ( npart_in : npart_fin ), & parts % nu ( npart_in : npart_fin ), & center ( i_matter , 1 ), barycenter ( i_matter , 1 ), & parts % masses ( i_matter ), & sizes ( i_matter , 1 ), & sizes ( i_matter , 2 ), & sizes ( i_matter , 3 ), & sizes ( i_matter , 5 ), & apm_max_it , max_inc , mass_it , parts % correct_nu , & nuratio_thres , nuratio_des , nx_gh , ny_gh , nz_gh , & filename_apm_pos_id , filename_apm_pos , filename_apm_results , & check_negative_hydro ) CALL parts % apm_timers ( i_matter )% stop_timer () PRINT * , \"** Particles placed on star 1 according to the APM.\" PRINT * equal_masses_apm : IF ( i_matter == 1 . AND . parts % n_matter == 2 ) THEN IF ( ABS ( parts % mass_ratios ( 1 ) - parts % mass_ratios ( 2 ) ) & / parts % mass_ratios ( 2 ) <= 0.005 . AND . & !parts% mass_ratios(1) >= 0.995 .AND. & !parts% mass_ratios <= 1.005 .AND. & reflect_particles_x ) THEN parts % pos ( 1 , parts % npart_i ( 1 ) + 1 : parts % npart ) = & - parts % pos ( 1 , 1 : parts % npart_i ( 1 )) parts % pos ( 2 , parts % npart_i ( 1 ) + 1 : parts % npart ) = & parts % pos ( 2 , 1 : parts % npart_i ( 1 )) parts % pos ( 3 , parts % npart_i ( 1 ) + 1 : parts % npart ) = & parts % pos ( 3 , 1 : parts % npart_i ( 1 )) parts % nu ( parts % npart_i ( 1 ) + 1 : parts % npart ) = & parts % nu ( 1 : parts % npart_i ( 1 )) parts % h ( parts % npart_i ( 1 ) + 1 : parts % npart ) = & parts % h ( 1 : parts % npart_i ( 1 )) parts % npart_i ( 2 ) = parts % npart_i ( 1 ) parts % npart = parts % npart_i ( 1 ) + parts % npart_i ( 1 ) PRINT * , \"** Particles placed on star 1 according to the APM\" , & \" reflected about the yz plane onto star 2.\" PRINT * EXIT ENDIF ENDIF equal_masses_apm ENDIF !    IF( apm_iterate2 .AND. .NOT.(parts% mass_ratio >= 0.995 .AND. & !        parts% mass_ratio <= 1.005 .AND. reflect_particles_x) )THEN ! !      PRINT * !      PRINT *, \"** Placing particles on star 2 using the APM...\" !      PRINT * ! !      IF(.NOT.ALLOCATED( parts% h ))THEN !        ALLOCATE( parts% h( parts% npart ), STAT= ios, & !                  ERRMSG= err_msg ) !        IF( ios > 0 )THEN !           PRINT *, \"...allocation error for array h in SUBROUTINE \", & !                    \"construct_particles_idase. The error message is\",& !                    err_msg !           STOP !        ENDIF !      ENDIF ! !      IF(.NOT.ALLOCATED( parts% nu ))THEN !        ALLOCATE( parts% nu( parts% npart ), STAT= ios, & !                  ERRMSG= err_msg ) !        IF( ios > 0 )THEN !           PRINT *, \"...allocation error for array nu in SUBROUTINE \", & !                    \"construct_particles_idase. The error message is\",& !                    err_msg !           STOP !        ENDIF !      ENDIF ! !      filename_apm_pos_id = \"apm_pos_id2.dat\" !      filename_apm_pos    = \"apm_pos2.dat\" !      filename_apm_results= \"apm_results2.dat\" ! !      ! Star 2 !      CALL parts% apm2_timer% start_timer() !      CALL parts% perform_apm( & !                import_density, get_nstar_p, & !                parts% pos(:,parts% npart1+1:parts% npart), & !                parts% pvol(parts% npart1+1:parts% npart), & !                parts% h(parts% npart1+1:parts% npart), & !                parts% nu(parts% npart1+1:parts% npart), & !                center2, com2, parts% masses(2), & !                id% get_radius2_x_comp(), & !                id% get_radius2_x_opp(), & !                id% get_radius2_y(), & !                id% get_radius2_z(), & !                apm_max_it, max_inc, mass_it, parts% correct_nu, & !                nuratio_thres, nuratio_des, nx_gh, ny_gh, nz_gh, & !                filename_apm_pos_id, filename_apm_pos, filename_apm_results, & !                check_negative_hydro ) !      CALL parts% apm2_timer% stop_timer() ! !      PRINT *, \"** Particles placed on star 2 according to the APM.\" !      PRINT * ! !    ENDIF END ASSOCIATE ENDDO matter_objects_loop ! Allocate needed memory CALL allocate_lorene_id_parts_memory ( parts ) ! flag that particles are 'alive' ALLOCATE ( alive ( parts % npart ) ) alive ( 1 : parts % npart ) = 1 IF ( debug ) PRINT * , \"33\" ! !-- Import the needed |lorene| ID on the particles, and time the process ! PRINT * , \"** Importing the LORENE ID on the particles...\" CALL parts % importer_timer % start_timer () CALL id % read_id_particles ( parts % npart , & parts % pos ( 1 , : ), & parts % pos ( 2 , : ), & parts % pos ( 3 , : ), & parts % lapse_parts , & parts % shift_parts_x , & parts % shift_parts_y , & parts % shift_parts_z , & parts % g_xx_parts , & parts % g_xy_parts , & parts % g_xz_parts , & parts % g_yy_parts , & parts % g_yz_parts , & parts % g_zz_parts , & parts % baryon_density_parts , & parts % energy_density_parts , & parts % specific_energy_parts , & parts % pressure_parts , & parts % v_euler_parts_x , & parts % v_euler_parts_y , & parts % v_euler_parts_z ) CALL parts % importer_timer % stop_timer () IF ( debug ) PRINT * , \"34\" ! !-- Check that the imported ID does not contain NaNs ! !CALL Check_Array_for_NAN( parts% npart, parts% lapse_parts, & !                                         \"lapse_parts\" ) !CALL Check_Array_for_NAN( parts% npart, parts% shift_parts_x, & !                                         \"shift_parts_x\" ) !CALL Check_Array_for_NAN( parts% npart, parts% shift_parts_y, & !                                         \"shift_parts_y\" ) !CALL Check_Array_for_NAN( parts% npart, parts% shift_parts_z, & !                                         \"shift_parts_z\" ) !CALL Check_Array_for_NAN( parts% npart, parts% g_xx_parts, & !                                         \"g_xx_parts\" ) !CALL Check_Array_for_NAN( parts% npart, parts% g_xy_parts, & !                                         \"g_xy_parts\" ) !CALL Check_Array_for_NAN( parts% npart, parts% g_xz_parts, & !                                         \"g_xz_parts\" ) !CALL Check_Array_for_NAN( parts% npart, parts% g_yy_parts, & !                                         \"g_yy_parts\" ) !CALL Check_Array_for_NAN( parts% npart, parts% g_yz_parts, & !                                         \"g_yz_parts\" ) !CALL Check_Array_for_NAN( parts% npart, parts% g_zz_parts, & !                                         \"g_zz_parts\" ) !CALL Check_Array_for_NAN( parts% npart, & !        parts% baryon_density_parts, \"baryon_density_parts\" ) !CALL Check_Array_for_NAN( parts% npart, & !        parts% energy_density_parts, \"energy_density_parts\" ) !CALL Check_Array_for_NAN( parts% npart, & !        parts% specific_energy_parts, \"specific_energy_parts\" ) !CALL Check_Array_for_NAN( parts% npart, & !               parts% pressure_parts, \"pressure_parts\" ) !CALL Check_Array_for_NAN( parts% npart, & !              parts% v_euler_parts_x, \"v_euler_parts_x\" ) !CALL Check_Array_for_NAN( parts% npart, & !              parts% v_euler_parts_y, \"v_euler_parts_y\" ) !CALL Check_Array_for_NAN( parts% npart, & !              parts% v_euler_parts_z, \"v_euler_parts_z\" ) IF (. NOT . ALLOCATED ( parts % baryon_density_index )) THEN ALLOCATE ( parts % baryon_density_index ( parts % npart ), & STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array baryon_density_index in \" & // \"SUBROUTINE construct_particles_idase. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF !PRINT *, \"baryon_density_index\" !DO itr= 1, parts% npart1, 1 !  PRINT *, parts% baryon_density_index( itr ), & !           parts% baryon_density_parts( itr ) !ENDDO !    PRINT *, \"baryon_density_parts in ascending order\" !DO itr= 1, parts% npart1, 1 !  PRINT *, parts% baryon_density_parts( & !                                parts% baryon_density_index( itr ) ) !ENDDO !PRINT *, \"baryon_density_parts in descending order\" !DO itr= parts% npart1, 1, -1 !  PRINT *, parts% baryon_density_parts( & !                                parts% baryon_density_index( itr ) ) !ENDDO ! Ok it seems working !    PRINT *, \"** Computing typical length scale for the change in pressure\", & !             \" on the x axis.\" !    PRINT * ! !    ALLOCATE( abs_pos( 3, parts% npart ) ) ! !    DO itr = 1, parts% npart, 1 !      abs_pos( 1, itr )= ABS( parts% pos( 1, itr ) ) !      abs_pos( 2, itr )= ABS( parts% pos( 2, itr ) ) !      abs_pos( 3, itr )= ABS( parts% pos( 3, itr ) ) !    ENDDO ! !    min_y_index= 0 !    min_abs_y= 1D+20 !    DO itr = 1, parts% npart, 1 !      IF( ABS( parts% pos( 2, itr ) ) < min_abs_y )THEN !        min_abs_y= ABS( parts% pos( 2, itr ) ) !        min_y_index= itr !      ENDIF !    ENDDO ! !    min_z_index= 0 !    min_abs_z= 1D+20 !    DO itr = 1, parts% npart, 1 !      IF( ABS( parts% pos( 3, itr ) ) < min_abs_z )THEN !        min_abs_z= ABS( parts% pos( 3, itr ) ) !        min_z_index= itr !      ENDIF !    ENDDO ! !    min_abs_z= MINVAL( abs_pos( 3, : ) ) ! !    !PRINT *, \"1\" ! !    cntr1= 0 !    cntr2= 0 !    DO itr = 1, parts% npart, 1 !      IF( parts% pos( 3, itr ) == min_abs_z & !          .AND. & !          ABS( ( parts% pos( 2, itr ) - & !                 parts% pos( 2, min_y_index ) )/ & !                 parts% pos( 2, min_y_index ) ) < 1.0D-5 & !      )THEN ! !        IF( parts% pos( 1, itr ) < 0 )THEN !          cntr1= cntr1 + 1 !        ELSEIF( parts% pos( 1, itr ) > 0 )THEN !          cntr2= cntr2 + 1 !        ENDIF ! !      ENDIF !    ENDDO !    !PRINT *, \"cntr1= \", cntr1 !    !PRINT *, \"cntr2= \", cntr2 ! !    ALLOCATE( parts% pos_x1( cntr1 ) ) !    ALLOCATE( parts% pos_x2( cntr2 ) ) !    ALLOCATE( parts% pressure_parts_x1( cntr1 ) ) !    ALLOCATE( parts% pressure_parts_x2( cntr2 ) ) !    ALLOCATE( parts% pressure_parts_x_der1( cntr1 - 5 ) ) !    ALLOCATE( parts% pressure_parts_x_der2( cntr2 - 5 ) ) !    ALLOCATE( parts% pressure_length_scale_x1( cntr1 - 5 ) ) !    ALLOCATE( parts% pressure_length_scale_x2( cntr2 - 5 ) ) ! !    !PRINT *, \"2\" ! !    itr_1= 0 !    itr_2= 0 !    DO itr = 1, parts% npart, 1 !      IF( parts% pos( 3, itr ) == min_abs_z & !          .AND. & !          ABS( ( parts% pos( 2, itr ) - & !                 parts% pos( 2, min_y_index ) )/ & !                 parts% pos( 2, min_y_index ) ) < 1.0D-5 & !        )THEN ! !        IF( parts% pos( 1, itr ) < 0 )THEN !          itr_1= itr_1 + 1 !          parts% pos_x1( itr_1 )= parts% pos( 1, itr ) !          parts% pressure_parts_x1( itr_1 )= & !                                              parts% pressure_parts( itr ) !        ELSEIF( parts% pos( 1, itr ) > 0 )THEN !          itr_2= itr_2 + 1 !          parts% pos_x2( itr_2 )= parts% pos( 1, itr ) !          parts% pressure_parts_x2( itr_2 )= & !                                              parts% pressure_parts( itr ) !        ENDIF ! !      ENDIF !    ENDDO ! !    !PRINT *, \"3\" ! !    DO itr= 3, cntr1 - 3, 1 !      parts% pressure_parts_x_der1( itr - 2 )=& !                     ( + parts% pressure_parts_x1( itr - 2 )/12.0D0 & !                       - 2.0*parts% pressure_parts_x1( itr - 1 )/3.0D0 & !                       + 2.0*parts% pressure_parts_x1( itr + 1 )/3.0D0 & !                       - parts% pressure_parts_x1( itr + 2 )/12.0D0 )& !                       /( Msun_geo*km2m*ABS( parts% pos_x1( itr ) - & !                                             parts% pos_x1( itr - 1 ) ) ) ! !      parts% pressure_length_scale_x1( itr - 2 )= & !                          ABS( parts% pressure_parts_x1( itr - 2 )/ & !                               parts% pressure_parts_x_der1( itr - 2 ) ) ! !      !PRINT *, \"p1=\", parts% pressure_parts_x1( itr - 2 ) !      !PRINT *, \"p_r1=\", parts% pressure_parts_x_der1( itr - 2 ) !      !PRINT *, \"p/p_r1=\", parts% pressure_length_scale_x1( itr - 2 ) !      !PRINT * ! !    ENDDO !    DO itr= 3, cntr2 - 3, 1 !      parts% pressure_parts_x_der2( itr - 2 )=& !                     ( + parts% pressure_parts_x2( itr - 2 )/12.0D0 & !                       - 2.0*parts% pressure_parts_x2( itr - 1 )/3.0D0 & !                       + 2.0*parts% pressure_parts_x2( itr + 1 )/3.0D0 & !                       - parts% pressure_parts_x2( itr + 2 )/12.0D0 )& !                       /( Msun_geo*km2m*ABS( parts% pos_x2( itr ) - & !                                             parts% pos_x2( itr - 1 ) ) ) ! !      parts% pressure_length_scale_x2( itr - 2 )= & !                          ABS( parts% pressure_parts_x2( itr - 2 )/ & !                               parts% pressure_parts_x_der2( itr - 2 ) ) ! !      !PRINT *, \"p2=\", parts% pressure_parts_x2( itr - 2 ) !      !PRINT *, \"p_r2=\", parts% pressure_parts_x_der2( itr - 2 ) !      !PRINT *, \"p/p_r2=\", parts% pressure_length_scale_x2( itr - 2 ) !      !PRINT * ! !    ENDDO ! !    PRINT *, \" * Maximum typical length scale for change in pressure\", & !             \" along the x axis for NS 1= \", & !             MAXVAL( parts% pressure_length_scale_x1, DIM= 1 )/km2m, \" km\" !    PRINT *, \" * Minimum typical length scale for change in pressure\", & !             \" along the x axis for NS 1= \", & !             MINVAL( parts% pressure_length_scale_x1, DIM= 1 )/km2m, \" km\" !    PRINT * !    PRINT *, \" * Maximum typical length scale for change in pressure\", & !             \" along the x axis for NS 2= \", & !             MAXVAL( parts% pressure_length_scale_x2, DIM= 1 )/km2m, \" km\" !    PRINT *, \" * Minimum typical length scale for change in pressure\", & !             \" along the x axis for NS 2= \", & !             MINVAL( parts% pressure_length_scale_x2, DIM= 1 )/km2m, \" km\" !    PRINT * ! Increase the counter that identifies the particle distribution counter = counter + 1 !PRINT *, \"End of particle constructor\" !  IF( parts% redistribute_nu )THEN ! !    ! Index particles on star 1 in increasing order of nu ! !    CALL indexx( parts% npart1, & !                 parts% baryon_density_parts( 1 : parts% npart1 ), & !                 parts% baryon_density_index( 1 : parts% npart1 ) ) ! !    ! Index particles on star 2 in increasing order of nu ! !    CALL indexx( parts% npart2, & !                 parts% baryon_density_parts( parts% npart1 + 1 : & !                                                  parts% npart ), & !                 parts% baryon_density_index( parts% npart1 + 1 : & !                                                  parts% npart ) ) ! !    ! Shift indices on star 2 by npart1 since all the arrays store !    ! the quantities on star 1 first, and then on star 2 ! !    parts% baryon_density_index( parts% npart1 + 1 : & !                                     parts% npart )= & !                   parts% npart1 + & !                   parts% baryon_density_index( parts% npart1 + 1 : & !                                                    parts% npart ) ! !  ENDIF ! TODO: fix this by removing the abs_pos array !   IF( debug )THEN ! !     namefile= \"dbg-hydro.dat\" ! !     INQUIRE( FILE= TRIM(namefile), EXIST= exist ) ! !     IF( exist )THEN !         OPEN( UNIT= 2, FILE= TRIM(namefile), STATUS= \"REPLACE\", & !               FORM= \"FORMATTED\", & !               POSITION= \"REWIND\", ACTION= \"WRITE\", IOSTAT= ios, & !               IOMSG= err_msg ) !     ELSE !         OPEN( UNIT= 2, FILE= TRIM(namefile), STATUS= \"NEW\", & !               FORM= \"FORMATTED\", & !               ACTION= \"WRITE\", IOSTAT= ios, IOMSG= err_msg ) !     ENDIF !     IF( ios > 0 )THEN !       PRINT *, \"...error when opening \" // TRIM(namefile), & !                \". The error message is\", err_msg !       STOP !     ENDIF !     !CALL test_status( ios, err_msg, \"...error when opening \" & !     !                  // TRIM(namefile) ) ! !     WRITE( UNIT = 2, IOSTAT = ios, IOMSG = err_msg, FMT = * ) & !     \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id ! !     WRITE( UNIT = 2, IOSTAT = ios, IOMSG = err_msg, FMT = * ) & !     \"# Values of the fields (including coordinates) exported by |lorene| \"& !     // \"on each grid point\" !     IF( ios > 0 )THEN !       PRINT *, \"...error when writing line 1 in \" // TRIM(namefile), & !                \". The error message is\", err_msg !       STOP !     ENDIF !     !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !     !        // TRIM(namefile) ) ! !     WRITE( UNIT = 2, IOSTAT = ios, IOMSG = err_msg, FMT = * ) & !     \"# column:      1        2       3       4       5\", & !     \"       6       7       8\", & !     \"       9       10      11\", & !     \"       12      13      14\", & !     \"       15      16      17      18\" ! !     IF( ios > 0 )THEN !       PRINT *, \"...error when writing line 2 in \" // TRIM(namefile), & !                \". The error message is\", err_msg !       STOP !     ENDIF !     !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !     !            // TRIM(namefile) ) ! !     WRITE( UNIT = 2, IOSTAT = ios, IOMSG = err_msg, FMT = * ) & !     \"#      grid point      x [km]       y [km]       z [km]       lapse\", & !     \"       shift_x [c]    shift_y [c]    shift_z [c]\", & !     \"       baryon density in the local rest frame [kg m&#94;{-3}$]\", & !     \"       energy density [c&#94;2]\", & !     \"       specific energy [c&#94;2]\", & !     \"       pressure [Pa]\", & !     \"       fluid 3-velocity wrt the Eulerian observer (3 columns) [c]\", & !     \"       fluid coordinate 3-velocity vel_u (3 columns) [c]\", & !     \"       baryon number per particle nu\", & !     \"       baryon density in the local rest frame nlrf [baryon/Msun_geo&#94;3]\", & !     \"       electron fraction\", & !     \"       generalized Lorentz factor Theta\" !     IF( ios > 0 )THEN !       PRINT *, \"...error when writing line 3 in \" // TRIM(namefile), & !                \". The error message is\", err_msg !       STOP !     ENDIF !     !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !     !          // TRIM(namefile) ) ! !     DO itr = 1, parts% npart, 1 !       abs_pos( 1, itr )= ABS( parts% pos( 1, itr ) ) !       abs_pos( 2, itr )= ABS( parts% pos( 2, itr ) ) !       abs_pos( 3, itr )= ABS( parts% pos( 3, itr ) ) !     ENDDO ! !     min_y_index= 0 !     min_abs_y= 1D+20 !     DO itr = 1, parts% npart, 1 !       IF( ABS( parts% pos( 2, itr ) ) < min_abs_y )THEN !         min_abs_y= ABS( parts% pos( 2, itr ) ) !         min_y_index= itr !       ENDIF !     ENDDO ! !     min_abs_z= MINVAL( abs_pos( 3, : ) ) ! !     write_data_loop: DO itr = 1, parts% npart, 1 ! !       IF( parts% export_form_xy .AND. & !           parts% pos( 3, itr ) /= min_abs_z )THEN !         CYCLE !       ENDIF !       IF( parts% export_form_x .AND. & !           ( parts% pos( 3, itr ) /= min_abs_z & !             .OR. & !             parts% pos( 2, itr ) /= parts% pos( 2, min_y_index ) ) & !       )THEN !         CYCLE !       ENDIF !       WRITE( UNIT = 2, IOSTAT = ios, IOMSG = err_msg, FMT = * ) & !         itr, & !         parts% pos( 1, itr ), & !         parts% pos( 2, itr ), & !         parts% pos( 3, itr ), & !         parts% lapse_parts( itr ), & !         parts% shift_parts_x( itr ), & !         parts% shift_parts_y( itr ), & !         parts% shift_parts_z( itr ), & !         parts% baryon_density_parts( itr ), & !         parts% energy_density_parts( itr ), & !         parts% specific_energy_parts( itr ), & !         parts% pressure_parts( itr ), & !         parts% v_euler_parts_x( itr ), & !         parts% v_euler_parts_y( itr ), & !         parts% v_euler_parts_z( itr ) ! !     IF( ios > 0 )THEN !       PRINT *, \"...error when writing the arrays in \" // TRIM(namefile), & !                \". The error message is\", err_msg !       STOP !     ENDIF !     !CALL test_status( ios, err_msg, \"...error when writing \" & !     !         // \"the arrays in \" // TRIM(finalnamefile) ) !     ENDDO write_data_loop ! !     CLOSE( UNIT= 2 ) ! !   ENDIF CONTAINS FUNCTION import_density ( x , y , z ) RESULT ( density ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z DOUBLE PRECISION :: density density = id % read_mass_density ( x , y , z ) END FUNCTION import_density SUBROUTINE import_id ( x , y , z , & g_xx , & baryon_density , & gamma_euler ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z DOUBLE PRECISION , INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , INTENT ( IN OUT ) :: gamma_euler CALL id % read_id_mass_b ( x , y , z , & g_xx , & baryon_density , & gamma_euler ) END SUBROUTINE import_id SUBROUTINE integrate_mass_density ( center , radius , & central_density , & dr , dth , dphi , & mass , mass_profile , & mass_profile_idx ) IMPLICIT NONE !& Array to store the indices for array mass_profile, sorted so that !  mass_profile[mass_profile_idx] is in increasing order INTEGER , DIMENSION (:), ALLOCATABLE , INTENT ( IN OUT ) :: mass_profile_idx !> Center of the star DOUBLE PRECISION , INTENT ( IN ) :: center !> Central density of the star DOUBLE PRECISION , INTENT ( IN ) :: central_density !> Radius of the star DOUBLE PRECISION , INTENT ( IN ) :: radius !> Integration steps DOUBLE PRECISION , INTENT ( IN ) :: dr , dth , dphi !> Integrated mass of the star DOUBLE PRECISION , INTENT ( IN OUT ) :: mass !> Array storing the radial mass profile of the star DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( IN OUT ) :: & mass_profile CALL id % integrate_baryon_mass_density ( center , radius , & central_density , & dr , dth , dphi , & mass , mass_profile , & mass_profile_idx ) END SUBROUTINE integrate_mass_density FUNCTION check_negative_hydro ( x , y , z ) RESULT ( answer ) IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z INTEGER :: answer answer = id % test_position ( x , y , z ) END FUNCTION check_negative_hydro SUBROUTINE get_nstar_p ( npart_real , x , y , z , nstar_p ) IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart_real DOUBLE PRECISION , INTENT ( IN ) :: x ( npart_real ) DOUBLE PRECISION , INTENT ( IN ) :: y ( npart_real ) DOUBLE PRECISION , INTENT ( IN ) :: z ( npart_real ) DOUBLE PRECISION , INTENT ( OUT ) :: nstar_p ( npart_real ) DOUBLE PRECISION , DIMENSION ( npart_real ) :: lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & baryon_density , & energy_density , & specific_energy , & pressure , & v_euler_x , v_euler_y , v_euler_z CALL id % read_id_particles ( npart_real , x , y , z , & lapse , shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & baryon_density , & energy_density , & specific_energy , & pressure , & v_euler_x , v_euler_y , v_euler_z ) CALL compute_nstar_p ( npart_real , lapse , shift_x , shift_y , & shift_z , v_euler_x , v_euler_y , v_euler_z , & g_xx , g_xy , g_xz , g_yy , g_yz , g_zz , & baryon_density , nstar_p ) END SUBROUTINE get_nstar_p SUBROUTINE compute_nstar_p ( npart_real , lapse , shift_x , shift_y , & shift_z , v_euler_x , v_euler_y , v_euler_z , & g_xx , g_xy , g_xz , g_yy , g_yz , g_zz , & baryon_density , nstar_p ) !************************************************************** ! !# Compute nstar_p, the proper baryon mass density, given the !  |lorene| ID ! !  FT 31.08.2021 ! !************************************************************** USE constants , ONLY : Msun_geo , km2m , amu , g2kg USE matrix , ONLY : determinant_4x4_matrix IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart_real DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: lapse DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: shift_x DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: shift_y DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: shift_z DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: v_euler_x DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: v_euler_y DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: v_euler_z DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: g_xx DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: g_xy DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: g_xz DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: g_yy DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: g_yz DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: g_zz DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( IN ) :: baryon_density DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( OUT ) :: nstar_p INTEGER :: a , mus , nus DOUBLE PRECISION :: det , sq_g , Theta_a DOUBLE PRECISION , DIMENSION ( 0 : 3 , npart_real ) :: vel DOUBLE PRECISION :: g4 ( 0 : 3 , 0 : 3 ) !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( npart_real, lapse, shift_x, shift_y, shift_z, & !$OMP                     v_euler_x, v_euler_y, v_euler_z, & !$OMP                     g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, & !$OMP                     baryon_density, vel, nstar_p ) & !$OMP             PRIVATE( a, det, sq_g, Theta_a, g4 ) DO a = 1 , npart_real , 1 ! Coordinate velocity of the fluid [c] vel ( 0 , a ) = 1.0D0 vel ( 1 , a ) = lapse ( a ) * v_euler_x ( a ) - shift_x ( a ) vel ( 2 , a ) = lapse ( a ) * v_euler_y ( a ) - shift_y ( a ) vel ( 3 , a ) = lapse ( a ) * v_euler_z ( a ) - shift_z ( a ) ! !-- Metric as matrix for easy manipulation ! g4 ( 0 , 0 ) = - lapse ( a ) ** 2 + g_xx ( a ) * shift_x ( a ) * shift_x ( a )& + 2 * g_xy ( a ) * shift_x ( a ) * shift_y ( a ) & + 2 * g_xz ( a ) * shift_x ( a ) * shift_z ( a ) & + g_yy ( a ) * shift_y ( a ) * shift_y ( a ) & + 2 * g_yz ( a ) * shift_y ( a ) * shift_z ( a ) & + g_zz ( a ) * shift_z ( a ) * shift_z ( a ) g4 ( 0 , 1 ) = g_xx ( a ) * shift_x ( a ) + g_xy ( a ) * shift_y ( a ) + g_xz ( a ) * shift_z ( a ) g4 ( 0 , 2 ) = g_xy ( a ) * shift_x ( a ) + g_yy ( a ) * shift_y ( a ) + g_yz ( a ) * shift_z ( a ) g4 ( 0 , 3 ) = g_xz ( a ) * shift_x ( a ) + g_yz ( a ) * shift_y ( a ) + g_zz ( a ) * shift_z ( a ) g4 ( 1 , 0 ) = g_xx ( a ) * shift_x ( a ) + g_xy ( a ) * shift_y ( a ) + g_xz ( a ) * shift_z ( a ) g4 ( 1 , 1 ) = g_xx ( a ) g4 ( 1 , 2 ) = g_xy ( a ) g4 ( 1 , 3 ) = g_xz ( a ) g4 ( 2 , 0 ) = g_xy ( a ) * shift_x ( a ) + g_yy ( a ) * shift_y ( a ) + g_yz ( a ) * shift_z ( a ) g4 ( 2 , 1 ) = g_xy ( a ) g4 ( 2 , 2 ) = g_yy ( a ) g4 ( 2 , 3 ) = g_yz ( a ) g4 ( 3 , 0 ) = g_xz ( a ) * shift_x ( a ) + g_yz ( a ) * shift_y ( a ) + g_zz ( a ) * shift_z ( a ) g4 ( 3 , 1 ) = g_xz ( a ) g4 ( 3 , 2 ) = g_yz ( a ) g4 ( 3 , 3 ) = g_zz ( a ) ! sqrt(-det(g4)) CALL determinant_4x4_matrix ( g4 , det ) IF ( ABS ( det ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spacetime metric is \" & // \"effectively 0 at particle \" , a STOP ELSEIF ( det > 0 ) THEN PRINT * , \"The determinant of the spacetime metric is \" & // \"positive at particle \" , a STOP ENDIF sq_g = SQRT ( - det ) ! !-- Generalized Lorentz factor ! Theta_a = 0.D0 DO nus = 0 , 3 DO mus = 0 , 3 Theta_a = Theta_a & + g4 ( mus , nus ) * vel ( mus , a ) * vel ( nus , a ) ENDDO ENDDO Theta_a = 1.0D0 / SQRT ( - Theta_a ) !Theta(a)= Theta_a nstar_p ( a ) = sq_g * Theta_a * baryon_density ( a ) * (( Msun_geo * km2m ) ** 3 ) & / ( amu * g2kg ) IF ( ISNAN ( nstar_p ( a ) ) ) THEN PRINT * , \"** ERROR! nstar_p(\" , a , \") is a NaN!\" , & \" Stopping..\" PRINT * STOP ENDIF IF ( nstar_p ( a ) == 0 ) THEN PRINT * , \"** ERROR! nstar_p(\" , a , \")= 0 on a real particle!\" !PRINT *, \" * Particle position: x=\", all_pos(1,a), & !         \", y=\", all_pos(2,a), \", z=\", all_pos(3,a) PRINT * , \"   sq_g=\" , sq_g PRINT * , \"   Theta_a=\" , Theta_a PRINT * , \"   baryon_density(\" , a , \")=\" , baryon_density ( a ) PRINT * , \" * Stopping..\" PRINT * STOP ENDIF ENDDO !$OMP END PARALLEL DO END SUBROUTINE compute_nstar_p END PROCEDURE construct_particles MODULE PROCEDURE destruct_particles !********************************************* ! !# Destructor of a particles object ! !  FT ! !********************************************* IMPLICIT NONE CALL THIS % deallocate_lorene_id_parts_memory () END PROCEDURE destruct_particles END SUBMODULE particles_constructor","tags":"","loc":"sourcefile/submodule_particles_constructor.f90.html"},{"title":"submodule_particles_sph_variables.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_sph_variables.f90~~EfferentGraph sourcefile~submodule_particles_sph_variables.f90 submodule_particles_sph_variables.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_sph_variables.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_sph_variables Source Code submodule_particles_sph_variables.f90 Source Code ! File:         submodule_particles_sph_variables.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_sph_variables !**************************************************** ! !# THIS SUBMODULE contains the implementation of !  the methods of TYPE particles !  that compute, print and read the SPH variables. ! !  FT 16.10.2020 ! !  Renamed from particles_methods to !  particles_sph_variables upon improving modularity ! !  FT 12.07.2021 ! !**************************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE compute_and_export_SPH_variables !************************************************ ! !# Compute the SPH quantities from the LORENE !  ID, and export it to a binary file with !  write_SPHINCS_dump, and to a formatted file ! !  FT 18.09.2020 ! !************************************************ USE constants , ONLY : km2cm , km2m , m2cm , g2kg , amu , MSun_geo , & third , kg2g , Msun , k_lorene2hydrobase USE units , ONLY : set_units USE matrix , ONLY : determinant_4x4_matrix USE sph_variables , ONLY : npart , & ! particle number n1 , & ! particle number for star 1 n2 , & ! particle number for star 2 pos_u , & ! particle positions vel_u , & ! particle velocities in ! coordinate frame nlrf , & ! baryon number density in ! local rest frame !ehat,  &  ! canonical energy per baryon nu , & ! canonical baryon number per ! particle Theta , & ! Generalized Lorentz factor h , & ! Smoothing length Pr , & ! Pressure u , & ! Internal energy in local rest ! frame (no kinetic energy) temp , & ! Temperature av , & ! Dissipation ye , & ! Electron fraction divv , & ! Divergence of velocity vel_u allocate_SPH_memory , & deallocate_SPH_memory USE metric_on_particles , ONLY : allocate_metric_on_particles , & deallocate_metric_on_particles , & sq_det_g4 USE options , ONLY : basename USE input_output , ONLY : dcount , write_SPHINCS_dump , read_options USE NR , ONLY : indexx USE RCB_tree_3D , ONLY : allocate_RCB_tree_memory_3D ,& deallocate_RCB_tree_memory_3D , iorig USE APM , ONLY : density_loop USE kernel_table , ONLY : ktable USE options , ONLY : ndes USE set_h , ONLY : exact_nei_tree_update USE gradient , ONLY : allocate_gradient , deallocate_gradient USE sphincs_sph , ONLY : density , ncand !, flag_dead_ll_cells USE alive_flag , ONLY : alive USE APM , ONLY : assign_h USE pwp_EOS , ONLY : select_EOS_parameters , gen_pwp_eos_all , & get_u_pwp , shorten_eos_name USE constants , ONLY : m0c2 , kg2g , m2cm USE units , ONLY : m0c2_cu IMPLICIT NONE ! The flag call_flag is set different than 0 if the SUBROUTINE ! compute_and_export_SPH_variables is called INTEGER , SAVE :: call_flag = 0 INTEGER , PARAMETER :: max_it_h = 1 ! Spacetime indices \\mu and \\nu INTEGER :: nus , mus , cnt1 , a , i_matter , itr2 !, cnt2 DOUBLE PRECISION :: g4 ( 0 : 3 , 0 : 3 ) DOUBLE PRECISION :: det , sq_g , Theta_a !, &!nu_max1, nu_max2, & !nu_tmp, nu_thres1, nu_thres2 LOGICAL :: few_ncand , good_h LOGICAL , PARAMETER :: debug = . FALSE . CHARACTER ( LEN = : ), ALLOCATABLE :: compose_namefile CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile PRINT * , \"** Executing the compute_and_export_SPH_variables \" & // \"subroutine...\" PRINT * ! !-- Set up the MODULE variables in MODULE sph_variables !-- (used by write_SPHINCS_dump) ! npart = THIS % npart n1 = THIS % npart_i ( 1 ) IF ( THIS % n_matter == 2 ) n2 = THIS % npart_i ( 2 ) CALL set_units ( 'NSM' ) CALL read_options CALL allocate_SPH_memory CALL allocate_metric_on_particles ( THIS % npart ) IF ( debug ) PRINT * , \"1\" IF (. NOT . ALLOCATED ( THIS % nu )) THEN ALLOCATE ( THIS % nu ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nu \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array nu\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % nlrf )) THEN ALLOCATE ( THIS % nlrf ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nlrf \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array nlrf\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % Theta )) THEN ALLOCATE ( THIS % Theta ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array Theta \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array Theta\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v )) THEN ALLOCATE ( THIS % v ( 0 : 3 , THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array v\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % h )) THEN ALLOCATE ( THIS % h ( THIS % npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array h \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array h\" ) ENDIF IF ( debug ) PRINT * , \"2\" ! !-- Compute SPH quantities ! CALL THIS % sph_computer_timer % start_timer () !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( THIS, pos_u, vel_u, sq_det_g4, Theta, nlrf, & !$OMP                     Pr, u, temp, av, divv ) & !$OMP             PRIVATE( itr, g4, det, sq_g, Theta_a, & !$OMP                      nus, mus ) compute_SPH_variables_on_particles : DO itr = 1 , THIS % npart , 1 ! Particle positions [Msun_geo] pos_u ( 1 , itr ) = THIS % pos ( 1 , itr ) pos_u ( 2 , itr ) = THIS % pos ( 2 , itr ) pos_u ( 3 , itr ) = THIS % pos ( 3 , itr ) ! Coordinate velocity of the fluid [c] THIS % v ( 0 , itr ) = 1.0D0 THIS % v ( 1 , itr ) = THIS % lapse_parts ( itr ) * THIS % v_euler_parts_x ( itr ) & - THIS % shift_parts_x ( itr ) THIS % v ( 2 , itr ) = THIS % lapse_parts ( itr ) * THIS % v_euler_parts_y ( itr ) & - THIS % shift_parts_y ( itr ) THIS % v ( 3 , itr ) = THIS % lapse_parts ( itr ) * THIS % v_euler_parts_z ( itr ) & - THIS % shift_parts_z ( itr ) vel_u ( 1 , itr ) = THIS % v ( 1 , itr ) vel_u ( 2 , itr ) = THIS % v ( 2 , itr ) vel_u ( 3 , itr ) = THIS % v ( 3 , itr ) ! !-- Metric as matrix for easy manipulation ! g4 ( 0 , 0 ) = - THIS % lapse_parts ( itr ) ** 2 & + THIS % g_xx_parts ( itr ) * THIS % shift_parts_x ( itr ) & * THIS % shift_parts_x ( itr )& + 2 * THIS % g_xy_parts ( itr ) * THIS % shift_parts_x ( itr ) & * THIS % shift_parts_y ( itr )& + 2 * THIS % g_xz_parts ( itr ) * THIS % shift_parts_x ( itr ) & * THIS % shift_parts_z ( itr )& + THIS % g_yy_parts ( itr ) * THIS % shift_parts_y ( itr ) & * THIS % shift_parts_y ( itr )& + 2 * THIS % g_yz_parts ( itr ) * THIS % shift_parts_y ( itr ) & * THIS % shift_parts_z ( itr )& + THIS % g_zz_parts ( itr ) * THIS % shift_parts_z ( itr ) & * THIS % shift_parts_z ( itr ) g4 ( 0 , 1 ) = THIS % g_xx_parts ( itr ) * THIS % shift_parts_x ( itr ) & + THIS % g_xy_parts ( itr ) * THIS % shift_parts_y ( itr ) & + THIS % g_xz_parts ( itr ) * THIS % shift_parts_z ( itr ) g4 ( 0 , 2 ) = THIS % g_xy_parts ( itr ) * THIS % shift_parts_x ( itr ) & + THIS % g_yy_parts ( itr ) * THIS % shift_parts_y ( itr ) & + THIS % g_yz_parts ( itr ) * THIS % shift_parts_z ( itr ) g4 ( 0 , 3 ) = THIS % g_xz_parts ( itr ) * THIS % shift_parts_x ( itr ) & + THIS % g_yz_parts ( itr ) * THIS % shift_parts_y ( itr ) & + THIS % g_zz_parts ( itr ) * THIS % shift_parts_z ( itr ) g4 ( 1 , 0 ) = THIS % g_xx_parts ( itr ) * THIS % shift_parts_x ( itr ) & + THIS % g_xy_parts ( itr ) * THIS % shift_parts_y ( itr ) & + THIS % g_xz_parts ( itr ) * THIS % shift_parts_z ( itr ) g4 ( 1 , 1 ) = THIS % g_xx_parts ( itr ) g4 ( 1 , 2 ) = THIS % g_xy_parts ( itr ) g4 ( 1 , 3 ) = THIS % g_xz_parts ( itr ) g4 ( 2 , 0 ) = THIS % g_xy_parts ( itr ) * THIS % shift_parts_x ( itr ) & + THIS % g_yy_parts ( itr ) * THIS % shift_parts_y ( itr ) & + THIS % g_yz_parts ( itr ) * THIS % shift_parts_z ( itr ) g4 ( 2 , 1 ) = THIS % g_xy_parts ( itr ) g4 ( 2 , 2 ) = THIS % g_yy_parts ( itr ) g4 ( 2 , 3 ) = THIS % g_yz_parts ( itr ) g4 ( 3 , 0 ) = THIS % g_xz_parts ( itr ) * THIS % shift_parts_x ( itr ) & + THIS % g_yz_parts ( itr ) * THIS % shift_parts_y ( itr ) & + THIS % g_zz_parts ( itr ) * THIS % shift_parts_z ( itr ) g4 ( 3 , 1 ) = THIS % g_xz_parts ( itr ) g4 ( 3 , 2 ) = THIS % g_yz_parts ( itr ) g4 ( 3 , 3 ) = THIS % g_zz_parts ( itr ) ! sqrt(-det(g4)) CALL determinant_4x4_matrix ( g4 , det ) IF ( ABS ( det ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spacetime metric is \" & // \"effectively 0 at particle \" , itr STOP ELSEIF ( det > 0 ) THEN PRINT * , \"The determinant of the spacetime metric is \" & // \"positive at particle \" , itr STOP ENDIF sq_g = SQRT ( - det ) sq_det_g4 ( itr ) = sq_g ! !-- Generalized Lorentz factor ! Theta_a = 0.D0 DO nus = 0 , 3 DO mus = 0 , 3 Theta_a = Theta_a & + g4 ( mus , nus ) * THIS % v ( mus , itr ) * THIS % v ( nus , itr ) ENDDO ENDDO Theta_a = 1.0D0 / SQRT ( - Theta_a ) Theta ( itr ) = Theta_a THIS % Theta ( itr ) = Theta_a ! This is a first guess for the smoothing length ! The real smoothing length is such that the kernel sees ! only 300 neighbors, and it is computed in exact_nei_tree_update, ! MODULE set_h. ! N.B. This first guess is very important, as it affects the algorithm in !      exact_tree_nei_update. Here it is set to 3 times the size of a !      particle !IF( itr <= THIS% npart1 )THEN !  THIS% h(itr)= 3.0*(THIS% vol1_a)**third !ELSE !  THIS% h(itr)= 3.0*(THIS% vol2_a)**third !ENDIF ! Baryon density in the local rest frame [baryon (Msun_geo)&#94;{-3}] ! Computed from the LORENE baryon mass density in [kg/m&#94;3] nlrf ( itr ) = THIS % baryon_density_parts ( itr ) * (( Msun_geo * km2m ) ** 3 ) / ( amu * g2kg ) THIS % nlrf ( itr ) = & THIS % baryon_density_parts ( itr ) * (( Msun_geo * km2m ) ** 3 ) / ( amu * g2kg ) ! Specific internal energy [c&#94;2] u ( itr ) = THIS % specific_energy_parts ( itr ) ! Pressure [amu*c**2/(Msun_geo**3)] !          dimensions: [(M/L**3)*L**2/T**2]= [M/(L*T**2)], same as !                      energy density Pr ( itr ) = THIS % pressure_parts ( itr ) * (( Msun_geo * km2m ) ** 3 ) / ( amu * g2kg ) THIS % pressure_parts_cu ( itr ) = Pr ( itr ) IF ( . FALSE . . AND . debug ) THEN IF ( itr >= THIS % npart / 10 - 200 . AND . itr <= THIS % npart / 10 ) THEN PRINT \"(A15,E15.4)\" , \"det=\" , det PRINT \"(A15,E15.4)\" , \"sq_g=\" , sq_g PRINT \"(A15,E15.4)\" , \"sq_det_g4(itr)=\" , sq_det_g4 ( itr ) PRINT \"(A15,E15.4)\" , \"amu=\" , amu PRINT \"(A15,E15.4)\" , \"g2kg=\" , g2kg PRINT \"(A15,E15.4)\" , \"(1477**3)=\" , ( 147 7.0 ) ** 3 PRINT * PRINT \"(A15,E15.4)\" , \"nbar(a)=\" , THIS % baryon_density_parts ( itr ) PRINT \"(A25,E15.4)\" , \"THIS% nlrf(a)=\" , THIS % nlrf ( itr ) PRINT \"(A25,E15.4)\" , \"THIS% nu(a)=\" , THIS % nu ( itr ) PRINT \"(A25,E15.4)\" , \"THIS% pressure_parts_cu(a)=\" , & THIS % pressure_parts_cu ( itr ) PRINT * PRINT \"(A15,E15.4)\" , \"theta(a)=\" , THIS % Theta ( itr ) PRINT \"(A15,E15.4)\" , \"sq_det_g4(a)=\" , sq_det_g4 ( itr ) !PRINT \"(A15,E15.4)\", \"vol_a=\", THIS% vol_a PRINT * PRINT * ENDIF ENDIF ! Temperature: here dummy temp ( itr ) = 1.0D0 ! Dissipation parameter av ( itr ) = 1.0D0 ! Velocity divergence divv ( itr ) = 0.D0 ENDDO compute_SPH_variables_on_particles !$OMP END PARALLEL DO IF ( debug ) PRINT * , \"3\" ! Compute nstar (proper baryon number density) from LORENE THIS % nstar = ( THIS % nlrf * THIS % Theta ) * sq_det_g4 ! !-- Compute the particle proper mass, if not computed yet ! IF ( . NOT . ALLOCATED ( THIS % pvol ) ) THEN PRINT * , \"** ERROR! The array pvol is not allocated. \" , & \"Stopping...\" PRINT * STOP ENDIF IF ( . NOT .( THIS % distribution_id == 3 . OR . & ( THIS % distribution_id == 0 . AND . THIS % read_nu ) ) ) THEN THIS % pmass = THIS % nstar * THIS % pvol ENDIF ! Compute particle number density from LORENE THIS % particle_density = ( THIS % nstar ) / ( THIS % pmass ) IF ( debug ) PRINT * , \"4\" ! !-- Compute the first guess for the smoothing length, if the APM was not !-- used ! DO i_matter = 1 , THIS % n_matter , 1 IF ( . NOT . THIS % apm_iterate ( i_matter ) ) THEN IF ( debug ) PRINT * , \"Compute first guess for the smoothing length \" , & \"h, for particles on matter object\" , itr , \"...\" compute_h : DO itr = THIS % npart_i ( i_matter - 1 ) + 1 , & THIS % npart_i ( i_matter - 1 ) + THIS % npart_i ( i_matter ),& 1 THIS % h ( itr ) = 3.0D0 * ( THIS % pvol ( itr )) ** third h ( itr ) = THIS % h ( itr ) ! /(Msun_geo**3) IF ( debug . AND . THIS % h ( itr ) <= 0.0D0 ) THEN PRINT * , \"** ERROR! h(\" , itr , \")=\" , THIS % h ( itr ) PRINT * , \"Stopping...\" PRINT * STOP ENDIF ENDDO compute_h ENDIF ENDDO IF ( debug ) PRINT * , \"5\" !   IF( .NOT.THIS% apm_iterate2 )THEN ! !     IF( debug ) PRINT *, \"Compute first guess for h for star 2...\" ! !     compute_h2: DO itr= THIS% npart1 + 1, THIS% npart, 1 ! !       THIS% h(itr)= 3.0D0*(THIS% pvol(itr))**third !       h(itr)= THIS% h(itr) !       ! /(Msun_geo**3) !       IF( debug .AND. THIS% h(itr) <= 0.0D0 )THEN !         PRINT *, \"** ERROR! h(\", itr, \")=\", THIS% h(itr) !         PRINT *, \"Stopping...\" !         PRINT * !         STOP !       ENDIF ! !     ENDDO compute_h2 ! !   ENDIF IF ( debug ) PRINT * , \"1\" !-------------------------------------! !--  Assignment of nu on the stars. --! !-------------------------------------! !    IF( THIS% redistribute_nu )THEN ! !      !---------------------------------------------------------------------! !      !--  Assignment of nu on the stars, with the purpose                --! !      !--  of having a more uniform nu over the particles without losing  --! !      !--  baryon mass. This is used only on the lattice, optionally.     --! !      !---------------------------------------------------------------------! ! !      IF( THIS% distribution_id == 3 )THEN !        PRINT *, \"** ERROR! Particle placer \", THIS% distribution_id, & !                 \" is not compatible with redistribute_nu= .TRUE.\" !        PRINT *, \" * Check the parameter file lorene_bns_id_particles.par. \", & !                 \"Stopping...\" !        PRINT * !        STOP !      ENDIF ! !      nu_max1= nlrf( THIS% baryon_density_index( THIS% npart1 ) )& !              *THIS% pvol( THIS% npart1 ) & !              *Theta( THIS% baryon_density_index( THIS% npart1 ) )& !              *sq_det_g4( THIS% baryon_density_index( THIS% npart1 ) ) !      nu_max2= nlrf( THIS% baryon_density_index( THIS% npart ) )& !              *THIS% pvol( THIS% npart ) & !              *Theta( THIS% baryon_density_index( THIS% npart ) )& !              *sq_det_g4( THIS% baryon_density_index( THIS% npart ) ) ! !      nu_thres1= nu_max1/THIS% nu_ratio !      nu_thres2= nu_max2/THIS% nu_ratio ! !      ! Reset the total baryon number to 0 (necessary), and nu to an arbitrary !      ! value (to make debugging easier) ! !      nu= 1.0D0 !      THIS% nu= 1.0D0 !      THIS% nbar_tot= 0.0D0 !      THIS% nbar1= 0.0D0 !      THIS% nbar2= 0.0D0 ! !      cnt1= 0 !      compute_nu_on_particles_star1: DO itr= THIS% npart1, 1, -1 ! !        cnt1= cnt1 + 1 ! !        nu_tmp= nlrf( THIS% baryon_density_index( itr ) ) & !                *THIS% pvol(itr) & !                *Theta( THIS% baryon_density_index( itr ) )& !                *sq_det_g4( THIS% baryon_density_index( itr ) ) ! !        !IF( itr == THIS% npart1 ) nu_max= nu_tmp ! move this out of the loop ! !        IF( nu_tmp > nu_thres1 )THEN !          nu( THIS% baryon_density_index( itr ) )      = nu_tmp !          THIS% nu( THIS% baryon_density_index( itr ) )= nu_tmp !        ELSE !          nu( THIS% baryon_density_index( itr ) )      = nu_thres1 !          THIS% nu( THIS% baryon_density_index( itr ) )= nu_thres1 !        ENDIF ! !        THIS% nbar1= THIS% nbar1 + & !                     THIS% nu( THIS% baryon_density_index( itr ) ) ! !        IF( THIS% nbar1*amu/MSun > THIS% masses(1) )THEN !          EXIT !        ENDIF ! !      ENDDO compute_nu_on_particles_star1 ! !      cnt2= 0 !      compute_nu_on_particles_star2: DO itr= THIS% npart, THIS% npart1 + 1, -1 ! !        cnt2= cnt2 + 1 ! !        nu_tmp= nlrf( THIS% baryon_density_index( itr ) ) & !                *THIS% pvol(itr) & !                *Theta( THIS% baryon_density_index( itr ) ) & !                *sq_det_g4( THIS% baryon_density_index( itr ) ) ! !        !IF( itr == THIS% npart ) nu_max= nu_tmp ! !        IF( nu_tmp > nu_thres2 )THEN !          nu( THIS% baryon_density_index( itr ) )      = nu_tmp !          THIS% nu( THIS% baryon_density_index( itr ) )= nu_tmp !        ELSE !          nu( THIS% baryon_density_index( itr ) )      = nu_thres2 !          THIS% nu( THIS% baryon_density_index( itr ) )= nu_thres2 !        ENDIF ! !        THIS% nbar2= THIS% nbar2 + & !                     THIS% nu( THIS% baryon_density_index( itr ) ) ! !        IF( THIS% nbar2*amu/MSun > THIS% masses(2) )THEN !          EXIT !        ENDIF ! !      ENDDO compute_nu_on_particles_star2 !      THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !      ! !      !-- Reshape MODULE variables !      ! ! !      CALL THIS% reshape_sph_field( pos_u, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( vel_u, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( Theta, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( h, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( nlrf, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( u, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( Pr, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( nu, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( temp, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( av, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( divv, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      ! !      !-- Reshape TYPE member SPH variables !      ! ! !      CALL THIS% reshape_sph_field( THIS% pos, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% v, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% v_euler_parts_x, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% v_euler_parts_y, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% v_euler_parts_z, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% Theta, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% h, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% baryon_density_parts, cnt1, & !                                    cnt2, THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% nlrf, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% energy_density_parts, cnt1, & !                                    cnt2, THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% specific_energy_parts, cnt1, & !                                    cnt2, THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% pressure_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% pressure_parts_cu, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% nu, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% pvol, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      ! !      !-- Reshape TYPE member spacetime variables !      ! ! !      CALL THIS% reshape_sph_field( THIS% lapse_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% shift_parts_x, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% shift_parts_y, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% shift_parts_z, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% g_xx_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% g_xy_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% g_xz_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% g_yy_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% g_yz_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      CALL THIS% reshape_sph_field( THIS% g_zz_parts, cnt1, cnt2, & !                                    THIS% baryon_density_index ) ! !      ! !      !-- Reassign particle numbers !      ! ! !      npart= cnt1 + cnt2 !      THIS% npart= npart !      THIS% npart1= cnt1 !      THIS% npart2= cnt2 !      n1= THIS% npart1 !      n2= THIS% npart2 ! !      PRINT *, \" * Particles replaced after reassigning nu.\" !      PRINT *, \" * New number of particles=\", THIS% npart !      PRINT * !      PRINT *, \" * Number of particles on NS 1=\", THIS% npart1 !      PRINT *, \" * Number of particles on NS 2=\", THIS% npart2 !      PRINT * !----------------------------------------------! !--  Assignment of nu on the matter objects. --! !----------------------------------------------! DO i_matter = 1 , THIS % n_matter , 1 ASSOCIATE ( npart_in => THIS % npart_i ( i_matter - 1 ) + 1 , & npart_fin => THIS % npart_i ( i_matter - 1 ) + & THIS % npart_i ( i_matter ) ) IF ( THIS % distribution_id == 0 . AND . THIS % read_nu ) THEN ! If the particle positions and nu were read from formatted file... ! Do nothing, nu is already read from file nu ( npart_in : npart_fin ) = & THIS % nu ( npart_in : npart_fin ) THIS % nbar_i ( i_matter ) = SUM ( THIS % nu ( npart_in : npart_fin ), DIM = 1 ) ELSEIF ( THIS % apm_iterate ( i_matter ) ) THEN ! If the APM was used for star 1... ! Do nothing, nu is already computed and reflected in the constructor nu ( npart_in : npart_fin ) = & THIS % nu ( npart_in : npart_fin ) THIS % nbar_i ( i_matter ) = SUM ( THIS % nu ( npart_in : npart_fin ), DIM = 1 ) ELSEIF ( THIS % distribution_id == 3 ) THEN !ELSE ! If the APM was not used for star 1... ! Set nu based on the particle mass... DO itr = npart_in , npart_fin , 1 nu ( itr ) = THIS % pmass ( itr ) * MSun / amu THIS % nu ( itr ) = nu ( i_matter ) THIS % nbar_i ( i_matter ) = THIS % nbar_i ( i_matter ) + nu ( itr ) ENDDO ELSE ! If the APM was not used for star 1 and the particles are on ! lattices... DO itr = npart_in , npart_fin , 1 nu ( itr ) = nlrf ( itr ) * THIS % pvol ( itr ) * Theta ( itr ) * sq_det_g4 ( itr ) THIS % nu ( itr ) = nu ( itr ) THIS % nbar_i ( i_matter ) = THIS % nbar_i ( i_matter ) + nu ( itr ) ENDDO ENDIF THIS % nbar_tot = THIS % nbar_tot + THIS % nbar_i ( i_matter ) equal_mass_binary : & IF ( i_matter == 1 . AND . THIS % n_matter == 2 ) THEN IF ( ABS ( THIS % mass_ratios ( 1 ) - THIS % mass_ratios ( 2 )) & / THIS % mass_ratios ( 2 ) <= 0.005 . AND . THIS % reflect_particles_x . AND . & THIS % distribution_id /= 1 ) THEN ! Consistency check IF ( THIS % npart_i ( i_matter ) + & THIS % npart_i ( i_matter + 1 ) /= THIS % npart ) THEN PRINT * , \"** ERROR! npart_next /= THIS% npart! \" PRINT * , \"   npart_next=\" , THIS % npart_i ( i_matter ) + & THIS % npart_i ( i_matter + 1 ) PRINT * , \"   THIS% npart=\" , THIS % npart PRINT * , \"   Stopping...\" PRINT * STOP ENDIF nu ( npart_fin + 1 : THIS % npart_i ( i_matter ) + & THIS % npart_i ( i_matter + 1 ) ) = nu ( npart_in : npart_fin ) THIS % nu ( npart_fin + 1 : THIS % npart_i ( i_matter ) + & THIS % npart_i ( i_matter + 1 ) ) = nu ( npart_in : npart_fin ) THIS % nbar_i ( i_matter + 1 ) = THIS % nbar_i ( i_matter ) THIS % nbar_tot = THIS % nbar_tot + THIS % nbar_i ( i_matter + 1 ) ! Consistency check IF ( THIS % nbar_tot /= 2 * THIS % nbar_i ( i_matter + 1 ) ) THEN PRINT * , \"** ERROR! THIS% nbar_tot /= 2*THIS% nbar(i_matter + 1) \" ,& \"   when reflecting particles or a binary system\" PRINT * , \"   THIS% nbar_tot=\" , THIS % nbar_tot PRINT * , \"   2*THIS% nbar(\" , i_matter + 1 , \")=\" , & 2 * THIS % nbar_i ( i_matter + 1 ) PRINT * , \"   Stopping...\" PRINT * STOP ENDIF EXIT ENDIF ENDIF equal_mass_binary END ASSOCIATE ENDDO !    IF( THIS% distribution_id == 0 .AND. THIS% read_nu )THEN ! !      ! If the particle positions and nu were read from formatted file... ! !      ! Do nothing, nu is already read from file !      nu= THIS% nu !      THIS% nbar1= SUM( THIS% nu(1:THIS% npart1), DIM= 1 ) !      THIS% nbar2= SUM( THIS% nu(THIS% npart1+1:THIS% npart), DIM= 1 ) !      THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !    ELSEIF( THIS% n_matter == 2 .AND. & !            ABS(THIS% mass_ratios(1) - THIS% mass_ratios(2)) & !            /THIS% mass_ratios(2) <= 0.005 .AND. reflect_particles_x  )THEN ! !      ! If there are 2 object with practically the same mass, and the user wants !      ! to have the same particles on them, but reflected with respect to !      ! the yz plane... ! !      IF( THIS% apm_iterate(1) )THEN ! !        ! If the APM was used for star 1... ! !        ! Do nothing, nu and h are already computed in the APM iteration !        nu= THIS% nu !        h = THIS% h !        THIS% nbar1= SUM( THIS% nu(1:THIS% npart1), DIM= 1 ) !        THIS% nbar2= SUM( THIS% nu(THIS% npart1+1:THIS% npart), DIM= 1 ) !        THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !      ELSEIF( THIS% distribution_id == 3 )THEN !      !ELSE ! !        ! If the APM was not used for star 1... ! !        ! Set nu based on the particle mass... ! !        DO itr= 1, THIS% npart1, 1 !          nu(itr)= THIS% pmass(itr)*MSun/amu !          THIS% nu(itr)= nu(itr) !          THIS% nbar1= THIS% nbar1 + nu(itr) !        ENDDO ! !        ! ...and copy this nu to the particles on star 2 ! !        nu( THIS% npart1 + 1:THIS% npart )= nu( 1:THIS% npart1 ) !        THIS% nu( THIS% npart1 + 1:THIS% npart )= nu( 1:THIS% npart1 ) !        THIS% nbar2= THIS% nbar1 ! !        THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !      ELSE ! !        ! If the APM was not used for star 1 and the particles are on !        ! lattices... ! !        DO itr= 1, THIS% npart1, 1 !          nu(itr)= nlrf(itr)*THIS% pvol(itr)*Theta( itr )*sq_det_g4( itr ) !          THIS% nu(itr)= nu(itr) !          THIS% nbar1= THIS% nbar1 + nu(itr) !        ENDDO ! !        nu( THIS% npart1 + 1:THIS% npart )= nu( 1:THIS% npart1 ) !        THIS% nu( THIS% npart1 + 1:THIS% npart )= nu( 1:THIS% npart1 ) !        THIS% nbar2= THIS% nbar1 ! !        THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !      ENDIF ! !    ELSEIF( THIS% apm_iterate(1) .AND. THIS% apm_iterate(2) )THEN ! !      ! If the stars do not have the same mass... ! !      ! If the APM was used for both of them... ! !      ! Do nothing, nu and h are already computed in the APM iteration !      nu= THIS% nu !      h = THIS% h !      THIS% nbar1= SUM( THIS% nu(1:THIS% npart1), DIM= 1 ) !      THIS% nbar2= SUM( THIS% nu(THIS% npart1+1:THIS% npart), DIM= 1 ) !      THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !    ELSEIF( THIS% apm_iterate(1) .AND. .NOT.THIS% apm_iterate(2) )THEN ! !      ! If the stars do not have the same mass... ! !      ! If the APM was used for star 1 only... ! !      ! Do nothing on star 1, nu and h are already computed in the APM iteration !      nu(1:THIS% npart1)= THIS% nu(1:THIS% npart1) !      h(1:THIS% npart1) = THIS% h(1:THIS% npart1) !      THIS% nbar1= SUM( THIS% nu(1:THIS% npart1), DIM= 1 ) ! !      ! Set nu based on the particle mass on star 2... ! !      IF( THIS% distribution_id == 3 )THEN ! !        DO itr= THIS% npart1 + 1, THIS% npart, 1 !          nu(itr)= THIS% pmass(itr)*MSun/amu !          THIS% nu(itr)= nu(itr) !          THIS% nbar2= THIS% nbar2 + nu(itr) !        ENDDO ! !      ELSE ! !        DO itr= THIS% npart1 + 1, THIS% npart, 1 !          nu(itr)= nlrf(itr)*THIS% pvol(itr)*Theta( itr )*sq_det_g4( itr ) !          THIS% nu(itr)= nu(itr) !          THIS% nbar2= THIS% nbar2 + nu(itr) !        ENDDO ! !      ENDIF ! !      THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !    ELSEIF( .NOT.THIS% apm_iterate(1) .AND. THIS% apm_iterate(2) )THEN ! !      ! If the stars do not have the same mass... ! !      ! If the APM was used for star 2 only... ! !      ! Set nu based on the particle mass on star 1... ! !      IF( THIS% distribution_id == 3 )THEN ! !        DO itr= 1, THIS% npart1, 1 !          nu(itr)= THIS% pmass(itr)*MSun/amu !          THIS% nu(itr)= nu(itr) !          THIS% nbar1= THIS% nbar1 + nu(itr) !        ENDDO ! !      ELSE ! !        DO itr= 1, THIS% npart1, 1 !          nu(itr)= nlrf(itr)*THIS% pvol(itr)*Theta( itr )*sq_det_g4( itr ) !          THIS% nu(itr)= nu(itr) !          THIS% nbar1= THIS% nbar1 + nu(itr) !        ENDDO ! !      ENDIF ! !      ! Do nothing on star 2, nu and h are already computed in the APM iteration !      nu(THIS% npart1+1:THIS% npart)= THIS% nu(THIS% npart1+1:THIS% npart) !      h(THIS% npart1+1:THIS% npart) = THIS% h(THIS% npart1+1:THIS% npart) !      THIS% nbar2= SUM( THIS% nu(THIS% npart1+1:THIS% npart), DIM= 1 ) ! !      THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !    ELSE ! !      ! If the APM was not used on both stars... ! !      ! Set nu based on the particle mass on both stars... ! !      IF( THIS% distribution_id == 3 )THEN ! !        DO itr= 1, THIS% npart1, 1 !          nu(itr)= THIS% pmass(itr)*MSun/amu !          THIS% nu(itr)= nu(itr) !          THIS% nbar1= THIS% nbar1 + nu(itr) !        ENDDO !        DO itr= THIS% npart1 + 1, THIS% npart, 1 !          nu(itr)= THIS% pmass(itr)*MSun/amu !          THIS% nu(itr)= nu(itr) !          THIS% nbar2= THIS% nbar2 + nu(itr) !        ENDDO !        THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !      ELSE ! !        DO itr= 1, THIS% npart1, 1 !          nu(itr)= nlrf(itr)*THIS% pvol(itr)*Theta( itr )*sq_det_g4( itr ) !          THIS% nu(itr)= nu(itr) !          THIS% nbar1= THIS% nbar1 + nu(itr) !        ENDDO !        DO itr= THIS% npart1 + 1, THIS% npart, 1 !          nu(itr)= nlrf(itr)*THIS% pvol(itr)*Theta( itr )*sq_det_g4( itr ) !          THIS% nu(itr)= nu(itr) !          THIS% nbar2= THIS% nbar2 + nu(itr) !        ENDDO !        THIS% nbar_tot= THIS% nbar1 + THIS% nbar2 ! !      ENDIF ! !    ENDIF !------------------------------------------------------------------------! ! Compute SPH density estimate (nu has to be assigned before this step)  ! !------------------------------------------------------------------------! CALL allocate_RCB_tree_memory_3D ( npart ) iorig ( 1 : npart ) = ( / ( a , a = 1 , npart ) / ) CALL allocate_gradient ( npart ) IF ( debug ) PRINT * , \"-1\" PRINT * , \" * Assigning h...\" PRINT * ! Determine smoothing length so that each particle has exactly ! 300 neighbours inside 2h DO itr2 = 1 , max_it_h , 1 good_h = . TRUE . CALL assign_h ( ndes , & THIS % npart , & THIS % pos , THIS % h , & h ) DO a = 1 , THIS % npart , 1 IF ( ISNAN ( h ( a ) ) . OR . h ( a ) <= 0.0D0 ) THEN IF ( a > THIS % npart / 2 ) THEN DO itr = CEILING ( DBLE ( THIS % npart / 2 )) - 1 , 1 , - 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ELSE !h(a) = h(a - 1) DO itr = a + 1 , THIS % npart , 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ENDIF !THIS% h(a)= 3.0D0*THIS% h(a) !THIS% h= h good_h = . FALSE . ENDIF ENDDO IF ( good_h ) THEN EXIT ELSE THIS % h = h ENDIF ENDDO PRINT * , \" * Computing neighbours...\" PRINT * cnt1 = 0 DO few_ncand = . FALSE . ! Redo the previous step slightly different (it's built-in; ! exact_nei_tree_update does not work if I don't call assign_h first), ! then update the neighbour-tree and fill the neighbour-data CALL exact_nei_tree_update ( ndes , & THIS % npart , & THIS % pos , & THIS % nu ) ! !-- Check that the number of candidate neighbours is larger than !-- or equal to ndes - 1 ! DO itr = 1 , SIZE ( ncand ), 1 ! If there are too few candidate neighbors IF ( ncand ( itr ) < ndes - 1 ) THEN ! Increase the smoothing length and rebuild the tree few_ncand = . TRUE . h = 3.0D0 * h EXIT ELSE few_ncand = . FALSE . ENDIF ENDDO cnt1 = cnt1 + 1 IF ( . NOT . few_ncand . OR . cnt1 >= 10 ) THEN PRINT * , \" * Smoothing lengths assigned and tree is built.\" EXIT ENDIF ENDDO ! !-- Check that the smoothing length is acceptable ! check_h : DO a = 1 , THIS % npart , 1 IF ( ISNAN ( h ( a ) ) ) THEN PRINT * , \"** ERROR! h(\" , a , \") is a NaN\" !PRINT *, \"Stopping...\" ! PRINT * !STOP IF ( a > THIS % npart / 2 ) THEN DO itr = CEILING ( DBLE ( THIS % npart / 2 )) - 1 , 1 , - 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ELSE !h(a) = h(a - 1) DO itr = a + 1 , THIS % npart , 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ENDIF !PRINT *, \"** ERROR! h(\", a, \")=\", h(a) !PRINT * ENDIF IF ( h ( a ) <= 0.0D0 ) THEN PRINT * , \"** ERROR! h(\" , a , \")=\" , h ( a ) !PRINT *, \"Stopping...\" !PRINT * !STOP IF ( a > THIS % npart / 2 ) THEN DO itr = CEILING ( DBLE ( THIS % npart / 2 )) - 1 , 1 , - 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ELSE !h(a) = h(a - 1) DO itr = a + 1 , THIS % npart , 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ENDIF !PRINT *, \"** ERROR! h(\", a, \")=\", h(a) !PRINT * ENDIF ENDDO check_h ! Update the member variables storing smoothing length and particle volume THIS % h = h THIS % pvol = ( THIS % h / 3.0D0 ) ** 3.0D0 ! !-- Compute the proper baryon number density with kernel interpolation ! PRINT * , \" * Computing SPH proper baryon number density with kernel\" , & \" interpolation...\" PRINT * ! density calls dens_ll_cell, which computes nstar on particle a as ! Na=     Na + nu(b)*Wab_ha, so this is nstar= nlrf*sq_g*Theta ! It has to be compared with nstar= nlrf*sq_g*Theta CALL density ( THIS % npart , & THIS % pos , & THIS % nstar_int ) !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! ! This point here is CRUCIAL: the particle distribution may NOT resolve   ! ! properly the steep density gradient at the surface, even if the APM     ! ! is used. This implies that the kernel interpolated nstar_int will be    ! ! different than nstar close to the surface.                              ! ! The error can be such that the recovery fails in SPHINCS_BSSN, and      ! ! this is of course a problem. Now, the density used in SPHINCS_BSSN      ! ! during the evolution is not the one given by LORENE. Hence, once        ! ! nstar_int is computed, nlrf should be recomputed from it, so that the   ! ! density on the particles corresponds to the density that \"they see\",    ! ! that is, the kernel interpolated density that uses these values of nu.  ! !-------------------------------------------------------------------------! !-------------------------------------------------------------------------! THIS % nlrf_int = ( THIS % nstar_int / THIS % Theta ) / sq_det_g4 nlrf = THIS % nlrf_int !-----------------------------------------------------------------------! ! For single and piecewise polytropes, do not use the LORENE pressure   ! ! and specific                                                          ! ! internal energy. Compute them using the exact formulas for piecewise  ! ! polytropic instead, starting from the kernel interpolated density     ! !-----------------------------------------------------------------------! DO i_matter = 1 , THIS % n_matter , 1 ASSOCIATE ( npart_in => THIS % npart_i ( i_matter - 1 ) + 1 , & npart_fin => THIS % npart_i ( i_matter - 1 ) + & THIS % npart_i ( i_matter ) ) IF ( THIS % all_eos ( i_matter )% eos_parameters ( 1 ) == 1 ) THEN ! If the |eos| is polytropic PRINT * , \" * Computing pressure and specific internal energy from\" , & \" the baryon mass density, using the exact formulas for\" , & \" single polytropic EOS...\" PRINT * ! Formulas from Read et al. (2009) Pr ( npart_in : npart_fin ) = THIS % all_eos ( i_matter )% eos_parameters ( 3 ) & * ( THIS % nlrf_int ( npart_in : npart_fin ) * m0c2_cu ) & ** THIS % all_eos ( i_matter )% eos_parameters ( 2 ) u ( npart_in : npart_fin ) = ( Pr ( npart_in : npart_fin ) & / ( THIS % nlrf_int ( npart_in : npart_fin ) * m0c2_cu & * ( THIS % all_eos ( i_matter )% eos_parameters ( 2 ) - 1.0D0 ) ) ) Pr ( npart_in : npart_fin ) = Pr ( npart_in : npart_fin ) / m0c2_cu THIS % pressure_parts_cu ( npart_in : npart_fin ) = Pr ( npart_in : npart_fin ) THIS % u_pwp ( npart_in : npart_fin ) = u ( npart_in : npart_fin ) ELSEIF ( THIS % all_eos ( i_matter )% eos_parameters ( 1 ) == 110 ) THEN ! If the |eos| is piecewise polytropic PRINT * , \" * Computing pressure and specific internal energy from\" , & \" the baryon mass density, using the exact formulas for\" , & \" piecewise polytropic EOS...\" PRINT * CALL select_EOS_parameters ( & shorten_eos_name ( THIS % all_eos ( i_matter )% eos_name ) ) CALL gen_pwp_eos_all ( THIS % npart_i ( i_matter ), & THIS % nlrf_int ( npart_in : npart_fin ) * m0c2_cu , & u ( npart_in : npart_fin ) ) THIS % pressure_parts_cu ( npart_in : npart_fin ) = Pr ( npart_in : npart_fin ) THIS % u_pwp ( npart_in : npart_fin ) = get_u_pwp () u ( npart_in : npart_fin ) = get_u_pwp () ENDIF END ASSOCIATE ENDDO !  IF( THIS% all_eos(1)% eos_parameters(1) == 1 & !      .AND. THIS% all_eos(2)% eos_parameters(1) == 1 )THEN ! !    PRINT *, \" * Computing pressure and specific internal energy from\", & !             \" the baryon mass density, using the exact formulas for\", & !             \" single polytropic EOS...\" !    PRINT * ! !    ! Formulas from Read et al. (2009) ! !    Pr(1:THIS% npart_i(1))= THIS% all_eos(1)% eos_parameters(3) & !                *( THIS% nlrf_int(1:THIS% npart_i(1))*m0c2_cu )**THIS% all_eos(1)% eos_parameters(2) ! !    Pr(THIS% npart_i(1)+1:THIS% npart)= THIS% all_eos(2)% eos_parameters(3) & !     *( THIS% nlrf_int(THIS% npart_i(1)+1:THIS% npart)*m0c2_cu )**THIS% all_eos(2)% eos_parameters(2) ! !    u(1:THIS% npart_i(1))= ( Pr(1:THIS% npart_i(1)) & !      /(THIS% nlrf_int(1:THIS% npart_i(1))*m0c2_cu*( THIS% all_eos(1)% eos_parameters(2) - 1.0D0 ) ) ) ! !    u(THIS% npart_i(1)+1:THIS% npart)= ( Pr(THIS% npart_i(1)+1:THIS% npart) & !      /(THIS% nlrf_int(THIS% npart_i(1)+1:THIS% npart)*m0c2_cu & !            *( THIS% all_eos(2)% eos_parameters(3) - 1.0D0 ) ) ) ! !    Pr= Pr/m0c2_cu !    THIS% pressure_parts_cu= Pr !    THIS% u_pwp= u ! !  ENDIF ! !  IF( THIS% all_eos(1)% eos_parameters(1) == 110 & !     .AND. THIS% all_eos(2)% eos_parameters(1) == 110 )THEN ! !    PRINT *, \" * Computing pressure and specific internal energy from\", & !             \" the baryon mass density, using the exact formulas for\", & !             \" piecewise polytropic EOS...\" !    PRINT * ! !    CALL select_EOS_parameters( & !            shorten_eos_name(THIS% all_eos(1)% eos_name) & !         ) !    CALL gen_pwp_eos_all( THIS% npart, THIS% nlrf_int*m0c2_cu, u ) !    THIS% pressure_parts_cu= Pr !    THIS% u_pwp= get_u_pwp() !    u= get_u_pwp() ! !  ENDIF !-------------------! ! Assignment of Ye  ! !-------------------! IF (. NOT . ALLOCATED ( THIS % Ye )) THEN ALLOCATE ( THIS % Ye ( THIS % npart ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array Ye \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array lapse_parts\" ) ENDIF assign_ye_on_particles : IF ( THIS % compose_eos ) THEN PRINT * , \"Assigning electron fraction using the CompOSE file \" , & TRIM ( THIS % compose_path ) // TRIM ( THIS % compose_filename ) compose_namefile = TRIM ( THIS % compose_path ) // TRIM ( THIS % compose_filename ) CALL THIS % read_compose_composition ( compose_namefile ) CALL THIS % compute_Ye () PRINT * , \"Electron fraction assigned.\" PRINT * ELSE THIS % Ye = 0.0D0 ENDIF assign_ye_on_particles Ye = THIS % Ye !  assign_ye_on_particles: DO itr= 1, THIS% npart, 1 ! !    ! Electron fraction !    IF( THIS% compose_eos )THEN !      Ye(itr)= THIS% Ye(itr) !    ELSE !      Ye(itr)= 0.0D0 !      THIS% Ye(itr)= 0.0D0 !    ENDIF ! !  ENDDO assign_ye_on_particles CALL THIS % sph_computer_timer % stop_timer () ! !-- Printouts ! !\"(A28,E15.8,A10)\" DO i_matter = 1 , THIS % n_matter , 1 ASSOCIATE ( npart_in => THIS % npart_i ( i_matter - 1 ) + 1 , & npart_fin => THIS % npart_i ( i_matter - 1 ) + & THIS % npart_i ( i_matter ) ) PRINT * , \" * Maximum baryon density on object\" , i_matter , \"=\" , & MAXVAL ( THIS % baryon_density_parts ( npart_in : npart_fin ), DIM = 1 ) & * kg2g / ( m2cm ** 3 ), \" g cm&#94;{-3}\" PRINT * , \" * Minimum baryon density on object\" , i_matter , \"=\" , & MINVAL ( THIS % baryon_density_parts ( npart_in : npart_fin ), DIM = 1 ) & * kg2g / ( m2cm ** 3 ), \" g cm&#94;{-3}\" PRINT * , \" * Ratio between the two=\" , & MAXVAL ( THIS % baryon_density_parts ( npart_in : npart_fin ), DIM = 1 ) / & MINVAL ( THIS % baryon_density_parts ( npart_in : npart_fin ), DIM = 1 ) PRINT * PRINT * , \" * Maximum nlrf on object\" , i_matter , \"=\" , & MAXVAL ( THIS % nlrf ( npart_in : npart_fin ), DIM = 1 ), & \"baryon Msun_geo&#94;{-3}\" PRINT * , \" * Minimum nlrf on object\" , i_matter , \"=\" , & MINVAL ( THIS % nlrf ( npart_in : npart_fin ), DIM = 1 ), & \"baryon Msun_geo&#94;{-3}\" PRINT * , \" * Ratio between the two=\" , & MAXVAL ( THIS % nlrf ( npart_in : npart_fin ), DIM = 1 ) / & MINVAL ( THIS % nlrf ( npart_in : npart_fin ), DIM = 1 ) PRINT * THIS % nuratio_i ( i_matter ) = MAXVAL ( THIS % nu ( npart_in : npart_fin ), DIM = 1 )& / MINVAL ( THIS % nu ( npart_in : npart_fin ), DIM = 1 ) PRINT * , \" * Maximum n. baryon per particle (nu) on object\" , i_matter , & \"=\" , MAXVAL ( THIS % nu ( npart_in : npart_fin ), DIM = 1 ) PRINT * , \" * Minimum n. baryon per particle (nu) on object\" , i_matter , & \"=\" , MINVAL ( THIS % nu ( npart_in : npart_fin ), DIM = 1 ) PRINT * , \" * Ratio between the two=\" , THIS % nuratio_i ( i_matter ) PRINT * PRINT * , \" * Number of baryons on object\" , i_matter , \"=\" , & THIS % nbar_i ( i_matter ) PRINT * , \" * Total mass of the baryons on object\" , i_matter , \"=\" , & THIS % nbar_i ( i_matter ) * amu / Msun , \"Msun =\" , & THIS % nbar_i ( i_matter ) * amu / Msun / THIS % masses ( i_matter ), & \"of the baryon mass of object\" , i_matter , \".\" PRINT * END ASSOCIATE ENDDO THIS % nuratio = MAXVAL ( THIS % nu , DIM = 1 ) / MINVAL ( THIS % nu , DIM = 1 ) PRINT * , \" * Baryon number ratio across the stars=\" , THIS % nuratio PRINT * PRINT * , \" * Total mass of the baryons=\" , & THIS % nbar_tot * amu / Msun , \"Msun =\" , & THIS % nbar_tot * amu / Msun / ( SUM ( THIS % masses , DIM = 1 )), & \"of the total baryon mass.\" PRINT * ! !-- Adjusting the baryon number per particle uniformly so that !-- the baryon mass is correct, but the ratio between nu_max and nu_min !-- does not change. !-- nlrf is not to be rescaled, according to Stephan, since: !--   (i)  it is directly computed from the LORENE ID and should therefore !--        be consistent with it !--   (ii) it is anyway immediately recomputed in SPHINCS_BSSN ! IF ( THIS % correct_nu ) THEN THIS % nbar_tot = 0.0D0 DO i_matter = 1 , THIS % n_matter , 1 ASSOCIATE ( npart_in => THIS % npart_i ( i_matter - 1 ) + 1 , & npart_fin => THIS % npart_i ( i_matter - 1 ) + & THIS % npart_i ( i_matter ) ) THIS % nu ( npart_in : npart_fin ) = THIS % nu ( npart_in : npart_fin ) & / ( THIS % nbar_i ( i_matter ) * amu / Msun / THIS % masses ( i_matter )) nu ( npart_in : npart_fin ) = THIS % nu ( npart_in : npart_fin ) THIS % nbar_i ( i_matter ) = THIS % nbar_i ( i_matter ) & / ( THIS % nbar_i ( i_matter ) * amu / Msun / THIS % masses ( i_matter )) THIS % nbar_tot = THIS % nbar_tot + THIS % nbar_i ( i_matter ) PRINT * , \" * Number of corrected baryons on object\" , i_matter , \"=\" , & THIS % nbar_i ( i_matter ) PRINT * , \" * Total mass of the corrected baryons object\" , i_matter , & \"=\" , THIS % nbar_i ( i_matter ) * amu / Msun , \"Msun =\" , & THIS % nbar_i ( i_matter ) * amu / Msun / THIS % masses ( i_matter ), & \"of the baryon mass of object\" , i_matter , \".\" END ASSOCIATE ENDDO PRINT * , \" * Total number of corrected baryons=\" , THIS % nbar_tot PRINT * , \" * Total mass of the corrected baryons=\" , & THIS % nbar_tot * amu / Msun , \"Msun =\" , & THIS % nbar_tot * amu / Msun / ( SUM ( THIS % masses , DIM = 1 )), & \"of the total baryon mass.\" PRINT * ENDIF ! !-- Exporting the SPH ID to a binary file, for evolution ! IF ( THIS % export_bin ) THEN IF ( PRESENT ( namefile ) ) THEN finalnamefile = TRIM ( namefile ) // \"00000\" dcount = - 1 ! since it is increased before writing CALL write_SPHINCS_dump ( finalnamefile ) ELSE basename = \"NSNS.\" dcount = - 1 ! since it is increased before writing CALL write_SPHINCS_dump () ENDIF ENDIF PRINT * , \" * Computing particle number density by kernel interpolation...\" PRINT * nu = 1.0D0 CALL density_loop ( THIS % npart , THIS % pos , nu , h , & THIS % particle_density_int ) PRINT * , \" * Deallocating MODULE variables...\" PRINT * CALL deallocate_metric_on_particles CALL deallocate_gradient DEALLOCATE ( alive ) CALL deallocate_RCB_tree_memory_3D CALL deallocate_SPH_memory call_flag = call_flag + 1 THIS % call_flag = call_flag PRINT * , \"** Subroutine compute_and_export_SPH_variables executed.\" PRINT * END PROCEDURE compute_and_export_SPH_variables MODULE PROCEDURE read_sphincs_dump_print_formatted !************************************************ ! !# Read the SPH ID from the binary file output !  by write_SPHINCS_dump, and print it to a !  formatted file ! !  FT 12.02.2021 ! !************************************************ USE sph_variables , ONLY : npart , & ! particle number pos_u , & ! particle positions vel_u , & ! particle velocities in ! coordinate frame nlrf , & ! baryon number density in ! local rest frame !ehat,  &  ! canonical energy per baryon nu , & ! canonical baryon number per ! particle Theta , & ! Generalized Lorentz factor h , & ! Smoothing length Pr , & ! Pressure u , & ! Internal energy in local rest ! frame (no kinetic energy) temp , & ! Temperature av , & ! Dissipation ye , & ! Electron fraction divv , & ! Divergence of velocity vel_u allocate_SPH_memory , & deallocate_SPH_memory USE metric_on_particles , ONLY : allocate_metric_on_particles , & deallocate_metric_on_particles USE input_output , ONLY : set_units , read_SPHINCS_dump IMPLICIT NONE INTEGER :: itr , min_y_index DOUBLE PRECISION :: min_abs_y , min_abs_z1 , min_abs_z2 DOUBLE PRECISION , DIMENSION ( :, : ), ALLOCATABLE :: abs_pos LOGICAL :: exist CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile PRINT * , \"** Executing the read_sphincs_dump_print_formatted subroutine...\" ! !-- Set up the MODULE variables in MODULE sph_variables !-- (used by write_SPHINCS_dump) ! npart = THIS % npart CALL set_units ( 'NSM' ) CALL allocate_SPH_memory CALL allocate_metric_on_particles ( THIS % npart ) finalnamefile = TRIM ( namefile_bin ) // \"00000\" CALL read_SPHINCS_dump ( finalnamefile ) ! Being abs_grid a local array, it is good practice to allocate it on the ! heap, otherwise it will be stored on the stack which has a very limited ! size. This results in a segmentation fault. ALLOCATE ( abs_pos ( 3 , THIS % npart ) ) IF ( THIS % call_flag == 0 ) THEN PRINT * , \"** The SUBROUTINE print_formatted_lorene_id_particles must\" , & \" be called after compute_and_export_SPH_variables, otherwise\" , & \" there are no SPH fields to export to the formatted file.\" PRINT * , \"   Aborting.\" PRINT * STOP ENDIF IF ( PRESENT ( namefile ) ) THEN finalnamefile = namefile ELSE finalnamefile = \"sph_vars.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !                  // TRIM(finalnamefile) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Values of the fields (including coordinates) exported by LORENE \" & // \"on each grid point\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 1 in \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !        // TRIM(finalnamefile) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4       5\" , & \"       6       7       8\" , & \"       9       10      11\" , & \"       12      13      14\" , & \"       15      16      17\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 2 in \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !        // TRIM(finalnamefile) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      grid point      x [km]       y [km]       z [km]       lapse\" , & \"       shift_x [c]    shift_y [c]    shift_z [c]\" , & \"       baryon density in the local rest frame [kg m&#94;{-3}$]\" , & \"       energy density [c&#94;2]\" , & \"       specific energy [c&#94;2]\" , & \"       pressure [Pa]\" , & \"       fluid 3-velocity wrt the Eulerian observer (3 columns) [c]\" , & \"       fluid coordinate 3-velocity vel_u (3 columns) [c]\" , & \"       baryon number per particle nu\" , & \"       baryon density in the local rest frame nlrf [baryon/cm&#94;3]\" , & \"       generalized Lorentz factor Theta\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 3 in \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !        // TRIM(finalnamefile) ) DO itr = 1 , THIS % npart , 1 abs_pos ( 1 , itr ) = ABS ( THIS % pos ( 1 , itr ) ) abs_pos ( 2 , itr ) = ABS ( THIS % pos ( 2 , itr ) ) abs_pos ( 3 , itr ) = ABS ( THIS % pos ( 3 , itr ) ) ENDDO min_y_index = 0 min_abs_y = 1 D + 20 DO itr = 1 , THIS % npart , 1 IF ( ABS ( THIS % pos ( 2 , itr ) ) < min_abs_y ) THEN min_abs_y = ABS ( THIS % pos ( 2 , itr ) ) min_y_index = itr ENDIF ENDDO min_abs_z1 = MINVAL ( abs_pos ( 3 , 1 : THIS % npart_i ( 1 ) ) ) min_abs_z2 = MINVAL ( abs_pos ( 3 , THIS % npart_i ( 1 ) + 1 : THIS % npart ) ) write_data_loop : DO itr = 1 , THIS % npart , 1 IF ( THIS % export_form_xy . AND . & !( THIS% pos( 3, itr ) /= min_abs_z1 .AND. & !  THIS% pos( 3, itr ) /= min_abs_z2 ) & ( THIS % pos ( 3 , itr ) >= 0.5D0 . OR . & THIS % pos ( 3 , itr ) <= - 0.5D0 ) & ) THEN CYCLE ENDIF IF ( THIS % export_form_x . AND . & !( THIS% pos( 3, itr ) /= min_abs_z1 & !.OR. THIS% pos( 3, itr ) /= min_abs_z2 & !.OR. THIS% pos( 2, itr ) /= THIS% pos( 2, min_y_index ) ) )THEN ( THIS % pos ( 3 , itr ) >= 0.5D0 . OR . & THIS % pos ( 3 , itr ) <= - 0.5D0 . OR . & THIS % pos ( 2 , itr ) >= 0.5D0 . OR . & THIS % pos ( 2 , itr ) <= - 0.5D0 ) & ) THEN CYCLE ENDIF WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & itr , & pos_u ( 1 , itr ), & pos_u ( 2 , itr ), & pos_u ( 3 , itr ), & vel_u ( 1 , itr ), & vel_u ( 2 , itr ), & vel_u ( 3 , itr ), & h ( itr ), & u ( itr ), & nu ( itr ), & nlrf ( itr ), & temp ( itr ), & av ( itr ), & ye ( itr ), & divv ( itr ), & Theta ( itr ), & Pr ( itr ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" & // TRIM ( finalnamefile ), \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing \" & !       // \"the arrays in \" // TRIM(finalnamefile) ) ENDDO write_data_loop CLOSE ( UNIT = 2 ) ! !-- Deallocate MODULE variables ! CALL deallocate_metric_on_particles CALL deallocate_SPH_memory PRINT * , \" * LORENE SPH ID on the particles saved to formatted \" & // \"file\" , TRIM ( namefile ) PRINT * , \"** Subroutine read_sphincs_dump_print_formatted \" & // \"executed.\" PRINT * END PROCEDURE read_sphincs_dump_print_formatted MODULE PROCEDURE print_formatted_lorene_id_particles !************************************************ ! !# Print the LORENE ID on the particles in a !  formatted file ! !  FT 18.09.2020 ! !************************************************ USE constants , ONLY : c_light2 , cm2m , Msun_geo , amu , g2kg , km2m , km2cm IMPLICIT NONE INTEGER :: itr DOUBLE PRECISION , DIMENSION ( :, : ), ALLOCATABLE :: abs_pos LOGICAL :: exist CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile ! Being abs_pos a local array, it is good practice to allocate it on the ! heap, otherwise it will be stored on the stack which has a very limited ! size. This results in a segmentation fault. ALLOCATE ( abs_pos ( 3 , THIS % npart ) ) PRINT * , \"** Executing the print_formatted_lorene_id_particles \" & // \"subroutine...\" PRINT * IF ( THIS % call_flag == 0 ) THEN PRINT * , \"** The SUBROUTINE print_formatted_lorene_id_particles must\" , & \" be called after compute_and_export_SPH_variables, otherwise\" , & \" there are no SPH fields to export to the formatted file.\" PRINT * , \"   Aborting.\" PRINT * STOP ENDIF IF ( PRESENT ( namefile ) ) THEN finalnamefile = namefile ELSE finalnamefile = \"lorene-bns-id-particles-form.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !                  // TRIM(finalnamefile) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Values of the fields (including coordinates) exported by LORENE \" & // \"on each grid point\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 1 in \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !        // TRIM(finalnamefile) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4       5\" , & \"       6       7       8\" , & \"       9       10      11\" , & \"       12      13      14\" , & \"       15      16      17      18     19     20      21\" , & \"       22      23      24      25     26     27      28      29\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 2 in \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !            // TRIM(finalnamefile) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      grid point      x [km]       y [km]       z [km]       lapse\" , & \"       shift_x [c]    shift_y [c]    shift_z [c]\" , & \"       baryon density in the local rest frame [kg m&#94;{-3}$]\" , & \"       energy density [c&#94;2]\" , & \"       specific energy [c&#94;2]\" , & \"       pressure [Pa]\" , & \"       fluid 3-velocity wrt the Eulerian observer (3 columns) [c]\" , & \"       fluid coordinate 3-velocity vel_u (3 columns) [c]\" , & \"       baryon number per particle nu\" , & \"       baryon density in the local rest frame nlrf [baryon/Msun_geo&#94;3]\" , & \"       electron fraction\" , & \"       generalized Lorentz factor Theta\" , & \"       computing frame baryon number density\" , & \"       computing frame baryon number density from kernel interpolation\" , & \"       smoothing length\" , & \"       particle density [particle/Msun_geo&#94;3]\" , & \"       particle volume [1/Msun_geo&#94;3]\" , & \"       particle mass [Msun]\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 3 in \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !          // TRIM(finalnamefile) ) !DO itr = 1, THIS% npart, 1 !  abs_pos( 1, itr )= ABS( THIS% pos( 1, itr ) ) !  abs_pos( 2, itr )= ABS( THIS% pos( 2, itr ) ) !  abs_pos( 3, itr )= ABS( THIS% pos( 3, itr ) ) !ENDDO ! !min_y_index= 0 !min_abs_y= 1D+20 !DO itr = 1, THIS% npart, 1 !  IF( ABS( THIS% pos( 2, itr ) ) < min_abs_y )THEN !    min_abs_y= ABS( THIS% pos( 2, itr ) ) !    min_y_index= itr !  ENDIF !ENDDO ! !min_abs_z1= MINVAL( abs_pos( 3, 1:THIS% npart1 ) ) !min_abs_z2= MINVAL( abs_pos( 3, THIS% npart1+1:THIS% npart ) ) write_data_loop : DO itr = 1 , THIS % npart , 1 IF ( THIS % export_form_xy . AND . & !( THIS% pos( 3, itr ) /= min_abs_z1 .AND. & !  THIS% pos( 3, itr ) /= min_abs_z2 ) & ( THIS % pos ( 3 , itr ) >= 0.5D0 . OR . & THIS % pos ( 3 , itr ) <= - 0.5D0 ) & ) THEN CYCLE ENDIF IF ( THIS % export_form_x . AND . & !( THIS% pos( 3, itr ) /= min_abs_z1 & !.OR. THIS% pos( 3, itr ) /= min_abs_z2 & !.OR. THIS% pos( 2, itr ) /= THIS% pos( 2, min_y_index ) ) )THEN ( THIS % pos ( 3 , itr ) >= 0.5D0 . OR . & THIS % pos ( 3 , itr ) <= - 0.5D0 . OR . & THIS % pos ( 2 , itr ) >= 0.5D0 . OR . & THIS % pos ( 2 , itr ) <= - 0.5D0 ) & ) THEN CYCLE ENDIF WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & itr , & THIS % pos ( 1 , itr ), & THIS % pos ( 2 , itr ), & THIS % pos ( 3 , itr ), & THIS % lapse_parts ( itr ), & THIS % shift_parts_x ( itr ), & THIS % shift_parts_y ( itr ), & THIS % shift_parts_z ( itr ), & THIS % baryon_density_parts ( itr ), & THIS % energy_density_parts ( itr ), & THIS % specific_energy_parts ( itr ), & THIS % pressure_parts ( itr ) * (( Msun_geo * km2m ) ** 3 ) / ( amu * g2kg ), & THIS % pressure_parts_cu ( itr ), & THIS % v_euler_parts_x ( itr ), & THIS % v_euler_parts_y ( itr ), & THIS % v_euler_parts_z ( itr ), & THIS % v ( 1 , itr ), & THIS % v ( 2 , itr ), & THIS % v ( 3 , itr ), & THIS % nu ( itr ), & THIS % nlrf ( itr ), & THIS % Ye ( itr ), & THIS % Theta ( itr ), & THIS % nstar ( itr ), & THIS % nstar_int ( itr ), & THIS % h ( itr ), & THIS % particle_density ( itr ), & THIS % particle_density_int ( itr ), & THIS % pvol ( itr ), & THIS % pmass ( itr ), & THIS % u_pwp ( itr ), & THIS % nlrf_int ( itr ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing \" & !         // \"the arrays in \" // TRIM(finalnamefile) ) ENDDO write_data_loop CLOSE ( UNIT = 2 ) PRINT * , \" * LORENE ID on particles saved to formatted file \" , & TRIM ( finalnamefile ) PRINT * PRINT * , \"** Subroutine print_formatted_lorene_id_particles executed.\" PRINT * END PROCEDURE print_formatted_lorene_id_particles MODULE PROCEDURE analyze_hydro !************************************************ ! !# Export the points where some of the hydro !  fields are negative to a formatted file !  (deprecated?) ! !  FT 5.12.2020 ! !************************************************ IMPLICIT NONE LOGICAL :: exist , negative_hydro INQUIRE ( FILE = TRIM ( namefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 20 , FILE = TRIM ( namefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 20 , FILE = TRIM ( namefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( namefile ), & \" The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(namefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Points where some of the hydro fields are negative. \" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 1 in \" , TRIM ( namefile ), & \" The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 1 in \"& !         // TRIM(namefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 2 in \" , TRIM ( namefile ), & \" The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 2 in \"& !        // TRIM(namefile) ) WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      x   y   z\" IF ( ios > 0 ) THEN PRINT * , \"...error when writing line 3 in \" , TRIM ( namefile ), & \" The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when writing line 3 in \"& !        // TRIM(namefile) ) DO itr = 1 , THIS % npart , 1 IF ( THIS % baryon_density_parts ( itr ) < 0 . OR . & THIS % energy_density_parts ( itr ) < 0 . OR . & THIS % specific_energy_parts ( itr ) < 0 . OR . & THIS % pressure_parts ( itr ) < 0 ) THEN negative_hydro = . TRUE . WRITE ( UNIT = 20 , IOSTAT = ios , IOMSG = err_msg , & FMT = * )& THIS % pos ( 1 , itr ), & THIS % pos ( 2 , itr ), & THIS % pos ( 3 , itr ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , TRIM ( namefile ), & \" The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \"& !                // \"the arrays in \" // TRIM(namefile) ) ENDIF ENDDO CLOSE ( UNIT = 20 ) IF ( negative_hydro ) THEN PRINT * , \"** WARNING! Some of the hydro fields are negative on\" , & \" some of the particles! See the file \" , namefile , & \" for the positions of such particles.\" PRINT * ELSE PRINT * , \" * The hydro fields are positive on the particles.\" PRINT * ENDIF END PROCEDURE analyze_hydro ! SUBROUTINE compute_hydro_from_enthalpy_pwp( enthalpy, baryon_density, & !                                             pressure, energy_density, & !                                             specific_energy ) ! !   !************************************************** !   ! !   !# Compute the values of the the baryon density, !   !  the pressure, the energy density and the !   !  specific energy, from the value of the enthalpy !   !  for piecewise polytropic EOS !   ! !   !  FT 11.08.2021 !   ! !   !************************************************** ! !   IMPLICIT NONE ! !   USE pwp_eos,  ONLY: get_Gamma1, get_Gamma2, ! !   DOUBLE PRECISION, INTENT(IN) :: enthalpy !   DOUBLE PRECISION, INTENT(OUT):: baryon_density !   DOUBLE PRECISION, INTENT(OUT):: pressure !   DOUBLE PRECISION, INTENT(OUT):: energy_density !   DOUBLE PRECISION, INTENT(OUT):: specific_energy ! ! ! ! END SUBROUTINE compute_hydro_from_enthalpy_pwp !MODULE PROCEDURE write_lorene_bns_id_dump ! !    !************************************************* !    ! !    !# Returns the array of initial guess for the !    !  smoothing length !    ! !    !  FT !    ! !    !************************************************* ! !    USE input_output !    USE options, ONLY: basename ! !    INTEGER:: a ! !    LOGICAL:: exist ! !    ! TODO: THIS OPTIONAL ARGUMENT DOES NOT WORK... !    IF( .NOT.PRESENT(TRIM(namefile)) )THEN !            TRIM(namefile)= \"lorene-bns-id-particles-form.dat\" !    ENDIF ! !    INQUIRE( FILE= TRIM(namefile), EXIST= exist ) ! !    !PRINT *, TRIM(namefile) !    !PRINT * ! !    IF( exist )THEN !        OPEN( UNIT= 3, FILE= TRIM(namefile), STATUS= \"REPLACE\", & !              FORM= \"UNFORMATTED\", & !              POSITION= \"REWIND\", ACTION= \"WRITE\", IOSTAT= ios, & !              IOMSG= err_msg ) !    ELSE !        OPEN( UNIT= 3, FILE= TRIM(namefile), STATUS= \"NEW\", & !              FORM= \"UNFORMATTED\", & !              ACTION= \"WRITE\", IOSTAT= ios, IOMSG= err_msg ) !    ENDIF !    IF( ios > 0 )THEN !      PRINT *, \"..error when opening \" // TRIM(namefile) !               \". The error message is\", err_msg !      STOP !    ENDIF ! !    ! update dump counter !    dcount= dcount + 1 !    ! construct file name !    basename= 'lbns.' !    CALL construct_filename(dcount,filename) ! !    ! nlrf & nu are LARGE numbers --> scale for SPLASH !    nlrf= nlrf*m0c2_CU !    nu=   nu*amu/umass ! !    ! write in MAGMA-type format !    WRITE( UNIT= 3, IOSTAT = ios, IOMSG = err_msg ) & !            npart,       & ! number of particles !            rstar,mstar, & ! radius and mass of the star !                           ! obsolete (see module_sph_variables) !            n1,n2,       & ! obsolete (see module_sph_variables) !            npm,         & ! obsolete (see module_sph_variables) !            t,           & ! time !            ( h(a), a=1, npart ),      & ! smoothing length !            escap,tkin,tgrav,tterm, & ! obsolete (see module_sph_variables) !            ( pos_u(1,a), a=1, npart), & ! particle positions !            ( pos_u(2,a), a=1, npart ),& !            ( pos_u(3,a), a=1, npart), & !            ( vel_u(1,a), a=1, npart ),& ! spatial coordinate velocity !            ( vel_u(2,a), a=1, npart), & ! of particles !            ( vel_u(3,a), a=1, npart ),& !            ( u(a), a=1, npart),       & !            ( nu(a), a=1, npart ),     & !            ( nlrf(a), a=1, npart),    & !            ( temp(a), a=1, npart ),   & !            ( Ye(a), a=1, npart),      & !            ( av(a), a=1, npart ),     & ! = 1 !            ( divv(a), a=1, npart ),   & ! = 0 !            ( Theta(a), a=1, npart ),  & !            ( Pr(a), a=1, npart ) !            ! !            !-- leave here for potential later use !            ! !            !(pmasspm(a),a=1,npm),& !            !(pmpos(1,a),a=1,npm),(pmpos(2,a),a=1,npm),& !            !(pmpos(3,a),a=1,npm),(pmvel(1,a),a=1,npm),& !            !(pmvel(2,a),a=1,npm),(pmvel(3,a),a=1,npm),& !            !(pmdvdt(1,a),a=1,npm),(pmdvdt(2,a),a=1,npm),& !            !(pmdvdt(3,a),a=1,npm) !          IF( ios > 0 )THEN !            PRINT *, \"..error when writing in \" // TRIM(namefile) !                     \". The error message is\", err_msg !            STOP !          ENDIF !          !CALL test_status( ios, err_msg, \"...error when writing in \" & !         !            // TRIM(namefile) ) ! !    CLOSE( UNIT= 3 ) ! !END PROCEDURE write_lorene_bns_id_dump END SUBMODULE particles_sph_variables","tags":"","loc":"sourcefile/submodule_particles_sph_variables.f90.html"},{"title":"module_particles_id.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_particles_id.f90~~EfferentGraph sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_particles_id.f90~~AfferentGraph sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_spherical_surfaces.f90 submodule_particles_spherical_surfaces.f90 sourcefile~submodule_particles_spherical_surfaces.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_compose.f90 submodule_particles_compose.f90 sourcefile~submodule_particles_compose.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_memory.f90 submodule_particles_memory.f90 sourcefile~submodule_particles_memory.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_sph_variables.f90 submodule_particles_sph_variables.f90 sourcefile~submodule_particles_sph_variables.f90->sourcefile~module_particles_id.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_particles_id.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_access.f90 submodule_particles_access.f90 sourcefile~submodule_particles_access.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_lattices.f90 submodule_particles_lattices.f90 sourcefile~submodule_particles_lattices.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_constructor.f90 submodule_particles_constructor.f90 sourcefile~submodule_particles_constructor.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_apm.f90 submodule_particles_apm.f90 sourcefile~submodule_particles_apm.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_redistribute_nu.f90 submodule_particles_redistribute_nu.f90 sourcefile~submodule_particles_redistribute_nu.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bssn_id_variables.f90 submodule_bssn_id_variables.f90 sourcefile~submodule_bssn_id_variables.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bssn_id_constraints.f90 submodule_bssn_id_constraints.f90 sourcefile~submodule_bssn_id_constraints.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_formul_3p1_access.f90 submodule_formul_3p1_access.f90 sourcefile~submodule_formul_3p1_access.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_bssn_id_memory.f90 submodule_bssn_id_memory.f90 sourcefile~submodule_bssn_id_memory.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90 submodule_formul_3p1_standard3p1_variables.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~submodule_formul_3p1_analysis.f90 submodule_formul_3p1_analysis.f90 sourcefile~submodule_formul_3p1_analysis.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_bssn_id_constructor.f90 submodule_bssn_id_constructor.f90 sourcefile~submodule_bssn_id_constructor.f90->sourcefile~module_bssn_id.f90 var pansourcefilemodule_particles_idf90AfferentGraph = svgPanZoom('#sourcefilemodule_particles_idf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules particles_id Source Code module_particles_id.f90 Source Code ! File:         module_particles_id.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE particles_id !*********************************************************** ! !# This module contains the definition of TYPE particles ! !*********************************************************** USE utility , ONLY : itr , ios , err_msg , test_status , & perc , creturn , run_id , show_progress USE id_base , ONLY : idbase USE timing , ONLY : timer IMPLICIT NONE TYPE eos !! Data structure representing an |eos| CHARACTER ( LEN = : ), ALLOCATABLE :: eos_name !! The |eos| name DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: eos_parameters !# The |eos| parameters, in the following order: !  @todo complete the list END TYPE !********************************************************** !                                                         * !              Definition of TYPE particles               * !                                                         * ! This class places the SPH particles, imports            * ! the |lorene| BNS ID on the particle positions, stores     * ! it, computes the relevant SPH fields and exports it to  * ! both a formatted, and a binary file for evolution       * !                                                         * !********************************************************** TYPE :: particles !! TYPE representing a particle distribution PRIVATE INTEGER :: npart !! Total particle number !INTEGER:: npart1 !! Particle number for star 1 !INTEGER:: npart2 !! Particle number for star 1 INTEGER :: n_matter !! Particle number for star 1 INTEGER , DIMENSION (:), ALLOCATABLE :: npart_i !! Particle number for star 2 INTEGER :: distribution_id !! Identification number for the particle distribution !  INTEGER:: eos1_id !! |lorene| identification number for the EOS of star 1 !  INTEGER:: eos2_id !! |lorene| identification number for the EOS of star 1 INTEGER :: call_flag = 0 ! Flag that is set different than 0 if the SUBROUTINE ! compute_and_export_SPH_variables is called INTEGER , DIMENSION (:), ALLOCATABLE :: baryon_density_index !# Array storing the indices to use with [[particles:baryon_density_parts]] !  to sort the elements of [[particles:baryon_density_parts]] in increasing !  order ! !-- Hydro variables on the particles ! !> 2-D array storing the particle positions DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pos !> 1-D array storing the position of the particles on the x axis for S 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pos_x1 !> 1-D array storing the position of the particles on the x axis for NS2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pos_x2 !& 1-D array storing the baryon mass density in the fluid frame !  [\\mathrm{kg}\\,\\mathrm{m}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: baryon_density_parts !> 1-D array storing the energy density !  [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: energy_density_parts !> 1-D array storing the specific internal energy [c&#94;2] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: specific_energy_parts !& 1-D array storing the specific internal energy [c&#94;2] computed using !  formula (9) in Read et al., Phys.Rev.D79:124032,2009, !  [arXiv:0812.2163][https://arxiv.org/abs/0812.2163]{:target=\"_blank\"} DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: u_pwp !> 1-D array storing the pressure [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts !& 1-D array storing the pressure on the x axis !  [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x1 !& 1-D array storing the pressure on the x axis !  [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x2 !& 1-D array storing the first derivative of the pressure !  along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x_der1 !& 1-D array storing the first derivative of the pressure !  along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x_der2 !> 1-D array storing the typical length scale for the pressure change DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_length_scale_x1 !> 1-D array storing the typical length scale for the pressure change DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_length_scale_x2 !& 1-D array storing the pressure in code units !  [\\mathrm{amu}\\,c&#94;2\\,\\mathrm{L_\\odot}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_cu !& 1-D array storing the x component of the fluid 3-velocity wrt !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_parts_x !& 1-D array storing the y component of the fluid 3-velocity wrt !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_parts_y !& 1-D array storing the z component of the fluid 3-velocity wrt !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_parts_z ! !-- Arrays to store the electron fraction Ye as a function of the !-- baryon number density for beta-equilibrated EoS at T~0, !-- imported from the CompOSE database's and software's files ! !& Array storing the values of the baryon number density in the CompOSE !  table. @todo ADD UNITS DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nb_table !> Array storing the values of the electron fraction in the CompOSE table DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: Ye_table ! !-- Spacetime fields ! !> Array storing the values of the lapse function on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: lapse_parts !& Array storing the values of the x component of the shift vector !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_parts_x !& Array storing the values of the y component of the shift vector !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_parts_y !& Array storing the values of the z component of the shift vector !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_parts_z !& Array storing the values of the xx component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xx_parts !& Array storing the values of the xy component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xy_parts !& Array storing the values of the xz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xz_parts !& Array storing the values of the xz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yy_parts !& Array storing the values of the yz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yz_parts !& Array storing the values of the zz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_zz_parts ! !-- SPH fields ! !& 1-D array storing baryon density in the local rest frame !  [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}], computed directly from !  the |lorene| density DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nlrf !& 1-D array storing baryon density in the local rest frame !  [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}], computed from the kernel !  interpolated proper baryon number density [[particles:nstar_int]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nlrf_int !> 1-D array storing the baryon number per particle DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nu !& 1-D array storing the SPH estimate of the proper baryon number density !  [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nstar !& 1-D array storing the particle number density !  [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: particle_density !& 1-D array storing the SPH estimate of the proper baryon number density, !  from kernel interpolation [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nstar_int !& 1-D array storing the SPH estimate of the particle number density, from !  kernel interpolation [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: particle_density_int !> 2-D array storing the coordinate fluid 4-velocity [c] DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: v !> 1-D array storing the generalized Lorentz factor DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: Theta !> 1-D array storing the electron fraction DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: Ye !> 1-D array storing the smoothing length L_\\odot DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: h !> 1-D array storing the particle volumes L_\\odot&#94;3 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pvol !> 1-D array storing the particle masses M_\\odot DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pmass !> Baryonic masses of the matter objects M_\\odot DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: masses !& Ratio of baryonic masses of the stars M_\\odot !  @warning always < 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: mass_ratios DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: mass_fractions !> Total grid volume !DOUBLE PRECISION:: vol, vol1, vol2 !> Volume per particle !DOUBLE PRECISION:: vol_a, vol1_a, vol2_a !> Ratio between the max and min of the baryon number per particle DOUBLE PRECISION :: nu_ratio !> Total baryon number DOUBLE PRECISION :: nbar_tot !> Baryon number on star 1 !DOUBLE PRECISION:: nbar1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nbar_i !> Baryon number on star 2 !DOUBLE PRECISION:: nbar2 !> Baryon number ratio on both stars DOUBLE PRECISION :: nuratio !> Baryon number ratio on star 1 !DOUBLE PRECISION:: nuratio1 !> Baryon number ratio on star 2 !DOUBLE PRECISION:: nuratio2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nuratio_i !> Polytropic index for single polytropic EOS for star 1 !DOUBLE PRECISION:: gamma_sp1= 0.0D0 !> Polytropic constant for single polytropic EOS for star 1 @todo add units !DOUBLE PRECISION:: kappa_sp1= 0.0D0 !> Polytropic index for single polytropic EOS for star 2 !DOUBLE PRECISION:: gamma_sp2= 0.0D0 !> Polytropic constant for single polytropic EOS for star 2 @todo add units !DOUBLE PRECISION:: kappa_sp2= 0.0D0 ! !-- Strings ! !> String containing the name of the particles parameter file CHARACTER ( LEN = 50 ) :: lorene_bns_id_parfile !> String storing the local path to the directory containing the CompOSE EOS CHARACTER ( LEN = : ), ALLOCATABLE :: compose_path !> String storing the subpath of compose_path to the CompOSE file with !  .beta extension CHARACTER ( LEN = : ), ALLOCATABLE :: compose_filename !> String containing the |lorene| name of the EOS for star 1 !   CHARACTER( LEN= : ), ALLOCATABLE:: eos1 !> String containing the |lorene| name of the EOS for star 2 !   CHARACTER( LEN= : ), ALLOCATABLE:: eos2 TYPE ( eos ), DIMENSION (:), ALLOCATABLE :: all_eos ! !-- Steering variables ! !> `.TRUE.` if the object is empty, `.FALSE.` if it's not empty LOGICAL :: empty_object !& `.TRUE.` if the binary files for SPHINCS_BSSN are to be exported, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_bin !& `.TRUE.` if the ID in the formatted files is to be on the xy plane only, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_form_xy !& `.TRUE.` if the ID in the formatted files is to be on the x axis only, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_form_x !& `.TRUE.` if the threshold on the baryon mass density should e applied !  when placing particles on lattices, `.FALSE.` otherwise LOGICAL :: use_thres !& `.TRUE.` if the baryon number per particle should be reassigned, trying !  to obtain a baryon number ratio no larger than nu_ratio, !  when placing particles on lattices; `.FALSE.` otherwise LOGICAL :: redistribute_nu !& `.TRUE.` if the baryon number per particle should be corrected to account !  for the total baryon masses of the stars, `.FALSE.` otherwise LOGICAL :: correct_nu !& `.TRUE.` if the electron fraction Y_e should be read from the CompOSE !  table with extension.beta, `.FALSE.` otherwise !  @todo Chamge name of this variable to assign_Ye_compose. Check that !        the used EOS is indeed the one used to read Y_e LOGICAL :: compose_eos !& `.TRUE.` if the particle positions on spherical surfaces are randomized !  in the \\phi direction, `.FALSE.` otherwise LOGICAL :: randomize_phi !& `.TRUE.` if the particle positions on spherical surfaces are randomized !  in the \\theta direction, `.FALSE.` otherwise LOGICAL :: randomize_theta !& `.TRUE.` if the particle positions on spherical surfaces are randomized !  in the r direction, `.FALSE.` otherwise LOGICAL :: randomize_r !& `.TRUE.` if the Artificial Pressure Method (APM) has to be applied to the !  particles on star 1, `.FALSE.` otherwise LOGICAL , DIMENSION (:), ALLOCATABLE :: apm_iterate !& `.TRUE.` if the baryon number per particle \\nu has to be read from the !  formatted file containing the particle positions, `.FALSE.` otherwise LOGICAL :: read_nu !& `.TRUE.` if the particles on star 2 should be the reflection of the !  particles on star 1 with respect to the yz plane, only if the baryon !  masses of the stars differe less than 0.2\\%; `.FALSE.` otherwise LOGICAL :: reflect_particles_x ! !-- Timers ! !> Timer that times how long it takes to place particles on the stars TYPE ( timer ), PUBLIC :: placer_timer !& Timer that times how long it takes to check if there are multiple !  particles at the same positions TYPE ( timer ), PUBLIC :: same_particle_timer !& Timer that times how long it takes to perform the APM on the matter !  objects TYPE ( timer ), DIMENSION (:), ALLOCATABLE , PUBLIC :: apm_timers !& Timer that times how long it takes to import the \\texttt{|lorene|} ID !  at the particle positions TYPE ( timer ), PUBLIC :: importer_timer !& Timer that times how long it takes to compute the SPH variables at the !  particle pitions TYPE ( timer ), PUBLIC :: sph_computer_timer CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: place_particles_lattice !! Places particles on a single lattice that surrounds both stars !  PROCEDURE:: place_particles_lattices !! Places particles on two lattices, each one surrounding one star PROCEDURE :: place_particles_spherical_surfaces !! Places particles on spherical surfaces on one star PROCEDURE , NOPASS :: perform_apm !! Performs the Artificial Pressure Method (APM) on one star's particles !  GENERIC:: reshape_sph_field => reshape_sph_field_1d_ptr, & !                                 reshape_sph_field_2d_ptr !  !# GENERIC PROCEDURE, overloded to reallocate 1d and 2d arrays !  PROCEDURE:: reshape_sph_field_1d_ptr => reshape_sph_field_1d !  !! Reallocates a 1d array !  PROCEDURE:: reshape_sph_field_2d_ptr => reshape_sph_field_2d !  !! Reallocates a 2d array PROCEDURE :: allocate_lorene_id_parts_memory !! Allocates memory for the [[particles]] member arrays PROCEDURE :: deallocate_lorene_id_parts_memory !! Deallocates memory for the [[particles]] member arrays PROCEDURE :: read_compose_composition !! Reads the Y_e(n_b) table in the CompOSE file with extension .beta PROCEDURE :: compute_Ye !# Interpates linearly the electron fraction Y_e at the particle !  densities; that is, assigns Y_e at the particle positions PROCEDURE , PUBLIC :: analyze_hydro !# Scans the hydro fields taken from \\texttt{|lorene|} to look !  for negative or zero values PROCEDURE , PUBLIC :: compute_and_export_SPH_variables !# Computes the SPH variables at the particle positions, and optionally !  prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} !  and \\texttt{splash}, and to a formatted file to be read by !  \\texttt{gnuplot}, by calling !  [[particles:print_formatted_lorene_id_particles]] PROCEDURE , PUBLIC :: read_sphincs_dump_print_formatted !# Reads the binary ID file printed by !  [[particles:compute_and_export_SPH_variables]] PROCEDURE , PUBLIC :: print_formatted_lorene_id_particles !! Prints the SPH ID to a formatted file PROCEDURE , PUBLIC :: is_empty !# Returns `.TRUE` if the [[particles]] object is empty, `.FALSE` otherwise !  @warning experimental, not actively used in the code yet !PROCEDURE, PUBLIC:: write_lorene_bns_id_dump !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE , PUBLIC :: get_npart !! Returns [[particles:npart]] PROCEDURE , PUBLIC :: get_npart1 !! Returns [[particles:npart1]] PROCEDURE , PUBLIC :: get_npart2 !! Returns [[particles:npart2]] PROCEDURE , PUBLIC :: get_nuratio !! Returns [[particles:nuratio]] PROCEDURE , PUBLIC :: get_nuratio1 !! Returns [[particles:nuratio1]] PROCEDURE , PUBLIC :: get_nuratio2 !! Returns [[particles:nuratio2]] PROCEDURE , PUBLIC :: get_pos !! Returns [[particles:pos]] PROCEDURE , PUBLIC :: get_vel !! Returns [[particles:v]] PROCEDURE , PUBLIC :: get_nlrf !! Returns [[particles:nlrf]] PROCEDURE , PUBLIC :: get_nu !! Returns [[particles:nu]] PROCEDURE , PUBLIC :: get_u !! Returns [[particles:specific_energy_parts]] PROCEDURE , PUBLIC :: get_pressure !! Returns [[particles:pressure_parts]] PROCEDURE , PUBLIC :: get_pressure_cu !! Returns [[particles:pressure_parts_cu]] PROCEDURE , PUBLIC :: get_theta !! Returns [[particles:theta]] PROCEDURE , PUBLIC :: get_h !! Returns [[particles:h]] FINAL :: destruct_particles !! Finalizer (Destructor) of [[particles]] object END TYPE particles ! !-- Interface of the TYPE particles (i.e., declaration of the constructor) !-- Multiple procedures in this interface would overload the constructor. !-- Such procedures must have distingushable interfaces, in particular !-- distinguishable arguments) ! INTERFACE particles !! Interface of TYPE [[particles]] MODULE PROCEDURE construct_particles !! Constructs a [[particles]] object END INTERFACE particles ! !-- Interface of the constructor of TYPE particles !-- Its implementation is in submodule_particles_constructor.f90 ! INTERFACE MODULE FUNCTION construct_particles ( id , dist ) RESULT ( parts ) !! Constructs a [[particles]] object CLASS ( idbase ), INTENT ( IN OUT ) :: id !# [[idbase]] object representing the BNS for which we want to place !  particles INTEGER , INTENT ( IN ) :: dist !# Identifier of the desired particle distribution: ! !  - 0: Read particle positions (and optionally the baryon number per !     particle \\nu) from a formatted file ! !  - 1: Place particles on a single lattice that surrounds both stars ! !  - 2: Place particles on two lattices, each one surrounding a star ! !  - 3: Place particles on spherical surfaces inside the stars ! !  @warning Method 1 is almost deprecated, since method 2 is effectively !           an improvement of method 1 TYPE ( particles ) :: parts !! Constructed [[particles]] object END FUNCTION construct_particles !MODULE FUNCTION construct_particles_empty() & !                    RESULT ( parts_sl_obj ) !    TYPE(particles)             :: parts_sl_obj ! !END FUNCTION construct_particles_empty END INTERFACE ! !-- Interfaces of the methods of TYPE particles called by its constructor !-- Their implementations are in submodule_particles_constructor.f90 ! INTERFACE !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE SUBROUTINE place_particles_lattice ( THIS , & central_density , & xmin , xmax , ymin , ymax , zmin , zmax , & npart_des , npart_out , stretch , & thres , pos , pvol , & get_density , validate_position ) !! Places particles on a lattice containing a physical object CLASS ( particles ), INTENT ( IN OUT ) :: THIS !! [[particles]] object which this PROCEDURE is a member of DOUBLE PRECISION , INTENT ( IN ) :: central_density !! Maximum baryon mass density of the system INTEGER , INTENT ( IN ) :: npart_des !! Desired particle number DOUBLE PRECISION , INTENT ( IN ) :: xmin !! Left x boundary of the lattice DOUBLE PRECISION , INTENT ( IN ) :: xmax !! Right x boundary of the lattice DOUBLE PRECISION , INTENT ( IN ) :: ymin !! Left y boundary of the lattice DOUBLE PRECISION , INTENT ( IN ) :: ymax !! Right y boundary of the lattice DOUBLE PRECISION , INTENT ( IN ) :: zmin !! Left z boundary of the lattice DOUBLE PRECISION , INTENT ( IN ) :: zmax !! Right z boundary of the lattice DOUBLE PRECISION , INTENT ( IN ) :: stretch !! Stretching factor fo the lattice. `xmin` to `zmax` are multiplied by it DOUBLE PRECISION , INTENT ( IN ) :: thres !# (~rho_max)/thres is the minimum mass density considered ! when placing particles. Used only when redistribute_nu is ! .FALSE. . When redistribute_nu is .TRUE. thres= 100*nu_ratio INTEGER , INTENT ( OUT ) :: npart_out !! Real, output particle number DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: pos !> Array soring the inal particle volumes DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: pvol !! Array storing the final particle volumes INTERFACE FUNCTION get_density ( x , y , z ) RESULT ( density ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION :: density !! Baryon mass density at (x,y,z) END FUNCTION get_density END INTERFACE INTERFACE FUNCTION validate_position_int ( x , y , z ) RESULT ( answer ) !! Returns 1 if the position is not valid, 0 otherwise DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point INTEGER :: answer !! 1 if the position is not valid, 0 otherwise END FUNCTION validate_position_int END INTERFACE !> Returns 1 if the position is not valid, 0 otherwise PROCEDURE ( validate_position_int ), OPTIONAL :: validate_position END SUBROUTINE place_particles_lattice !  MODULE SUBROUTINE place_particles_lattices( THIS, & !                                xmin1, xmax1, ymin1, ymax1, zmin1, zmax1, & !                                xmin2, xmax2, ymin2, ymax2, zmin2, zmax2, & !                                nx, ny, nz, & !                                thres, id ) !  !! Places particles on two lattices, each one surrounding one star ! !    !> [[particles]] object which this PROCEDURE is a member of !    CLASS(particles), INTENT( IN OUT ):: THIS !    !& [[idbase]] object needed to access the BNS data !    CLASS(idbase),       INTENT( IN OUT ):: id !    !& Number of lattice points on the less massive star !    !  in the x direction !    INTEGER,          INTENT( IN )    :: nx !    !& Number of lattice points on the less massive star !    !  in the y direction !    INTEGER,          INTENT( IN )    :: ny !    !& Number of lattice points on the less massive star !    !  in the z direction !    INTEGER,          INTENT( IN )    :: nz !    !> Left x boundary of the lattice on star 1 !    DOUBLE PRECISION, INTENT( IN )    :: xmin1 !    !> Right x boundary of the lattice on star 1 !    DOUBLE PRECISION, INTENT( IN )    :: xmax1 !    !> Left y boundary of the lattice on star 1 !    DOUBLE PRECISION, INTENT( IN )    :: ymin1 !    !> Right y boundary of the lattice on star 1 !    DOUBLE PRECISION, INTENT( IN )    :: ymax1 !    !> Left z boundary of the lattice on star 1 !    DOUBLE PRECISION, INTENT( IN )    :: zmin1 !    !> Right z boundary of the lattice on star 1 !    DOUBLE PRECISION, INTENT( IN )    :: zmax1 !    !> Left x boundary of the lattice on star 2 !    DOUBLE PRECISION, INTENT( IN )    :: xmin2 !    !> Right x boundary of the lattice on star 2 !    DOUBLE PRECISION, INTENT( IN )    :: xmax2 !    !> Left y boundary of the lattice on star 2 !    DOUBLE PRECISION, INTENT( IN )    :: ymin2 !    !> Right y boundary of the lattice on star 2 !    DOUBLE PRECISION, INTENT( IN )    :: ymax2 !    !> Left z boundary of the lattice on star 2 !    DOUBLE PRECISION, INTENT( IN )    :: zmin2 !    !> Right z boundary of the lattice on star 2 !    DOUBLE PRECISION, INTENT( IN )    :: zmax2 !    !& (~rho_max)/thres is the minimum mass density considered !    ! when placing particles on each star. Used only when redistribute_nu is !    ! .FALSE. . When redistribute_nu is .TRUE. thres= 100*nu_ratio !    DOUBLE PRECISION, INTENT( IN )    :: thres ! !  END SUBROUTINE place_particles_lattices MODULE SUBROUTINE place_particles_spherical_surfaces ( THIS , & mass_star , radius , center , & central_density , npart_approx , & npart_out , pos , pvol , pmass , & last_r , upper_bound , lower_bound , & upper_factor , lower_factor , max_steps , & filename_mass_profile , filename_shells_radii ,& filename_shells_pos , & get_density , integrate_density , & get_id , validate_position ) !! Places particles on spherical surfaces on one star !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !& [[idbase]] object needed to access the BNS data !  @TODO Remove the [[idbase]] argument as done in SUBROUTINE perform_apm !CLASS(idbase),       INTENT( IN OUT ):: id !> Approximate particle number on the star INTEGER , INTENT ( IN ) :: npart_approx !> Final number of particles on the star INTEGER , INTENT ( OUT ) :: npart_out !& If, after max_steps, the iteration did not converge, !  multiply upper_bound by upper_factor, and lower_bound !  by lower_factor. max_steps >= 10. 100 is a nice value INTEGER , INTENT ( IN ) :: max_steps !> Baryonic mass of the star DOUBLE PRECISION , INTENT ( IN ) :: mass_star !> Radius of the star in the x direction towards the companion DOUBLE PRECISION , INTENT ( IN ) :: radius !& x|) coordinate of the center of the star, i.e., !  of the point with highest density DOUBLE PRECISION , INTENT ( IN ) :: center !> Central density of the star, i.e., highest density DOUBLE PRECISION , INTENT ( IN ) :: central_density !> Radius of the last spherical surface DOUBLE PRECISION , INTENT ( IN ) :: last_r !& If, after max_steps, the iteration did not converge, !  multiply upper_bound by upper_factor, and lower_bound !  by lower_factor. upper_factor >= 1, usually an increase of 1% works DOUBLE PRECISION , INTENT ( IN ) :: upper_factor !& If, after max_steps, the iteration did not converge, !  multiply upper_bound by upper_factor, and lower_bound !  by lower_factor. lower_factor <= 1, usually a decrease of 1% works DOUBLE PRECISION , INTENT ( IN ) :: lower_factor !& Desired upper bound for the differences between particle !  masses on neighbouring spherical surfaces DOUBLE PRECISION , INTENT ( INOUT ) :: upper_bound !& Desired lower bound for the differences between particle !  masses on neighbouring spherical surfaces DOUBLE PRECISION , INTENT ( INOUT ) :: lower_bound !> Array string the final positions DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( OUT ) :: pos !> Array soring the inal particle volumes DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: pvol !> Array storing the final particle masses DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: pmass !> Name of the file to store the radial mass profile CHARACTER ( LEN = * ), INTENT ( INOUT ), OPTIONAL :: filename_mass_profile !& Name of the file to store the surface radii !  @TODO change name of variable to filename_surfaces_radii CHARACTER ( LEN = * ), INTENT ( INOUT ), OPTIONAL :: filename_shells_radii !& Name of the file to store the final particle positions !  @TODO change name of variable to filename_surfaces_pos CHARACTER ( LEN = * ), INTENT ( INOUT ), OPTIONAL :: filename_shells_pos INTERFACE FUNCTION get_density ( x , y , z ) RESULT ( density ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION :: density !! Baryon mass density at (x,y,z) END FUNCTION get_density END INTERFACE INTERFACE SUBROUTINE get_id ( x , y , z , g_xx , baryon_density , gamma_euler ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION , INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , INTENT ( IN OUT ) :: gamma_euler END SUBROUTINE get_id END INTERFACE INTERFACE SUBROUTINE integrate_density ( center , radius , & central_density , & dr , dth , dphi , & mass , mass_profile , & mass_profile_idx ) !& Array to store the indices for array mass_profile, sorted so that !  mass_profile[mass_profile_idx] is in increasing order INTEGER , DIMENSION (:), ALLOCATABLE , INTENT ( IN OUT ) :: mass_profile_idx !> Center of the star DOUBLE PRECISION , INTENT ( IN ) :: center !> Central density of the star DOUBLE PRECISION , INTENT ( IN ) :: central_density !> Radius of the star DOUBLE PRECISION , INTENT ( IN ) :: radius !> Integration steps DOUBLE PRECISION , INTENT ( IN ) :: dr , dth , dphi !> Integrated mass of the star DOUBLE PRECISION , INTENT ( IN OUT ) :: mass !> Array storing the radial mass profile of the star DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( IN OUT ) :: & mass_profile END SUBROUTINE integrate_density END INTERFACE INTERFACE FUNCTION validate_position_int ( x , y , z ) RESULT ( answer ) !! Returns 1 if the position is not valid, 0 otherwise DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point INTEGER :: answer !! 1 if the position is not valid, 0 otherwise END FUNCTION validate_position_int END INTERFACE !> Returns 1 if the position is not valid, 0 otherwise PROCEDURE ( validate_position_int ), OPTIONAL :: validate_position END SUBROUTINE place_particles_spherical_surfaces !    MODULE SUBROUTINE reshape_sph_field_1d( THIS, field, new_size1, new_size2, & !                                            index_array ) !    !! Reallocates a 1d array ! !      !> [[particles]] object which this PROCEDURE is a member of !      CLASS(particles), INTENT( IN OUT ):: THIS !      !> New particle number on star 1 !      INTEGER,                        INTENT( IN ):: new_size1 !      !> New particle number on star 2 !      INTEGER,                        INTENT( IN ):: new_size2 !      !> Array to select elements to keep in the reshaped array !      INTEGER,          DIMENSION(:), INTENT( IN ):: index_array !      !> 1D array to reshape !      DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE, INTENT( IN OUT ):: field ! !    END SUBROUTINE reshape_sph_field_1d ! ! !    MODULE SUBROUTINE reshape_sph_field_2d( THIS, field, new_size1, new_size2, & !                                            index_array ) !    !! Reallocates a 2d array ! !      !> [[particles]] object which this PROCEDURE is a member of !      CLASS(particles), INTENT( IN OUT ):: THIS !      !> New particle number on star 1 !      INTEGER,                        INTENT( IN ):: new_size1 !      !> New particle number on star 2 !      INTEGER,                        INTENT( IN ):: new_size2 !      !> Array to select elements to keep in the reshaped array !      INTEGER,          DIMENSION(:), INTENT( IN ):: index_array !      !> 2D array to reshape !      DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE, INTENT( IN OUT ):: field ! !    END SUBROUTINE reshape_sph_field_2d MODULE SUBROUTINE allocate_lorene_id_parts_memory ( THIS ) !! Allocates allocatable arrays member of a [[particles]] object !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS END SUBROUTINE allocate_lorene_id_parts_memory MODULE SUBROUTINE deallocate_lorene_id_parts_memory ( THIS ) !! Deallocates allocatable arrays member of a [[particles]] object !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS END SUBROUTINE deallocate_lorene_id_parts_memory END INTERFACE ! !-- Interfaces of the methods of TYPE particles !-- Their implementations are in module_particles_methods.f90 ! INTERFACE MODULE SUBROUTINE analyze_hydro ( THIS , namefile ) !# Scans the hydro fields taken from \\texttt{|lorene|} to look !  for negative or zero values !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !& Name of the formatted file where the particle positions at which !  some of the hydro fields are negative or zero are printed to CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE analyze_hydro MODULE SUBROUTINE compute_and_export_SPH_variables ( THIS , namefile ) !# Computes the SPH variables at the particle positions, and optionally !  prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} !  and \\texttt{splash}, and to a formatted file to be read by !  \\texttt{gnuplot}, by calling !  [[particles:print_formatted_lorene_id_particles]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> Name of the formatted file where the SPH ID is printed to CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE compute_and_export_SPH_variables MODULE SUBROUTINE perform_apm ( get_density , & get_nstar_p , & pos_input , & pvol , h_output , nu_output , & center , & com_star , & mass , & radx_comp , radx_opp , & rady , radz , & apm_max_it , max_inc , & mass_it , correct_nu , nuratio_thres , & nuratio_des , & nx_gh , ny_gh , nz_gh , & namefile_pos_id , namefile_pos , & namefile_results , & validate_position ) !! Performs the Artificial Pressure Method (APM) on one star's particles !> [[particles]] object which this PROCEDURE is a member of !CLASS(particles),                 INTENT( INOUT ):: THIS INTERFACE FUNCTION get_density ( x , y , z ) RESULT ( density ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION :: density !! Baryon mass density at (x,y,z) END FUNCTION get_density END INTERFACE INTERFACE SUBROUTINE get_nstar_p ( npart_real , x , y , z , nstar_p ) !! Computes the proper baryon number density at the particle positions INTEGER , INTENT ( IN ) :: npart_real !! Number of real particles (i.e., no ghost particles included here) DOUBLE PRECISION , INTENT ( IN ) :: x ( npart_real ) !! Array of x coordinates DOUBLE PRECISION , INTENT ( IN ) :: y ( npart_real ) !! Array of y coordinates DOUBLE PRECISION , INTENT ( IN ) :: z ( npart_real ) !! Array of z coordinates DOUBLE PRECISION , INTENT ( OUT ) :: nstar_p ( npart_real ) !! Array to store the computed proper baryon number density END SUBROUTINE get_nstar_p END INTERFACE INTERFACE FUNCTION validate_position_int ( x , y , z ) RESULT ( answer ) !! Returns 1 if the position is not valid, 0 otherwise DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point INTEGER :: answer !! 1 if the position is not valid, 0 otherwise END FUNCTION validate_position_int END INTERFACE !> Returns 1 if the position is not valid, 0 otherwise PROCEDURE ( validate_position_int ), OPTIONAL :: validate_position !> Initial particle positions DOUBLE PRECISION , DIMENSION (:,:), INTENT ( INOUT ) :: pos_input !> Initial particle volume DOUBLE PRECISION , DIMENSION (:), INTENT ( INOUT ) :: pvol !& Array to store the smoothing lengths computed at the end of the !  APM iteration DOUBLE PRECISION , DIMENSION (:), INTENT ( OUT ) :: h_output !& Array to store the baryon number per particle computed at the end of !  the APM iteration DOUBLE PRECISION , DIMENSION (:), INTENT ( OUT ) :: nu_output !> Center of the star (point of highest density), computed by |lorene| DOUBLE PRECISION , INTENT ( IN ) :: center !> Center of mass of the star, computed by |lorene| DOUBLE PRECISION , INTENT ( IN ) :: com_star !> Mass of the star DOUBLE PRECISION , INTENT ( IN ) :: mass !> Radius of the star in the x direction, towards the companion DOUBLE PRECISION , INTENT ( IN ) :: radx_comp !> Radius of the star in the x direction, opposite to companion DOUBLE PRECISION , INTENT ( IN ) :: radx_opp !> Radius of the star in the y direction DOUBLE PRECISION , INTENT ( IN ) :: rady !> Radius of the star in the z direction DOUBLE PRECISION , INTENT ( IN ) :: radz !> Maximum number of APM iterations, irrespective of the EXIT condition INTEGER , INTENT ( IN ) :: apm_max_it !& Sets the EXIT condition: If the average over all the !  particles of the relative error in the density estimate !  grows max_inc times, exit the iteration. INTEGER , INTENT ( IN ) :: max_inc !& If .TRUE. performs a second iteration after the APM one, without moving !  the particles, changing their mass in order to better match !  the star density. The mass ratio grows very fast in all the tried !  experiments, hence the suggested value is .FALSE. LOGICAL , INTENT ( IN ) :: mass_it !& If .TRUE., the baryon number per particle nu is corrected !  to include the total baryonic masses of the !  stars. LOGICAL , INTENT ( IN ) :: correct_nu !& Maximum mass ratio (equivalently baryon number ratio) !  to be used in the one-time-only final correction !  of the particle masses to match the star density even !  better (without moving the particles) DOUBLE PRECISION , INTENT ( IN ) :: nuratio_thres !& Sets the EXIT condition: If the baryon number ratio !  is within 2.5% of nuratio_des, exit the iteration !  Set nuratio_des to 0 to deactivate and exit the APM !  iteration using max_inc DOUBLE PRECISION , INTENT ( IN ) :: nuratio_des !> Number of lattice points in the x direction for ghosts INTEGER , INTENT ( IN ) :: nx_gh !> Number of lattice points in the y direction for ghosts INTEGER , INTENT ( IN ) :: ny_gh !> Number of lattice points in the z direction for ghosts INTEGER , INTENT ( IN ) :: nz_gh !> Name for the formatted file where the initial particle positions !  and the ghost positions will be printed CHARACTER ( LEN = * ), INTENT ( INOUT ), OPTIONAL :: & namefile_pos_id !> Name for the formatted file where the particle positions !  and the ghost positions will be printed every 15 iterations CHARACTER ( LEN = * ), INTENT ( INOUT ), OPTIONAL :: & namefile_pos !> Name for the formatted file where various quantities related !  to the particle distribution, the baryon number particle and the !  kernel estimate of the density will be printed at the end of !  the APM iteration CHARACTER ( LEN = * ), INTENT ( INOUT ), OPTIONAL :: & namefile_results END SUBROUTINE perform_apm MODULE SUBROUTINE read_sphincs_dump_print_formatted ( THIS , namefile_bin , & namefile ) !# Reads the binary ID file printed by !  [[particles:compute_and_export_SPH_variables]] !   and prints the data stored in it to a formatted file !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> Name of the binary file to be read CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile_bin !> Name of the formatted file to be printed CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE read_sphincs_dump_print_formatted MODULE SUBROUTINE print_formatted_lorene_id_particles ( THIS , namefile ) !! Prints the SPH ID to a formatted file !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> Name of the formatted output file CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE print_formatted_lorene_id_particles MODULE SUBROUTINE read_compose_composition ( THIS , namefile ) !! Reads the Y_e(n_b) table in the CompOSE file with extension .beta !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !& To read the file great_eos.beta in directory compose_path/GREAT_EoS, !  namefile=\"GREAT_EoS/great_eos\" CHARACTER ( LEN = * ), INTENT ( IN OUT ), OPTIONAL :: namefile END SUBROUTINE read_compose_composition MODULE SUBROUTINE compute_Ye ( THIS ) !, nlrf, Ye ) !# Interpolates linearly the electron fraction Y_e at the particle !  densities; that is, assigns Y_e at the particle positions !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !DOUBLE PRECISION, DIMENSION( : ), INTENT( IN ):: nlrf !DOUBLE PRECISION, DIMENSION( : ), INTENT( OUT ):: Ye END SUBROUTINE compute_Ye MODULE SUBROUTINE destruct_particles ( THIS ) !> Finalizer (Destructor) of [[particles]] object !> [[particles]] object which this PROCEDURE is a member of TYPE ( particles ), INTENT ( IN OUT ) :: THIS END SUBROUTINE destruct_particles !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE FUNCTION is_empty ( THIS ) RESULT ( answer ) !# Returns `.TRUE` if the [[particles]] object is empty, `.FALSE` otherwise !  @warning experimental, not actively used in the code yet !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN ) :: THIS !> `.TRUE` if the [[particles]] object is empty, `.FALSE` otherwise LOGICAL :: answer END FUNCTION is_empty !MODULE SUBROUTINE write_lorene_bns_id_dump( THIS, namefile ) ! !    CLASS(particles),    INTENT( IN )               :: THIS !    CHARACTER( LEN= * ), INTENT( IN OUT ), OPTIONAL :: namefile ! !END SUBROUTINE write_lorene_bns_id_dump MODULE FUNCTION get_npart ( THIS ) RESULT ( n_part ) !! Returns [[particles:npart]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:npart]] INTEGER :: n_part END FUNCTION get_npart MODULE FUNCTION get_npart1 ( THIS ) RESULT ( n_part ) !! Returns [[particles:npart1]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:npart1]] INTEGER :: n_part END FUNCTION get_npart1 MODULE FUNCTION get_npart2 ( THIS ) RESULT ( n_part ) !! Returns [[particles:npart2]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:npart2]] INTEGER :: n_part END FUNCTION get_npart2 MODULE FUNCTION get_nuratio ( THIS ) RESULT ( nuratio ) !! Returns [[particles:nuratio]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:nuratio]] DOUBLE PRECISION :: nuratio END FUNCTION get_nuratio MODULE FUNCTION get_nuratio1 ( THIS ) RESULT ( nuratio1 ) !! Returns [[particles:nuratio1]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:nuratio1]] DOUBLE PRECISION :: nuratio1 END FUNCTION get_nuratio1 MODULE FUNCTION get_nuratio2 ( THIS ) RESULT ( nuratio2 ) !! Returns [[particles:nuratio2]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:nuratio2]] DOUBLE PRECISION :: nuratio2 END FUNCTION get_nuratio2 MODULE FUNCTION get_pos ( THIS ) RESULT ( pos_u ) !! Returns [[particles:pos]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:pos]] DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pos_u END FUNCTION get_pos MODULE FUNCTION get_vel ( THIS ) RESULT ( vel ) !! Returns [[particles:v]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:v]] DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: vel END FUNCTION get_vel MODULE FUNCTION get_nlrf ( THIS ) RESULT ( nlrf ) !! Returns [[particles:nlrf]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:nlrf]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nlrf END FUNCTION get_nlrf MODULE FUNCTION get_nu ( THIS ) RESULT ( nu ) !! Returns [[particles:nu]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:nu]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nu END FUNCTION get_nu MODULE FUNCTION get_u ( THIS ) RESULT ( u ) !! Returns [[particles:specific_energy_parts]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:specific_energy_parts]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: u END FUNCTION get_u MODULE FUNCTION get_pressure ( THIS ) RESULT ( pressure ) !! Returns [[particles:pressure_parts]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:pressure_parts]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure END FUNCTION get_pressure MODULE FUNCTION get_pressure_cu ( THIS ) RESULT ( pressure_cu ) !! Returns [[particles:pressure_parts_cu]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:pressure_parts_cu]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_cu END FUNCTION get_pressure_cu MODULE FUNCTION get_theta ( THIS ) RESULT ( theta ) !! Returns [[particles:theta]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:theta]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: theta END FUNCTION get_theta MODULE FUNCTION get_h ( THIS ) RESULT ( h ) !! Returns [[particles:h]] !> [[particles]] object which this PROCEDURE is a member of CLASS ( particles ), INTENT ( IN OUT ) :: THIS !> [[particles:h]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: h END FUNCTION get_h END INTERFACE CONTAINS SUBROUTINE check_particle_positions ( npart , pos , debug ) !************************************************* ! !# Check that the particles are not at the same !  positions ! !  FT 1.9.2021 ! !************************************************* USE NR , ONLY : indexx IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart LOGICAL , INTENT ( IN ), OPTIONAL :: debug DOUBLE PRECISION , DIMENSION ( 3 , npart ), INTENT ( IN ) :: pos INTEGER :: itr , itr2 , x_idx INTEGER , DIMENSION ( npart ) :: x_sort INTEGER , DIMENSION (:), ALLOCATABLE :: x_number PRINT * , \"** Checking that there are not multiple particles\" , & \" at the same position...\" PRINT * ALLOCATE ( x_number ( npart ) ) ! Sort x coordinates of the particles CALL indexx ( npart , pos ( 1 , : ), x_sort ) x_number = 1 itr2 = 1 ! Find the number of times each x appears DO itr = 1 , npart - 1 , 1 IF ( pos ( 1 , x_sort ( itr ) ) == & pos ( 1 , x_sort ( itr + 1 ) ) ) THEN x_number ( itr2 ) = x_number ( itr2 ) + 1 ELSE itr2 = itr2 + 1 ENDIF ENDDO x_number = x_number ( 1 : itr2 ) IF ( SUM ( x_number ) /= npart ) THEN PRINT * , \"** ERROR! The sum of the numbers of particles with the same\" , & \" x is not equal to the particle number.\" PRINT * , \" * SUM( x_number )=\" , SUM ( x_number ), \", \" , & \"npart=\" , npart PRINT * , \" * Stopping...\" PRINT * STOP ENDIF IF ( PRESENT ( debug ) . AND . debug . EQV . . TRUE . ) THEN !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, x_sort, x_number ) & !$OMP             PRIVATE( itr, itr2, x_idx ) DO itr = 1 , SIZE ( x_number ), 1 IF ( itr == 1 ) THEN x_idx = 1 ELSE x_idx = SUM ( x_number ( 1 : itr - 1 )) + 1 ENDIF DO itr2 = x_idx , x_idx + x_number ( itr ) - 2 , 1 ! If they do not have the same x IF ( pos ( 1 , x_sort ( itr2 ) ) /= & pos ( 1 , x_sort ( itr2 + 1 ) ) ) THEN PRINT * , \"** ERROR! \" , \"The two particles \" , x_sort ( itr2 ), & \" and\" , x_sort ( itr2 + 1 ), & \" do not have the same x, but should!\" PRINT * , pos ( :, x_sort ( itr2 ) ) PRINT * , pos ( :, x_sort ( itr2 + 1 ) ) PRINT * , \" * Stopping...\" PRINT * STOP ENDIF ENDDO ENDDO !$OMP END PARALLEL DO ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, x_sort, x_number ) & !$OMP             PRIVATE( itr, itr2, x_idx ) DO itr = 1 , SIZE ( x_number ), 1 IF ( itr == 1 ) THEN x_idx = 1 ELSE x_idx = SUM ( x_number ( 1 : itr - 1 )) + 1 ENDIF DO itr2 = x_idx , x_idx + x_number ( itr ) - 2 , 1 ! If they have the same y IF ( pos ( 2 , x_sort ( itr2 ) ) == & pos ( 2 , x_sort ( itr2 + 1 ) ) ) THEN ! If they have the same z IF ( pos ( 3 , x_sort ( itr2 ) ) == & pos ( 3 , x_sort ( itr2 + 1 ) ) ) THEN ! They are the same PRINT * , \"** ERROR! \" , \"The two particles \" , x_sort ( itr2 ), & \" and\" , x_sort ( itr2 + 1 ), \" have the same coordinates!\" PRINT * , pos ( :, x_sort ( itr2 ) ) PRINT * , pos ( :, x_sort ( itr2 + 1 ) ) PRINT * , \" * Stopping...\" PRINT * STOP ENDIF ENDIF ENDDO ENDDO !$OMP END PARALLEL DO DEALLOCATE ( x_number ) END SUBROUTINE check_particle_positions FUNCTION check_particle_position ( npart , pos , pos_a ) RESULT ( cnt ) !***************************************************** ! !# Return the number of times that pos_a appears !  in the array pos ! !  FT 13.10.2021 ! !***************************************************** !USE NR,             ONLY: indexx IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart DOUBLE PRECISION , DIMENSION ( 3 , npart ), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION ( 3 ), INTENT ( IN ) :: pos_a INTEGER :: cnt INTEGER :: itr , itr2 , size_x !, cnt INTEGER , DIMENSION ( npart ) :: x_sort , cnts INTEGER , DIMENSION ( npart ) :: x_number INTEGER , DIMENSION (:), ALLOCATABLE :: x_number_filt ! Sort x coordinates of the particles !CALL indexx( npart, pos( 1, : ), x_sort ) x_number = 0 itr2 = 0 ! Find the number of times that the x coordinate of pos_a appears in pos !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, pos_a, x_sort, x_number, npart ) & !$OMP             PRIVATE( itr ) DO itr = 1 , npart , 1 IF ( pos ( 1 , itr ) == pos_a ( 1 ) ) THEN !itr2= itr2 + 1 x_number ( itr ) = itr !ELSEIF( pos( 1, x_sort(itr) ) > pos_a( 1 ) )THEN ! !  EXIT ENDIF ENDDO !$OMP END PARALLEL DO x_number_filt = PACK ( x_number , x_number /= 0 ) size_x = SIZE ( x_number_filt ) cnts = 0 !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, pos_a, x_sort, x_number_filt, size_x, cnts )& !$OMP             PRIVATE( itr ) DO itr = 1 , size_x , 1 ! If they have the same y IF ( pos ( 2 , x_number_filt ( itr ) ) == pos_a ( 2 ) ) THEN ! If they have the same z IF ( pos ( 3 , x_number_filt ( itr ) ) == pos_a ( 3 ) ) THEN cnts ( itr ) = cnts ( itr ) + 1 ENDIF ENDIF ENDDO !$OMP END PARALLEL DO cnt = SUM ( cnts ) END FUNCTION check_particle_position END MODULE particles_id","tags":"","loc":"sourcefile/module_particles_id.f90.html"},{"title":"submodule_particles_access.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_access.f90~~EfferentGraph sourcefile~submodule_particles_access.f90 submodule_particles_access.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_access.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_access Source Code submodule_particles_access.f90 Source Code ! File:         submodule_particles_access.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_access !************************************************** ! !# This SUBMODULE contains the implementation of !  the methods of TYPE particles !  that allow to access PRIVATE members. ! !  FT 12.07.2021 ! !************************************************** IMPLICIT NONE CONTAINS !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE get_npart !************************************************ ! !# Returns the total number of particles ! !  FT ! !************************************************ IMPLICIT NONE n_part = THIS % npart END PROCEDURE get_npart MODULE PROCEDURE get_npart1 !************************************************ ! !# Returns the number of particles on star 1 ! !  FT 27.04.2021 ! !************************************************ IMPLICIT NONE n_part = THIS % npart_i ( 1 ) END PROCEDURE get_npart1 MODULE PROCEDURE get_npart2 !************************************************ ! !# Returns the number of particles on star 2 ! !  FT 27.04.2021 ! !************************************************ IMPLICIT NONE n_part = THIS % npart_i ( 2 ) END PROCEDURE get_npart2 MODULE PROCEDURE get_nuratio !************************************************ ! !# Returns the baryon number ratio on the stars ! !  FT 27.04.2021 ! !************************************************ IMPLICIT NONE nuratio = THIS % nuratio END PROCEDURE get_nuratio MODULE PROCEDURE get_nuratio1 !************************************************ ! !# Returns the baryon number ratio on star 1 ! !  FT 27.04.2021 ! !************************************************ IMPLICIT NONE nuratio1 = THIS % nuratio_i ( 1 ) END PROCEDURE get_nuratio1 MODULE PROCEDURE get_nuratio2 !************************************************ ! !# Returns the baryon number ratio on star 2 ! !  FT 27.04.2021 ! !************************************************ IMPLICIT NONE nuratio2 = THIS % nuratio_i ( 2 ) END PROCEDURE get_nuratio2 MODULE PROCEDURE get_pos !************************************************ ! !# Returns the array of particle positions ! !  FT ! !************************************************ IMPLICIT NONE pos_u = THIS % pos END PROCEDURE get_pos MODULE PROCEDURE get_vel !************************************************ ! !# Returns the array of coordinate 3-velocity of ! particles ! !  FT ! !************************************************ IMPLICIT NONE vel = THIS % v ( 1 : 3 ,:) END PROCEDURE get_vel MODULE PROCEDURE get_nlrf !************************************************ ! !# Returns the array of baryon density in the ! local rest frame ! !  FT ! !************************************************ IMPLICIT NONE nlrf = THIS % nlrf END PROCEDURE get_nlrf MODULE PROCEDURE get_nu !************************************************ ! !# Returns the array of baryon per particle ! [baryon (Msun_geo)&#94;{-3}] ! !  FT ! !************************************************ IMPLICIT NONE nu = THIS % nu END PROCEDURE get_nu MODULE PROCEDURE get_u !************************************************ ! !# Returns the array of specific internal ! energy [c&#94;2] ! !  FT ! !************************************************ IMPLICIT NONE u = THIS % specific_energy_parts END PROCEDURE get_u MODULE PROCEDURE get_pressure !************************************************ ! !# Returns the array of pressure [kg c&#94;2 m&#94;{-3}] ! !  FT ! !************************************************ IMPLICIT NONE pressure = THIS % pressure_parts END PROCEDURE get_pressure MODULE PROCEDURE get_pressure_cu !************************************************ ! !# Returns the array of pressure in code units ! [amu*c**2/(Msun_geo**3)] ! !  FT ! !************************************************ IMPLICIT NONE pressure_cu = THIS % pressure_parts_cu END PROCEDURE get_pressure_cu MODULE PROCEDURE get_theta !************************************************ ! !# Returns the array of generalized Lorentz ! factor ! !  FT ! !************************************************ IMPLICIT NONE theta = THIS % Theta END PROCEDURE get_theta MODULE PROCEDURE get_h !************************************************ ! !# Returns the array of initial guess for the ! smoothing length [Msun_geo] ! !  FT ! !************************************************ IMPLICIT NONE h = THIS % h END PROCEDURE get_h MODULE PROCEDURE is_empty !************************************************ ! !# Returns the variable empty_object !  @warning experimental, not actively used in !          the code yet ! !  FT ! !************************************************ IMPLICIT NONE answer = THIS % empty_object END PROCEDURE is_empty END SUBMODULE particles_access","tags":"","loc":"sourcefile/submodule_particles_access.f90.html"},{"title":"submodule_particles_compose.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_compose.f90~~EfferentGraph sourcefile~submodule_particles_compose.f90 submodule_particles_compose.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_compose.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_compose Source Code submodule_particles_compose.f90 Source Code ! File:         submodule_particles_compose.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_compose !*************************************************** ! !# This SUBMODULE contains the implementation of !  the methods of TYPE particles !  that compute Ye on the particles, using the !  data from the CompOSE database ! !  https://compose.obspm.fr/ ! !  FT 12.07.2021 ! !*************************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE read_compose_composition !************************************************ ! !# Reads the electron fraction Y_e = n_e/n_b, !  with n_e electron number density and n_b !  baryon number density, from the .compo file !  taken from the CompOSE database of EoS. !  Y_e is given as a function of T, n_b, Y_q on !  a grid; the computation of Ye on the stars is !  done by the SUBROUTINE compute_Ye_on_stars. ! !  FT 1.03.2021 ! !************************************************ USE constants , ONLY : fm2cm , cm2km , km2Msun_geo IMPLICIT NONE ! The commented variables might be useful in the future INTEGER :: itr , cntr !, & !i_t, i_nb, i_phase, n_pairs, i_e, i_n, Y_n, & !n_quad, & !i_i, A_i, Z_i, Y_i, i_leptons, i_ns INTEGER , PARAMETER :: unit_compose = 56 INTEGER , PARAMETER :: max_length_eos = 10000 !DOUBLE PRECISION:: m_n, m_p, & !                   p_nb, s_nb, mub_mn, muq_mn, mul_mn, f_nbmn, e_nbmn, h !DOUBLE PRECISION, DIMENSION( : ), ALLOCATABLE:: n_b, Y_e LOGICAL :: exist CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile PRINT * , \"** Executing the read_compose_composition subroutine...\" ALLOCATE ( THIS % nb_table ( max_length_eos ) ) ALLOCATE ( THIS % Ye_table ( max_length_eos ) ) THIS % nb_table = 0.0D0 THIS % Ye_table = 0.0D0 IF ( PRESENT ( namefile ) ) THEN finalnamefile = TRIM ( namefile ) // \".beta\" ELSE finalnamefile = \"../../CompOSE_EOS/SFHO_with_electrons/eos.beta\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_compose , FILE = TRIM ( finalnamefile ), & FORM = \"FORMATTED\" , ACTION = \"READ\" , IOSTAT = ios , & IOMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !                  // TRIM(finalnamefile) ) ELSE PRINT * , \"** ERROR! Unable to find file \" // TRIM ( finalnamefile ) STOP ENDIF !READ( UNIT= unit_compose, FMT= *, IOSTAT = ios, IOMSG= err_msg ) & !                                                    m_n, m_p, i_leptons PRINT * , \" * Reading file \" // TRIM ( finalnamefile ) // \"...\" cntr = 0 read_compose_beta : DO itr = 1 , max_length_eos , 1 READ ( UNIT = unit_compose , FMT = * , IOSTAT = ios , IOMSG = err_msg ) & ! Variables for .thermo.ns file !i_T, i_nb, i_yq, & !p_nb, s_nb, mub_mn, muq_mn, mul_mn, f_nbmn, e_nbmn, & !i_ns, THIS% Ye_table(itr), h ! Variables for .beta file THIS % nb_table ( itr ), & THIS % Ye_table ( itr ) ! Variables for .compo file !i_T, i_nb, i_yq, & !i_phase, n_pairs, & !i_e, Y_e(itr)!, & !i_n, Y_n, & !n_quad, & !i_i, A_i, Z_i, Y_i IF ( ios > 0 ) THEN PRINT * , \"...error when reading \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF IF ( ios < 0 ) THEN PRINT * , \" * Reached end of file \" // TRIM ( finalnamefile ) EXIT ENDIF cntr = cntr + 1 ENDDO read_compose_beta !PRINT *, \"cntr= \", cntr ! Reallocate the arrays to delete the empty elements THIS % nb_table = THIS % nb_table ( 1 : cntr ) / ( fm2cm ** 3 * cm2km ** 3 * km2Msun_geo ** 3 ) THIS % Ye_table = THIS % Ye_table ( 1 : cntr ) !PRINT *, i_T, i_nb, i_yq, i_phase, n_pairs, i_e !PRINT *, \"SIZE(n_b)= \", SIZE(THIS% n_b), \"SIZE(Y_e)= \", SIZE(THIS% Y_e) !PRINT *, \"n_b(1)= \", THIS% n_b(1), \"Y_e(1)= \", THIS% Y_e(1) !PRINT *, \"n_b(cntr)= \", THIS% n_b(cntr), \"Y_e(cntr)= \", THIS% Y_e(cntr) !STOP CLOSE ( unit_compose ) PRINT * , \"** Subroutine read_compose_composition executed.\" PRINT * END PROCEDURE read_compose_composition MODULE PROCEDURE compute_Ye !************************************************ ! !# Interpolates the electron fraction !  Y_e = n_e/n_b !  at the particle positions, using the data !  read by read_compose_composition. ! !  FT 3.03.2021 ! !************************************************ IMPLICIT NONE INTEGER :: d , itr2 DOUBLE PRECISION :: min_nb_table , max_nb_table d = SIZE ( THIS % nb_table ) min_nb_table = MINVAL ( THIS % nb_table , 1 ) max_nb_table = MAXVAL ( THIS % nb_table , 1 ) particle_loop : DO itr = 1 , THIS % npart , 1 ! There may be particles with initially negative hydro fields, ! close to the surface of the stars. The present ! version of the code sets their hydro fields to 0. ! In turn, this is a problem if we read Ye from the .beta file ! from the CompOSe database since the value of 0 ! for the baryon number density (used in the interpolation ! of Ye) is not included in the .beta file. ! In other words, Ye cannot be interpolated on those particles, ! and the present version of the code sets Ye to 0 as well. ! The problem above is solved: particles are not placed if the hydro ! is negative or zero. !IF( THIS% nlrf(itr) == 0.0D0 )THEN !THIS% Ye(itr)= 0.0D0 !CYCLE !ELSE IF ( THIS % nlrf ( itr ) < min_nb_table ) THEN PRINT * , \"** ERROR! The value of nlrf(\" , itr , \")=\" , THIS % nlrf ( itr ), & \"is lower than the minimum value in the table =\" , min_nb_table PRINT * , \" * Is nlrf computed when you call this SUBROUTINE? \" // & \"If yes, please select a table with a wider range.\" STOP ELSEIF ( THIS % nlrf ( itr ) > max_nb_table ) THEN PRINT * , \"** ERROR! The value of nlrf(\" , itr , \")=\" , THIS % nlrf ( itr ), & \"is larger than the maximum value in the table =\" , max_nb_table PRINT * , \" * Is nlrf computed when you call this SUBROUTINE? \" // & \"If yes, please select a table with a wider range.\" STOP ENDIF Ye_linear_interpolation_loop : DO itr2 = 1 , d - 1 , 1 IF ( THIS % nb_table ( itr2 ) < THIS % nlrf ( itr ) . AND . & THIS % nlrf ( itr ) < THIS % nb_table ( itr2 + 1 ) ) THEN THIS % Ye ( itr ) = THIS % Ye_table ( itr2 ) & + ( THIS % Ye_table ( itr2 + 1 ) - THIS % Ye_table ( itr2 )) / & ( THIS % nb_table ( itr2 + 1 ) - THIS % nb_table ( itr2 )) & * ( THIS % nlrf ( itr ) - THIS % nb_table ( itr2 )) EXIT ENDIF ENDDO Ye_linear_interpolation_loop !PRINT *, \"Ye(\", itr, \")=\", THIS% Ye(itr) !PRINT * ENDDO particle_loop END PROCEDURE compute_Ye END SUBMODULE particles_compose","tags":"","loc":"sourcefile/submodule_particles_compose.f90.html"},{"title":"submodule_particles_lattices.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_lattices.f90~~EfferentGraph sourcefile~submodule_particles_lattices.f90 submodule_particles_lattices.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_lattices.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_lattices Source Code submodule_particles_lattices.f90 Source Code ! File:         submodule_particles_lattices.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_lattices !*************************************************** ! !# This SUBMODULE contains the implementation of !  the methods of TYPE particles !  that place particles on 1 or 2 lattices around !  the stars. ! !  FT 12.07.2021 ! !*************************************************** IMPLICIT NONE CONTAINS MODULE PROCEDURE place_particles_lattice !********************************************************* ! !# Places paricles on a 3D lattice containing both stars ! !  FT 5.10.2020 ! !********************************************************* USE constants , ONLY : Msun_geo , pi , third IMPLICIT NONE INTEGER :: i , j , k , sgn , nx , ny , nz , npart_half INTEGER :: npart_tmp DOUBLE PRECISION :: dx , dy , dz , vol , vol_a DOUBLE PRECISION :: xtemp , ytemp , ztemp , zlim DOUBLE PRECISION :: thres_baryon_density DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: pos_tmp PRINT * , \"** Executing the place_particles_lattice \" & // \"subroutine...\" PRINT * ! !-- Set the boundary in z ! IF ( ABS ( zmax ) > ABS ( zmin ) ) THEN zlim = zmax ELSE zlim = zmin ENDIF ! !-- Compute number of lattice points (for now, equal in each direction) ! nx = FLOOR ( stretch * ( 6.0D0 * DBLE ( npart_des ) / pi ) ** third ) IF ( MOD ( nx , 2 ) /= 0 ) nx = nx + 1 ny = nx nz = nx ! !-- Consistency checks ! IF ( MOD ( nz , 2 ) /= 0 ) THEN PRINT * PRINT * , \"** ERROR! nz should be even!\" PRINT * STOP ENDIF IF ( nx == 0 . OR . ny == 0 . OR . nz == 0 ) THEN PRINT * PRINT * , \"** ERROR! nx, ny, nz are 0!\" PRINT * STOP ENDIF PRINT * , \" * nx= ny= nz=\" , nx PRINT * ! !-- Compute lattice steps ! dx = ABS ( xmax - xmin ) / DBLE ( nx ) dy = ABS ( ymax - ymin ) / DBLE ( ny ) dz = ABS ( zlim ) / DBLE ( nz / 2 ) PRINT * , \" * dx=\" , dx , \", dy=\" , dx , \", dz=\" , dz PRINT * npart_tmp = nx * ny * nz PRINT * , \" * Number of lattice points= nx*ny*nz=\" , npart_tmp PRINT * ! !-- Set the threshold above which a lattice point is !-- promoted to a particle ! IF ( THIS % use_thres ) THEN thres_baryon_density = central_density / thres ELSE thres_baryon_density = 0.0D0 ENDIF ! Allocating the memory for the array pos( 3, npart_tmp ) ! Note that after determining npart, the array pos is reshaped into ! pos( 3, npart ) IF (. NOT . ALLOCATED ( pos )) THEN ALLOCATE ( pos ( 3 , npart_tmp ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos in SUBROUTINE\" & // \"place_particles_3D_lattice. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF ! Initializing the array pos to 0 THIS % pos = 0.0D0 IF (. NOT . ALLOCATED ( pos_tmp )) THEN ALLOCATE ( pos_tmp ( 3 , nx , ny , nz ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos_tmp in SUBROUTINE\" & // \"place_particles_3D_lattice. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF ! Initializing the array pos to 0 pos_tmp = HUGE ( 0.0D0 ) !---------------------------------------------------------! !--  Storing the particle positions into the array pos  --! !--  symmetrically w.r.t. the xy plane                  --! !---------------------------------------------------------! PRINT * , \" * Placing particles on the lattice...\" PRINT * ! !-- Choose the larger value for the boundary in z ! IF ( zlim == zmin ) THEN sgn = - 1 ELSE sgn = 1 ENDIF ! !-- Place the first half of the particle (above or below the xy plane, !-- depending on the variable sgn) ! !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nx, ny, nz, dx, dy, dz, sgn, & !$OMP                     pos_tmp, thres_baryon_density, xmin, ymin ) & !$OMP             PRIVATE( i, j, k, xtemp, ytemp, ztemp ) particle_pos_z : DO k = 1 , nz / 2 , 1 ztemp = sgn * ( dz / 2 + ( k - 1 ) * dz ) particle_pos_y : DO j = 1 , ny , 1 ytemp = ymin + ( j - 1 ) * dy particle_pos_x : DO i = 1 , nx , 1 xtemp = xmin + dx / 2 + ( i - 1 ) * dx ! !-- Promote a lattice point to a particle, !-- if the mass density is higher than the threshold ! IF ( get_density ( xtemp , ytemp , ztemp ) & > thres_baryon_density & . AND . & validate_position ( xtemp , ytemp , ztemp ) == 0 ) THEN pos_tmp ( 1 , i , j , k ) = xtemp pos_tmp ( 2 , i , j , k ) = ytemp pos_tmp ( 3 , i , j , k ) = ztemp ENDIF ENDDO particle_pos_x ENDDO particle_pos_y ENDDO particle_pos_z !$OMP END PARALLEL DO npart_out = 0 DO k = 1 , nz , 1 DO j = 1 , ny , 1 DO i = 1 , nx , 1 IF ( pos_tmp ( 1 , i , j , k ) < HUGE ( 0.0D0 ) ) THEN npart_out = npart_out + 1 pos ( 1 , npart_out ) = pos_tmp ( 1 , i , j , k ) pos ( 2 , npart_out ) = pos_tmp ( 2 , i , j , k ) pos ( 3 , npart_out ) = pos_tmp ( 3 , i , j , k ) ENDIF ENDDO ENDDO ENDDO npart_half = npart_out IF ( npart_half == 0 ) THEN PRINT * , \"** There are no particles! Execution stopped...\" PRINT * STOP ENDIF DEALLOCATE ( pos_tmp ) ! !-- Place the second half of the particles, mirroring the first half !-- w.r.t the xy plane ! particle_pos_z_mirror : DO k = 1 , npart_half , 1 xtemp = pos ( 1 , k ) ytemp = pos ( 2 , k ) ztemp = - pos ( 3 , k ) npart_out = npart_out + 1 pos ( 1 , npart_out ) = xtemp pos ( 2 , npart_out ) = ytemp pos ( 3 , npart_out ) = ztemp !ENDIF ! Print progress on screen, every 10% !perc= 50 + 50*k/( npart_half ) !IF( show_progress .AND. MOD( perc, 10 ) == 0 )THEN !   WRITE( *, \"(A2,I3,A1)\", ADVANCE= \"NO\" ) & !           creturn//\" \", perc, \"%\" !ENDIF ENDDO particle_pos_z_mirror !WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn ! !-- Consistency checks ! IF ( npart_out /= 2 * npart_half ) THEN PRINT * PRINT * , \"** ERROR: The number of particles \" , npart_out , & \" is not the expected value \" , 2 * npart_half PRINT * STOP ENDIF DO k = 1 , npart_half , 1 IF ( pos ( 3 , k ) /= - pos ( 3 , npart_half + k ) ) THEN PRINT * PRINT * , \"** ERROR: The lattice is not mirrored \" & // \"by the xy plane.\" PRINT * STOP ENDIF ENDDO PRINT * , \" * Particles placed. Number of particles=\" , & npart_out , \"=\" , DBLE ( npart_out ) / DBLE ( npart_tmp ), & \" of the points in lattice.\" PRINT * ! !-- Computing total volume and volume per particle ! IF (. NOT . ALLOCATED ( pvol )) THEN ALLOCATE ( pvol ( npart_out ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pvol \" , & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...allocation error for array v_euler_parts_z\" ) ENDIF vol = ( xmax - xmin ) * ( ymax - ymin ) * 2 * ABS ( zlim ) vol_a = vol / npart_tmp pvol = vol_a ! Consistency check for the particle volume IF ( ABS ( vol_a - dx * dy * dz ) > 1.0D-9 ) THEN PRINT * , \" * The particle volume vol_a=\" , vol_a , \"Msun_geo&#94;3\" PRINT * , \" is not equal to dx*dy*dz=\" , dx * dy * dz , \"Msun_geo&#94;3.\" PRINT * STOP ENDIF PRINT * , \" * Total volume of the lattices=\" , vol , \"Msun_geo&#94;3\" PRINT * , \" * Particle volume=\" , vol_a , \"Msun_geo&#94;3\" PRINT * PRINT * , \"** Subroutine place_particles_3D_lattice executed.\" PRINT * END PROCEDURE place_particles_lattice !  MODULE PROCEDURE place_particles_lattices ! !    !**************************************************** !    ! !    !# Places paricles on two 3D lattices, each one !    !  containing a star !    ! !    !  FT 19.10.2020 !    ! !    !**************************************************** ! !    USE constants, ONLY: Msun_geo ! !    IMPLICIT NONE ! !    INTEGER:: i, j, k, sgn, npart_half, npart_half2 !    INTEGER:: npart_tmp, npart1_temp, npart2_temp !    INTEGER:: nx1, ny1, nz1, nx2, ny2, nz2 ! !    DOUBLE PRECISION:: dx1, dy1, dz1, dx2, dy2, dz2 !    DOUBLE PRECISION:: xtemp, ytemp, ztemp, zlim, zlim2 !    DOUBLE PRECISION:: max_baryon_density1, thres_baryon_density1 !    DOUBLE PRECISION:: max_baryon_density2, thres_baryon_density2 !    ! Variable used to compute the volume of a particle in an alternative way !    ! to perform a consistency check !    DOUBLE PRECISION:: vol_a_alt1, vol_a_alt2 ! !    DOUBLE PRECISION, DIMENSION(:,:,:,:), ALLOCATABLE:: pos_tmp ! !    PRINT *, \"** Executing the place_particles_lattices \" & !             // \"subroutine...\" !    PRINT * ! !    ! !    !-- Set the boundaries in z, for lattice 1 and lattice 2 !    ! !    IF( ABS(zmax1) > ABS(zmin1) )THEN !      zlim= zmax1 !    ELSE !      zlim= zmin1 !    ENDIF !    IF( ABS(zmax2) > ABS(zmin2) )THEN !      zlim2= zmax2 !    ELSE !      zlim2= zmin2 !    ENDIF ! !    IF( THIS% mass1 > THIS% mass2 )THEN ! !      ! mass_ratio < 1 !      THIS% mass_ratio= THIS% mass2/THIS% mass1 !      ! !      !-- Compute lattices' steps !      ! !      nx2= nx !      ny2= ny !      nz2= nz !      dx2= ABS(xmax2 - xmin2)/DBLE( nx2 ) !      dy2= ABS(ymax2 - ymin2)/DBLE( ny2 ) !      dz2= ABS(zlim2)/DBLE( nz2/2 ) ! !      dx1= dx2*(THIS% mass_ratio**(1.0D0/3.0D0)) !      dy1= dy2*(THIS% mass_ratio**(1.0D0/3.0D0)) !      dz1= dz2*(THIS% mass_ratio**(1.0D0/3.0D0)) !      nx1= NINT( ABS(xmax1 - xmin1)/dx1 ) + 1 !      ny1= NINT( ABS(ymax1 - ymin1)/dy1 ) + 1 !      nz1= NINT( 2*ABS(zlim)/dz1 ) + 1 ! !    ELSE ! !      ! mass_ratio < 1 !      THIS% mass_ratio= THIS% mass1/THIS% mass2 !      ! !      !-- Compute lattices' steps !      ! !      nx1= nx !      ny1= ny !      nz1= nz !      dx1= ABS(xmax1 - xmin1)/DBLE( nx1 ) !      dy1= ABS(ymax1 - ymin1)/DBLE( ny1 ) !      dz1= ABS(zlim)/DBLE( nz1/2 ) ! !      dx2= dx1*(THIS% mass_ratio**(1.0D0/3.0D0)) !      dy2= dy1*(THIS% mass_ratio**(1.0D0/3.0D0)) !      dz2= dz1*(THIS% mass_ratio**(1.0D0/3.0D0)) !      nx2= NINT( ABS(xmax2 - xmin2)/dx2 ) + 1 !      ny2= NINT( ABS(ymax2 - ymin2)/dy2 ) + 1 !      nz2= NINT( 2*ABS(zlim2)/dz2 ) + 1 ! !    ENDIF ! !    ! Set the number of particles in the z direction to an even number !    ! since half of the particles are above the xy plane, and half below it !    IF( MOD( nz2, 2 ) /= 0 )THEN !      nz2= nz2 - 1 !    ENDIF ! !    PRINT *, \" * dx1=\", dx1,  \", dy1=\", dx1,  \", dz1=\", dz1 !    PRINT *, \" * dx2=\", dx2,  \", dy2=\", dx2,  \", dz2=\", dz2 !    PRINT *, \" * nx1=\", nx1, \", ny1=\", ny1, \", nz1=\", nz1 !    PRINT *, \" * nx2=\", nx2, \", ny2=\", ny2, \", nz2=\", nz2 !    PRINT * ! !    !PRINT *, \" * xmin1=\", xmin1, \", xmax1=\", xmax1 !    !PRINT *, \" * xmin2=\", xmin2, \", xmax2=\", xmax2 !    !PRINT * !    !STOP ! !    ! Compute number of lattice points (temporary particle number) !    npart1_temp = nx*ny*nz !+ nx*ny !    npart2_temp = nx2*ny2*nz2 !+ nx2*ny2 !    npart_tmp  = npart1_temp + npart2_temp ! !    PRINT *, \" * Number of points for lattice 1= nx1*ny1*nz1=\", & !             npart1_temp !    PRINT *, \" * Number of points for lattice 2= nx2*ny2*nz2=\", & !             npart2_temp !    PRINT * ! !    ! !    !-- Compute the mass density at the center of the stars !    ! ! !    ! The following two density ar in SPHINCS units [Msun Msun_geo&#94;{-3}] !    max_baryon_density1= id% get_rho_center1() !    max_baryon_density2= id% get_rho_center2() ! !    ! !    !-- Set the thresholds above which a lattice point is !    !-- promoted to a particle !    ! !    IF( THIS% use_thres )THEN !      thres_baryon_density1= max_baryon_density1/thres !      thres_baryon_density2= max_baryon_density2/thres !    ELSE !      thres_baryon_density1= 0.0D0 !      thres_baryon_density2= 0.0D0 !    ENDIF ! !    ! Allocating the memory for the array pos( 3, npart_tmp ) !    ! Note that after determining npart, the array pos is reshaped into !    ! pos( 3, npart ) !    IF(.NOT.ALLOCATED( THIS% pos ))THEN !      ALLOCATE( THIS% pos( 3, npart_tmp ), STAT= ios, & !                ERRMSG= err_msg ) !      IF( ios > 0 )THEN !         PRINT *, \"...allocation error for array pos in SUBROUTINE\" & !                  // \"place_particles_3D_lattices. \", & !                  \"The error message is\", err_msg !         STOP !      ENDIF !      !CALL test_status( ios, err_msg, & !      !                \"...allocation error for array pos in SUBROUTINE\" & !      !                // \"place_particles_3D_lattice.\" ) !    ENDIF ! !    IF(.NOT.ALLOCATED( pos_tmp ))THEN !      ALLOCATE( pos_tmp( 3, nx, ny, nz ), STAT= ios, & !                ERRMSG= err_msg ) !      IF( ios > 0 )THEN !         PRINT *, \"...allocation error for array pos_tmp in SUBROUTINE\" & !                  // \"place_particles_3D_lattices. \", & !                  \"The error message is\", err_msg !         STOP !      ENDIF !      !CALL test_status( ios, err_msg, & !      !                \"...allocation error for array pos in SUBROUTINE\" & !      !                // \"place_particles_3D_lattice.\" ) !    ENDIF !    ! Initializing the array pos to 0 !    pos_tmp= HUGE(0.0D0) ! !    !---------------------------------------------------------! !    !--  Storing the particle positions into the array pos  --! !    !--  symmetrically w.r.t. the xy plane                  --! !    !---------------------------------------------------------! ! !    ! !    !-- Placing particles on NS 1 !    ! !    PRINT *, \"Placing particles on NS 1...\" !    PRINT * !    THIS% npart= 0 !    THIS% npart1= 0 !    ! !    !-- Choose the larger value for the boundary in z !    ! !    IF( zlim == zmin1 )THEN !      sgn= - 1 !    ELSE !      sgn= 1 !    ENDIF !    ! !    !-- Place the first half of the particle (above or below the xy plane) !    ! !    !$OMP PARALLEL DO DEFAULT( NONE ) & !    !$OMP             SHARED( nx, ny, nz, id, dx1, dy1, dz1, sgn, & !    !$OMP                     pos_tmp, thres_baryon_density1, xmin1, ymin1 ) & !    !$OMP             PRIVATE( i, j, k, xtemp, ytemp, ztemp ) !    particle_pos_z1: DO k= 1, nz/2, 1 ! !      ztemp= sgn*( dz1/2 + ( k - 1 )*dz1 ) ! !      particle_pos_y1: DO j= 1, ny, 1 ! !        ytemp= ymin1 + dy1/2 + ( j - 1 )*dy1 ! !        particle_pos_x1: DO i= 1, nx, 1 ! !          xtemp= xmin1 + dx1/2 + ( i - 1 )*dx1 ! !          ! !          !-- Promote a lattice point to a particle, !          !-- if the mass density is higher than the threshold !          ! !          IF( id% read_mass_density( xtemp, ytemp, ztemp ) & !                                > thres_baryon_density1 & !              .AND. & !              id% test_position( xtemp, ytemp, ztemp ) == 0 )THEN ! !            !THIS% npart = THIS% npart + 1 !            !THIS% npart1= THIS% npart1 + 1 !            !THIS% pos( 1, THIS% npart )= xtemp !            !THIS% pos( 2, THIS% npart )= ytemp !            !THIS% pos( 3, THIS% npart )= ztemp !            pos_tmp( 1, i, j, k )= xtemp !            pos_tmp( 2, i, j, k )= ytemp !            pos_tmp( 3, i, j, k )= ztemp ! !          ENDIF ! !          ! Print progress on screen, every 10% !          !perc= 50*( nx*ny*k + nx*j + i )/ & !          !        ( nx*ny*nz/2 ) !          !IF( show_progress .AND. MOD( perc, 10 ) == 0 )THEN !          !  WRITE( *, \"(A2,I3,A1)\", ADVANCE= \"NO\" ) & !          !         creturn//\" \", perc, \"%\" !          ! ENDIF !        ENDDO particle_pos_x1 !      ENDDO particle_pos_y1 !    ENDDO particle_pos_z1 !    !$OMP END PARALLEL DO !    !WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn ! ! !    DO k= 1, nz, 1 ! !      DO j= 1, ny, 1 ! !        DO i= 1, nx, 1 ! !          IF( pos_tmp( 1, i, j, k ) < HUGE(0.0D0) )THEN ! !            THIS% npart= THIS% npart + 1 !            THIS% npart1= THIS% npart1 + 1 !            THIS% pos( 1, THIS% npart )= pos_tmp( 1, i, j, k ) !            THIS% pos( 2, THIS% npart )= pos_tmp( 2, i, j, k ) !            THIS% pos( 3, THIS% npart )= pos_tmp( 3, i, j, k ) ! !          ENDIF ! !         ENDDO !      ENDDO !    ENDDO !    npart_half= THIS% npart !    IF( npart_half == 0 )THEN !      PRINT *, \"** There are no particles on star 1! Execution stopped...\" !      PRINT * !      STOP !    ENDIF ! !    DEALLOCATE( pos_tmp ) ! !    ! !    !-- Place the second half of the particles, mirroring the first half !    !-- w.r.t the xy plane !    ! !    particle_pos_z1_mirror: DO k= 1, npart_half, 1 ! !      xtemp=   THIS% pos( 1, k ) !      ytemp=   THIS% pos( 2, k ) !      ztemp= - THIS% pos( 3, k ) ! !      ! TODO: is this check needed? !      !IF( import_mass_density( xtemp, ytemp, ztemp ) & !      !                               > thres_baryon_density1 )THEN ! !      THIS% npart = THIS% npart + 1 !      THIS% npart1= THIS% npart1 + 1 !      THIS% pos( 1, THIS% npart )= xtemp !      THIS% pos( 2, THIS% npart )= ytemp !      THIS% pos( 3, THIS% npart )= ztemp ! !      !ENDIF ! !      perc= 50 + 50*k/( npart_half ) !      IF( show_progress .AND. MOD( perc, 10 ) == 0 )THEN !        WRITE( *, \"(A2,I3,A1)\", ADVANCE= \"NO\" ) & !               creturn//\" \", perc, \"%\" !      ENDIF ! !    ENDDO particle_pos_z1_mirror !    WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn ! !    ! !    !-- Place the particles on the xy plane !    ! !    !ztemp= 0.0D0 !    ! !    !particle_pos_y1_xy: DO j= 1, ny, 1 !    ! !    !  ytemp= ymin1 + dy/2 + ( j - 1 )*dy !    ! !    !  particle_pos_x1_xy: DO i= 1, nx, 1 !    ! !    !    xtemp= xmin1 + dx/2 + ( i - 1 )*dx !    ! !    !    ! !    !    !-- Promote a lattice point to a particle, !    !    !-- if the mass density is higher than the threshold !    !    ! !    !    IF( id% import_mass_density( xtemp, ytemp, ztemp ) & !    !                          > thres_baryon_density1 )THEN !    ! !    !      THIS% npart = THIS% npart + 1 !    !      THIS% npart1= THIS% npart1 + 1 !    !      THIS% pos( 1, THIS% npart )= xtemp !    !      THIS% pos( 2, THIS% npart )= ytemp !    !      THIS% pos( 3, THIS% npart )= ztemp !    ! !    !    ENDIF !    ! !    !    ! Print progress on screen, every 10% !    !    perc= 50*( nx*ny*k + nx*j + i )/ & !    !            ( nx*ny*nz/2 ) !    !    IF( MOD( perc, 10 ) == 0 )THEN !    !      WRITE( *, \"(A2,I3,A1)\", ADVANCE= \"NO\" ) & !    !             creturn//\" \", perc, \"%\" !    !     ENDIF !    !   ENDDO particle_pos_x1_xy !    !ENDDO particle_pos_y1_xy !    !WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn ! !    IF(.NOT.ALLOCATED( pos_tmp ))THEN !      ALLOCATE( pos_tmp( 3, nx2, ny2, nz2 ), STAT= ios, & !                ERRMSG= err_msg ) !      IF( ios > 0 )THEN !         PRINT *, \"...allocation error for array pos_tmp in SUBROUTINE\" & !                  // \"place_particles_3D_lattices. \", & !                  \"The error message is\", err_msg !         STOP !      ENDIF !      !CALL test_status( ios, err_msg, & !      !                \"...allocation error for array pos in SUBROUTINE\" & !      !                // \"place_particles_3D_lattice.\" ) !    ENDIF !    ! Initializing the array pos to 0 !    pos_tmp= HUGE(0.0D0) ! !    ! !    !-- Placing particles on NS 2 with the same algorithm as for NS 1 !    ! !    PRINT *, \"Placing particles on NS 2...\" !    PRINT * !    THIS% npart2= 0 !    IF( zlim2 == zmin2 )THEN !      sgn= - 1 !    ELSE !      sgn= 1 !    ENDIF !    !$OMP PARALLEL DO DEFAULT( NONE ) & !    !$OMP             SHARED( nx2, ny2, nz2, id, dx2, dy2, dz2, sgn, & !    !$OMP                     pos_tmp, thres_baryon_density2, xmin2, ymin2 ) & !    !$OMP             PRIVATE( i, j, k, xtemp, ytemp, ztemp ) !    particle_pos_z2: DO k= 1, nz2/2, 1 ! !      ztemp= sgn*( dz2/2 + ( k - 1 )*dz2 ) ! !      particle_pos_y2: DO j= 1, ny2, 1 ! !        ytemp= ymin2 + dy2/2 + ( j - 1 )*dy2 ! !        particle_pos_x2: DO i= 1, nx2, 1 ! !          xtemp= xmin2 + dx2/2 + ( i - 1 )*dx2 ! !          IF( id% read_mass_density( xtemp, ytemp, ztemp ) & !                                  > thres_baryon_density2 & !              .AND. & !              id% test_position( xtemp, ytemp, ztemp ) == 0 )THEN ! !            !THIS% npart = THIS% npart + 1 !            !THIS% npart2= THIS% npart2 + 1 !            !THIS% pos( 1, THIS% npart )= xtemp !            !THIS% pos( 2, THIS% npart )= ytemp !            !THIS% pos( 3, THIS% npart )= ztemp !            pos_tmp( 1, i, j, k )= xtemp !            pos_tmp( 2, i, j, k )= ytemp !            pos_tmp( 3, i, j, k )= ztemp ! !          ENDIF ! !          ! Print progress on screen, every 10% !          !perc= 50*( nx2*ny2*( k - 1 ) + nx2*( j - 1 ) & !          !      + i )/( nx2*ny2*nz2/2 ) !          !IF( show_progress .AND. MOD( perc, 10 ) == 0 )THEN !          !  WRITE( *, \"(A2,I3,A1)\", ADVANCE= \"NO\" ) & !          !         creturn//\" \", perc, \"%\" !          !ENDIF !        ENDDO particle_pos_x2 !      ENDDO particle_pos_y2 !    ENDDO particle_pos_z2 !    !$OMP END PARALLEL DO !    !WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn ! !    DO k= 1, nz2, 1 ! !      DO j= 1, ny2, 1 ! !        DO i= 1, nx2, 1 ! !          IF( pos_tmp( 1, i, j, k ) < HUGE(0.0D0) )THEN ! !            THIS% npart= THIS% npart + 1 !            THIS% npart2= THIS% npart2 + 1 !            THIS% pos( 1, THIS% npart )= pos_tmp( 1, i, j, k ) !            THIS% pos( 2, THIS% npart )= pos_tmp( 2, i, j, k ) !            THIS% pos( 3, THIS% npart )= pos_tmp( 3, i, j, k ) ! !          ENDIF ! !         ENDDO !      ENDDO !    ENDDO !    npart_half2= THIS% npart !    IF( npart_half2 == 2*npart_half )THEN !      PRINT *, \"** There are no particles on star 2! Execution stopped...\" !      PRINT * !      STOP !    ENDIF ! !    DEALLOCATE( pos_tmp ) ! !    particle_pos_z2_mirror: DO k= 2*npart_half + 1, npart_half2, 1 ! !      xtemp=   THIS% pos( 1, k ) !      ytemp=   THIS% pos( 2, k ) !      ztemp= - THIS% pos( 3, k ) ! !      !IF( import_mass_density( xtemp, ytemp, ztemp ) & !      !                               > thres_baryon_density2 )THEN ! !      THIS% npart = THIS% npart + 1 !      THIS% npart2= THIS% npart2 + 1 !      THIS% pos( 1, THIS% npart )= xtemp !      THIS% pos( 2, THIS% npart )= ytemp !      THIS% pos( 3, THIS% npart )= ztemp ! !      !ENDIF ! !      ! Print progress on screen, every 10% !      perc= 50 + 50*( k - 2*npart_half + 1 ) & !                    /( npart_half2 - 2*npart_half ) !      IF( show_progress .AND. MOD( perc, 10 ) == 0 )THEN !        WRITE( *, \"(A2,I3,A1)\", ADVANCE= \"NO\" ) & !                creturn//\" \", perc, \"%\" !      ENDIF ! !    ENDDO particle_pos_z2_mirror !    WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn ! !    ! !    !-- Place the particles on the xy plane !    ! !    !ztemp= 0.0D0 !    ! !    !particle_pos_y2_xy: DO j= 1, ny2, 1 !    ! !    !  ytemp= ymin2 + dy/2 + ( j - 1 )*dy !    ! !    !  particle_pos_x2_xy: DO i= 1, nx2, 1 !    ! !    !    xtemp= xmin2 + dx/2 + ( i - 1 )*dx !    ! !    !    IF( id% import_mass_density( xtemp, ytemp, ztemp ) & !    !                            > thres_baryon_density2 )THEN !    ! !    !      THIS% npart = THIS% npart + 1 !    !      THIS% npart2= THIS% npart2 + 1 !    !      THIS% pos( 1, THIS% npart )= xtemp !    !      THIS% pos( 2, THIS% npart )= ytemp !    !      THIS% pos( 3, THIS% npart )= ztemp !    ! !    !    ENDIF !    ! !    !    ! Print progress on screen, every 10% !    !    perc= 50*( nx2*ny2*( k - 1 ) + nx2*( j - 1 ) + i )& !    !          /( nx2*ny2*nz2/2 ) !    !    IF( MOD( perc, 10 ) == 0 )THEN !    !      WRITE( *, \"(A2,I3,A1)\", ADVANCE= \"NO\" ) & !    !             creturn//\" \", perc, \"%\" !    !    ENDIF !    !  ENDDO particle_pos_x2_xy !    !ENDDO particle_pos_y2_xy !    !WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn ! !    ! !    !-- Consistency checks !    ! !    IF( THIS% npart /= ( 2*( npart_half2 - npart_half ) ) )THEN !      PRINT * !      PRINT *, \"** ERROR: The number of particles \", THIS% npart, & !               \" is not the expected value \", & !               2*( npart_half2 - npart_half ) !      PRINT * !      STOP !    ENDIF ! !    DO k= 1, npart_half, 1 !      IF( THIS% pos( 3, k ) /= - THIS% pos( 3, npart_half + k ) )THEN !        PRINT * !        PRINT *, \"** ERROR: The lattice around NS 1 are not mirrored \" & !                 // \"by the xy plane.\" !        PRINT * !        STOP !      ENDIF !    ENDDO !    DO k= 2*npart_half + 1, npart_half2, 1 !      IF( THIS% pos( 3, k ) /= & !          - THIS% pos( 3, ( npart_half2 - 2*npart_half ) + k ) )THEN !        PRINT * !        PRINT *, \"** ERROR: The lattice around NS 2 are not mirrored \" & !                 // \"by the xy plane.\" !        PRINT * !        STOP !      ENDIF !    ENDDO ! !    IF( THIS% npart1 + THIS% npart2 /= THIS% npart )THEN !      PRINT *, \"** ERROR: npart1 + npart2 /= npart\" !      PRINT *, \" * npart1=\", THIS% npart1 !      PRINT *, \" * npart2=\", THIS% npart2 !      PRINT *, \" * npart1 + npart2=\", THIS% npart1 + THIS% npart2 !      PRINT *, \" * npart=\", THIS% npart !      STOP !    ENDIF ! !    ! !    !-- Printouts !    ! !    PRINT *, \" * Particles placed. Number of particles=\", & !             THIS% npart, \"=\", DBLE(THIS% npart)/DBLE(npart_tmp), & !             \" of the points in lattices.\" !    PRINT * !    PRINT *, \" * Number of particles on NS 1=\", THIS% npart1, \"=\", & !             DBLE(THIS% npart1)/DBLE(npart1_temp), & !             \" of the points in the first lattice.\" !    PRINT *, \" * Number of particles on NS 2=\", THIS% npart2, \"=\", & !             DBLE(THIS% npart2)/DBLE(npart2_temp), & !             \" of the points in the second lattice.\" !    PRINT * ! !    ! !    !-- Computing total volume and volume per particle !    ! !    IF(.NOT.ALLOCATED( THIS% pvol ))THEN !      ALLOCATE( THIS% pvol( THIS% npart ), STAT= ios, & !              ERRMSG= err_msg ) !      IF( ios > 0 )THEN !        PRINT *, \"...allocation error for array pvol \", & !                 \". The error message is\", err_msg !        STOP !      ENDIF !      !CALL test_status( ios, err_msg, & !      !        \"...allocation error for array v_euler_parts_z\" ) !    ENDIF ! !    THIS% vol1_a= dx1*dy1*dz1 !    THIS% vol1 = (xmax1 - xmin1)*(ymax1 - ymin1)*2*ABS(zlim) !    !THIS% vol2 = npart2_temp * THIS% vol_a !    !THIS% vol  = THIS% vol1 + THIS% vol2 !    vol_a_alt1  = THIS% vol1/npart1_temp ! !    THIS% vol2_a= dx2*dy2*dz2 !    THIS% vol2 =  dx2*nx2*dy2*ny2*dz2*nz2 !    !THIS% vol2 = (xmax2 - xmin2)*(ymax2 - ymin2)*2*ABS(zlim2) !    !THIS% vol2 = npart2_temp * THIS% vol_a2 !    !THIS% vol  = THIS% vol1 + THIS% vol2 !    vol_a_alt2  = THIS% vol2/npart2_temp ! !    THIS% pvol( 1:THIS% npart1 )              = THIS% vol1_a !    THIS% pvol( THIS% npart1 + 1:THIS% npart )= THIS% vol2_a ! !    THIS% vol= THIS% vol1 + THIS% vol2 ! !    ! Consistency check for the particle volume !    IF( ABS( THIS% vol1_a - vol_a_alt1 ) > 1D-7 )THEN !      PRINT *, \" * The particle volume vol_a_alt1=\", vol_a_alt1, \"Msun_geo&#94;3\" !      PRINT *, \" is not equal to dx1*dy1*dz1=\", THIS% vol1_a, \"Msun_geo&#94;3.\" !      PRINT * !      STOP !    ENDIF !    ! Consistency check for the particle volume !    IF( ABS( THIS% vol2_a - vol_a_alt2 ) > 1D-7 )THEN !      PRINT *, \" * The particle volume vol_a_alt2=\", vol_a_alt2, \"Msun_geo&#94;3\" !      PRINT *, \" is not equal to dx2*dy2*dz2=\", THIS% vol2_a, \"Msun_geo&#94;3.\" !      PRINT * !      STOP !    ENDIF ! !    PRINT *, \" * Total volume of the lattices=\", THIS% vol, \"Msun_geo&#94;3\" !    PRINT *, \" * Particle volume on NS 1=\", THIS% vol1_a, \"Msun_geo&#94;3\" !    PRINT *, \" * Particle volume on NS 2=\", THIS% vol2_a, \"Msun_geo&#94;3\" !    PRINT * ! !    PRINT *, \"** Subroutine place_particles_lattices \" & !             // \"executed.\" !    PRINT * ! !  END PROCEDURE place_particles_lattices END SUBMODULE particles_lattices","tags":"","loc":"sourcefile/submodule_particles_lattices.f90.html"},{"title":"submodule_particles_apm.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_apm.f90~~EfferentGraph sourcefile~submodule_particles_apm.f90 submodule_particles_apm.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~submodule_particles_apm.f90->sourcefile~module_utility.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_apm.f90->sourcefile~module_particles_id.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_apm Source Code submodule_particles_apm.f90 Source Code !& File:         submodule_particles_apm.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_apm !*********************************** ! !# This SUBMODULE contains the !  implementation of the method !  perform_apm of TYPE particles. ! !  FT 04.06.2021 ! !*********************************** IMPLICIT NONE CONTAINS MODULE PROCEDURE perform_apm !***************************************************** ! !#  Compute the particle positions as follows: ! !    - 1. Take initial particle distribution as input !    - 2. Assume that the particles have the same mass !    - 3. Do the APM iteration so that the final !       SPH kernel estimate of the baryon mass !       density matches the baryon density in the !       star as given by |lorene| !    - 4. Correct the particle masses ONCE, in order !       to match the density even better. Since we !       don't want a large mass ratio, we impose a !       maximum mass ratio when performing this !       correction. ! !  After this procedure, the resulting particle !  distribution has positions and baryon numbers !  that kernel-estimate very well the mass density !  of the star, and has a low mass ratio. ! !  This procedure assigns positions and \\nu. ! !  @warning !  If the outer layers of a star have a very low density !  compared to the core, it can happen that, irrespective !  of the initial particle distribution and the APM !  parameters, the particle distribution output by the !  APM does not have a smooth surface. In this case, !  the only solution (that has been found as of 20.10.2021) !  is to increase the particle number. ! !  As of 20.10.2021, this has only happened with the !  CompOSE tabulated EOS (all of them), but not with !  any piecewise polytropic or polytropic EOS. ! !  This problem can manifest itself with error messages !  concerning particles occupying the sameposition, !  or some smoothing lengths being 0, or a matrix not being !  invertible. ! !  FT 20.10.2021 !  @endwarning ! !  FT 04.06.2021 ! !***************************************************** USE utility , ONLY : cnt USE constants , ONLY : half , third , Msun , Msun_geo , km2m , g2kg , & amu , pi USE sph_variables , ONLY : allocate_sph_memory , deallocate_sph_memory , & npart , h , nu USE metric_on_particles , ONLY : allocate_metric_on_particles , & deallocate_metric_on_particles USE gradient , ONLY : allocate_gradient , deallocate_gradient USE set_h , ONLY : exact_nei_tree_update , posmash USE RCB_tree_3D , ONLY : allocate_RCB_tree_memory_3D , iorig , & deallocate_RCB_tree_memory_3D USE units , ONLY : umass USE APM , ONLY : density_loop , position_correction , assign_h USE analyze , ONLY : COM USE matrix , ONLY : determinant_4x4_matrix USE sphincs_sph , ONLY : density , ncand IMPLICIT NONE INTEGER , PARAMETER :: max_npart = 5 D + 6 INTEGER , PARAMETER :: nn_des = 301 INTEGER , PARAMETER :: m_max_it = 50 INTEGER , PARAMETER :: search_pos = 10 DOUBLE PRECISION , PARAMETER :: ellipse_thickness = 1.25D0 DOUBLE PRECISION , PARAMETER :: ghost_dist = 0.2D0 DOUBLE PRECISION , PARAMETER :: tol = 1.0D-3 DOUBLE PRECISION , PARAMETER :: iter_tol = 2.0D-2 INTEGER :: a , a2 , itr , itr2 , n_inc , cnt1 ! iterators INTEGER :: npart_real , npart_real_half , npart_ghost , npart_all INTEGER :: nx , ny , nz , i , j , k INTEGER :: a_numin , a_numin2 , a_numax , a_numax2 INTEGER :: dim_seed , rel_sign DOUBLE PRECISION :: smaller_radius , larger_radius , radius_y , radius_z DOUBLE PRECISION :: h_max , h_av , eps , tmp !, delta DOUBLE PRECISION :: xmin , xmax , ymin , ymax , zmin , zmax , dx , dy , dz , & rad_x , rad_y , rad_z , com_x , com_y , com_z , com_d DOUBLE PRECISION :: max_r_real , r_real , max_z_real DOUBLE PRECISION :: xtemp , ytemp , ztemp , x_ell , y_ell , z_ell DOUBLE PRECISION :: min_nu , max_nu , min_nu2 , max_nu2 ! The value of nu equal for all the particles, used during the APM iteration DOUBLE PRECISION :: nu_all DOUBLE PRECISION :: err_N_mean_min , err_N_mean_min_old , err_N_mean , & err_mean_old , err_n_min , err_N_max , dN , & !dNstar, & nstar_p_err , nstar_real_err , r_tmp , dN_max , dN_av DOUBLE PRECISION :: art_pr_max DOUBLE PRECISION :: nu_tot , nu_ratio , nu_tmp2 , nuratio_tmp DOUBLE PRECISION :: variance_nu , stddev_nu , mean_nu DOUBLE PRECISION :: rand_num , rand_num2 INTEGER , DIMENSION (:), ALLOCATABLE :: neighbors_lists INTEGER , DIMENSION (:), ALLOCATABLE :: n_neighbors INTEGER , DIMENSION (:), ALLOCATABLE :: seed DOUBLE PRECISION , DIMENSION ( 3 ) :: pos_corr_tmp DOUBLE PRECISION , DIMENSION ( 3 ) :: pos_maxerr DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pos DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pos_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: ghost_pos DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: ghost_pos_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: all_pos DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: all_pos_tmp DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: all_pos_best DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: all_pos_tmp2 DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: correction_pos DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: h_guess DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: h_tmp DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nstar_p DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nstar_real DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: dNstar DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: art_pr DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: freeze DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nu_tmp DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nu_one DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nstar_int DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: particle_density_final DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: nearest_neighbors DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & baryon_density , & energy_density , & specific_energy , & pressure , & v_euler_x , v_euler_y , v_euler_z LOGICAL :: exist LOGICAL :: good_h !CHARACTER:: it_n CHARACTER ( LEN = : ), ALLOCATABLE :: finalnamefile LOGICAL , PARAMETER :: debug = . FALSE . LOGICAL :: few_ncand CALL RANDOM_SEED ( SIZE = dim_seed ) ALLOCATE ( seed ( dim_seed ) ) seed ( 1 ) = 2 seed ( 2 ) = 1 DO itr = 3 , dim_seed seed ( itr ) = seed ( itr - 1 ) + seed ( itr - 2 ) ENDDO CALL RANDOM_SEED ( PUT = seed ) IF ( debug ) PRINT * , \"0\" npart_real = SIZE ( pos_input ( 1 ,:) ) !---------------------------------------! !-- Allocate, assign and test h_guess --! !---------------------------------------! IF (. NOT . ALLOCATED ( h_guess )) THEN ALLOCATE ( h_guess ( max_npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array h_guess in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF h_guess = 0.0D0 DO a = 1 , npart_real , 1 h_guess ( a ) = 3.0D0 * ( pvol ( a ) ** third ) IF ( ISNAN ( h_guess ( a ) ) ) THEN PRINT * , \" ** ERROR! h_guess(\" , a , & \") is a NaN in SUBROUTINE perform_apm!\" PRINT * , \"pvol(\" , a , \")=\" , pvol ( a ) PRINT * , \"    Stopping...\" PRINT * STOP ENDIF IF ( h_guess ( a ) <= 0.0D0 ) THEN PRINT * , \"** ERROR! h_guess(\" , a , \") is zero or negative!\" PRINT * , \"   pvol(\" , a , \")=\" , pvol ( a ) PRINT * , \"   Stopping...\" PRINT * STOP ENDIF ENDDO IF ( debug ) PRINT * , \"0.5\" !--------------------------------------------------------------------! !-- Store particles above xy plane as the first half of the array, --! !-- and mirror them to the second half                             --! !--------------------------------------------------------------------! pos_tmp = pos_input h_tmp = h_guess itr = 0 DO a = 1 , npart_real , 1 IF ( pos_tmp ( 3 , a ) > 0.0D0 ) THEN itr = itr + 1 pos_input ( 1 , itr ) = pos_tmp ( 1 , a ) pos_input ( 2 , itr ) = pos_tmp ( 2 , a ) pos_input ( 3 , itr ) = pos_tmp ( 3 , a ) h_guess ( itr ) = h_tmp ( itr ) ENDIF ENDDO npart_real_half = itr DO a = 1 , npart_real_half , 1 pos_input ( 1 , npart_real_half + a ) = pos_input ( 1 , a ) pos_input ( 2 , npart_real_half + a ) = pos_input ( 2 , a ) pos_input ( 3 , npart_real_half + a ) = - pos_input ( 3 , a ) h_guess ( npart_real_half + a ) = h_guess ( a ) ENDDO npart_real = 2 * npart_real_half IF ( debug ) PRINT * , \"1\" !--------------------------------------------------------------------! !-- Find the maximum and the average smoothing length of the       --! !-- particles whose distance from the center is higher than        --! !-- radius_z, and use them to place ghost particles a little more  --! !-- outside than the surface of the particles.                     --! !--------------------------------------------------------------------! !smaller_radius= ABS( MINVAL( pos_input( 1, : ), DIM= 1 ) - center ) !larger_radius = ABS( center - MAXVAL( pos_input( 1, : ), DIM= 1 ) ) !radius_y= ABS( MAXVAL( pos_input( 2, : ), DIM= 1 ) ) !radius_z= ABS( MAXVAL( pos_input( 3, : ), DIM= 1 ) ) !  IF( pos_input( 1, 10 ) < 0 )THEN ! !    smaller_radius= MIN( binary% get_radius1_x_comp(), & !                         binary% get_radius1_x_opp() ) !    larger_radius = MAX( binary% get_radius1_x_comp(), & !                         binary% get_radius1_x_opp() ) !    radius_y= binary% get_radius1_y() !    radius_z= binary% get_radius1_z() ! !  ELSE ! !    smaller_radius= MIN( binary% get_radius2_x_comp(), & !                         binary% get_radius2_x_opp() ) !    larger_radius = MAX( binary% get_radius2_x_comp(), & !                         binary% get_radius2_x_opp() ) !    radius_y= binary% get_radius2_y() !    radius_z= binary% get_radius2_z() ! !  ENDIF smaller_radius = MIN ( radx_comp , radx_opp ) larger_radius = MAX ( radx_comp , radx_opp ) radius_y = rady radius_z = radz h_max = 0.0D0 h_av = 0.0D0 itr = 0 max_z_real = ABS ( MAXVAL ( pos_input ( 3 , : ), DIM = 1 ) ) DO a = 1 , npart_real , 1 IF ( SQRT ( ( pos_input ( 1 , a ) - center ) ** 2.0D0 & + pos_input ( 2 , a ) ** 2.0D0 & + pos_input ( 3 , a ) ** 2.0D0 ) > 0.99D0 * max_z_real ) THEN itr = itr + 1 IF ( h_guess ( a ) > h_max ) THEN h_max = h_guess ( a ) ENDIF h_av = h_av + h_guess ( a ) ENDIF ENDDO h_av = h_av / itr IF ( debug ) PRINT * , \"h_av=\" , h_av IF ( debug ) PRINT * IF ( debug ) PRINT * , \"2\" !-------------------------------! !--  Placing ghost particles  --! !-------------------------------! IF (. NOT . ALLOCATED ( ghost_pos )) THEN ALLOCATE ( ghost_pos ( 3 , max_npart ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array ghost_pos in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF ghost_pos = 0.0D0 PRINT * , \" * Placing ghost particles on a lattice between ellipsodial \" , & \"surfaces...\" PRINT * max_r_real = 0.0D0 DO itr = 1 , npart_real , 1 r_real = SQRT ( ( pos_input ( 1 , itr ) - center ) ** 2.0D0 & + pos_input ( 2 , itr ) ** 2.0D0 + pos_input ( 3 , itr ) ** 2.0D0 ) IF ( r_real > max_r_real ) max_r_real = r_real ENDDO nx = nx_gh ny = ny_gh nz = nz_gh eps = 5.0D-1 xmin = center - larger_radius * ( 1.0D0 + eps ) xmax = center + larger_radius * ( 1.0D0 + eps ) ymin = - radius_y * ( 1.0D0 + eps ) ymax = radius_y * ( 1.0D0 + eps ) zmin = - radius_z * ( 1.0D0 + eps ) zmax = radius_z * ( 1.0D0 + eps ) dx = ABS ( xmax - xmin ) / DBLE ( nx ) dy = ABS ( ymax - ymin ) / DBLE ( ny ) dz = ABS ( zmax - zmin ) / DBLE ( nz ) IF (. NOT . ALLOCATED ( ghost_pos_tmp )) THEN ALLOCATE ( ghost_pos_tmp ( 3 , nx , ny , nz ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array ghost_pos in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF rad_x = larger_radius + ghost_dist !+ h_av/7.0D0 rad_y = radius_y + ghost_dist !+ h_av/7.0D0 rad_z = radius_z + ghost_dist !+ h_av/7.0D0 IF ( debug ) PRINT * , \"larger_radius= \" , larger_radius IF ( debug ) PRINT * , \"radius_y= \" , radius_y IF ( debug ) PRINT * , \"radius_z= \" , radius_z IF ( debug ) PRINT * , \"rad_x= \" , rad_x IF ( debug ) PRINT * , \"rad_y= \" , rad_y IF ( debug ) PRINT * , \"rad_z= \" , rad_z IF ( debug ) PRINT * ghost_pos_tmp = HUGE ( 0.0D0 ) !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nx, ny, nz, xmin, ymin, zmin, dx, dy, dz, & !$OMP                     ghost_pos_tmp, & !$OMP                     center, rad_x, rad_y, rad_z ) & !$OMP             PRIVATE( i, j, k, xtemp, ytemp, ztemp, & !$OMP                      x_ell, y_ell, z_ell ) DO k = 1 , nz , 1 ztemp = zmin + dz / 2.0D0 + DBLE ( k - 1 ) * dz DO j = 1 , ny , 1 ytemp = ymin + dy / 2.0D0 + DBLE ( j - 1 ) * dy DO i = 1 , nx , 1 xtemp = xmin + dx / 2.0D0 + DBLE ( i - 1 ) * dx x_ell = center + rad_x * COS ( ATAN ( ytemp / ( xtemp - center ) )) & * SIN ( ACOS ( ztemp / SQRT ( ( xtemp - center ) ** 2.0D0 & + ytemp ** 2.0D0 + ztemp ** 2.0D0 ))) y_ell = rad_y * SIN ( ATAN ( ytemp / ( xtemp - center ) )) & * SIN ( ACOS ( ztemp / SQRT ( ( xtemp - center ) ** 2.0D0 & + ytemp ** 2.0D0 + ztemp ** 2.0D0 ))) z_ell = rad_z * ( ztemp / SQRT ( ( xtemp - center ) ** 2.0D0 & + ytemp ** 2.0D0 + ztemp ** 2.0D0 ) ) IF ( SQRT ( ( xtemp - center ) ** 2.0D0 + ytemp ** 2.0D0 & + ztemp ** 2.0D0 ) <= & ellipse_thickness * SQRT ( ( x_ell - center ) ** 2.0D0 & + y_ell ** 2.0D0 + z_ell ** 2.0D0 ) & . AND . & SQRT ( ( xtemp - center ) ** 2.0D0 + ytemp ** 2.0D0 & + ztemp ** 2.0D0 ) >= & SQRT ( ( x_ell - center ) ** 2.0D0 + y_ell ** 2.0D0 & + z_ell ** 2.0D0 ) & . AND . & get_density ( xtemp , ytemp , ztemp ) <= 0.0D0 & ) THEN !itr= itr + 1 !ghost_pos( 1, itr )= xtemp !ghost_pos( 2, itr )= ytemp !ghost_pos( 3, itr )= ztemp ghost_pos_tmp ( 1 , i , j , k ) = xtemp ghost_pos_tmp ( 2 , i , j , k ) = ytemp ghost_pos_tmp ( 3 , i , j , k ) = ztemp ENDIF ENDDO ENDDO ENDDO !$OMP END PARALLEL DO itr = 0 DO k = 1 , nz , 1 DO j = 1 , ny , 1 DO i = 1 , nx , 1 IF ( ghost_pos_tmp ( 1 , i , j , k ) < HUGE ( 0.0D0 ) ) THEN itr = itr + 1 ghost_pos ( 1 , itr ) = ghost_pos_tmp ( 1 , i , j , k ) ghost_pos ( 2 , itr ) = ghost_pos_tmp ( 2 , i , j , k ) ghost_pos ( 3 , itr ) = ghost_pos_tmp ( 3 , i , j , k ) ENDIF ENDDO ENDDO ENDDO npart_ghost = itr IF ( npart_ghost == 0 ) THEN PRINT * , \"** ERROR: No ghost particles were placed. Stopping..\" PRINT * STOP ENDIF ghost_pos = ghost_pos ( :, 1 : npart_ghost ) PRINT * , \" * \" , npart_ghost , \" ghost particles placed around \" , & npart_real , \"real particles.\" PRINT * DEALLOCATE ( ghost_pos_tmp ) PRINT * , \" * Printing ghost particles to file...\" IF ( PRESENT ( namefile_pos_id ) ) THEN finalnamefile = namefile_pos_id ELSE finalnamefile = \"apm_pos_id.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF DO a = 1 , npart_real , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 1 , a , & pos_input ( 1 , a ), & pos_input ( 2 , a ), & pos_input ( 3 , a ) ENDDO DO a = 1 , npart_ghost , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 2 , a , & ghost_pos ( 1 , a ), & ghost_pos ( 2 , a ), & ghost_pos ( 3 , a ) ENDDO CLOSE ( UNIT = 2 ) PRINT * , \" * Positions of ghost and real particles printed to \" , & TRIM ( finalnamefile ), \" .\" !STOP npart_all = npart_real + npart_ghost IF (. NOT . ALLOCATED ( all_pos )) THEN ALLOCATE ( all_pos ( 3 , npart_all ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array ghost_pos in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF all_pos ( :, 1 : npart_real ) = pos_input all_pos ( :, npart_real + 1 : npart_all ) = ghost_pos h_guess = h_guess ( 1 : npart_all ) h_guess ( npart_real + 1 : npart_all ) = ( dx * dy * dz ) ** third !----------------------------! !-- Allocate needed memory --! !----------------------------! npart = npart_all CALL allocate_SPH_memory CALL allocate_RCB_tree_memory_3D ( npart ) iorig ( 1 : npart ) = ( / ( a , a = 1 , npart ) / ) IF ( debug ) PRINT * , \"10\" CALL allocate_gradient ( npart ) CALL allocate_metric_on_particles ( npart ) !------------------------------------------! !-- Apply the artificial pressure method --! !------------------------------------------! PRINT * , \"** Setting up ID for APM iteration...\" PRINT * PRINT * , \" * Assign h...\" PRINT * good_h = . TRUE . DO itr = 1 , 10 , 1 IF ( debug ) PRINT * , itr IF ( debug ) PRINT * CALL assign_h ( nn_des , & npart_all , & all_pos , h_guess , & h ) DO a = 1 , npart_all , 1 IF ( ISNAN ( h ( a ) ) . OR . h ( a ) <= 0.0D0 ) THEN h_guess ( a ) = 3.0D0 * h_guess ( a ) good_h = . FALSE . EXIT ENDIF ENDDO IF ( good_h ) EXIT ENDDO DO a = 1 , npart_all , 1 IF ( ISNAN ( h ( a ) ) ) THEN PRINT * , \"** ERROR! h(\" , a , \") is a NaN!\" PRINT * , \" * h_guess(\" , a , \")= \" , h_guess ( a ) PRINT * , \" * all_pos(:,\" , a , \")= \" , all_pos (:, a ) PRINT * , \" Stopping...\" PRINT * STOP ENDIF IF ( h ( a ) <= 0.0D0 ) THEN ! PRINT *, \"** ERROR! h(\", a, \") is zero or negative!\" ! PRINT *, \" * h_guess(\", a, \")= \", h_guess(a) ! PRINT *, \" * all_pos(:,\", a, \")= \", all_pos(:,a) ! PRINT *, \" * h(\", a, \")= \", h(a) ! PRINT *, \" Stopping...\" ! PRINT * ! STOP IF ( a == 1 ) THEN h ( a ) = h ( a + 1 ) ELSE h ( a ) = h ( a - 1 ) ENDIF ENDIF ENDDO PRINT * , \" * Measure SPH particle number density...\" PRINT * IF (. NOT . ALLOCATED ( nstar_real )) THEN ALLOCATE ( nstar_real ( npart_all ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nstar_real in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF nu = 1.0D0 CALL density_loop ( npart_all , all_pos , & ! input nu , h , nstar_real ) ! output DO a = 1 , npart_all , 1 IF ( ISNAN ( nstar_real ( a ) ) ) THEN PRINT * , \"** WARNING! nstar_real(\" , a , \") is a NaN!\" , & \"   Changing the values of nstar_real and h to one taken\" , & \"   from a neighboring particle.\" IF ( debug ) PRINT * , \" * h(\" , a , \")=\" , h ( a ) IF ( debug ) PRINT * , \" * nu(\" , a , \")=\" , nu ( a ) IF ( debug ) PRINT * , \" * all_pos(\" , a , \")=\" , all_pos (:, a ) IF ( debug ) PRINT * , \" * r(\" , a , \")=\" , & SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 & + all_pos ( 2 , a ) ** 2.0D0 + all_pos ( 3 , a ) ** 2.0D0 ) PRINT * , \" * Check if the smoothing length is 0 for some particles,\" , & \"   and if so, make its initial guess, h_guess, a bit larger.\" PRINT * ENDIF ENDDO IF ( debug ) PRINT * , \"4\" IF (. NOT . ALLOCATED ( nstar_p )) THEN ALLOCATE ( nstar_p ( npart_all ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nstar_p in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF IF ( debug ) PRINT * , \"5\" ALLOCATE ( lapse ( npart_real ) ) ALLOCATE ( shift_x ( npart_real ) ) ALLOCATE ( shift_y ( npart_real ) ) ALLOCATE ( shift_z ( npart_real ) ) ALLOCATE ( g_xx ( npart_real ) ) ALLOCATE ( g_xy ( npart_real ) ) ALLOCATE ( g_xz ( npart_real ) ) ALLOCATE ( g_yy ( npart_real ) ) ALLOCATE ( g_yz ( npart_real ) ) ALLOCATE ( g_zz ( npart_real ) ) ALLOCATE ( baryon_density ( npart_real ) ) ALLOCATE ( energy_density ( npart_real ) ) ALLOCATE ( specific_energy ( npart_real ) ) ALLOCATE ( pressure ( npart_real ) ) ALLOCATE ( v_euler_x ( npart_real ) ) ALLOCATE ( v_euler_y ( npart_real ) ) ALLOCATE ( v_euler_z ( npart_real ) ) IF ( debug ) PRINT * , \"6\" IF ( debug ) PRINT * , \"7\" max_nu = 0.0D0 min_nu = 1.0D60 IF (. NOT . ALLOCATED ( art_pr )) THEN ALLOCATE ( art_pr ( npart_all ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array art_pr in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF IF ( debug ) PRINT * , \"7\" CALL get_nstar_p ( npart_real , all_pos ( 1 , 1 : npart_real ), & all_pos ( 2 , 1 : npart_real ), & all_pos ( 3 , 1 : npart_real ), nstar_p ) IF ( debug ) PRINT * , \"8\" !----------------------------------------------------! !-- enforce centre of mass after having changed nu --! !----------------------------------------------------! CALL correct_center_of_mass ( npart_real , all_pos (:, 1 : npart_real ), & nu ( 1 : npart_real ), get_density , & validate_position_final , com_star , & verbose = . TRUE . ) !-----------------------------------------------------------------------! !-- Mirror the positions after having repositioned the center of mass --! !-----------------------------------------------------------------------! CALL impose_equatorial_plane_symmetry ( npart_real , & all_pos (:, 1 : npart_real ), & nu ( 1 : npart_real ) ) PRINT * , \" * ID set up for the APM iteration.\" PRINT * !-------------------------------------------------! !--               APM iteration                 --! !-- Assume equal mass particles, and move them  --! !-- so that the SPH kernel estimate of the mass --! !-- density matches the star mass density as    --! !-- well as reasonably possible.                --! !-------------------------------------------------! PRINT * , \" * Performing APM iteration...\" PRINT * ALLOCATE ( freeze ( npart_all ) ) ALLOCATE ( correction_pos ( 3 , npart_all ) ) ALLOCATE ( all_pos_tmp ( 3 , npart_all ) ) ALLOCATE ( all_pos_tmp2 ( 3 , npart_all ) ) ! Set the particles to be equal-mass nu_all = ( mass / DBLE ( npart_real )) * umass / amu nu = nu_all DO a = 1 , npart_all IF ( a <= npart_real ) THEN freeze ( a ) = 0 ELSE freeze ( a ) = 1 ENDIF ENDDO CALL correct_center_of_mass ( npart_real , all_pos (:, 1 : npart_real ), & nu ( 1 : npart_real ), get_density , & validate_position_final , com_star , & verbose = . TRUE . ) IF (. NOT . ALLOCATED ( dNstar )) THEN ALLOCATE ( dNstar ( npart_real ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array dNstar in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF IF (. NOT . ALLOCATED ( nu_tmp )) THEN ALLOCATE ( nu_tmp ( npart_real ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array nu_tmp in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF all_pos_tmp2 = - 1.0D0 PRINT * , \" * The APM iteration starts here.\" PRINT * n_inc = 0 err_N_mean_min = HUGE ( 1.0D0 ) apm_iteration : DO itr = 1 , apm_max_it , 1 !IF( itr == 2 ) EXIT PRINT * , ' * Starting with APM step #: ' , itr PRINT * IF ( MOD ( itr , 15 ) == 0 ) THEN !   DO a= 1, npart_real, 1 !     IF( check_particle_position( a - 1, & !                                  all_pos(:,1:a-1), & !                                  all_pos(:,a) ) > 0 & !         .AND. & !         check_particle_position( npart_real - a, & !                                  all_pos(:,a+1:npart_real), & !                                  all_pos(:,a) ) > 0 & !     )THEN ! !       CALL RANDOM_NUMBER( rand_num ) !       CALL RANDOM_NUMBER( rand_num2 ) ! !       IF( rand_num2 < half )  rel_sign= - 1 !       IF( rand_num2 >= half ) rel_sign=   1 ! !       all_pos(:,a)= all_pos(:,a)*( 1.0D0 + & !                                    DBLE(rel_sign)*rand_num*half*third ) ! !     ENDIF !   ENDDO IF ( debug ) PRINT * , \"printing positions to file...\" IF ( PRESENT ( namefile_pos ) ) THEN finalnamefile = namefile_pos ELSE finalnamefile = \"apm_pos.dat\" ENDIF !WRITE(it_n,'(i1)') itr !finalnamefile= \"apm_pos-\"//it_n//\".dat\" INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF DO a = 1 , npart_real , 1 tmp = get_density ( all_pos ( 1 , a ), all_pos ( 2 , a ), all_pos ( 3 , a ) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 1 , a , & all_pos ( 1 , a ), & all_pos ( 2 , a ), & all_pos ( 3 , a ), & tmp ENDDO DO a = npart_real + 1 , npart_all , 1 tmp = get_density ( all_pos ( 1 , a ), all_pos ( 2 , a ), all_pos ( 3 , a ) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 2 , a , & all_pos ( 1 , a ), & all_pos ( 2 , a ), & all_pos ( 3 , a ), & tmp ENDDO CLOSE ( UNIT = 2 ) ENDIF IF ( debug ) PRINT * , \"enforcing center of mass...\" CALL correct_center_of_mass ( npart_real , all_pos (:, 1 : npart_real ), & nu ( 1 : npart_real ), get_density , & validate_position_final , com_star ) IF ( debug ) PRINT * , \"mirroring particles...\" CALL impose_equatorial_plane_symmetry ( npart_real , & all_pos (:, 1 : npart_real ), & nu ( 1 : npart_real ) ) IF ( debug ) THEN CALL COM ( npart_real , all_pos (:, 1 : npart_real ), nu ( 1 : npart_real ), & ! input com_x , com_y , com_z , com_d ) ! output PRINT * , \"** After center of mass correction:\" PRINT * , \" * x coordinate of the center of mass of the star, \" , & \"from LORENE: com_star= \" , com_star , \"Msun_geo\" PRINT * , \" * x coordinate of the center of mass of the particle \" , & \"distribution: com_x= \" , com_x , \"Msun_geo\" PRINT * , \" * y coordinate of the center of mass of the particle \" , & \"distribution: com_y= \" , com_y , \"Msun_geo\" PRINT * , \" * z coordinate of the center of mass of the particle \" , & \"distribution: com_z= \" , com_z , \"Msun_geo\" PRINT * , \" * Distance of the center of mass of the particle \" , & \"distribution from the  origin: com_d= \" , com_d PRINT * , \" * |com_x-com_star/com_star|=\" , & ABS ( com_x - com_star ) / ABS ( com_star + 1 ) PRINT * finalnamefile = \"dbg-pos.dat\" INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF DO a = 1 , npart_real / 2 , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 1 , a , & all_pos ( 1 , a ), & all_pos ( 2 , a ), & all_pos ( 3 , a ) ENDDO DO a = npart_real / 2 + 1 , npart_real , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 2 , a , & all_pos ( 1 , a ), & all_pos ( 2 , a ), & all_pos ( 3 , a ) ENDDO DO a = npart_real + 1 , npart_all , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 3 , a , & all_pos ( 1 , a ), & all_pos ( 2 , a ), & all_pos ( 3 , a ) ENDDO CLOSE ( UNIT = 2 ) ENDIF IF ( debug ) PRINT * , \"assign h...\" h_guess ( 1 : npart_real ) = h ( 1 : npart_real ) !h_guess(npart_real+1:npart_all)= dx*dy*dz CALL assign_h ( nn_des , & npart_all , & all_pos , h_guess , h ) find_problem_in_h : DO a = 1 , npart_all , 1 IF ( ISNAN ( h ( a ) ) ) THEN PRINT * , \"** ERROR! h(\" , a , \") is a NaN!\" PRINT * , \" * h_guess(\" , a , \")= \" , h_guess ( a ) PRINT * , \" * all_pos(:,\" , a , \")= \" , all_pos (:, a ) PRINT * , \" Stopping...\" PRINT * STOP ENDIF IF ( h ( a ) <= 0.0D0 ) THEN ! PRINT *, \"** ERROR! h(\", a, \") is zero or negative!\" ! PRINT *, \" * h_guess(\", a, \")= \", h_guess(a) ! PRINT *, \" * all_pos(:,\", a, \")= \", all_pos(:,a) ! PRINT *, \" * h(\", a, \")= \", h(a) ! PRINT *, \" Stopping...\" ! PRINT * ! STOP IF ( a == 1 ) THEN DO a2 = 2 , npart_real , 1 IF ( h ( a2 ) > 0.0D0 ) THEN h ( a ) = h ( a2 ) EXIT ENDIF ENDDO ELSE h ( a ) = h ( a - 1 ) ENDIF ENDIF ENDDO find_problem_in_h IF ( debug ) PRINT * , \"density_loop...\" CALL density_loop ( npart_all , all_pos , & ! input nu , h , nstar_real ) ! output IF ( debug ) PRINT * , \"npart_real= \" , npart_real IF ( debug ) PRINT * , \"npart_all= \" , npart_all IF ( debug ) PRINT * find_nan_in_nstar_real : DO a = 1 , npart_all , 1 IF ( ISNAN ( nstar_real ( a ) ) ) THEN PRINT * , \"** WARNING! nstar_real(\" , a , \") is a NaN!\" , & \"   Changing the values of nstar_real and h to one taken\" , & \"   from a neighboring particle.\" IF ( debug ) PRINT * , \" * h(\" , a , \")=\" , h ( a ) IF ( debug ) PRINT * , \" * nu(\" , a , \")=\" , nu ( a ) IF ( debug ) PRINT * , \" * all_pos(\" , a , \")=\" , all_pos (:, a ) IF ( debug ) PRINT * , \" * r(\" , a , \")=\" , & SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 & + all_pos ( 2 , a ) ** 2.0D0 + all_pos ( 3 , a ) ** 2.0D0 ) PRINT * STOP IF ( a == 1 ) THEN DO a2 = 2 , npart_all , 1 IF ( . NOT . ISNAN ( nstar_real ( a2 ) ) ) THEN nstar_real ( a ) = nstar_real ( a2 ) h ( a ) = h ( a2 ) EXIT ENDIF ENDDO ELSEIF ( npart_real == a ) THEN nstar_real ( a ) = nstar_real ( a - 1 ) h ( a ) = h ( a - 1 ) ELSEIF ( npart_real + 1 == a ) THEN nstar_real ( a ) = nstar_real ( a + 1 ) h ( a ) = h ( a + 1 ) !ELSEIF( npart_all == a )THEN !  nstar_real( a )= nstar_real( a - 1 ) ELSE nstar_real ( a ) = nstar_real ( a - 1 ) h ( a ) = h ( a - 1 ) ENDIF ENDIF ENDDO find_nan_in_nstar_real CALL get_nstar_p ( npart_real , all_pos ( 1 , 1 : npart_real ), & all_pos ( 2 , 1 : npart_real ), & all_pos ( 3 , 1 : npart_real ), nstar_p ) art_pr_max = 0.0D0 err_N_max = 0.0D0 err_N_min = 1.D30 err_N_mean = 0.0D0 DO a = 1 , npart_real , 1 dNstar ( a ) = ( nstar_real ( a ) - nstar_p ( a ) ) / nstar_p ( a ) art_pr ( a ) = MAX ( 1.0D0 + dNstar ( a ), 0.1D0 ) art_pr_max = MAX ( art_pr_max , art_pr ( a ) ) IF ( ABS ( dNstar ( a )) > err_N_max ) THEN err_N_max = ABS ( dNstar ( a )) pos_maxerr = all_pos (:, a ) nstar_real_err = nstar_real ( a ) nstar_p_err = nstar_p ( a ) ENDIF !err_N_max = MAX( err_N_max, ABS(dNstar) ) err_N_min = MIN ( err_N_min , ABS ( dNstar ( a )) ) err_N_mean = err_N_mean + ABS ( dNstar ( a )) IF ( ISNAN ( dNstar ( a )) ) THEN PRINT * , \"dNstar is a NaN at particle \" , a PRINT * , \"nstar_real is \" , nstar_real ( a ) PRINT * , \"nstar_p is \" , nstar_p ( a ) STOP ENDIF ENDDO IF ( ISNAN ( art_pr_max ) ) THEN PRINT * , \"** ERROR! art_pr_max is a NaN!\" , & \" Stopping..\" PRINT * STOP ENDIF IF ( ISNAN ( nu_all ) ) THEN PRINT * , \"** ERROR! nu_all is a NaN!\" , & \" Stopping..\" PRINT * STOP ENDIF ! !-- Assign artificial pressure to the ghost particles ! nstar_p ( npart_real + 1 : npart_all ) = 0.0D0 !art_pr ( npart_real+1:npart_all )= 6.0D0*art_pr_max DO a = npart_real + 1 , npart_all , 1 x_ell = center & + rad_x * COS ( ATAN ( all_pos ( 2 , a ) / ( all_pos ( 1 , a ) - center ) )) & * SIN ( ACOS ( all_pos ( 3 , a ) / SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 & + all_pos ( 2 , a ) ** 2.0D0 + all_pos ( 3 , a ) ** 2.0D0 ))) y_ell = rad_y * SIN ( ATAN ( all_pos ( 2 , a ) / ( all_pos ( 1 , a ) - center ) )) & * SIN ( ACOS ( all_pos ( 3 , a ) / SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 & + all_pos ( 2 , a ) ** 2.0D0 + all_pos ( 3 , a ) ** 2.0D0 ))) z_ell = rad_z * ( all_pos ( 3 , a ) / SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 & + all_pos ( 2 , a ) ** 2.0D0 + all_pos ( 3 , a ) ** 2.0D0 ) ) DO itr2 = 1 , 10 , 1 IF ( SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 + all_pos ( 2 , a ) ** 2.0D0 & + all_pos ( 3 , a ) ** 2.0D0 ) <= & ( 1.0D0 + ( ellipse_thickness - 1.0D0 ) * DBLE ( itr ) / 1 0.0D0 ) & * SQRT ( ( x_ell - center ) ** 2.0D0 & + y_ell ** 2.0D0 + z_ell ** 2.0D0 ) & . AND . & SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 + all_pos ( 2 , a ) ** 2.0D0 & + all_pos ( 3 , a ) ** 2.0D0 ) >= & ( 1.0D0 + ( ellipse_thickness - 1.0D0 ) * DBLE ( itr - 1 ) / 1 0.0D0 ) & * SQRT ( ( x_ell - center ) ** 2.0D0 & + y_ell ** 2.0D0 + z_ell ** 2.0D0 ) & ) THEN art_pr ( a ) = DBLE ( 3 * itr ) * art_pr_max ENDIF ENDDO ENDDO IF ( debug ) PRINT * , \"Before calling position_correction\" IF ( debug ) PRINT * , npart_all IF ( debug ) PRINT * , SIZE ( all_pos ( 1 ,:)) IF ( debug ) PRINT * , SIZE ( h ) IF ( debug ) PRINT * , SIZE ( art_pr ) IF ( debug ) PRINT * , SIZE ( nstar_real ) IF ( debug ) PRINT * , SIZE ( correction_pos ( 1 ,:)) find_nan_in_art_pr : DO a = 1 , npart_all , 1 IF ( ISNAN ( art_pr ( a ) ) ) THEN PRINT * , \"** ERROR! art_pr(\" , a , \") is a NaN!\" , & \" Stopping..\" PRINT * STOP ENDIF IF ( art_pr ( a ) > HUGE ( 1.0D0 ) ) THEN PRINT * , \"** ERROR! art_pr(\" , a , \")= \" , art_pr ( a ), \" is infinite!\" ,& \" Stopping..\" PRINT * STOP ENDIF ENDDO find_nan_in_art_pr err_N_mean = err_N_mean / DBLE ( npart_real ) err_N_mean_min = MIN ( err_N_mean , err_N_mean_min ) IF ( err_N_mean_min == err_N_mean ) THEN all_pos_best = all_pos ENDIF PRINT * , \" * Maximum relative error between the star density profile\" , & \"   and its SPH estimate: err_N_max= \" , err_N_max PRINT * , \"     at position: x=\" , pos_maxerr ( 1 ), \", y=\" , pos_maxerr ( 2 ), & \", z=\" , pos_maxerr ( 3 ) PRINT * , \"     with r/r_x_opp= \" , SQRT ( & ( ABS ( pos_maxerr ( 1 )) - ABS ( center ) ) ** 2.0D0 & + pos_maxerr ( 2 ) ** 2.0D0 & + pos_maxerr ( 3 ) ** 2.0D0 ) & / smaller_radius PRINT * , \"   The LORENE density is   = \" , nstar_p_err PRINT * , \"   The SPH estimate is= \" , nstar_real_err PRINT * PRINT * , \" * Minimum relative error between the star density profile\" , & \" and its SPH estimate: \" , err_N_min PRINT * , \" * Average relative error between the star density profile\" , & \" and its SPH estimate: \" , err_N_mean PRINT * , \" * Minimum of the average relative error between the star\" , & \" density profile and its SPH estimate: \" , err_N_mean_min PRINT * ! !-- Compute what would be the baryon number at this step ! ! Compute particle number density nu = 1.0D0 CALL density_loop ( npart_all , all_pos , & ! input nu , h , nstar_real ) ! output nu = nu_all !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nu_tmp, nu, nstar_p, nstar_real, & !$OMP                     nuratio_thres, npart_real ) & !$OMP             PRIVATE( nu_tmp2, a ) DO a = 1 , npart_real , 1 nu_tmp2 = nu ( a ) nu_tmp ( a ) = nstar_p ( a ) / nstar_real ( a ) IF ( nu_tmp ( a ) > nu_tmp2 * SQRT ( nuratio_thres ) ) nu_tmp ( a ) = & nu_tmp2 * SQRT ( nuratio_thres ) IF ( nu_tmp ( a ) < nu_tmp2 / SQRT ( nuratio_thres ) ) nu_tmp ( a ) = & nu_tmp2 / SQRT ( nuratio_thres ) ENDDO !$OMP END PARALLEL DO nuratio_tmp = MAXVAL ( nu_tmp ( 1 : npart_real ), DIM = 1 )& / MINVAL ( nu_tmp ( 1 : npart_real ), DIM = 1 ) PRINT * , \" * Stopping the APM iteration at this step, with a threshold\" , & \" for the baryon number ratio equal to \" PRINT * , \"   nu_thres=\" , nuratio_thres , \",\" PRINT * , \"   the baryon number ratio would be equal to the following.\" PRINT * , \" * Temporary CORRECTED maximum baryon number at this step=\" , & MAXVAL ( nu_tmp ( 1 : npart_real ), DIM = 1 ) PRINT * , \" * Temporary CORRECTED minimum baryon number at this step=\" , & MINVAL ( nu_tmp ( 1 : npart_real ), DIM = 1 ) PRINT * , \" * Temporary CORRECTED baryon number ratio at this step=\" , & nuratio_tmp PRINT * ! Exit condition IF ( err_N_mean > err_mean_old ) THEN n_inc = n_inc + 1 ENDIF !IF( ABS( err_N_mean - err_mean_old )/ABS( err_mean_old ) < iter_tol & !    .AND. & !    err_N_max < 10.0D0 & !)THEN !  n_inc= n_inc + 1 !  PRINT *, \"n_inc/max_inc= \", n_inc, \"/\", max_inc !  PRINT *, \"ABS( err_N_mean - err_mean_old )/ABS(err_mean_old)= \", & !           ABS( err_N_mean - err_mean_old )/ABS(err_mean_old) !ENDIF !IF( ABS(err_N_mean_min - err_N_mean_min_old)/ABS(err_N_mean_min_old) & !      < 10.0D0*iter_tol & !    .AND. & !    ABS(err_N_mean - err_N_mean_min)/ABS(err_N_mean_min) < iter_tol & !)THEN !  n_inc= n_inc + 1 !  PRINT *, \"n_inc/max_inc= \", n_inc, \"/\", max_inc !  PRINT *, err_N_mean, \"err_N_mean\" !  PRINT *, err_N_mean_min, \"err_N_mean_min\" !  PRINT *, \"ABS(err_N_mean - err_N_mean_min)/ABS(err_N_mean_min)= \", & !           ABS(err_N_mean - err_N_mean_min)/ABS(err_N_mean_min), \" < \", & !           iter_tol !ELSE !  n_inc= 0 !ENDIF ! !-- EXIT conditions ! IF ( nuratio_des > 0.0D0 ) THEN IF ( ( nuratio_tmp >= nuratio_des * 0.975D0 . AND . & nuratio_tmp <= nuratio_des * 1.025D0 . AND . & nuratio_tmp /= nuratio_thres ) . OR . itr == apm_max_it ) EXIT ELSE PRINT * , \" * n_inc= \" , n_inc PRINT * IF ( n_inc == max_inc . OR . itr == apm_max_it ) EXIT ENDIF err_mean_old = err_N_mean err_N_mean_min_old = err_N_mean_min ! !-- If the particle distribution is not yet good enough, update it ! PRINT * , \" * Updating positions...\" PRINT * all_pos_tmp2 = all_pos CALL position_correction ( npart_all , & all_pos , h , nu_all , art_pr , nstar_real , & correction_pos ) find_nan_in_correction_pos : DO a = 1 , npart_all , 1 DO itr2 = 1 , 3 , 1 IF ( ISNAN ( correction_pos ( itr2 , a ) ) ) THEN PRINT * , \"** ERROR! correction_pos(\" , itr2 , \",\" , a , \") is a NaN!\" PRINT * , \" *        Particle position: x=\" , all_pos ( 1 , a ), & \", y=\" , all_pos ( 2 , a ), \", z=\" , all_pos ( 3 , a ) r_tmp = SQRT ( ( all_pos ( 1 , a ) - center ) ** 2.0D0 + & all_pos ( 2 , a ) ** 2.0D0 + all_pos ( 3 , a ) ** 2.0D0 ) PRINT * , \" *        Particle radius: r=\" , r_tmp , & \"=\" , r_tmp / larger_radius * 10 0.0D0 , & \"% of the larger radius of the star.\" PRINT * , \" *        Particle colatitude: theta=\" , & ACOS ( all_pos ( 3 , a ) / r_tmp ) / pi , \" pi\" PRINT * , \" *        Particle longitude: phi=\" , & ATAN ( all_pos ( 2 , a ) / all_pos ( 1 , a ) ) / pi , \" pi\" PRINT * , \" * Stopping..\" PRINT * STOP ENDIF ENDDO ENDDO find_nan_in_correction_pos IF ( debug ) PRINT * , \"After calling position_correction\" !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( all_pos, correction_pos, & !$OMP                     dNstar, npart_real, nstar_p ) & !$OMP             PRIVATE( pos_corr_tmp, a, cnt, rand_num, rand_num2, & !$OMP                      rel_sign ) DO a = 1 , npart_real , 1 IF ( dNstar ( a ) >= 10 0.0D0 ) THEN pos_corr_tmp = all_pos (:, a ) + 1 0.0D0 * correction_pos (:, a ) ELSEIF ( dNstar ( a ) >= 1 0.0D0 ) THEN pos_corr_tmp = all_pos (:, a ) + 3.0D0 * correction_pos (:, a ) ELSE pos_corr_tmp = all_pos (:, a ) + correction_pos (:, a ) ENDIF !    IF( get_density( & !              pos_corr_tmp(1), pos_corr_tmp(2), pos_corr_tmp(3) ) > 0.0D0 & !        .AND. & !        nstar_p(a) > 0.0D0 & !        .AND. & !        validate_position_final( & !              pos_corr_tmp(1), pos_corr_tmp(2), pos_corr_tmp(3) ) == 0 & !    )THEN ! !      all_pos(:,a)= pos_corr_tmp ! !    ENDIF cnt = 0 DO IF ( get_density ( & pos_corr_tmp ( 1 ), pos_corr_tmp ( 2 ), pos_corr_tmp ( 3 ) ) > 0.0D0 & . AND . & validate_position_final ( & pos_corr_tmp ( 1 ), pos_corr_tmp ( 2 ), pos_corr_tmp ( 3 ) ) == 0 & !.AND. & !check_particle_position( a - 1, & !                         all_pos(:,1:a-1), & !                         pos_corr_tmp ) == 0 & !.AND. & !check_particle_position( npart_real - a, & !                         all_pos(:,a+1:npart_real), & !                         pos_corr_tmp ) == 0 & ) THEN all_pos (:, a ) = pos_corr_tmp EXIT ELSEIF ( cnt <= search_pos ) THEN cnt = cnt + 1 !  pos_corr_tmp= pos_corr_tmp*3.0D0/4.0D0 CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 pos_corr_tmp ( 1 ) = all_pos ( 1 , a ) + & correction_pos ( 1 , a ) * ( 1.0D0 + DBLE ( rel_sign ) * rand_num * half ) CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 pos_corr_tmp ( 2 ) = all_pos ( 2 , a ) + & correction_pos ( 2 , a ) * ( 1.0D0 + DBLE ( rel_sign ) * rand_num * half ) CALL RANDOM_NUMBER ( rand_num ) CALL RANDOM_NUMBER ( rand_num2 ) IF ( rand_num2 < half ) rel_sign = - 1 IF ( rand_num2 >= half ) rel_sign = 1 pos_corr_tmp ( 3 ) = all_pos ( 3 , a ) + & correction_pos ( 3 , a ) * ( 1.0D0 + DBLE ( rel_sign ) * rand_num * half ) !pos_corr_tmp*( 1.0D0 + DBLE(rel_sign)*rand_num*half*third ) ELSEIF ( cnt == search_pos + 1 ) THEN ! cnt= cnt + 1 ! CALL RANDOM_NUMBER( rand_num ) ! CALL RANDOM_NUMBER( rand_num2 ) ! ! IF( rand_num2 < half )  rel_sign= - 1 ! IF( rand_num2 >= half ) rel_sign=   1 ! all_pos(:,a)= all_pos(:,a)*( 1.0D0 -rand_num*half*third ) EXIT ENDIF !IF( cnt == 11 ) EXIT ENDDO ENDDO !$OMP END PARALLEL DO find_nan_in_all_pos : DO a = 1 , npart_all , 1 DO itr2 = 1 , 3 , 1 IF ( ISNAN ( all_pos ( itr2 , a ) ) ) THEN PRINT * , \"** ERROR! all_pos(\" , itr2 , \",\" , a , \") is a NaN!\" , & \" Stopping..\" PRINT * STOP ENDIF ENDDO ENDDO find_nan_in_all_pos ! If some of the particles crossed the xy plane top-down in the ! last step, reflect them back above the xy plane !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( all_pos, all_pos_tmp2, npart_real ) & !$OMP             PRIVATE( a ) DO a = 1 , npart_real , 1 IF ( all_pos_tmp2 ( 3 , a ) > 0 . AND . & all_pos ( 3 , a ) <= 0 ) THEN all_pos ( 3 , a ) = all_pos_tmp2 ( 3 , a ) ENDIF ENDDO !$OMP END PARALLEL DO IF ( debug ) PRINT * , \"After correcting positions\" ENDDO apm_iteration PRINT * , \"** APM iteration completed.\" PRINT * ! Now get rid of the ghost particles IF (. NOT . ALLOCATED ( pos )) THEN ALLOCATE ( pos ( 3 , npart_real ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array pos in SUBROUTINE \" , & \"perform_apm. The error message is\" ,& err_msg STOP ENDIF ENDIF pos = all_pos ( :, 1 : npart_real ) npart = npart_real IF ( debug ) PRINT * , npart h_guess = h ( 1 : npart_real ) !----------------------------! !-- enforce centre of mass --! !----------------------------! CALL correct_center_of_mass ( npart_real , pos , & nu ( 1 : npart_real ), get_density , & validate_position_final , com_star , & verbose = . TRUE . ) !-----------------------------------------------------------------------! !-- Mirror the positions after having repositioned the center of mass --! !-----------------------------------------------------------------------! CALL impose_equatorial_plane_symmetry ( npart_real , & all_pos (:, 1 : npart_real ), & nu ( 1 : npart_real ) ) !-----------------------------! !-- Print positions to file --! !-----------------------------! IF ( PRESENT ( namefile_pos ) ) THEN finalnamefile = namefile_pos ELSE finalnamefile = \"apm_pos.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF DO a = 1 , npart_real , 1 tmp = get_density ( pos ( 1 , a ), pos ( 2 , a ), pos ( 3 , a ) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 1 , a , & pos ( 1 , a ), & pos ( 2 , a ), & pos ( 3 , a ), & tmp ENDDO DO a = npart_real + 1 , npart_all , 1 tmp = get_density ( all_pos ( 1 , a ), all_pos ( 2 , a ), all_pos ( 3 , a ) ) WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & 2 , a , & all_pos ( 1 , a ), & all_pos ( 2 , a ), & all_pos ( 3 , a ), & tmp ENDDO CLOSE ( UNIT = 2 ) !-------------------------------------------------------------------! !-- now assign baryon number to match profile as good as possible --! !-------------------------------------------------------------------! PRINT * , \" * Assign baryon number...\" PRINT * IF ( debug ) PRINT * , \"1\" h = h ( 1 : npart_real ) h_guess = h_guess ( 1 : npart_real ) nu = nu ( 1 : npart_real ) CALL assign_h ( nn_des , & ! npart_real , & ! pos , h_guess , & ! Input h ) ! Output find_problem_in_h_2 : DO a = 1 , npart_real , 1 IF ( ISNAN ( h ( a ) ) ) THEN PRINT * , \"** ERROR! h(\" , a , \") is a NaN!\" PRINT * , \" * h_guess(\" , a , \")= \" , h_guess ( a ) PRINT * , \" * all_pos(:,\" , a , \")= \" , all_pos (:, a ) PRINT * , \" Stopping...\" PRINT * STOP ENDIF IF ( h ( a ) <= 0.0D0 ) THEN ! PRINT *, \"** ERROR! h(\", a, \") is zero or negative!\" ! PRINT *, \" * h_guess(\", a, \")= \", h_guess(a) ! PRINT *, \" * all_pos(:,\", a, \")= \", all_pos(:,a) ! PRINT *, \" * h(\", a, \")= \", h(a) ! PRINT *, \" Stopping...\" ! PRINT * ! STOP IF ( a == 1 ) THEN DO a2 = 2 , npart_real , 1 IF ( h ( a2 ) > 0.0D0 ) THEN h ( a ) = h ( a2 ) EXIT ENDIF ENDDO ELSE h ( a ) = h ( a - 1 ) ENDIF ENDIF ENDDO find_problem_in_h_2 IF ( debug ) PRINT * , \"2\" ! Measure SPH particle number density nu = 1.0D0 CALL density_loop ( npart_real , pos , & ! input nu , h , nstar_real ) ! output IF ( debug ) PRINT * , \"3\" CALL get_nstar_p ( npart_real , pos ( 1 ,:), & pos ( 2 ,:), & pos ( 3 ,:), nstar_p ) nu = nu_all PRINT * , \" * Baryon number on all particles before correction nu_all= \" , & nu_all nu_tot = 0.0D0 DO a = 1 , npart_real , 1 nu_tot = nu_tot + nu ( a ) ENDDO PRINT * , \" * Total baryon number nu_tot=\" , nu_tot PRINT * , \" * Total baryon mass= \" , nu_tot * amu / MSun , \"=\" , & 10 0.0D0 * nu_tot * amu / MSun / mass , \"% of the LORENE baryon mass\" PRINT * IF ( debug ) PRINT * , \"4\" IF ( debug ) PRINT * , \"npart_real= \" , npart_real IF ( debug ) PRINT * , \"SIZE(nu)= \" , SIZE ( nu ) IF ( debug ) PRINT * IF ( debug ) nu_ratio = MAXVAL ( nu , DIM = 1 ) / MINVAL ( nu , DIM = 1 ) IF ( debug ) PRINT * , \" * nu_ratio before correction = \" , nu_ratio IF ( debug ) PRINT * !----------------------! !-- Correcting nu... --! !----------------------! PRINT * , \" * Correcting nu...\" PRINT * !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nu_tmp, nu, nstar_p, nstar_real, & !$OMP                     nuratio_thres, npart_real ) & !$OMP             PRIVATE( nu_tmp2, a ) DO a = 1 , npart_real , 1 nu_tmp2 = nu ( a ) nu ( a ) = nstar_p ( a ) / nstar_real ( a ) IF ( nu ( a ) > nu_tmp2 * SQRT ( nuratio_thres ) ) nu ( a ) = & nu_tmp2 * SQRT ( nuratio_thres ) IF ( nu ( a ) < nu_tmp2 / SQRT ( nuratio_thres ) ) nu ( a ) = & nu_tmp2 / SQRT ( nuratio_thres ) ENDDO !$OMP END PARALLEL DO ! !-- Check that nu is acceptable ! DO a = 1 , npart_real , 1 IF ( ISNAN ( nu ( a ) ) ) THEN PRINT * , \" * ERROR! nu(\" , a , \") is a NaN.\" PRINT * , \" nstar_real(a)= \" , nstar_real ( a ) PRINT * , \" nstar_p(a)= \" , nstar_p ( a ) PRINT * , \" Stopping...\" PRINT * STOP ENDIF IF ( nu ( a ) < 0.0D0 ) THEN PRINT * , \" * ERROR! nu(\" , a , \") is negative.\" PRINT * , \" nu(a)= \" , nu ( a ) PRINT * , \" nstar_real(a)= \" , nstar_real ( a ) PRINT * , \" nstar_p(a)= \" , nstar_p ( a ) PRINT * , \" Stopping...\" PRINT * STOP ENDIF ENDDO nu_ratio = MAXVAL ( nu , DIM = 1 ) / MINVAL ( nu , DIM = 1 ) PRINT * , \" * nu_ratio after correction = \" , nu_ratio PRINT * max_nu = 0.0D0 min_nu = HUGE ( 1.0D0 ) DO a = 1 , npart_real , 1 IF ( nu ( a ) > max_nu ) THEN max_nu = nu ( a ) a_numax = a ENDIF IF ( nu ( a ) < min_nu ) THEN min_nu = nu ( a ) a_numin = a ENDIF ENDDO PRINT * , \" * Baryon number assigned.\" PRINT * IF ( mass_it ) THEN ! just a few iterations to NOT get the nu-ratio too large mass_iteration : DO itr = 1 , m_max_it , 1 ! measure density CALL density_loop ( npart_real , pos , & ! input nu , h , nstar_real ) ! output CALL get_nstar_p ( npart_real , pos ( 1 ,:), & pos ( 2 ,:), & pos ( 3 ,:), nstar_p ) !nstar_p( npart_real+1:npart_all )= 0.0D0 ! get RELATIVE nu's right dN_av = 0.0D0 max_nu = 0.0D0 min_nu = HUGE ( 1.0D0 ) DO a = 1 , npart_real , 1 dN = ( nstar_real ( a ) - nstar_p ( a )) / nstar_p ( a ) nu ( a ) = nu ( a ) * ( 1.0D0 - dN ) dN_av = dN_av + dN IF ( nu ( a ) > max_nu ) THEN max_nu = nu ( a ) a_numax = a ENDIF IF ( nu ( a ) < min_nu ) THEN min_nu = nu ( a ) a_numin = a ENDIF ENDDO dN_av = dN_av / DBLE ( npart_real ) ! exit condition IF ( dN_av < tol ) EXIT ENDDO mass_iteration ENDIF !  PRINT *, \"max_nu=\", max_nu !  PRINT *, \"        at \", pos(:, a_numax), \" r= \", & !           NORM2( pos(:, a_numax) )/larger_radius !  PRINT *, \"min_nu=\", min_nu !  PRINT *, \"        at \", pos(:, a_numin), \" r= \", & !           NORM2( pos(:, a_numin) )/larger_radius !  PRINT *, \"max_nu/min_nu=\", max_nu/min_nu !  PRINT * PRINT * , \" * CORRECTED maximum baryon number at this step=\" , & max_nu PRINT * , \" * CORRECTED minimum baryon number at this step=\" , & min_nu PRINT * , \" * CORRECTED baryon number ratio at this step=\" , & max_nu / min_nu PRINT * max_nu2 = 0.0D0 min_nu2 = HUGE ( 1.0D0 ) DO a = 1 , npart_real , 1 IF ( nu ( a ) > max_nu2 . AND . a /= a_numax ) THEN max_nu2 = nu ( a ) a_numax2 = a ENDIF IF ( nu ( a ) < min_nu2 . AND . a /= a_numin ) THEN min_nu2 = nu ( a ) a_numin2 = a ENDIF ENDDO PRINT * , \"Excluding the absolute max and min of nu:\" PRINT * PRINT * , \"max_nu=\" , max_nu2 PRINT * , \"        at \" , pos (:, a_numax2 ), \" r= \" , & NORM2 ( pos (:, a_numax2 ) ) / larger_radius PRINT * , \"min_nu=\" , min_nu2 PRINT * , \"        at \" , pos (:, a_numin2 ), \" r= \" , & NORM2 ( pos (:, a_numin2 ) ) / larger_radius PRINT * , \"max_nu/min_nu=\" , max_nu2 / min_nu2 PRINT * nu_tot = 0.0D0 DO a = 1 , npart_real , 1 nu_tot = nu_tot + nu ( a ) ENDDO mean_nu = nu_tot / npart_real variance_nu = 0.0 ! compute variance DO a = 1 , npart_real , 1 variance_nu = variance_nu + ( nu ( a ) - mean_nu ) ** 2.0D0 END DO variance_nu = variance_nu / DBLE ( npart_real - 1 ) stddev_nu = SQRT ( variance_nu ) ! compute standard deviation PRINT * , \"mean_nu=\" , mean_nu PRINT * , \"variance_nu=\" , variance_nu PRINT * , \"stddev_nu=\" , stddev_nu PRINT * , \"stddev_nu/mean_nu=\" , stddev_nu / mean_nu PRINT * PRINT * , \"Before correcting nu to match the mass of the star...\" PRINT * PRINT * , \"nu_tot=\" , nu_tot PRINT * , \"mass estimate= \" , nu_tot * amu / MSun , \"=\" , & 10 0.0D0 * nu_tot * amu / MSun / mass , \"% of the LORENE baryon mass\" PRINT * IF ( correct_nu ) THEN nu = nu / ( nu_tot * amu / Msun / mass ) nu_tot = 0.0D0 DO a = 1 , npart_real , 1 nu_tot = nu_tot + nu ( a ) ENDDO PRINT * , \"After correcting nu to match the mass of the star...\" PRINT * PRINT * , \"nu_tot=\" , nu_tot PRINT * , \"mass estimate= \" , nu_tot * amu / MSun , \"=\" , & 10 0.0D0 * nu_tot * amu / MSun / mass , \"% of the LORENE baryon mass\" PRINT * ENDIF !----------------------------! !-- enforce centre of mass --! !----------------------------! CALL correct_center_of_mass ( npart_real , pos , & nu ( 1 : npart_real ), get_density , & validate_position_final , com_star , & verbose = . TRUE . ) !-----------------------------------------------------------------------! !-- Mirror the positions after having repositioned the center of mass --! !-----------------------------------------------------------------------! CALL impose_equatorial_plane_symmetry ( npart_real , & all_pos (:, 1 : npart_real ), & nu ( 1 : npart_real ) ) !-------------------! !-- monitoring... --! !-------------------! ! measure density CALL density_loop ( npart_real , pos , & ! input nu , h , nstar_real ) ! output CALL get_nstar_p ( npart_real , pos ( 1 ,:), & pos ( 2 ,:), & pos ( 3 ,:), nstar_p ) !nstar_p( npart_real+1:npart_all )= 0.0D0 ! get RELATIVE nu's right dN_av = 0.0D0 dN_max = 0.0D0 DO a = 1 , npart_real , 1 dN = ABS ( nstar_real ( a ) - nstar_p ( a )) / nstar_p ( a ) dN_max = MAX ( dN_max , dN ) dN_av = dN_av + dN ENDDO dN_av = dN_av / DBLE ( npart_real ) PRINT * , '...dN_max ' , dN_max PRINT * , '...dN_av  ' , dN_av PRINT * IF ( debug ) PRINT * , \"100\" IF ( . NOT . ALLOCATED ( nstar_int ) ) ALLOCATE ( nstar_int ( npart_real ) ) IF ( debug ) PRINT * , \"101\" ! Determine smoothing length so that each particle has exactly ! 300 neighbours inside 2h CALL assign_h ( nn_des , & npart_real , & pos , h_guess , & ! Input h ) ! Output IF ( debug ) PRINT * , \"101.5\" cnt1 = 0 DO few_ncand = . FALSE . ! Redo the previous step slightly different (it's built-in; ! exact_nei_tree_update does not work if I don't call assign_h first), ! then update the neighbour-tree and fill the neighbour-data CALL exact_nei_tree_update ( nn_des , & npart_real , & pos , nu ) ! !-- Check that the number of candidate neighbours is larger than !-- or equal to ndes - 1 ! DO itr = 1 , SIZE ( ncand ), 1 ! If there are too few candidate neighbors IF ( ncand ( itr ) < nn_des - 1 ) THEN ! Increase the smoothing length and rebuild the tree few_ncand = . TRUE . h = 3.0D0 * h EXIT ELSE few_ncand = . FALSE . ENDIF ENDDO cnt1 = cnt1 + 1 IF ( . NOT . few_ncand . OR . cnt1 >= 10 ) THEN PRINT * , \" * Smoothing lengths assigned and tree is built.\" EXIT ENDIF ENDDO !IF( mass == THIS% mass2 ) STOP ! !-- Check that the smoothing length is acceptable ! check_h : DO a = 1 , npart_real , 1 IF ( ISNAN ( h ( a ) ) ) THEN PRINT * , \"** ERROR! h(\" , a , \") is a NaN\" !PRINT *, \"Stopping...\" ! PRINT * !STOP IF ( a > npart_real / 2 ) THEN DO itr = CEILING ( DBLE ( npart_real / 2 )) - 1 , 1 , - 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ELSE !h(a) = h(a - 1) DO itr = a + 1 , npart_real , 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ENDIF !PRINT *, \"** ERROR! h(\", a, \")=\", h(a) !PRINT * ENDIF IF ( h ( a ) <= 0.0D0 ) THEN PRINT * , \"** ERROR! h(\" , a , \")=\" , h ( a ) !PRINT *, \"Stopping...\" !PRINT * !STOP IF ( a > npart_real / 2 ) THEN DO itr = CEILING ( DBLE ( npart_real / 2 )) - 1 , 1 , - 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ELSE !h(a) = h(a - 1) DO itr = a + 1 , npart_real , 1 IF ( h ( itr ) > 0.25D0 ) THEN h ( a ) = h ( itr ) EXIT ENDIF ENDDO ENDIF !PRINT *, \"** ERROR! h(\", a, \")=\", h(a) !PRINT * ENDIF ENDDO check_h IF ( debug ) PRINT * , \"102\" CALL density ( npart_real , pos , nstar_int ) !nstar_int= 0.0D0 IF ( debug ) PRINT * , \"103\" !  PRINT *, \"** Finding nearest neighbors...\" ALLOCATE ( neighbors_lists ( npart_real ) ) ALLOCATE ( n_neighbors ( npart_real ) ) ALLOCATE ( nearest_neighbors ( 2 , npart_real ) ) neighbors_lists = 0 n_neighbors = 0 nearest_neighbors ( 1 ,:) = 0 nearest_neighbors ( 2 ,:) = HUGE ( 1.0D0 ) !   find_neighbors: DO a= 1, npart_real, 1 ! !     CALL get_neighbours_bf( a, npart_real, pos, h, 3, &           ! Input !                             n_neighbors(a), neighbors_lists(:) )  ! Output ! !     DO itr= 1, n_neighbors(a), 1 ! !       dist= NORM2( pos(:,a) - pos(:,neighbors_lists(itr)) ) ! !       !PRINT *, \"dist= \", dist !       !PRINT *, \"nearest_neighbors(2,a)= \", nearest_neighbors(2,a) !       !PRINT *, \"dist < nearest_neighbors(2,a)= \", dist < nearest_neighbors(2,a) ! !       IF( dist < nearest_neighbors(2,a) )THEN ! !         nearest_neighbors(1,a)= neighbors_lists(itr) !         nearest_neighbors(2,a)= dist ! !       ENDIF ! !     ENDDO ! !     !PRINT *, \"dist= \", dist !     !PRINT *, \"nearest_neighbors(2,a)= \", nearest_neighbors(2,a) !     !PRINT * ! !   ENDDO find_neighbors ! !   PRINT *, \" * Nearest neighbors found. \" !   PRINT *, \" * Average number of neighbors= \", DBLE(SUM(n_neighbors))/DBLE(npart_real) !   PRINT * IF ( debug ) PRINT * , \"0\" IF ( PRESENT ( namefile_results ) ) THEN finalnamefile = namefile_results ELSE finalnamefile = \"apm_results.dat\" ENDIF INQUIRE ( FILE = TRIM ( finalnamefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( finalnamefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( finalnamefile ), & \". The error message is\" , err_msg STOP ENDIF IF ( debug ) PRINT * , \"1\" IF ( . NOT . ALLOCATED ( nu_one ) ) ALLOCATE ( nu_one ( npart_real ) ) IF ( . NOT . ALLOCATED ( particle_density_final ) ) & ALLOCATE ( particle_density_final ( npart_real ) ) nu_one = 1.0D0 CALL density_loop ( npart_real , pos , & ! input nu_one , h , particle_density_final ) ! output DO a = 1 , npart_real , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & a , & pos ( 1 , a ), pos ( 2 , a ), pos ( 3 , a ), & nstar_p ( a ), & nstar_int ( a ), & particle_density_final ( a ), & particle_density_final ( a ) * nstar_p ( 1 ) / particle_density_final ( 1 ), & ABS ( nstar_real ( a ) - nstar_p ( a )) / nstar_p ( a ), & nu ( a ), & nearest_neighbors ( 2 , a ) ENDDO CLOSE ( UNIT = 2 ) IF ( debug ) PRINT * , \"2\" pos_input = pos IF ( debug ) PRINT * , \"2.5\" h_output = h IF ( debug ) PRINT * , \"2.6\" nu_output = nu IF ( debug ) PRINT * , \"3\" IF ( ALLOCATED ( posmash ) ) DEALLOCATE ( posmash ) CALL deallocate_metric_on_particles () IF ( debug ) PRINT * , \"4\" CALL deallocate_gradient () IF ( debug ) PRINT * , \"5\" CALL deallocate_RCB_tree_memory_3D () IF ( debug ) PRINT * , \"6\" CALL deallocate_SPH_memory () ! !-- Check that there aren't particles with the same positions ! !IF( debug ) finalnamefile= \"negative_hydro.dat\" !IF( debug ) CALL THIS% analyze_hydro( finalnamefile ) CALL check_particle_positions ( npart_real , pos ) CONTAINS FUNCTION validate_position_final ( x , y , z ) RESULT ( answer ) !******************************************************* ! !# Returns validate_position( x, y, z ) if the latter !  is present, 0 otherwise ! !  FT 22.09.2021 ! !******************************************************* IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point INTEGER :: answer !! validate_position( x, y, z ) if the latter is present, 0 otherwise IF ( PRESENT ( validate_position ) ) THEN answer = validate_position ( x , y , z ) ELSE answer = 0 ENDIF END FUNCTION validate_position_final END PROCEDURE perform_apm SUBROUTINE correct_center_of_mass ( npart_real , pos , nu , get_density , & validate_pos , com_star , verbose ) !*********************************************************** ! !# Translate the particles so that their center of mass !  coincides with the center of mass of the star, given by !  LORENE ! !  FT 1.09.2021 ! !*********************************************************** USE analyze , ONLY : COM IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart_real DOUBLE PRECISION , INTENT ( IN ) :: com_star LOGICAL , INTENT ( IN ), OPTIONAL :: verbose !TYPE(bns), INTENT(IN):: binary INTERFACE FUNCTION get_density ( x , y , z ) RESULT ( density ) DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z DOUBLE PRECISION :: density END FUNCTION END INTERFACE INTERFACE FUNCTION validate_pos ( x , y , z ) RESULT ( answer ) DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z INTEGER :: answer END FUNCTION END INTERFACE DOUBLE PRECISION , DIMENSION ( 3 , npart_real ), INTENT ( INOUT ) :: pos DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( INOUT ) :: nu INTEGER :: a DOUBLE PRECISION :: com_x , com_y , com_z , com_d DOUBLE PRECISION , DIMENSION ( 3 ) :: pos_corr_tmp CALL COM ( npart_real , pos , nu , & ! input com_x , com_y , com_z , com_d ) ! output IF ( PRESENT ( verbose ) . AND . verbose . EQV . . TRUE . ) THEN PRINT * , \"** Before center of mass correction:\" PRINT * , \" * x coordinate of the center of mass of the star, \" , & \"from LORENE: com_star= \" , com_star , \"Msun_geo\" PRINT * , \" * x coordinate of the center of mass of the particle \" , & \"distribution: com_x= \" , com_x , \"Msun_geo\" PRINT * , \" * y coordinate of the center of mass of the particle \" , & \"distribution: com_y= \" , com_y , \"Msun_geo\" PRINT * , \" * z coordinate of the center of mass of the particle \" , & \"distribution: com_z= \" , com_z , \"Msun_geo\" PRINT * , \" * Distance of the center of mass of the particle \" , & \"distribution from the  origin: com_d= \" , com_d PRINT * , \" * |com_x-com_star/com_star|=\" , & ABS ( com_x - com_star ) / ABS ( com_star + 1 ) PRINT * ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, com_star, & !$OMP                     com_x, com_y, com_z, npart_real ) & !$OMP             PRIVATE( pos_corr_tmp, a ) DO a = 1 , npart_real , 1 pos_corr_tmp ( 1 ) = pos ( 1 , a ) - ( com_x - com_star ) pos_corr_tmp ( 2 ) = pos ( 2 , a ) - com_y pos_corr_tmp ( 3 ) = pos ( 3 , a ) - com_z IF ( get_density ( & pos_corr_tmp ( 1 ), pos_corr_tmp ( 2 ), pos_corr_tmp ( 3 ) ) > 0.0D0 & . AND . & !binary% is_hydro_negative( & validate_pos ( & pos_corr_tmp ( 1 ), pos_corr_tmp ( 2 ), pos_corr_tmp ( 3 ) ) == 0 & ) THEN pos (:, a ) = pos_corr_tmp ENDIF ENDDO !$OMP END PARALLEL DO CALL COM ( npart_real , pos , nu , & ! input com_x , com_y , com_z , com_d ) ! output IF ( PRESENT ( verbose ) . AND . verbose . EQV . . TRUE . ) THEN PRINT * , \"** After center of mass correction:\" PRINT * , \" * x coordinate of the center of mass of the star, \" , & \"from LORENE: com_star= \" , com_star , \"Msun_geo\" PRINT * , \" * x coordinate of the center of mass of the particle \" , & \"distribution: com_x= \" , com_x , \"Msun_geo\" PRINT * , \" * y coordinate of the center of mass of the particle \" , & \"distribution: com_y= \" , com_y , \"Msun_geo\" PRINT * , \" * z coordinate of the center of mass of the particle \" , & \"distribution: com_z= \" , com_z , \"Msun_geo\" PRINT * , \" * Distance of the center of mass of the particle \" , & \"distribution from the  origin: com_d= \" , com_d PRINT * , \" * |com_x-com_star/com_star|=\" , & ABS ( com_x - com_star ) / ABS ( com_star + 1 ) PRINT * ENDIF END SUBROUTINE correct_center_of_mass SUBROUTINE impose_equatorial_plane_symmetry ( npart_real , pos , nu , com_star , & verbose ) !************************************************************* ! !# Mirror the particle with z>0 with respect to the xy plane, !  to impose the equatorial-plane symmetry ! !  FT 1.09.2021 ! !************************************************************* USE analyze , ONLY : COM IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart_real DOUBLE PRECISION , INTENT ( IN ), OPTIONAL :: com_star LOGICAL , INTENT ( IN ), OPTIONAL :: verbose DOUBLE PRECISION , DIMENSION ( 3 , npart_real ), INTENT ( INOUT ) :: pos DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( INOUT ) :: nu INTEGER :: a , itr , npart_real_half DOUBLE PRECISION :: com_x , com_y , com_z , com_d DOUBLE PRECISION , DIMENSION ( 3 , npart_real ) :: pos_tmp DOUBLE PRECISION , DIMENSION ( npart_real ) :: nu_tmp pos_tmp = pos nu_tmp = nu itr = 0 DO a = 1 , npart_real , 1 IF ( pos_tmp ( 3 , a ) > 0.0D0 & . AND . & itr < npart_real / 2 ) THEN itr = itr + 1 pos ( 1 , itr ) = pos_tmp ( 1 , a ) pos ( 2 , itr ) = pos_tmp ( 2 , a ) pos ( 3 , itr ) = pos_tmp ( 3 , a ) nu ( itr ) = nu_tmp ( a ) ENDIF ENDDO npart_real_half = itr ! If some of the particles crossed the xy plane top-down in the ! last step, replace them with their previous position ! above the xy plane !   IF( npart_real_half < npart_real/2 )THEN ! !     npart_missing= npart_real/2 - npart_real_half ! !     DO a= npart_real_half + 1, npart_real/2, 1 ! !       pos( :, a )= all_pos_tmp2( :, a ) ! !     ENDDO ! !   ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, npart_real_half, nu ) & !$OMP             PRIVATE( a ) DO a = 1 , npart_real_half , 1 pos ( 1 , npart_real_half + a ) = pos ( 1 , a ) pos ( 2 , npart_real_half + a ) = pos ( 2 , a ) pos ( 3 , npart_real_half + a ) = - pos ( 3 , a ) nu ( npart_real_half + a ) = nu ( a ) ENDDO !$OMP END PARALLEL DO IF ( PRESENT ( verbose ) . AND . verbose . EQV . . TRUE . ) THEN CALL COM ( npart_real , pos , nu , & ! input com_x , com_y , com_z , com_d ) ! output PRINT * , \"** After mirroring particles:\" IF ( PRESENT ( com_star ) ) PRINT * , & \" * x coordinate of the center of mass of the star, \" , & \"from LORENE: com_star= \" , com_star , \"Msun_geo\" PRINT * , \" * x coordinate of the center of mass of the particle \" , & \"distribution: com_x= \" , com_x , \"Msun_geo\" PRINT * , \" * y coordinate of the center of mass of the particle \" , & \"distribution: com_y= \" , com_y , \"Msun_geo\" PRINT * , \" * z coordinate of the center of mass of the particle \" , & \"distribution: com_z= \" , com_z , \"Msun_geo\" PRINT * , \" * Distance of the center of mass of the particle \" , & \"distribution from the  origin: com_d= \" , com_d IF ( PRESENT ( com_star ) ) PRINT * , \" * |com_x-com_star/com_star|=\" , & ABS ( com_x - com_star ) / ABS ( com_star + 1 ) PRINT * ENDIF END SUBROUTINE impose_equatorial_plane_symmetry SUBROUTINE get_neighbours_bf ( ipart , npart , pos , h , dimensions , nnei , neilist ) !************************************************************** ! !# just for test purposes: get neighbours of particle ipart in !  a \"brute force\" way; ipart is ALSO on the neighbour list; !  SKR 8.2.2010 ! !  Removed ipart from its own neighbors' list !  FT 04.06.2021 ! !************************************************************** IMPLICIT NONE INTEGER , INTENT ( IN ) :: ipart , npart , dimensions DOUBLE PRECISION , INTENT ( IN ) :: pos ( dimensions , npart ), h ( npart ) INTEGER , INTENT ( OUT ) :: nnei , neilist ( npart ) INTEGER a DOUBLE PRECISION diff ( dimensions ), d2 , r_int2 ! square of interaction radius r_int2 = ( 2.0D0 * h ( ipart )) ** 2 nnei = 0 !$OMP PARALLEL DO SHARED(pos,dimensions,ipart,npart,r_int2,nnei,neilist)& !$OMP             PRIVATE(a,diff,d2) DO a = 1 , npart , 1 IF ( a /= ipart ) THEN diff = pos ( 1 : dimensions , a ) - pos ( 1 : dimensions , ipart ) d2 = DOT_PRODUCT ( diff , diff ) ! neighbour? IF ( d2 < r_int2 ) THEN nnei = nnei + 1 neilist ( nnei ) = a ENDIF ENDIF ENDDO !$OMP END PARALLEL DO END SUBROUTINE get_neighbours_bf END SUBMODULE particles_apm","tags":"","loc":"sourcefile/submodule_particles_apm.f90.html"},{"title":"submodule_particles_redistribute_nu.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_particles_redistribute_nu.f90~~EfferentGraph sourcefile~submodule_particles_redistribute_nu.f90 submodule_particles_redistribute_nu.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~submodule_particles_redistribute_nu.f90->sourcefile~module_particles_id.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_particles_id.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules particles_redistribute_nu Source Code submodule_particles_redistribute_nu.f90 Source Code ! File:         submodule_particles_redistribute_nu.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( particles_id ) particles_redistribute_nu !*************************************************** ! !# This SUBMODULE contains the implementation of !  the methods of TYPE particles !  that reallocate the sph variables and !  redistribute nu (baryon number per particle) !  on the particles. ! !  These methods find application when one wants to !  decrease the particle mass ratio with particles !  on lattices. ! !  They DON'T HAVE ANYTHING to do with the APM. ! !  TODO: Add other SUBROUTINES to improve !        modularity in SUBMODULE !        particles_sph_variables ! !  FT 12.07.2021 ! !*************************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE reshape_sph_field_1d !************************************************ ! !# Read the SPH ID from the binary file output !  by write_SPHINCS_dump, and print it to a !  formatted file ! !  FT 31.03.2021 ! !************************************************ IMPLICIT NONE INTEGER :: itr , i_tmp DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: tmp ALLOCATE ( tmp ( new_size1 + new_size2 ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array tmp in SUBROUTINE \" , & \"reshape_sph_field_1d. The error message is\" , err_msg STOP ENDIF i_tmp = 0 DO itr = THIS % npart1 , THIS % npart1 - new_size1 + 1 , - 1 i_tmp = i_tmp + 1 tmp ( i_tmp ) = field ( index_array ( itr ) ) !IF( itr == THIS% npart1 - new_size1 + 1 )THEN !  PRINT *, i_tmp !ENDIF ENDDO DO itr = THIS % npart , THIS % npart - new_size2 + 1 , - 1 i_tmp = i_tmp + 1 tmp ( i_tmp ) = field ( index_array ( itr ) ) !IF( itr == THIS% npart )THEN !  PRINT *, i_tmp !ENDIF !IF( itr == THIS% npart - new_size2 + 1 )THEN !  PRINT *, i_tmp !  PRINT *, new_size1 + new_size2 !ENDIF ENDDO DEALLOCATE ( field , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array field in SUBROUTINE \" , & \"reshape_sph_field_1d. The error message is\" , err_msg STOP ENDIF ALLOCATE ( field ( new_size1 + new_size2 ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array field in SUBROUTINE \" , & \"reshape_sph_field_1d. The error message is\" , err_msg STOP ENDIF DO itr = 1 , new_size1 + new_size2 , 1 field ( itr ) = tmp ( itr ) ENDDO END PROCEDURE reshape_sph_field_1d MODULE PROCEDURE reshape_sph_field_2d !************************************************ ! !# Read the SPH ID from the binary file output !  by write_SPHINCS_dump, and print it to a !  formatted file ! !  FT 31.03.2021 ! !************************************************ IMPLICIT NONE INTEGER :: itr , i_tmp , itr2 DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: tmp ALLOCATE ( tmp ( 3 , new_size1 + new_size2 ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array tmp in SUBROUTINE \" , & \"reshape_sph_field_2d. The error message is\" , err_msg STOP ENDIF DO itr2 = 1 , 3 , 1 i_tmp = 0 DO itr = THIS % npart1 , THIS % npart1 - new_size1 + 1 , - 1 i_tmp = i_tmp + 1 tmp ( itr2 , i_tmp ) = field ( itr2 , index_array ( itr ) ) !PRINT *, field( itr2, index_array( itr ) ) !PRINT *, index_array( itr ) !PRINT *, itr !EXIT ENDDO !PRINT *, i_tmp !PRINT *, new_size1 DO itr = THIS % npart , THIS % npart - new_size2 + 1 , - 1 i_tmp = i_tmp + 1 tmp ( itr2 , i_tmp ) = field ( itr2 , index_array ( itr ) ) !PRINT *, field( itr2, index_array( itr ) ) !PRINT *, index_array( itr ) !PRINT *, itr !IF( field( itr2, index_array( itr ) ) < 0 )THEN !  PRINT *, \"The x coordinate of the second star is negative...\", & !           \"something is wrong\" !  STOP !ENDIF !STOP ENDDO !PRINT *, i_tmp - new_size1 !PRINT *, new_size2 ENDDO DEALLOCATE ( field , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array field in SUBROUTINE \" , & \"reshape_sph_field_2d. The error message is\" , err_msg STOP ENDIF ALLOCATE ( field ( 3 , new_size1 + new_size2 ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array field in SUBROUTINE \" , & \"reshape_sph_field_2d. The error message is\" , err_msg STOP ENDIF DO itr2 = 1 , 3 , 1 DO itr = 1 , new_size1 + new_size2 , 1 field ( itr2 , itr ) = tmp ( itr2 , itr ) ENDDO ENDDO END PROCEDURE reshape_sph_field_2d END SUBMODULE particles_redistribute_nu","tags":"","loc":"sourcefile/submodule_particles_redistribute_nu.f90.html"},{"title":"submodule_id_base_mass_profile.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_id_base_mass_profile.f90~~EfferentGraph sourcefile~submodule_id_base_mass_profile.f90 submodule_id_base_mass_profile.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~submodule_id_base_mass_profile.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~submodule_id_base_mass_profile.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules id_base_mass_profile Source Code submodule_id_base_mass_profile.f90 Source Code ! File:         submodule_id_base_mass_profile.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( id_base ) id_base_mass_profile !******************************************** ! !# Implementation of the method of TYPE idbase !  that integrates the baryon mass density to !  extract the radial baryon mass profile. ! !  FT 12.07.2021 ! !******************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE integrate_baryon_mass_density !************************************************ ! !# Perform 3D integration over a spherical grid !  of the baryon mass density. Output baryon !  mass and radial mass profile. ! !  FT 19.02.2021 ! !************************************************ USE utility , ONLY : ios , err_msg USE constants , ONLY : pi USE NR , ONLY : indexx IMPLICIT NONE INTEGER :: r , th , phi DOUBLE PRECISION :: rad_coord , colat , long , mass_element DOUBLE PRECISION :: g_xx , sq_g , baryon_density , gamma_euler !DOUBLE PRECISION:: rad LOGICAL , PARAMETER :: debug = . TRUE . !rad= 0.0D0 IF (. NOT . ALLOCATED ( mass_profile )) THEN ALLOCATE ( mass_profile ( 3 , 0 : NINT ( radius / dr ) ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array mass_profile in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF IF (. NOT . ALLOCATED ( mass_profile_idx )) THEN ALLOCATE ( mass_profile_idx ( 0 : NINT ( radius / dr ) ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array mass_profile in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF mass_profile ( 1 , 0 ) = 0.0D0 mass_profile ( 2 , 0 ) = 4.0D0 / 3.0D0 * pi * dr ** 3.0D0 * central_density mass_profile ( 3 , 0 ) = 4.0D0 / 3.0D0 * pi * dr ** 3.0D0 * central_density !$OMP PARALLEL DO DEFAULT(NONE) & !$OMP             SHARED(dr,dphi,dth,center,radius,mass_profile,THIS) & !$OMP             PRIVATE(r,th,phi,rad_coord,long,colat,sq_g,gamma_euler, & !$OMP                     g_xx,baryon_density,mass_element,mass) radius_loop : DO r = 1 , NINT ( radius / dr ), 1 mass = 0.0D0 rad_coord = r * dr longitude_loop : DO phi = 1 , NINT ( 2.0D0 * pi / dphi ), 1 long = phi * dphi colatitude_loop : DO th = 1 , NINT ( pi / 2.0D0 / dth ), 1 colat = th * dth ! The definition of the baryon mass for the LORENE ID is in eq.(69) ! of Gourgoulhon et al., PRD 63 064029 (2001) CALL THIS % read_id_mass_b ( & center + ( rad_coord + dr ) * SIN ( colat ) * COS ( long ), & ( rad_coord + dr ) * SIN ( colat ) * SIN ( long ), & ( rad_coord + dr ) * COS ( colat ), & g_xx , baryon_density , gamma_euler ) ! IF( debug )THEN ! !   IF( ISNAN( g_xx ) )THEN !     PRINT *, \" ** g_xx is NaN\" !     STOP !   ENDIF !   IF( ISNAN( baryon_density ) )THEN !     PRINT *, \" ** baryon_density is NaN\" !     STOP !   ENDIF !   IF( ISNAN( gamma_euler ) )THEN !     PRINT *, \" ** gamma_euler is NaN\" !     STOP !   ENDIF ! ! ENDIF IF ( ISNAN ( g_xx ) . OR . ISNAN ( baryon_density ) . OR . & ISNAN ( gamma_euler ) ) CYCLE !        CALL bns_obj% import_id( & !                 center1 + rad_coord*SIN(lat)*COS(long), & !                 rad_coord*SIN(lat)*SIN(long), & !                 rad_coord*COS(lat), & !                 g_xx, baryon_density, & !                 gamma_euler ) ! !        ! Compute covariant spatial fluid velocity (metric is diagonal and !        ! conformally flat) !        !v_euler_x_l= g_xx*v_euler_x !        !v_euler_y_l= g_xx*v_euler_y !        !v_euler_z_l= g_xx*v_euler_z !        ! !        !! Compute the corresponding Lorentz factor !        !lorentz_factor= 1.0D0/SQRT( 1.0D0 - ( v_euler_x_l*v_euler_x & !        !                                    + v_euler_y_l*v_euler_y & !        !                                    + v_euler_z_l*v_euler_z ) ) !        ! !        !! Compute covariant fluid 4-velocity !        !u_euler_t_l= lorentz_factor *( - lapse + v_euler_x_l*shift_x & !        !                                       + v_euler_y_l*shift_y & !        !                                       + v_euler_z_l*shift_z ) !        !u_euler_x_l= lorentz_factor*v_euler_x_l !        !u_euler_y_l= lorentz_factor*v_euler_y_l !        !u_euler_z_l= lorentz_factor*v_euler_z_l !        ! !        !! Compute vector normal to spacelike hypersurface !        !! (4-velocity of the Eulerian observer) !        !n_t= 1.0D0/lapse !        !n_x= - shift_x/lapse !        !n_y= - shift_y/lapse !        !n_z= - shift_z/lapse !        ! !        !! Compute relative Lorentz factor between 4-velocity of the fluid !        !! wrt the Eulerian observer and the 4-velocity of the Eulerian observer !        !lorentz_factor_rel= - ( n_t*u_euler_t_l + n_x*u_euler_x_l & !        !                      + n_y*u_euler_y_l + n_z*u_euler_z_l ) ! Compute square root of the determinant of the spatial metric sq_g = g_xx * SQRT ( g_xx ) mass_element = ( rad_coord ** 2.0D0 ) * SIN ( colat ) * dr * dth * dphi & * sq_g * gamma_euler * baryon_density mass = mass + 2.0D0 * mass_element ENDDO colatitude_loop ENDDO longitude_loop mass_profile ( 1 , r ) = rad_coord mass_profile ( 2 , r ) = mass ENDDO radius_loop !$OMP END PARALLEL DO DO r = 1 , NINT ( radius / dr ), 1 mass_profile ( 3 , r ) = mass_profile ( 3 , r - 1 ) + mass_profile ( 2 , r ) ENDDO mass = mass_profile ( 3 , NINT ( radius / dr ) ) IF ( ISNAN ( mass ) ) THEN PRINT * , \"** ERROR! The integrated mass is a NaN!\" PRINT * STOP ELSEIF ( mass <= 0 ) THEN PRINT * , \"** ERROR! The integrated mass is mass=\" , mass , \"<= 0!\" PRINT * STOP ENDIF PRINT * , \" * Radius covered by the integration of baryon mass density=\" , & MAXVAL ( mass_profile ( 1 , : ), DIM = 1 ) PRINT * , \" * Integrated baryon mass of the star=\" , mass PRINT * CALL indexx ( NINT ( radius / dr ) + 1 , mass_profile ( 1 , : ), mass_profile_idx ) END PROCEDURE integrate_baryon_mass_density END SUBMODULE id_base_mass_profile","tags":"","loc":"sourcefile/submodule_id_base_mass_profile.f90.html"},{"title":"submodule_id_base_access.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_id_base_access.f90~~EfferentGraph sourcefile~submodule_id_base_access.f90 submodule_id_base_access.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~submodule_id_base_access.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules id_base_access Source Code submodule_id_base_access.f90 Source Code ! File:         submodule_id_base_access.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( id_base ) id_base_access !******************************************** ! !# Implementation of the methods of TYPE !  idbase to access PRIVATE data ! !  FT 28.10.2021 ! !******************************************** IMPLICIT NONE CONTAINS MODULE PROCEDURE set_n_matter !************************************************ ! !# Sets [[idbase:n_matter]] to the given value ! !  FT 28.10.2021 ! !************************************************ IMPLICIT NONE THIS % n_matter = value END PROCEDURE set_n_matter MODULE PROCEDURE get_n_matter !************************************************ ! !# Returns [[idbase:n_matter]], the number of !  matter objects in the physical system ! !  FT 28.10.2021 ! !************************************************ IMPLICIT NONE get_n_matter = THIS % n_matter END PROCEDURE get_n_matter MODULE PROCEDURE set_one_lapse !************************************************ ! !# Sets [[idbase:one_lapse]] to the given value ! !  FT 3.11.2021 ! !************************************************ IMPLICIT NONE THIS % one_lapse = logic END PROCEDURE set_one_lapse MODULE PROCEDURE get_one_lapse !************************************************ ! !# Returns [[idbase:one_lapse]] ! !  FT 3.11.2021 ! !************************************************ IMPLICIT NONE get_one_lapse = THIS % one_lapse END PROCEDURE get_one_lapse MODULE PROCEDURE set_zero_shift !************************************************ ! !# Sets [[idbase:zero_shift]] to the given value ! !  FT 3.11.2021 ! !************************************************ IMPLICIT NONE THIS % zero_shift = logic END PROCEDURE set_zero_shift MODULE PROCEDURE get_zero_shift !************************************************ ! !# Returns [[idbase:zero_shift]] ! !  FT 3.11.2021 ! !************************************************ IMPLICIT NONE get_zero_shift = THIS % zero_shift END PROCEDURE get_zero_shift MODULE PROCEDURE check_i_matter !************************************************ ! !# Checks that the given index `i_matter` is !  between 1 and [[idbase:n_matter]], included. !  If not, it stops the execution of the program. ! !  FT 2.11.2021 ! !************************************************ IMPLICIT NONE IF ( i_matter < 1 ) THEN PRINT * , \"** ERROR! The index of the matter object is lower than 1. \" PRINT * , \"   It should be between 1 and n_matter= \" , THIS % n_matter PRINT * , \"   The index is \" , i_matter PRINT * , \"   Stopping...\" PRINT * STOP ELSEIF ( i_matter > THIS % n_matter ) THEN PRINT * , \"** ERROR! The index of the matter object is larger than \" , & THIS % n_matter PRINT * , \"   It should be between 1 and n_matter= \" , THIS % n_matter PRINT * , \"   The index is \" , i_matter PRINT * , \"   Stopping...\" PRINT * STOP ENDIF END PROCEDURE check_i_matter MODULE PROCEDURE get_total_spatial_extent !************************************************ ! !# Return the coordinates !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} !  of a box containing the entire physical system ! !  FT 28.10.2021 ! !************************************************ IMPLICIT NONE INTEGER :: i_matter DOUBLE PRECISION , DIMENSION ( 3 ) :: center_matter DOUBLE PRECISION , DIMENSION ( 6 ) :: size_matter box ( 1 ) = HUGE ( 1.0D0 ) box ( 3 ) = HUGE ( 1.0D0 ) box ( 5 ) = HUGE ( 1.0D0 ) box ( 2 ) = - HUGE ( 1.0D0 ) box ( 4 ) = - HUGE ( 1.0D0 ) box ( 6 ) = - HUGE ( 1.0D0 ) DO i_matter = 1 , THIS % get_n_matter (), 1 size_matter = THIS % return_spatial_extent ( i_matter ) center_matter = THIS % return_center ( i_matter ) IF ( size_matter ( 1 ) < box ( 1 ) ) box ( 1 ) = center_matter ( 1 ) - size_matter ( 1 ) IF ( size_matter ( 2 ) > box ( 2 ) ) box ( 2 ) = center_matter ( 1 ) + size_matter ( 2 ) IF ( size_matter ( 3 ) < box ( 3 ) ) box ( 3 ) = center_matter ( 2 ) - size_matter ( 3 ) IF ( size_matter ( 4 ) > box ( 4 ) ) box ( 4 ) = center_matter ( 2 ) + size_matter ( 4 ) IF ( size_matter ( 5 ) < box ( 5 ) ) box ( 5 ) = center_matter ( 3 ) - size_matter ( 5 ) IF ( size_matter ( 6 ) > box ( 6 ) ) box ( 6 ) = center_matter ( 3 ) + size_matter ( 6 ) ENDDO END PROCEDURE get_total_spatial_extent END SUBMODULE id_base_access","tags":"","loc":"sourcefile/submodule_id_base_access.f90.html"},{"title":"module_id_base.f90 – SPHINCS_LORENE","text":"Files dependent on this one sourcefile~~module_id_base.f90~~AfferentGraph sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_bssn_id.f90 module_bssn_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bssn_id.f90 sourcefile~module_formul_3p1_id.f90 module_formul_3p1_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_particles_id.f90 module_particles_id.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_particles_id.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_bssn_id.f90->sourcefile~module_id_base.f90 sourcefile~module_bssn_id.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~module_bssn_id.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_id_base_access.f90 submodule_id_base_access.f90 sourcefile~submodule_id_base_access.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_id_base.f90 sourcefile~module_formul_3p1_id.f90->sourcefile~module_particles_id.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 sourcefile~submodule_id_base_mass_profile.f90 submodule_id_base_mass_profile.f90 sourcefile~submodule_id_base_mass_profile.f90->sourcefile~module_id_base.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 sourcefile~module_particles_id.f90->sourcefile~module_id_base.f90 sourcefile~submodule_particles_memory.f90 submodule_particles_memory.f90 sourcefile~submodule_particles_memory.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_sph_variables.f90 submodule_particles_sph_variables.f90 sourcefile~submodule_particles_sph_variables.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bns_lorene_import.f90 submodule_bns_lorene_import.f90 sourcefile~submodule_bns_lorene_import.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_particles_apm.f90 submodule_particles_apm.f90 sourcefile~submodule_particles_apm.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bns_lorene_memory.f90 submodule_bns_lorene_memory.f90 sourcefile~submodule_bns_lorene_memory.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_particles_redistribute_nu.f90 submodule_particles_redistribute_nu.f90 sourcefile~submodule_particles_redistribute_nu.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_spherical_surfaces.f90 submodule_particles_spherical_surfaces.f90 sourcefile~submodule_particles_spherical_surfaces.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bns_lorene_constructor.f90 submodule_bns_lorene_constructor.f90 sourcefile~submodule_bns_lorene_constructor.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bssn_id_memory.f90 submodule_bssn_id_memory.f90 sourcefile~submodule_bssn_id_memory.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_diffstar_base_access.f90 submodule_diffstar_base_access.f90 sourcefile~submodule_diffstar_base_access.f90->sourcefile~module_diffstar_base.f90 sourcefile~submodule_particles_access.f90 submodule_particles_access.f90 sourcefile~submodule_particles_access.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_particles_lattices.f90 submodule_particles_lattices.f90 sourcefile~submodule_particles_lattices.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_formul_3p1_analysis.f90 submodule_formul_3p1_analysis.f90 sourcefile~submodule_formul_3p1_analysis.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_particles_compose.f90 submodule_particles_compose.f90 sourcefile~submodule_particles_compose.f90->sourcefile~module_particles_id.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~submodule_bssn_id_variables.f90 submodule_bssn_id_variables.f90 sourcefile~submodule_bssn_id_variables.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_formul_3p1_access.f90 submodule_formul_3p1_access.f90 sourcefile~submodule_formul_3p1_access.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~submodule_bns_lorene_params.f90 submodule_bns_lorene_params.f90 sourcefile~submodule_bns_lorene_params.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90 submodule_formul_3p1_standard3p1_variables.f90 sourcefile~submodule_formul_3p1_standard3p1_variables.f90->sourcefile~module_formul_3p1_id.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~submodule_particles_constructor.f90 submodule_particles_constructor.f90 sourcefile~submodule_particles_constructor.f90->sourcefile~module_particles_id.f90 sourcefile~submodule_bns_base_mass_profile.f90 submodule_bns_base_mass_profile.f90 sourcefile~submodule_bns_base_mass_profile.f90->sourcefile~module_bns_base.f90 sourcefile~submodule_bssn_id_constraints.f90 submodule_bssn_id_constraints.f90 sourcefile~submodule_bssn_id_constraints.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_bns_base_access.f90 submodule_bns_base_access.f90 sourcefile~submodule_bns_base_access.f90->sourcefile~module_bns_base.f90 sourcefile~submodule_bns_lorene_access.f90 submodule_bns_lorene_access.f90 sourcefile~submodule_bns_lorene_access.f90->sourcefile~module_bns_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~submodule_bssn_id_constructor.f90 submodule_bssn_id_constructor.f90 sourcefile~submodule_bssn_id_constructor.f90->sourcefile~module_bssn_id.f90 sourcefile~submodule_diffstar_lorene_access.f90 submodule_diffstar_lorene_access.f90 sourcefile~submodule_diffstar_lorene_access.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_memory.f90 submodule_diffstar_lorene_memory.f90 sourcefile~submodule_diffstar_lorene_memory.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_params.f90 submodule_diffstar_lorene_params.f90 sourcefile~submodule_diffstar_lorene_params.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_constructor.f90 submodule_diffstar_lorene_constructor.f90 sourcefile~submodule_diffstar_lorene_constructor.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_import.f90 submodule_diffstar_lorene_import.f90 sourcefile~submodule_diffstar_lorene_import.f90->sourcefile~module_diffstar_lorene.f90 var pansourcefilemodule_id_basef90AfferentGraph = svgPanZoom('#sourcefilemodule_id_basef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules id_base Source Code module_id_base.f90 Source Code ! File:         module_id_base.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE id_base !*********************************************************** ! !# This MODULE contains the definition of TYPE idbase, !  which is an ABSTRACT TYPE representing any possible !  type of initial data (ID) to be set up for |sphincsbssn|. !  That is, a binary neutron star system, a rotating !  star, a binary black hole system, etc. ! !  PROCEDURES and variables shared by all these types !  of ID should belong to TYPE idbase, as !  they are inherited by its EXTENDED TYPES that !  represent more specific types of ID. ! !  FT 24.09.2021 ! !*********************************************************** USE timing , ONLY : timer IMPLICIT NONE !************************************************************* !                                                            * !              Definition of TYPE idbase                     * !                                                            * !   This ABSTRACT TYPE represents a generic ID for           * !   |sphincsbssn| (binary neutron star, rotating star...).   * !                                                            * !************************************************************* TYPE , ABSTRACT :: idbase !# Represents a generic ID for |sphincsbssn| (binary neutron star, rotating !  star, etc.) PRIVATE INTEGER :: n_matter = 0 !# Number of matter objects belonging the physical system. !  For example, n_objects= 2 for a binary system of stars, and n_objects= 1 !  for a single star or for a binary system of a black hole and a star. LOGICAL :: one_lapse !! Logical variable that determines if the lapse function \\alpha=1, !  i.e., if the geodesic gauge is to be used LOGICAL :: zero_shift !! Logical variable that determines if the shift \\beta&#94;i=0 TYPE ( timer ), PUBLIC :: construction_timer !! Timer that times the construction of the appropriate object CONTAINS !---------------------------! !--  DEFERRED PROCEDURES  --! !---------------------------! ! !-- PROCEDURES to read the value of a field at a point ! PROCEDURE ( read_double_at_pos ), DEFERRED :: read_mass_density !# Returns the baryon mass density at the given point PROCEDURE ( read_integer_at_pos ), DEFERRED :: test_position !# Returns 1 if the position has physically acceptable properties, !  0 otherwise ! !-- PROCEDURES to read the value of several fields at several points ! PROCEDURE ( read_id_full_int ), DEFERRED :: read_id_full !# Reads the full ID PROCEDURE ( read_id_particles_int ), DEFERRED :: read_id_particles !! Reads the hydro ID needed to compute the SPH ID PROCEDURE ( read_id_mass_b_int ), DEFERRED :: read_id_mass_b !! Reads the hydro ID needed to compute the baryon mass PROCEDURE ( read_id_spacetime_int ), DEFERRED :: read_id_spacetime !# Reads the spacetime ID needed to compute !  the BSSN variables and constraints PROCEDURE ( read_id_hydro_int ), DEFERRED :: read_id_hydro !# Reads the hydro ID needed to compute the constraints on the refined mesh PROCEDURE ( read_id_k_int ), DEFERRED :: read_id_k !! Reads the components of the extrinsic curvature ! !-- PROCEDURES returning the values of some parameters of a matter object ! PROCEDURE ( return_spatial_extent_int ), DEFERRED :: return_spatial_extent !# Returns the spatial extent of the matter objects, !  returning the array of 6 numbers !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} PROCEDURE ( return_double_parameter ), DEFERRED :: return_mass !! Returns the masses of the matter objects. PROCEDURE ( return_position ), DEFERRED :: return_center !! Returns the centers of the matter objects. PROCEDURE ( return_position ), DEFERRED :: return_barycenter !! Returns the barycenters (centers of mass) of the matter objects. PROCEDURE ( return_eos_parameters_int ), DEFERRED :: return_eos_parameters !# Returns the identification number of the |eos| of the matter objects. !  @todo Set up a convention for the identification number PROCEDURE ( return_string_parameter ), DEFERRED :: return_eos_name !! Returns the name of the |eos| of the matter objects. ! !-- PROCEDURES returning the values of some parameters of the entire system ! !   PROCEDURE(return_total_spatial_extent_int), DEFERRED:: & !                                                   return_total_spatial_extent !# Returns the spatial extent of the physical system considered, !  as the array of 6 numbers !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} !PROCEDURE(derived_type_constructor_int), NOPASS, DEFERRED:: derived_type_constructor !# !-------------------------------! !--  NON-DEFERRED PROCEDURES  --! !-------------------------------! !PROCEDURE, NON_OVERRIDABLE:: sanity_check !# !PROCEDURE, NON_OVERRIDABLE:: initialize !# PROCEDURE , NON_OVERRIDABLE :: get_total_spatial_extent !# Returns the spatial extent of the physical system considered, !  as the array of 6 numbers !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} PROCEDURE , NON_OVERRIDABLE :: set_n_matter !# Sets [[idbase:n_matter]], the number of matter objects in the !  physical system, to a value PROCEDURE , NON_OVERRIDABLE :: get_n_matter !# Returns [[idbase:n_matter]], the number of matter objects in the !  physical system PROCEDURE , NON_OVERRIDABLE :: set_one_lapse !# Sets [[idbase:one_lapse]], the logical variable that determines if !  the lapse \\alpha=1, i.e., if the geodesic gauge is to be used PROCEDURE , NON_OVERRIDABLE :: get_one_lapse !# Returns [[idbase:one_lapse]], the logical variable that determines if ! the lapse function \\alpha=1, i.e., if the geodesic gauge is to be used PROCEDURE , NON_OVERRIDABLE :: set_zero_shift !# Sets [[idbase:zero_shift]], the logical variable that determines if !  the shift \\beta&#94;i=0 PROCEDURE , NON_OVERRIDABLE :: get_zero_shift !# Returns [[idbase:zero_shift]], the logical variable that determines if !  the shift \\beta&#94;i=0 PROCEDURE , NON_OVERRIDABLE :: check_i_matter !# Checks that the given index is between 1 and [[idbase:n_matter]], !  included. If not, it stops the execution of the program. PROCEDURE :: integrate_baryon_mass_density !# Integrates the baryon mass density over a matter object, using spherical !  coordinates, and computes its radial profile inside the star END TYPE idbase ABSTRACT INTERFACE ! FUNCTION derived_type_constructor_int() RESULT( derived_type ) ! !# ! !   IMPORT:: idbase !   CLASS(idbase), POINTER:: derived_type ! ! END FUNCTION derived_type_constructor_int FUNCTION read_double_at_pos ( THIS , x , y , z ) RESULT ( res ) !# INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION at a given !  position IMPORT :: idbase CLASS ( idbase ), INTENT ( IN ) :: THIS !! Object of class [[idbase]] which this PROCEDURE is a member of DOUBLE PRECISION , INTENT ( IN ), VALUE :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: z !! z coordinate of the desired point DOUBLE PRECISION :: res !! Real number at (x,y,z) END FUNCTION read_double_at_pos FUNCTION read_integer_at_pos ( THIS , x , y , z ) RESULT ( res ) !# INTERFACE for a PROCEDURE that returns an INTEGER at a given position IMPORT :: idbase CLASS ( idbase ), INTENT ( IN ) :: THIS !! Object of class [[idbase]] which this PROCEDURE is a member of DOUBLE PRECISION , INTENT ( IN ), VALUE :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: z !! z coordinate of the desired point INTEGER :: res !! Integer at (x,y,z) END FUNCTION read_integer_at_pos FUNCTION return_double_parameter ( THIS , i_matter ) RESULT ( res ) !# INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION IMPORT :: idbase CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION :: res !! Real number. Parameter of the `i_matter`-th matter object END FUNCTION return_double_parameter FUNCTION return_position ( THIS , i_matter ) RESULT ( res ) !# INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION IMPORT :: idbase CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION ( 3 ) :: res !# Centers of the matter objects. The first index runs over the matter !  objects, the second index over (x,y,z). END FUNCTION return_position FUNCTION return_integer_parameter ( THIS , i_matter ) RESULT ( res ) !# INTERFACE for a PROCEDURE that returns an INTEGER IMPORT :: idbase CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return INTEGER :: res !! Real number. Parameter of the `i_matter`-th matter object END FUNCTION return_integer_parameter SUBROUTINE return_eos_parameters_int ( THIS , i_matter , eos_params ) !# INTERFACE for a PROCEDURE that returns an array containing the !  parametersf the |eos| for the matter objects IMPORT :: idbase CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: eos_params !# Array containing the parameters of the |eos| for the `i_matter`-th !  matter object END SUBROUTINE return_eos_parameters_int FUNCTION return_string_parameter ( THIS , i_matter ) RESULT ( string ) !# INTERFACE for a PROCEDURE that returns a CHARACTER( LEN= : ) IMPORT :: idbase CLASS ( idbase ), INTENT ( IN OUT ) :: THIS !! [[idbase]] object which this PROCEDURE is a member of INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose string is to return CHARACTER ( LEN = : ), ALLOCATABLE :: string END FUNCTION return_string_parameter SUBROUTINE read_id_mass_b_int ( THIS , x , y , z , & g_xx , & baryon_density , & gamma_euler ) !# INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the !  baryon mass IMPORT :: idbase CLASS ( idbase ), INTENT ( IN OUT ) :: THIS !! Object of class [[idbase]] which this PROCEDURE is a member of DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z DOUBLE PRECISION , INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , INTENT ( IN OUT ) :: gamma_euler END SUBROUTINE read_id_mass_b_int SUBROUTINE read_id_full_int ( THIS , n , x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz , & baryon_density , & energy_density , & specific_energy , & u_euler_x , u_euler_y , u_euler_z ) !# INTERFACE or the SUBROUTINE reading the full ID IMPORT :: idbase !> [[idbase]] object which this PROCEDURE is a member of CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_z END SUBROUTINE read_id_full_int SUBROUTINE read_id_spacetime_int ( THIS , nx , ny , nz , & pos , & lapse , & shift , & g , & ek ) !# INTERFACE or the SUBROUTINE reading the spacetime ID IMPORT :: idbase !> [[idbase]] object which this PROCEDURE is a member of CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: nx INTEGER , INTENT ( IN ) :: ny INTEGER , INTENT ( IN ) :: nz DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: shift DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: g DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: ek END SUBROUTINE read_id_spacetime_int SUBROUTINE read_id_hydro_int ( THIS , nx , ny , nz , & pos , & baryon_density , & energy_density , & specific_energy , & pressure , & u_euler ) !# INTERFACE or the SUBROUTINE reading the the hydro ID needed to compute !  the constraints on the refined mesh IMPORT :: idbase !> [[idbase]] object which this PROCEDURE is a member of CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: nx INTEGER , INTENT ( IN ) :: ny INTEGER , INTENT ( IN ) :: nz DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: pressure DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: u_euler END SUBROUTINE read_id_hydro_int SUBROUTINE read_id_particles_int ( THIS , n , x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & baryon_density , & energy_density , & specific_energy , & pressure , & u_euler_x , u_euler_y , u_euler_z ) !# INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the !  SPH ID IMPORT :: idbase !> [[idbase]] object which this PROCEDURE is a member of CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: pressure DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_z END SUBROUTINE read_id_particles_int SUBROUTINE read_id_k_int ( THIS , n , x , y , z ,& k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz ) !# INTERFACE or the SUBROUTINE reading the components of the extrinsic !  curvature IMPORT :: idbase !> [[idbase]] object which this PROCEDURE is a member of CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_zz END SUBROUTINE read_id_k_int SUBROUTINE integrate_field_int ( THIS , center , radius , & central_density , & dr , dth , dphi , & mass , mass_profile , & mass_profile_idx ) !# INTERFACE to the SUBROUTINE integrating the baryon mass density to !  compute the radial mass profile of a single star. IMPORT :: idbase !> Object of class [[idbase]] which this PROCEDURE is a member of CLASS ( idbase ), INTENT ( IN OUT ) :: THIS !& Array to store the indices for array mass_profile, sorted so that !  mass_profile[mass_profile_idx] is in increasing order INTEGER , DIMENSION (:), ALLOCATABLE , INTENT ( IN OUT ) :: mass_profile_idx !> Center of the star DOUBLE PRECISION , INTENT ( IN ) :: center !> Central density of the star DOUBLE PRECISION , INTENT ( IN ) :: central_density !> Radius of the star DOUBLE PRECISION , INTENT ( IN ) :: radius !> Integration steps DOUBLE PRECISION , INTENT ( IN ) :: dr , dth , dphi !> Integrated mass of the star DOUBLE PRECISION , INTENT ( IN OUT ) :: mass !> Array storing the radial mass profile of the star DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( IN OUT ) :: & mass_profile END SUBROUTINE integrate_field_int FUNCTION return_spatial_extent_int ( THIS , i_matter ) RESULT ( box ) !# INTERFACE to the SUBROUTINE that detects the spatial extent of the !  matter objects, and returns a 6-dimensional array !  containing the coordinates !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} !  of a box **centered at the center of the object** and containing the !  system. IMPORT :: idbase CLASS ( idbase ), INTENT ( IN OUT ) :: THIS !! Object of class [[idbase]] which this PROCEDURE is a member of INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose string is to return DOUBLE PRECISION , DIMENSION ( 6 ) :: box !# 6-dimensional array containing the coordinates !  x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max}, !    z_{\\rm min},z_{\\rm max} !  of a box containing the physical system. END FUNCTION return_spatial_extent_int FUNCTION return_total_spatial_extent_int ( THIS ) RESULT ( box ) !# INTERFACE to the SUBROUTINE that detects the spatial extent of the !  physical system considered, and returns a 6-dimensional array !  containing the coordinates !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} !  of a box **centered at the center of the object** and containing the !  system. IMPORT :: idbase CLASS ( idbase ), INTENT ( IN ) :: THIS !! Object of class [[idbase]] which this PROCEDURE is a member of DOUBLE PRECISION , DIMENSION ( 6 ) :: box !# 6-dimensional array containing the coordinates !  x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max}, !    z_{\\rm min},z_{\\rm max} !  of a box containing the physical system. END FUNCTION return_total_spatial_extent_int END INTERFACE INTERFACE MODULE SUBROUTINE integrate_baryon_mass_density ( THIS , center , radius , & central_density , & dr , dth , dphi , & mass , mass_profile , & mass_profile_idx ) !# INTERFACE to the SUBROUTINE integrating the baryon mass density to !  compute the radial mass profile of a single star. !> Object of class [[idbase]] which this PROCEDURE is a member of CLASS ( idbase ), INTENT ( IN OUT ) :: THIS !& Array to store the indices for array mass_profile, sorted so that !  mass_profile[mass_profile_idx] is in increasing order INTEGER , DIMENSION (:), ALLOCATABLE , INTENT ( IN OUT ) :: mass_profile_idx !> Center of the star DOUBLE PRECISION , INTENT ( IN ) :: center !> Central density of the star DOUBLE PRECISION , INTENT ( IN ) :: central_density !> Radius of the star DOUBLE PRECISION , INTENT ( IN ) :: radius !> Integration steps DOUBLE PRECISION , INTENT ( IN ) :: dr , dth , dphi !> Integrated mass of the star DOUBLE PRECISION , INTENT ( IN OUT ) :: mass !> Array storing the radial mass profile of the star DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( IN OUT ) :: & mass_profile END SUBROUTINE integrate_baryon_mass_density MODULE FUNCTION get_n_matter ( THIS ) !# Returns [[idbase:n_matter]], the number of matter objects in the !  physical system CLASS ( idbase ), INTENT ( IN ) :: THIS DOUBLE PRECISION :: get_n_matter !! [[idbase:n_matter]], the number of matter objects in the !  physical system END FUNCTION get_n_matter MODULE SUBROUTINE set_n_matter ( THIS , value ) !# Sets [[idbase:n_matter]], the number of matter objects in the !  physical system, to the given value CLASS ( idbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: value !! Value to set [[idbase:n_matter]] to END SUBROUTINE set_n_matter MODULE SUBROUTINE check_i_matter ( THIS , i_matter ) !# Checks that the given index `i_matter` is between 1 and !  [[idbase:n_matter]], included. If not, it stops the execution of the !  program. CLASS ( idbase ), INTENT ( IN ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Value to be checked END SUBROUTINE check_i_matter MODULE FUNCTION get_total_spatial_extent ( THIS ) RESULT ( box ) !# INTERFACE to the SUBROUTINE that detects the spatial extent of the !  physical system considered, and returns a 6-dimensional array !  containing the coordinates !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} !  of a box **centered at the center of the object** and containing the !  system. CLASS ( idbase ), INTENT ( IN OUT ) :: THIS !! Object of class [[idbase]] which this PROCEDURE is a member of DOUBLE PRECISION , DIMENSION ( 6 ) :: box !# 6-dimensional array containing the coordinates !  x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max}, !    z_{\\rm min},z_{\\rm max} !  of a box containing the physical system. END FUNCTION get_total_spatial_extent MODULE FUNCTION get_one_lapse ( THIS ) !# Returns [[idbase:n_matter]], the number of matter objects in the !  physical system CLASS ( idbase ), INTENT ( IN ) :: THIS LOGICAL :: get_one_lapse !! [[idbase:n_matter]], the number of matter objects in the !  physical system END FUNCTION get_one_lapse MODULE SUBROUTINE set_one_lapse ( THIS , logic ) !# Sets [[idbase:n_matter]], the number of matter objects in the !  physical system, to the given value CLASS ( idbase ), INTENT ( IN OUT ) :: THIS LOGICAL , INTENT ( IN ) :: logic !! Value to set [[idbase:n_matter]] to END SUBROUTINE set_one_lapse MODULE FUNCTION get_zero_shift ( THIS ) !# Returns [[idbase:n_matter]], the number of matter objects in the !  physical system CLASS ( idbase ), INTENT ( IN ) :: THIS LOGICAL :: get_zero_shift !! [[idbase:n_matter]], the number of matter objects in the !  physical system END FUNCTION get_zero_shift MODULE SUBROUTINE set_zero_shift ( THIS , logic ) !# Sets [[idbase:n_matter]], the number of matter objects in the !  physical system, to the given value CLASS ( idbase ), INTENT ( IN OUT ) :: THIS LOGICAL , INTENT ( IN ) :: logic !! Value to set [[idbase:n_matter]] to END SUBROUTINE set_zero_shift END INTERFACE END MODULE id_base","tags":"","loc":"sourcefile/module_id_base.f90.html"},{"title":"submodule_bns_base_mass_profile.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bns_base_mass_profile.f90~~EfferentGraph sourcefile~submodule_bns_base_mass_profile.f90 submodule_bns_base_mass_profile.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~submodule_bns_base_mass_profile.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bns_base_mass_profile Source Code submodule_bns_base_mass_profile.f90 Source Code ! File:         submodule_bns_mass_profile.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( bns_base ) bns_base_mass_profile !******************************************** ! !# Implementation of the method of TYPE bns !  that integrates the baryon mass density to !  extract the radial baryon mass profile. ! !  FT 12.07.2021 ! !******************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE integrate_baryon_mass_density !************************************************ ! !# Perform 3D integration over a spherical grid !  of the baryon mass density. Output baryon !  mass and radial mass profile. ! !  FT 19.02.2021 ! !************************************************ USE constants , ONLY : pi USE NR , ONLY : indexx IMPLICIT NONE INTEGER :: r , th , phi DOUBLE PRECISION :: rad_coord , colat , long , mass_element DOUBLE PRECISION :: g_xx , sq_g , baryon_density , gamma_euler !DOUBLE PRECISION:: rad LOGICAL , PARAMETER :: debug = . TRUE . !rad= 0.0D0 IF (. NOT . ALLOCATED ( mass_profile )) THEN ALLOCATE ( mass_profile ( 3 , 0 : NINT ( radius / dr ) ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array mass_profile in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF IF (. NOT . ALLOCATED ( mass_profile_idx )) THEN ALLOCATE ( mass_profile_idx ( 0 : NINT ( radius / dr ) ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array mass_profile in SUBROUTINE\" & // \"place_particles_. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...allocation error for array pos in SUBROUTINE\" & !                // \"place_particles_3D_lattice.\" ) ENDIF mass_profile ( 1 , 0 ) = 0.0D0 mass_profile ( 2 , 0 ) = 4.0D0 / 3.0D0 * pi * dr ** 3.0D0 * central_density mass_profile ( 3 , 0 ) = 4.0D0 / 3.0D0 * pi * dr ** 3.0D0 * central_density !$OMP PARALLEL DO DEFAULT(NONE) & !$OMP             SHARED(dr,dphi,dth,center,radius,mass_profile,THIS) & !$OMP             PRIVATE(r,th,phi,rad_coord,long,colat,sq_g,gamma_euler, & !$OMP                     g_xx,baryon_density,mass_element,mass) radius_loop : DO r = 1 , NINT ( radius / dr ), 1 mass = 0.0D0 rad_coord = r * dr longitude_loop : DO phi = 1 , NINT ( 2.0D0 * pi / dphi ), 1 long = phi * dphi colatitude_loop : DO th = 1 , NINT ( pi / 2.0D0 / dth ), 1 colat = th * dth ! The definition of the baryon mass for the LORENE ID is in eq.(69) ! of Gourgoulhon et al., PRD 63 064029 (2001) CALL THIS % read_id_mass_b ( & center + ( rad_coord + dr ) * SIN ( colat ) * COS ( long ), & ( rad_coord + dr ) * SIN ( colat ) * SIN ( long ), & ( rad_coord + dr ) * COS ( colat ), & g_xx , baryon_density , gamma_euler ) ! IF( debug )THEN ! !   IF( ISNAN( g_xx ) )THEN !     PRINT *, \" ** g_xx is NaN\" !     STOP !   ENDIF !   IF( ISNAN( baryon_density ) )THEN !     PRINT *, \" ** baryon_density is NaN\" !     STOP !   ENDIF !   IF( ISNAN( gamma_euler ) )THEN !     PRINT *, \" ** gamma_euler is NaN\" !     STOP !   ENDIF ! ! ENDIF IF ( ISNAN ( g_xx ) . OR . ISNAN ( baryon_density ) . OR . & ISNAN ( gamma_euler ) ) CYCLE !        CALL bns_obj% import_id( & !                 center1 + rad_coord*SIN(lat)*COS(long), & !                 rad_coord*SIN(lat)*SIN(long), & !                 rad_coord*COS(lat), & !                 g_xx, baryon_density, & !                 gamma_euler ) ! !        ! Compute covariant spatial fluid velocity (metric is diagonal and !        ! conformally flat) !        !v_euler_x_l= g_xx*v_euler_x !        !v_euler_y_l= g_xx*v_euler_y !        !v_euler_z_l= g_xx*v_euler_z !        ! !        !! Compute the corresponding Lorentz factor !        !lorentz_factor= 1.0D0/SQRT( 1.0D0 - ( v_euler_x_l*v_euler_x & !        !                                    + v_euler_y_l*v_euler_y & !        !                                    + v_euler_z_l*v_euler_z ) ) !        ! !        !! Compute covariant fluid 4-velocity !        !u_euler_t_l= lorentz_factor *( - lapse + v_euler_x_l*shift_x & !        !                                       + v_euler_y_l*shift_y & !        !                                       + v_euler_z_l*shift_z ) !        !u_euler_x_l= lorentz_factor*v_euler_x_l !        !u_euler_y_l= lorentz_factor*v_euler_y_l !        !u_euler_z_l= lorentz_factor*v_euler_z_l !        ! !        !! Compute vector normal to spacelike hypersurface !        !! (4-velocity of the Eulerian observer) !        !n_t= 1.0D0/lapse !        !n_x= - shift_x/lapse !        !n_y= - shift_y/lapse !        !n_z= - shift_z/lapse !        ! !        !! Compute relative Lorentz factor between 4-velocity of the fluid !        !! wrt the Eulerian observer and the 4-velocity of the Eulerian observer !        !lorentz_factor_rel= - ( n_t*u_euler_t_l + n_x*u_euler_x_l & !        !                      + n_y*u_euler_y_l + n_z*u_euler_z_l ) ! Compute square root of the determinant of the spatial metric sq_g = g_xx * SQRT ( g_xx ) mass_element = ( rad_coord ** 2.0D0 ) * SIN ( colat ) * dr * dth * dphi & * sq_g * gamma_euler * baryon_density mass = mass + 2.0D0 * mass_element ENDDO colatitude_loop ENDDO longitude_loop mass_profile ( 1 , r ) = rad_coord mass_profile ( 2 , r ) = mass ENDDO radius_loop !$OMP END PARALLEL DO DO r = 1 , NINT ( radius / dr ), 1 mass_profile ( 3 , r ) = mass_profile ( 3 , r - 1 ) + mass_profile ( 2 , r ) ENDDO mass = mass_profile ( 3 , NINT ( radius / dr ) ) IF ( ISNAN ( mass ) ) THEN PRINT * , \"** ERROR! The integrated mass is a NaN!\" PRINT * STOP ELSEIF ( mass <= 0 ) THEN PRINT * , \"** ERROR! The integrated mass is mass=\" , mass , \"<= 0!\" PRINT * STOP ENDIF PRINT * , \" * Radius covered by the integration of baryon mass density=\" , & MAXVAL ( mass_profile ( 1 , : ), DIM = 1 ) PRINT * , \" * Integrated baryon mass of the star=\" , mass PRINT * CALL indexx ( NINT ( radius / dr ) + 1 , mass_profile ( 1 , : ), mass_profile_idx ) END PROCEDURE integrate_baryon_mass_density END SUBMODULE bns_base_mass_profile","tags":"","loc":"sourcefile/submodule_bns_base_mass_profile.f90.html"},{"title":"submodule_bns_base_access.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bns_base_access.f90~~EfferentGraph sourcefile~submodule_bns_base_access.f90 submodule_bns_base_access.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~submodule_bns_base_access.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bns_base_access Source Code submodule_bns_base_access.f90 Source Code ! File:         submodule_bns_base_access.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( bns_base ) bns_base_access !*************************************************** ! !# The module contains the implementation of the !  methods of TYPE bnsbase that allow to access !  PRIVATE members. ! !  FT 12.07.2021 ! !*************************************************** IMPLICIT NONE CONTAINS !----------------------------! !--  OVERRIDING FUNCTIONS  --! !----------------------------! MODULE PROCEDURE get_mass !************************************************ ! !# Returns the baryon mass of NS `i_matter`-th star !  [M_\\odot] ! !  FT 27.10.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_mass = THIS % mass ( i_matter ) END PROCEDURE get_mass MODULE PROCEDURE get_radii !************************************************ ! !# Returns the radii of the `i_matter`-th star !  [L_\\odot] ! !  FT 27.10.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_radii = THIS % radii ( i_matter ,:) END PROCEDURE get_radii MODULE PROCEDURE get_center !************************************************ ! !# Returns the center of the `i_matter`-th star !  [L_\\odot] ! !  FT 27.10.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_center = THIS % center ( i_matter ,:) END PROCEDURE get_center MODULE PROCEDURE get_barycenter !************************************************ ! !# Returns the barycenter of the `i_matter`-th star !  [L_\\odot] ! !  FT 27.10.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_barycenter = THIS % barycenter ( i_matter ,:) END PROCEDURE get_barycenter MODULE PROCEDURE get_eos !************************************************ ! !# Returns the |eos| name of the `i_matter`-th star !  [L_\\odot] ! !  FT 27.10.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) IF ( i_matter == 1 ) get_eos = THIS % eos1 IF ( i_matter == 2 ) get_eos = THIS % eos2 END PROCEDURE get_eos !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE get_gamma_1 !************************************************ ! !# Returns the value of [[gamma_1]], the !  polytropic index for NS 1 with polytropic EOS, !  not piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma_1 = THIS % gamma_1 END PROCEDURE get_gamma_1 MODULE PROCEDURE get_gamma_2 !************************************************ ! !# Returns the value of [[gamma_2]], the !  polytropic index for NS 2 with polytropic EOS, !  not piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma_2 = THIS % gamma_2 END PROCEDURE get_gamma_2 MODULE PROCEDURE get_kappa_1 !************************************************ ! !# Returns the value of [[kappa_1]], the !  polytropic constant for NS 1 with polytropic !  EOS, not piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa_1 = THIS % kappa_1 END PROCEDURE get_kappa_1 MODULE PROCEDURE get_kappa_2 !************************************************ ! !# Returns the value of [[kappa_2]], the !  polytropic constant for NS 2 with polytropic !  EOS, not piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa_2 = THIS % kappa_2 END PROCEDURE get_kappa_2 MODULE PROCEDURE get_angular_vel !************************************************ ! !# Returns the angular velocity of the system ! !  FT ! !************************************************ IMPLICIT NONE get_angular_vel = THIS % angular_vel END PROCEDURE get_angular_vel MODULE PROCEDURE get_distance !************************************************ ! !# Returns the distance between the NSs ! !  FT ! !************************************************ IMPLICIT NONE get_distance = THIS % distance END PROCEDURE get_distance MODULE PROCEDURE get_distance_com !************************************************ ! !# Returns the distance between the centers of !  mass of the NSs ! !  FT ! !************************************************ IMPLICIT NONE get_distance_com = THIS % distance_com END PROCEDURE get_distance_com MODULE PROCEDURE get_mass1 !************************************************ ! !# Returns the baryon mass of NS 1 [M_\\odot] ! !  FT ! !************************************************ IMPLICIT NONE get_mass1 = THIS % mass1 END PROCEDURE get_mass1 MODULE PROCEDURE get_mass2 !************************************************ ! !# Returns the baryon mass of NS 2 [M_\\odot] ! !  FT ! !************************************************ IMPLICIT NONE get_mass2 = THIS % mass2 END PROCEDURE get_mass2 MODULE PROCEDURE get_grav_mass1 !************************************************ ! !# Returns the gravitational mass of NS 1 [M_\\odot] ! !  FT ! !************************************************ IMPLICIT NONE get_grav_mass1 = THIS % mass_grav1 END PROCEDURE get_grav_mass1 MODULE PROCEDURE get_grav_mass2 !************************************************ ! !# Returns the gravitational mass of NS 2 [M_\\odot] ! !  FT ! !************************************************ IMPLICIT NONE get_grav_mass2 = THIS % mass_grav2 END PROCEDURE get_grav_mass2 MODULE PROCEDURE get_adm_mass !************************************************ ! !# Returns the ADM mass of the system ! !  FT ! !************************************************ IMPLICIT NONE get_adm_mass = THIS % adm_mass END PROCEDURE get_adm_mass MODULE PROCEDURE get_angular_momentum !************************************************ ! !# Returns the angular momentum of the system ! !  FT ! !************************************************ IMPLICIT NONE get_angular_momentum = THIS % angular_momentum END PROCEDURE get_angular_momentum MODULE PROCEDURE get_radius1_x_comp !************************************************ ! !# Returns the radius of NS 1 along the x axis !  on the side of the companion ! !  FT ! !************************************************ IMPLICIT NONE get_radius1_x_comp = THIS % radius1_x_comp END PROCEDURE get_radius1_x_comp MODULE PROCEDURE get_radius1_y !************************************************ ! !# Returns the radius of NS 1 along the y axis ! !  FT ! !************************************************ IMPLICIT NONE get_radius1_y = THIS % radius1_y END PROCEDURE get_radius1_y MODULE PROCEDURE get_radius1_z !************************************************ ! !# Returns the radius of NS 1 along the z axis ! !  FT ! !************************************************ IMPLICIT NONE get_radius1_z = THIS % radius1_z END PROCEDURE get_radius1_z MODULE PROCEDURE get_radius1_x_opp !************************************************ ! !# Returns the radius of NS 1 along the x axis !  on the side opposite to the companion ! !  FT ! !************************************************ IMPLICIT NONE get_radius1_x_opp = THIS % radius1_x_opp END PROCEDURE get_radius1_x_opp MODULE PROCEDURE get_center1_x !************************************************ ! !# Returns the stellar center of NS 1, i.e., the !  origin of the LORENE chart centered on NS 1 ! !  FT 09.02.2021 ! !************************************************ IMPLICIT NONE get_center1_x = THIS % center1_x END PROCEDURE get_center1_x MODULE PROCEDURE get_barycenter1_x !************************************************ ! !# Returns the barycenter of NS 1 ! !  FT 09.02.2021 ! !************************************************ IMPLICIT NONE get_barycenter1_x = THIS % barycenter1_x END PROCEDURE get_barycenter1_x MODULE PROCEDURE get_radius2_x_comp !************************************************ ! !# Returns the radius of NS 2 along the x axis !  on the side of the companion ! !  FT ! !************************************************ IMPLICIT NONE get_radius2_x_comp = THIS % radius2_x_comp END PROCEDURE get_radius2_x_comp MODULE PROCEDURE get_radius2_y !************************************************ ! !# Returns the radius of NS 2 along the y axis ! !  FT ! !************************************************ IMPLICIT NONE get_radius2_y = THIS % radius2_y END PROCEDURE get_radius2_y MODULE PROCEDURE get_radius2_z !************************************************ ! !# Returns the radius of NS 2 along the z axis ! !  FT ! !************************************************ IMPLICIT NONE get_radius2_z = THIS % radius2_z END PROCEDURE get_radius2_z MODULE PROCEDURE get_radius2_x_opp !************************************************ ! !# Returns the radius of NS 2 along the x axis !  on the side opposite to the companion ! !  FT ! !************************************************ IMPLICIT NONE get_radius2_x_opp = THIS % radius2_x_opp END PROCEDURE get_radius2_x_opp MODULE PROCEDURE get_center2_x !************************************************ ! !# Returns the stellar center of NS 2, i.e., the !  origin of the LORENE chart centered on NS 2 ! !  FT 09.02.2021 ! !************************************************ IMPLICIT NONE get_center2_x = THIS % center2_x END PROCEDURE get_center2_x MODULE PROCEDURE get_barycenter2_x !************************************************ ! !# Returns the barycenter of NS 2 ! !  FT 09.02.2021 ! !************************************************ IMPLICIT NONE get_barycenter2_x = THIS % barycenter2_x END PROCEDURE get_barycenter2_x MODULE PROCEDURE get_ent_center1 !************************************************ ! !# Returns the central enthalpy of NS 1 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_ent_center1 = THIS % ent_center1 END PROCEDURE get_ent_center1 MODULE PROCEDURE get_nbar_center1 !************************************************ ! !# Returns the central baryon number density !  of NS 1 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_nbar_center1 = THIS % nbar_center1 END PROCEDURE get_nbar_center1 MODULE PROCEDURE get_rho_center1 !************************************************ ! !# Returns the central baryon mass density !  of NS 1 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_rho_center1 = THIS % rho_center1 END PROCEDURE get_rho_center1 MODULE PROCEDURE get_energy_density_center1 !************************************************ ! !# Returns the central energy density of NS 1 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_energy_density_center1 = THIS % energy_density_center1 END PROCEDURE get_energy_density_center1 MODULE PROCEDURE get_specific_energy_center1 !************************************************ ! !# Returns the central specific energy of NS 1 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_specific_energy_center1 = THIS % specific_energy_center1 END PROCEDURE get_specific_energy_center1 MODULE PROCEDURE get_pressure_center1 !************************************************ ! !# Returns the central pressure of NS 1 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_pressure_center1 = THIS % pressure_center1 END PROCEDURE get_pressure_center1 MODULE PROCEDURE get_ent_center2 !************************************************ ! !# Returns the central enthalpy of NS 2 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_ent_center2 = THIS % ent_center2 END PROCEDURE get_ent_center2 MODULE PROCEDURE get_nbar_center2 !************************************************ ! !# Returns the central baryon number density !  of NS 2 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_nbar_center2 = THIS % nbar_center2 END PROCEDURE get_nbar_center2 MODULE PROCEDURE get_rho_center2 !************************************************ ! !# Returns the central baryon mass density !  of NS 2 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_rho_center2 = THIS % rho_center2 END PROCEDURE get_rho_center2 MODULE PROCEDURE get_energy_density_center2 !************************************************ ! !# Returns the central energy density of NS 2 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_energy_density_center2 = THIS % energy_density_center2 END PROCEDURE get_energy_density_center2 MODULE PROCEDURE get_specific_energy_center2 !************************************************ ! !# Returns the central specific energy of NS 2 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_specific_energy_center2 = THIS % specific_energy_center2 END PROCEDURE get_specific_energy_center2 MODULE PROCEDURE get_pressure_center2 !************************************************ ! !# Returns the central pressure of NS 2 ! !  FT 12.02.2021 ! !************************************************ IMPLICIT NONE get_pressure_center2 = THIS % pressure_center2 END PROCEDURE get_pressure_center2 MODULE PROCEDURE get_eos1 !************************************************ ! !# Returns the name of the EOS for NS 1 ! !  FT ! !************************************************ IMPLICIT NONE get_eos1 = THIS % eos1 END PROCEDURE get_eos1 MODULE PROCEDURE get_eos2 !************************************************ ! !# Returns the name of the EOS for NS 2 ! !  FT ! !************************************************ IMPLICIT NONE get_eos2 = THIS % eos2 END PROCEDURE get_eos2 MODULE PROCEDURE get_npeos_1 !************************************************ ! !# Returns the identifier of the EOS for NS 1 ! !  FT ! !************************************************ IMPLICIT NONE get_npeos_1 = THIS % npeos_1 END PROCEDURE get_npeos_1 MODULE PROCEDURE get_npeos_2 !************************************************ ! !# Returns the identifier of the EOS for NS 2 ! !  FT ! !************************************************ IMPLICIT NONE get_npeos_2 = THIS % npeos_2 END PROCEDURE get_npeos_2 MODULE PROCEDURE get_gamma0_1 !************************************************ ! !# Returns the value of [[gamma0_1]], the crust's !  polytropic index for NS 1 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma0_1 = THIS % gamma0_1 END PROCEDURE get_gamma0_1 MODULE PROCEDURE get_gamma0_2 !************************************************ ! !# Returns the value of [[gamma0_2]], the crust's !  polytropic index for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma0_2 = THIS % gamma0_2 END PROCEDURE get_gamma0_2 MODULE PROCEDURE get_gamma1_1 !************************************************ ! !# Returns the value of [[gamma1_1]], the first !  polytropic index for NS 1 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma1_1 = THIS % gamma1_1 END PROCEDURE get_gamma1_1 MODULE PROCEDURE get_gamma1_2 !************************************************ ! !# Returns the value of [[gamma1_2]], the first !  polytropic index for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma1_2 = THIS % gamma1_2 END PROCEDURE get_gamma1_2 MODULE PROCEDURE get_gamma2_1 !************************************************ ! !# Returns the value of [[gamma2_1]], the second !  polytropic index for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma2_1 = THIS % gamma2_1 END PROCEDURE get_gamma2_1 MODULE PROCEDURE get_gamma2_2 !************************************************ ! !# Returns the value of [[gamma2_2]], the second !  polytropic index for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_gamma2_2 = THIS % gamma2_2 END PROCEDURE get_gamma2_2 MODULE PROCEDURE get_gamma3_1 !************************************************ ! !# Returns the value of [[gamma3_1]], the third !  polytropic index for NS 1 with piecewise !  polytropic EOS (innermost index) ! !  FT ! !************************************************ IMPLICIT NONE get_gamma3_1 = THIS % gamma3_1 END PROCEDURE get_gamma3_1 MODULE PROCEDURE get_gamma3_2 !************************************************ ! !# Returns the value of [[gamma3_2]], the third !  polytropic index for NS 2 with piecewise !  polytropic EOS (innermost index) ! !  FT ! !************************************************ IMPLICIT NONE get_gamma3_2 = THIS % gamma3_2 END PROCEDURE get_gamma3_2 MODULE PROCEDURE get_kappa0_1 !************************************************ ! !# Returns the value of [[kappa0_1]], the crust's !  polytropic constant for NS 1 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa0_1 = THIS % kappa0_1 END PROCEDURE get_kappa0_1 MODULE PROCEDURE get_kappa1_1 !************************************************ ! !# Returns the value of [[kappa1_1]], the first !  polytropic constant for NS 1 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa1_1 = THIS % kappa1_1 END PROCEDURE get_kappa1_1 MODULE PROCEDURE get_kappa2_1 !************************************************ ! !# Returns the value of [[kappa2_1]], the second !  polytropic constant for NS 1 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa2_1 = THIS % kappa2_1 END PROCEDURE get_kappa2_1 MODULE PROCEDURE get_kappa3_1 !************************************************ ! !# Returns the value of [[kappa3_1]], the third !  polytropic constant for NS 1 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa3_1 = THIS % kappa3_1 END PROCEDURE get_kappa3_1 MODULE PROCEDURE get_kappa0_2 !************************************************ ! !# Returns the value of [[kappa0_2]], the crust's !  polytropic constant for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa0_2 = THIS % kappa0_2 END PROCEDURE get_kappa0_2 MODULE PROCEDURE get_kappa1_2 !************************************************ ! !# Returns the value of [[kappa1_2]], the first !  polytropic constant for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa1_2 = THIS % kappa1_2 END PROCEDURE get_kappa1_2 MODULE PROCEDURE get_kappa2_2 !************************************************ ! !# Returns the value of [[kappa2_2]], the second !  polytropic constant for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa2_2 = THIS % kappa2_2 END PROCEDURE get_kappa2_2 MODULE PROCEDURE get_kappa3_2 !************************************************ ! !# Returns the value of [[kappa3_2]], the third !  polytropic constant for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_kappa3_2 = THIS % kappa3_2 END PROCEDURE get_kappa3_2 MODULE PROCEDURE get_logp1_1 !************************************************ ! !# Returns the value of [[logp1_1]], the base 10 !  logarithm of the pressure where the gamma1_1 !  polytrope starts, for NS 1 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logp1_1 = THIS % logp1_1 END PROCEDURE get_logp1_1 MODULE PROCEDURE get_logp1_2 !************************************************ ! !# Returns the value of [[logp1_2]], the base 10 !  logarithm of the pressure where the gamma1_2 !  polytrope starts, for NS 2 with piecewise !  polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logp1_2 = THIS % logp1_2 END PROCEDURE get_logp1_2 MODULE PROCEDURE get_logRho0_1 !************************************************ ! !# Returns the value of [[logRho0_1]], the base 10 !  logarithm of the mass density where the !  gamma1_1 polytrope starts, for NS 1 with !  piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logRho0_1 = THIS % logRho0_1 END PROCEDURE get_logRho0_1 MODULE PROCEDURE get_logRho0_2 !************************************************ ! !# Returns the value of [[logRho0_2]], the base 10 !  logarithm of the mass density where the !  gamma1_2 polytrope starts, for NS 2 with !  piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logRho0_2 = THIS % logRho0_2 END PROCEDURE get_logRho0_2 MODULE PROCEDURE get_logRho1_1 !************************************************ ! !# Returns the value of [[logRho1_1]], the base 10 !  logarithm of the mass density where the !  gamma2_1 polytrope starts, for NS 1 with !  piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logRho1_1 = THIS % logRho1_1 END PROCEDURE get_logRho1_1 MODULE PROCEDURE get_logRho1_2 !************************************************ ! !# Returns the value of [[logRho1_2]], the base 10 !  logarithm of the mass density where the !  gamma2_2 polytrope starts, for NS 2 with !  piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logRho1_2 = THIS % logRho1_2 END PROCEDURE get_logRho1_2 MODULE PROCEDURE get_logRho2_1 !************************************************ ! !# Returns the value of [[logRho2_1]], the base 10 !  logarithm of the mass density where the !  gamma3_1 polytrope starts, for NS 1 with !  piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logRho2_1 = THIS % logRho2_1 END PROCEDURE get_logRho2_1 MODULE PROCEDURE get_logRho2_2 !************************************************ ! !# Returns the value of [[logRho2_2]]]], the base 10 !  logarithm of the mass density where the !  gamma3_2 polytrope starts, for NS 2 with !  piecewise polytropic EOS ! !  FT ! !************************************************ IMPLICIT NONE get_logRho2_2 = THIS % logRho2_2 END PROCEDURE get_logRho2_2 END SUBMODULE bns_base_access","tags":"","loc":"sourcefile/submodule_bns_base_access.f90.html"},{"title":"module_bns_base.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_bns_base.f90~~EfferentGraph sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_bns_base.f90~~AfferentGraph sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~submodule_bns_base_mass_profile.f90 submodule_bns_base_mass_profile.f90 sourcefile~submodule_bns_base_mass_profile.f90->sourcefile~module_bns_base.f90 sourcefile~submodule_bns_base_access.f90 submodule_bns_base_access.f90 sourcefile~submodule_bns_base_access.f90->sourcefile~module_bns_base.f90 sourcefile~submodule_bns_lorene_constructor.f90 submodule_bns_lorene_constructor.f90 sourcefile~submodule_bns_lorene_constructor.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_access.f90 submodule_bns_lorene_access.f90 sourcefile~submodule_bns_lorene_access.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_params.f90 submodule_bns_lorene_params.f90 sourcefile~submodule_bns_lorene_params.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_import.f90 submodule_bns_lorene_import.f90 sourcefile~submodule_bns_lorene_import.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_memory.f90 submodule_bns_lorene_memory.f90 sourcefile~submodule_bns_lorene_memory.f90->sourcefile~module_bns_lorene.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 var pansourcefilemodule_bns_basef90AfferentGraph = svgPanZoom('#sourcefilemodule_bns_basef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules bns_base Source Code module_bns_base.f90 Source Code ! File:         module_bns_base.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE bns_base !******************************************************** ! !# This MODULE contains the definition of TYPE bnsbase, !  which is an ABSTRACT TYPE representing any possible !  type of binary neutron star (BNS) initial data (ID) !  to be set up for |sphincsbssn|. That is, BNS ID !  produced with LORENE, with |fuka|, etc. ! !  PROCEDURES and variables shared by all the types !  of BNS ID should belong to TYPE bnsbase, as !  they are inherited by its EXTENDED TYPES that !  represent more specific typesof BNS ID. ! !  FT 24.09.2021 ! !******************************************************** USE id_base , ONLY : idbase USE utility , ONLY : ios , err_msg IMPLICIT NONE !******************************************************* !                                                      * !   Definition of TYPE bnsbase (binary neutron star)   * !                                                      * !******************************************************* TYPE , ABSTRACT , EXTENDS ( idbase ) :: bnsbase !# Represents a generic BNS ID for |sphincsbssn| (produced with LORENE, or with !  |fuka|, etc.; or produced with the same tool, but read in different ways, !  for example by linking to the LORENE library, or reading the ID from !  a lattice, etc.) !-----------------------------! !--  Parameters of the BNS  --! !-----------------------------! !> Angular velocity [{\\rm rad/s}] DOUBLE PRECISION :: angular_vel !> Distance d between the points of maximum baryon density [{\\rm km}] DOUBLE PRECISION :: distance !> Distance between the centers of mass [L_\\odot(=1.47662503825040{\\rm km})] DOUBLE PRECISION :: distance_com DOUBLE PRECISION , DIMENSION ( 2 ) :: mass !! Array containing the baryonic masses [M_\\odot] !> Baryonic mass of star 1 [M_\\odot] DOUBLE PRECISION :: mass1 !> Baryonic mass of star 2 [M_\\odot] DOUBLE PRECISION :: mass2 DOUBLE PRECISION , DIMENSION ( 2 ) :: mass_grav !! Array containing the gravitatil masses [M_\\odot] !> Gravitational mass of star 1 [M_\\odot] DOUBLE PRECISION :: mass_grav1 !> Gravitational mass of star 2 [M_\\odot] DOUBLE PRECISION :: mass_grav2 !> ADM mass of the BNS [M_\\odot] DOUBLE PRECISION :: adm_mass !& mOmega= ( [[bnsbase:angular_vel]][{\\rm km&#94;{-1}}] ) !  \\times ( [[bnsbase:mass_grav1]][{\\rm km}] !      + [[bnsbase:mass_grav2]][{\\rm km}] ) [pure number] ! !  Constant used in [K. Hotokezaka et al, Phys. Rev. D 87, 024001](https://arxiv.org/abs/1212.0905){:target=\"_blank\"} (see Sec. IIB) to determine when !  the BNS is at approximately 3-4 quasicircular orbits from merger. For the ! EOS APR4 and ALF2, this requirement is approximately satisfied for ! mOmega =0.026; for the EOS H4 and MS1, for mOmega =0.025. DOUBLE PRECISION :: mOmega !& Estimated time of the merger [M_\\odot] !   !  t_\\mathrm{merger}=\\dfrac{5}{256} !  \\dfrac{d&#94;4}{M&#94;1_\\mathrm{g}M&#94;2_\\mathrm{g}(M&#94;1_\\mathrm{g}+M&#94;2_\\mathrm{g})} !   !  [P. C. Peters, \"Gravitational Radiation and the Motion of Two Point !  Masses\", Phys. Rev. 136, B1224 (1964)](http://gravity.psu.edu/numrel/jclub/jc/Peters_PR_136_B1224_1964.pdf){:target=\"_blank\"} DOUBLE PRECISION :: t_merger !> Angular momentum of the BNS system [G M_\\odot&#94;2/c] DOUBLE PRECISION :: angular_momentum = 0.0D0 !& Areal (or circumferential) radius of star 1 [L_\\odot] ! Note that these is the areal radius of the star in the binary system, ! which is different than that of an isolated star. The latter is used ! in the mass-radius diagrams, together with the gravitatonal mass DOUBLE PRECISION :: area_radius1 DOUBLE PRECISION , DIMENSION ( 2 , 6 ) :: radii !# Array containing the **signed** radii of the stars !  @todo add details !> Radius of star 1, in the x direction, towards the companion [L_\\odot] DOUBLE PRECISION :: radius1_x_comp !> Radius of star 1, in the y direction [L_\\odot] DOUBLE PRECISION :: radius1_y !> Radius of star 1, in the z direction [L_\\odot] DOUBLE PRECISION :: radius1_z !> Radius of star 1, in the x direction, opposite to companion [L_\\odot] DOUBLE PRECISION :: radius1_x_opp !& Stellar center of star 1 (origin of the LORENE chart centered on star 1) !  [L_\\odot] DOUBLE PRECISION :: center1_x DOUBLE PRECISION , DIMENSION ( 2 , 3 ) :: center !# Array containing the centers of the stars !  @todo add details DOUBLE PRECISION , DIMENSION ( 2 , 3 ) :: barycenter !# Array containing the barycenters of the stars !  @todo add details !> Barycenter of star 1 [L_\\odot] DOUBLE PRECISION :: barycenter1_x !& Areal (or circumferential) radius of star 2 [L_\\odot] ! Note that these is the areal radius of the star in the binary system, ! which is different than that of an isolated star. The latter is used ! in the mass-radius diagrams, together with the gravitatonal mass DOUBLE PRECISION :: area_radius2 !> Radius of star 2, in the x direction, towards the companion [L_\\odot] DOUBLE PRECISION :: radius2_x_comp !> Radius of star 2, in the y direction [L_\\odot] DOUBLE PRECISION :: radius2_y !> Radius of star 2, in the z direction [L_\\odot] DOUBLE PRECISION :: radius2_z !> Radius of star 2, in the x direction, opposite to companion [L_\\odot] DOUBLE PRECISION :: radius2_x_opp !& Stellar center of star 2 (origin of the LORENE chart centered on star 2) !  [L_\\odot] DOUBLE PRECISION :: center2_x !> Barycenter of star 2 [L_\\odot] DOUBLE PRECISION :: barycenter2_x !> Central enthalpy for star 1 [c&#94;2] DOUBLE PRECISION :: ent_center1 !> Central baryon number density for star 1 [L_\\odot&#94;{-3}] DOUBLE PRECISION :: nbar_center1 !> Central baryon mass density for star 1 [M_\\odot L_\\odot&#94;{-3}] DOUBLE PRECISION :: rho_center1 !> Central energy density for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: energy_density_center1 !> Central specific energy for star 1 [c&#94;2] DOUBLE PRECISION :: specific_energy_center1 !> Central pressure for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: pressure_center1 !> Central enthalpy for star 2 [c&#94;2] DOUBLE PRECISION :: ent_center2 !> Central baryon number density for star 2 [L_\\odot&#94;{-3}] DOUBLE PRECISION :: nbar_center2 !> Central baryon mass density for star 2 [M_\\odot L_\\odot&#94;{-3}] DOUBLE PRECISION :: rho_center2 !> Central energy density for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: energy_density_center2 !> Central specific energy for star 2 [c&#94;2] DOUBLE PRECISION :: specific_energy_center2 !> Central pressure for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: pressure_center2 !> Name of the equation of state (|eos|) of star 1 CHARACTER ( LEN = : ), ALLOCATABLE :: eos1 !> Name of the equation of state (|eos|) of star 2 CHARACTER ( LEN = : ), ALLOCATABLE :: eos2 ! !-- Parameters of single polytropic equations of state for the two NSs ! !> Single polytrope: polytropic index for star 1 DOUBLE PRECISION :: gamma_1 !> Single polytrope: polytropic index for star 2 DOUBLE PRECISION :: gamma_2 !> Single polytrope: polytropic constant for star 1 [pure number] DOUBLE PRECISION :: kappa_1 !> Single polytrope: polytropic constant for star 2 [pure number] DOUBLE PRECISION :: kappa_2 ! !-- Parameters of the piecewise polytropic equation of state for NS 1 ! !> Piecewise polytrope: Number of polytropic pieces for star 1 INTEGER :: npeos_1 !> Piecewise polytrope: polytropic index \\gamma_0 for star 1 DOUBLE PRECISION :: gamma0_1 !> Piecewise polytrope: polytropic index \\gamma_1 for star 1 DOUBLE PRECISION :: gamma1_1 !> Piecewise polytrope: polytropic index \\gamma_2 for star 1 DOUBLE PRECISION :: gamma2_1 !> Piecewise polytrope: polytropic index \\gamma_3 for star 1 DOUBLE PRECISION :: gamma3_1 !& Piecewise polytrope: polytropic constant \\kappa_0 for star 1 !  [pure number] DOUBLE PRECISION :: kappa0_1 !& Piecewise polytrope: polytropic constant \\kappa_1 for star 1 !  [pure number] DOUBLE PRECISION :: kappa1_1 !& Piecewise polytrope: polytropic constant \\kappa_2 for star 1 !  [pure number] DOUBLE PRECISION :: kappa2_1 !& Piecewise polytrope: polytropic constant \\kappa_3 for star 1 !  [pure number] DOUBLE PRECISION :: kappa3_1 !& Piecewise polytrope: Base 10 exponent of the pressure at the first !  fiducial density (between \\gamma_0 and \\gamma_1) [{\\rm dyne/cm&#94;2}] !  for star 1 DOUBLE PRECISION :: logP1_1 !& Piecewise polytrope: Base 10 exponent of the first fiducial density !  (between \\gamma_0 and \\gamma_1) [{\\rm g/cm&#94;3}] for star 1 DOUBLE PRECISION :: logRho0_1 !& Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] for star 1 DOUBLE PRECISION :: logRho1_1 !& Piecewise polytrope: Base 10 exponent of the third fiducial density !  (between \\gamma_2 and \\gamma_3) [{\\rm g/cm&#94;3}] for star 1 DOUBLE PRECISION :: logRho2_1 ! !-- Parameters of the piecewise polytropic equation of state for NS 2 ! !> Piecewise polytrope: Number of polytropic pieces for star 2 INTEGER :: npeos_2 !> Piecewise polytrope: polytropic index \\gamma_0 for star 2 DOUBLE PRECISION :: gamma0_2 !> Piecewise polytrope: polytropic index \\gamma_1 for star 2 DOUBLE PRECISION :: gamma1_2 !> Piecewise polytrope: polytropic index \\gamma_2 for star 2 DOUBLE PRECISION :: gamma2_2 !> Piecewise polytrope: polytropic index \\gamma_3 for star 2 DOUBLE PRECISION :: gamma3_2 !& Piecewise polytrope: polytropic constant \\kappa_0 for star 2 !  [pure number] DOUBLE PRECISION :: kappa0_2 !& Piecewise polytrope: polytropic constant \\kappa_1 for star 2 !  [pure number] DOUBLE PRECISION :: kappa1_2 !& Piecewise polytrope: polytropic constant \\kappa_2 for star 2 !  [pure number] DOUBLE PRECISION :: kappa2_2 !& Piecewise polytrope: polytropic constant \\kappa_3 for star 2 !  [pure number] DOUBLE PRECISION :: kappa3_2 !& Piecewise polytrope: Base 10 exponent of the pressure at the first !  fiducial density (between \\gamma_0 and \\gamma_1) [{\\rm dyne/cm&#94;2}] !  for star 2 DOUBLE PRECISION :: logP1_2 !& Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] for star 2 DOUBLE PRECISION :: logRho0_2 !& Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] for star 2 DOUBLE PRECISION :: logRho1_2 !& Piecewise polytrope: Base 10 exponent of the third fiducial density !  (between \\gamma_2 and \\gamma_3) [{\\rm g/cm&#94;3}] for star 2 DOUBLE PRECISION :: logRho2_2 CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE ( get_eos_id_int ), DEFERRED :: get_eos1_id !! Returns an integer that identifies the equation of state of star 1 PROCEDURE ( get_eos_id_int ), DEFERRED :: get_eos2_id !! Returns an integer that identifies the equation of state of star 2 !PROCEDURE:: integrate_field_on_star => integrate_baryon_mass_density !# Integrates the LORENE baryon mass density and computes the !  radial mass profile !-----------------! !--  FUNCTIONS  --! !-----------------! ! !-- Overloaded FUNCTION to access the fields as arrays and as values ! !     GENERIC, PUBLIC:: get_field => get_fa, get_fv !     !# GENERIC PROCEDURE, overloded to access the bns member variables as arrays !     !  and as values !     PROCEDURE::       get_fa    => get_field_array !     !! Access the bns member arrays !     PROCEDURE::       get_fv    => get_field_value !! Access the components of the bns member arrays ! !-- FUNCTIONS that access member variables ! !PROCEDURE, PUBLIC:: get_bns_identifier !PROCEDURE, PUBLIC:: get_bns_ptr PROCEDURE :: return_mass => get_mass PROCEDURE :: return_center => get_center PROCEDURE :: return_barycenter => get_barycenter PROCEDURE :: return_eos_name => get_eos PROCEDURE :: return_spatial_extent => get_radii !PROCEDURE:: return_total_spatial_extent => get_bounding_box PROCEDURE , PUBLIC :: get_angular_vel !! Returns [[bnsbase:angular_vel]] PROCEDURE , PUBLIC :: get_distance !! Returns [[bnsbase:distance]] PROCEDURE , PUBLIC :: get_distance_com !! Returns [[bnsbase:distance_com]] PROCEDURE , PUBLIC :: get_mass1 !! Returns [[bnsbase:mass1]] PROCEDURE , PUBLIC :: get_mass2 !! Returns [[bnsbase:mass2]] PROCEDURE , PUBLIC :: get_grav_mass1 !! Returns [[bnsbase:mass_grav1]] PROCEDURE , PUBLIC :: get_grav_mass2 !! Returns [[bnsbase:mass_grav2]] PROCEDURE , PUBLIC :: get_adm_mass !! Returns [[bnsbase:adm_mass]] PROCEDURE , PUBLIC :: get_angular_momentum !! Returns [[bnsbase:angular_momentum]] PROCEDURE , PUBLIC :: get_radius1_x_comp !! Returns [[bnsbase:radius1_x_comp]] PROCEDURE , PUBLIC :: get_radius1_y !! Returns [[bnsbase:radius1_y]] PROCEDURE , PUBLIC :: get_radius1_z !! Returns [[bnsbase:radius1_z]] PROCEDURE , PUBLIC :: get_radius1_x_opp !! Returns [[bnsbase:radius1_x_opp]] PROCEDURE , PUBLIC :: get_center1_x !! Returns [[bnsbase:center1_x]] PROCEDURE , PUBLIC :: get_barycenter1_x !! Returns [[bnsbase:barycenter1_x]] PROCEDURE , PUBLIC :: get_radius2_x_comp !! Returns [[bnsbase:radius2_x_comp]] PROCEDURE , PUBLIC :: get_radius2_y !! Returns [[bnsbase:radius2_y]] PROCEDURE , PUBLIC :: get_radius2_z !! Returns [[bnsbase:radius2_y]] PROCEDURE , PUBLIC :: get_radius2_x_opp !! Returns [[bnsbase:radius2_x_opp]] PROCEDURE , PUBLIC :: get_center2_x !! Returns [[bnsbase:center2_x]] PROCEDURE , PUBLIC :: get_barycenter2_x !! Returns [[bnsbase:barycenter2_x]] PROCEDURE , PUBLIC :: get_ent_center1 !! Returns [[bnsbase:ent_center1]] PROCEDURE , PUBLIC :: get_nbar_center1 !! Returns [[bnsbase:nbar_center1]] PROCEDURE , PUBLIC :: get_rho_center1 !! Returns [[bnsbase:rho_center1]] PROCEDURE , PUBLIC :: get_energy_density_center1 !! Returns [[bnsbase:energy_density_center1]] PROCEDURE , PUBLIC :: get_specific_energy_center1 !! Returns [[bnsbase:specific_energy_center1]] PROCEDURE , PUBLIC :: get_pressure_center1 !! Returns [[bnsbase:pressure_center1]] PROCEDURE , PUBLIC :: get_ent_center2 !! Returns [[bnsbase:ent_center2]] PROCEDURE , PUBLIC :: get_nbar_center2 !! Returns [[bnsbase:nbar_center2]] PROCEDURE , PUBLIC :: get_rho_center2 !! Returns [[bnsbase:rho_center2]] PROCEDURE , PUBLIC :: get_energy_density_center2 !! Returns [[bnsbase:energy_density_center2]] PROCEDURE , PUBLIC :: get_specific_energy_center2 !! Returns [[bnsbase:specific_energy_center2]] PROCEDURE , PUBLIC :: get_pressure_center2 !! Returns [[bnsbase:pressure_center2]] PROCEDURE , PUBLIC :: get_eos1 !! Returns [[bnsbase:eos1]] PROCEDURE , PUBLIC :: get_eos2 !! Returns [[bnsbase:eos2]] ! !-- PROCEDURES to be used for single polytropic EOS ! PROCEDURE , PUBLIC :: get_gamma_1 !! Returns [[bnsbase:gamma_1]] PROCEDURE , PUBLIC :: get_gamma_2 !! Returns [[bnsbase:gamma_2]] PROCEDURE , PUBLIC :: get_kappa_1 !! Returns [[bnsbase:kappa_1]] PROCEDURE , PUBLIC :: get_kappa_2 !! Returns [[bnsbase:kappa_2]] ! !-- PROCEDURES to be used for piecewise polytropic EOS ! PROCEDURE , PUBLIC :: get_npeos_1 !! Returns [[bnsbase:npeos_1]] PROCEDURE , PUBLIC :: get_gamma0_1 !! Returns [[bnsbase:gamma0_1]] PROCEDURE , PUBLIC :: get_gamma1_1 !! Returns [[bnsbase:gamma1_1]] PROCEDURE , PUBLIC :: get_gamma2_1 !! Returns [[bnsbase:gamma2_1]] PROCEDURE , PUBLIC :: get_gamma3_1 !! Returns [[bnsbase:gamma3_1]] PROCEDURE , PUBLIC :: get_kappa0_1 !! Returns [[bnsbase:kappa0_1]] PROCEDURE , PUBLIC :: get_kappa1_1 !! Returns [[bnsbase:kappa1_1]] PROCEDURE , PUBLIC :: get_kappa2_1 !! Returns [[bnsbase:kappa2_1]] PROCEDURE , PUBLIC :: get_kappa3_1 !! Returns [[bnsbase:kappa3_1]] PROCEDURE , PUBLIC :: get_logP1_1 !! Returns [[bnsbase:logP1_1]] PROCEDURE , PUBLIC :: get_logRho0_1 !! Returns [[bnsbase:logRho0_1]] PROCEDURE , PUBLIC :: get_logRho1_1 !! Returns [[bnsbase:logRho1_1]] PROCEDURE , PUBLIC :: get_logRho2_1 !! Returns [[bnsbase:logRho2_1]] PROCEDURE , PUBLIC :: get_npeos_2 !! Returns [[bnsbase:npeos_2]] PROCEDURE , PUBLIC :: get_gamma0_2 !! Returns [[bnsbase:gamma0_2]] PROCEDURE , PUBLIC :: get_gamma1_2 !! Returns [[bnsbase:gamma1_2]] PROCEDURE , PUBLIC :: get_gamma2_2 !! Returns [[bnsbase:gamma2_2]] PROCEDURE , PUBLIC :: get_gamma3_2 !! Returns [[bnsbase:gamma3_2]] PROCEDURE , PUBLIC :: get_kappa0_2 !! Returns [[bnsbase:kappa0_2]] PROCEDURE , PUBLIC :: get_kappa1_2 !! Returns [[bnsbase:kappa1_2]] PROCEDURE , PUBLIC :: get_kappa2_2 !! Returns [[bnsbase:kappa2_2]] PROCEDURE , PUBLIC :: get_kappa3_2 !! Returns [[bnsbase:kappa3_2]] PROCEDURE , PUBLIC :: get_logP1_2 !! Returns [[bnsbase:logP1_2]] PROCEDURE , PUBLIC :: get_logRho0_2 !! Returns [[bnsbase:logRho0_2]] PROCEDURE , PUBLIC :: get_logRho1_2 !! Returns [[bnsbase:logRho1_2]] PROCEDURE , PUBLIC :: get_logRho2_2 !! Returns [[bnsbase:logRho2_2]] END TYPE bnsbase ABSTRACT INTERFACE FUNCTION get_eos_id_int ( THIS ) IMPORT :: bnsbase !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_eos_id_int END FUNCTION get_eos_id_int END INTERFACE INTERFACE !  MODULE FUNCTION get_field_array( THIS, field ) RESULT( field_array ) !  !! Returns the [[bnsbase]] member arrays named field ! !    !> [[bnsbase]] object which this PROCEDURE is a member of !    CLASS(bnsbase),          INTENT( IN )             :: THIS !    !> Name of the desired [[bnsbase]] member array !    CHARACTER( LEN= : ), INTENT( IN ), ALLOCATABLE:: field !    !> Desired [[bnsbase]] member array !    DOUBLE PRECISION, DIMENSION(:),    ALLOCATABLE:: field_array ! !  END FUNCTION get_field_array ! ! !  MODULE FUNCTION get_field_value( THIS, field, n ) RESULT( field_value ) !  !! Returns the component n of the [[bnsbase]] member arrays named field ! !    !> [[bnsbase]] object which this PROCEDURE is a member of !    CLASS(bnsbase),          INTENT( IN )             :: THIS !    !> Name of the desired [[bnsbase]] member array !    CHARACTER( LEN= : ), INTENT( IN ), ALLOCATABLE:: field !    !> Component of the desired [[bnsbase]] member array !    INTEGER,             INTENT( IN )             :: n !    !> Component n of the desired [[bnsbase]] member array !    DOUBLE PRECISION                              :: field_value ! !  END FUNCTION get_field_value ! ! !  MODULE FUNCTION get_bns_identifier( THIS ) ! !    !> [[bnsbase]] object which this PROCEDURE is a member of !    CLASS(bnsbase), INTENT( IN ):: THIS !    ! Result !    DOUBLE PRECISION:: get_bns_identifier ! !  END FUNCTION get_bns_identifier !   SUBROUTINE read_bns_id_spacetime_int( THIS, nx, ny, nz, & !                                             pos, & !                                             lapse, & !                                             shift, & !                                             g, & !                                             ek ) !   !# Stores the spacetime ID in multi-dimensional arrays needed to compute !   !  the BSSN variables and constraints !     IMPORT:: bnsbase !     !> [[bnsbase]] object which this PROCEDURE is a member of !     CLASS(bnsbase),                        INTENT( IN OUT ):: THIS !     INTEGER,                              INTENT( IN )    :: nx !     INTEGER,                              INTENT( IN )    :: ny !     INTEGER,                              INTENT( IN )    :: nz !     DOUBLE PRECISION, DIMENSION(:,:,:,:), INTENT( IN )    :: pos !     DOUBLE PRECISION, DIMENSION(:,:,:),   INTENT( IN OUT ):: lapse !     DOUBLE PRECISION, DIMENSION(:,:,:,:), INTENT( IN OUT ):: shift !     DOUBLE PRECISION, DIMENSION(:,:,:,:), INTENT( IN OUT ):: g !     DOUBLE PRECISION, DIMENSION(:,:,:,:), INTENT( IN OUT ):: ek ! !   END SUBROUTINE read_bns_id_spacetime_int !   MODULE SUBROUTINE integrate_baryon_mass_density( THIS, center, radius, & !                                                    central_density, & !                                                    dr, dth, dphi, & !                                                    mass, mass_profile, & !                                                    mass_profile_idx ) !   !# Integrates the LORENE baryon mass density to compute the radial mass !   !  profile. TODO: Improve integration algorithm. ! !     !> [[bnsbase]] object which this PROCEDURE is a member of !     CLASS(bnsbase), INTENT( IN OUT )      :: THIS !     !& Array to store the indices for array mass_profile, sorted so that !     !  mass_profile[mass_profile_idx] is in increasing order !     INTEGER, DIMENSION(:), ALLOCATABLE, INTENT( IN OUT ):: mass_profile_idx !     !> Center of the star !     DOUBLE PRECISION, INTENT( IN )    :: center !     !> Central density of the star !     DOUBLE PRECISION, INTENT( IN )    :: central_density !     !> Radius of the star !     DOUBLE PRECISION, INTENT( IN )    :: radius !     !> Integration steps !     DOUBLE PRECISION, INTENT( IN )    :: dr, dth, dphi !     !> Integrated mass of the star !     DOUBLE PRECISION, INTENT( IN OUT ):: mass !     !> Array storing the radial mass profile of the star !     DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE, INTENT( IN OUT ):: & !                                      mass_profile ! !   END SUBROUTINE integrate_baryon_mass_density !----------------------------! !--  OVERRIDING FUNCTIONS  --! !----------------------------! MODULE FUNCTION get_mass ( THIS , i_matter ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter ! Result DOUBLE PRECISION :: get_mass END FUNCTION get_mass MODULE FUNCTION get_radii ( THIS , i_matter ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose string is to return DOUBLE PRECISION , DIMENSION ( 6 ) :: get_radii END FUNCTION get_radii MODULE FUNCTION get_center ( THIS , i_matter ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION ( 3 ) :: get_center END FUNCTION get_center MODULE FUNCTION get_barycenter ( THIS , i_matter ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION ( 3 ) :: get_barycenter END FUNCTION get_barycenter MODULE FUNCTION get_eos ( THIS , i_matter ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose string is to return CHARACTER ( LEN = : ), ALLOCATABLE :: get_eos END FUNCTION get_eos !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE FUNCTION get_gamma_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma_1 END FUNCTION get_gamma_1 MODULE FUNCTION get_gamma_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma_2 END FUNCTION get_gamma_2 MODULE FUNCTION get_kappa_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa_1 END FUNCTION get_kappa_1 MODULE FUNCTION get_kappa_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa_2 END FUNCTION get_kappa_2 MODULE FUNCTION get_angular_vel ( THIS ) !! Returns angular_vel !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_angular_vel END FUNCTION get_angular_vel MODULE FUNCTION get_distance ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_distance END FUNCTION get_distance MODULE FUNCTION get_distance_com ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_distance_com END FUNCTION get_distance_com MODULE FUNCTION get_mass1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_mass1 END FUNCTION get_mass1 MODULE FUNCTION get_mass2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_mass2 END FUNCTION get_mass2 MODULE FUNCTION get_grav_mass1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_grav_mass1 END FUNCTION get_grav_mass1 MODULE FUNCTION get_grav_mass2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_grav_mass2 END FUNCTION get_grav_mass2 MODULE FUNCTION get_adm_mass ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_adm_mass END FUNCTION get_adm_mass MODULE FUNCTION get_angular_momentum ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_angular_momentum END FUNCTION get_angular_momentum MODULE FUNCTION get_radius1_x_comp ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius1_x_comp END FUNCTION get_radius1_x_comp MODULE FUNCTION get_radius1_y ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius1_y END FUNCTION get_radius1_y MODULE FUNCTION get_radius1_z ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius1_z END FUNCTION get_radius1_z MODULE FUNCTION get_radius1_x_opp ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius1_x_opp END FUNCTION get_radius1_x_opp MODULE FUNCTION get_center1_x ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_center1_x END FUNCTION get_center1_x MODULE FUNCTION get_barycenter1_x ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_barycenter1_x END FUNCTION get_barycenter1_x MODULE FUNCTION get_radius2_x_comp ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius2_x_comp END FUNCTION get_radius2_x_comp MODULE FUNCTION get_radius2_y ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius2_y END FUNCTION get_radius2_y MODULE FUNCTION get_radius2_z ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius2_z END FUNCTION get_radius2_z MODULE FUNCTION get_radius2_x_opp ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_radius2_x_opp END FUNCTION get_radius2_x_opp MODULE FUNCTION get_center2_x ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_center2_x END FUNCTION get_center2_x MODULE FUNCTION get_barycenter2_x ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_barycenter2_x END FUNCTION get_barycenter2_x MODULE FUNCTION get_ent_center1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_ent_center1 END FUNCTION get_ent_center1 MODULE FUNCTION get_nbar_center1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_nbar_center1 END FUNCTION get_nbar_center1 MODULE FUNCTION get_rho_center1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_rho_center1 END FUNCTION get_rho_center1 MODULE FUNCTION get_energy_density_center1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_energy_density_center1 END FUNCTION get_energy_density_center1 MODULE FUNCTION get_specific_energy_center1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_specific_energy_center1 END FUNCTION get_specific_energy_center1 MODULE FUNCTION get_pressure_center1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_pressure_center1 END FUNCTION get_pressure_center1 MODULE FUNCTION get_ent_center2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_ent_center2 END FUNCTION get_ent_center2 MODULE FUNCTION get_nbar_center2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_nbar_center2 END FUNCTION get_nbar_center2 MODULE FUNCTION get_rho_center2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_rho_center2 END FUNCTION get_rho_center2 MODULE FUNCTION get_energy_density_center2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_energy_density_center2 END FUNCTION get_energy_density_center2 MODULE FUNCTION get_specific_energy_center2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_specific_energy_center2 END FUNCTION get_specific_energy_center2 MODULE FUNCTION get_pressure_center2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_pressure_center2 END FUNCTION get_pressure_center2 MODULE FUNCTION get_eos1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result CHARACTER ( LEN = : ), ALLOCATABLE :: get_eos1 END FUNCTION get_eos1 MODULE FUNCTION get_eos2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result CHARACTER ( LEN = : ), ALLOCATABLE :: get_eos2 END FUNCTION get_eos2 MODULE FUNCTION get_npeos_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_npeos_1 END FUNCTION get_npeos_1 MODULE FUNCTION get_npeos_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_npeos_2 END FUNCTION get_npeos_2 MODULE FUNCTION get_gamma0_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma0_1 END FUNCTION get_gamma0_1 MODULE FUNCTION get_gamma1_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma1_1 END FUNCTION get_gamma1_1 MODULE FUNCTION get_gamma2_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma2_1 END FUNCTION get_gamma2_1 MODULE FUNCTION get_gamma3_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma3_1 END FUNCTION get_gamma3_1 MODULE FUNCTION get_kappa0_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa0_1 END FUNCTION get_kappa0_1 MODULE FUNCTION get_kappa1_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa1_1 END FUNCTION get_kappa1_1 MODULE FUNCTION get_kappa2_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa2_1 END FUNCTION get_kappa2_1 MODULE FUNCTION get_kappa3_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa3_1 END FUNCTION get_kappa3_1 MODULE FUNCTION get_logP1_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logP1_1 END FUNCTION get_logP1_1 MODULE FUNCTION get_logRho0_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho0_1 END FUNCTION get_logRho0_1 MODULE FUNCTION get_logRho1_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho1_1 END FUNCTION get_logRho1_1 MODULE FUNCTION get_logRho2_1 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho2_1 END FUNCTION get_logRho2_1 MODULE FUNCTION get_gamma0_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma0_2 END FUNCTION get_gamma0_2 MODULE FUNCTION get_gamma1_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma1_2 END FUNCTION get_gamma1_2 MODULE FUNCTION get_gamma2_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma2_2 END FUNCTION get_gamma2_2 MODULE FUNCTION get_gamma3_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma3_2 END FUNCTION get_gamma3_2 MODULE FUNCTION get_kappa0_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa0_2 END FUNCTION get_kappa0_2 MODULE FUNCTION get_kappa1_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa1_2 END FUNCTION get_kappa1_2 MODULE FUNCTION get_kappa2_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa2_2 END FUNCTION get_kappa2_2 MODULE FUNCTION get_kappa3_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa3_2 END FUNCTION get_kappa3_2 MODULE FUNCTION get_logP1_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logP1_2 END FUNCTION get_logP1_2 MODULE FUNCTION get_logRho0_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho0_2 END FUNCTION get_logRho0_2 MODULE FUNCTION get_logRho1_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho1_2 END FUNCTION get_logRho1_2 MODULE FUNCTION get_logRho2_2 ( THIS ) !> [[bnsbase]] object which this PROCEDURE is a member of CLASS ( bnsbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho2_2 END FUNCTION get_logRho2_2 END INTERFACE END MODULE bns_base","tags":"","loc":"sourcefile/module_bns_base.f90.html"},{"title":"submodule_bns_lorene_import.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bns_lorene_import.f90~~EfferentGraph sourcefile~submodule_bns_lorene_import.f90 submodule_bns_lorene_import.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~submodule_bns_lorene_import.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_bns_lorene_importf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bns_lorene_importf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bns_lorene_import Source Code submodule_bns_lorene_import.f90 Source Code ! File:         submodule_bns_methods.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( bns_lorene ) bns_lorene_import !**************************************************** ! !# Implementation of the methods of TYPE bns that !  import BNS data using |lorene| ! !  FT 23.10.2020 ! !  Renamed from bns_methods to bns_import upon !  improving modularity ! !  OMP parallelized loops that call |lorene| !  in all MODULE PROCEDURE ! !  FT 12.07.2021 ! !**************************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE import_id_int !************************************************** ! !# Stores the ID in the [[bnslorene]] member arrays ! !  FT 5.10.2020 ! !************************************************** USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN IF ( SIZE ( x ) /= SIZE ( y ) . OR . SIZE ( x ) /= SIZE ( z ) & . OR . SIZE ( y ) /= SIZE ( z ) ) THEN PRINT * , \"** ERROR: The sizes of the arrays of positions\" & // \"passed to import_lorene_id are not the same.\" PRINT * STOP ENDIF IF ( ALLOCATED ( THIS % lapse ) . AND . & ALLOCATED ( THIS % shift_x ) . AND . & ALLOCATED ( THIS % shift_y ) . AND . & ALLOCATED ( THIS % shift_z ) . AND . & ALLOCATED ( THIS % g_xx ) . AND . ALLOCATED ( THIS % g_xy ) . AND . & ALLOCATED ( THIS % g_xz ) . AND . ALLOCATED ( THIS % g_yy ) . AND . & ALLOCATED ( THIS % g_yz ) . AND . ALLOCATED ( THIS % g_zz ) . AND . & ALLOCATED ( THIS % k_xx ) . AND . ALLOCATED ( THIS % k_xy ) . AND . & ALLOCATED ( THIS % k_xz ) . AND . ALLOCATED ( THIS % k_yy ) . AND . & ALLOCATED ( THIS % k_yz ) . AND . ALLOCATED ( THIS % k_zz ) . AND . & ALLOCATED ( THIS % baryon_density ) . AND . & ALLOCATED ( THIS % energy_density ) . AND . & ALLOCATED ( THIS % specific_energy ) . AND . & ALLOCATED ( THIS % v_euler_x ) . AND . & ALLOCATED ( THIS % v_euler_y ) . AND . & ALLOCATED ( THIS % v_euler_z ) & ) THEN !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( n, THIS, x, y, z ) & !$OMP             PRIVATE( itr ) import_id_loop : DO itr = 1 , n , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_lorene_id ( THIS % bns_ptr , & x ( itr ) * Msun_geo , & y ( itr ) * Msun_geo , & z ( itr ) * Msun_geo , & THIS % lapse ( itr ), & THIS % shift_x ( itr ), & THIS % shift_y ( itr ), & THIS % shift_z ( itr ), & THIS % g_xx ( itr ), & THIS % k_xx ( itr ), & THIS % k_xy ( itr ), & THIS % k_xz ( itr ), & THIS % k_yy ( itr ), & THIS % k_yz ( itr ), & THIS % k_zz ( itr ), & THIS % baryon_density ( itr ), & THIS % energy_density ( itr ), & THIS % specific_energy ( itr ), & THIS % v_euler_x ( itr ), & THIS % v_euler_y ( itr ), & THIS % v_euler_z ( itr ) ) ENDDO import_id_loop !$OMP END PARALLEL DO DO itr = 1 , n , 1 ! !-- The following follows from the assumption of conformal !-- flatness in |lorene| ! THIS % g_yy ( itr ) = THIS % g_xx ( itr ) THIS % g_zz ( itr ) = THIS % g_xx ( itr ) THIS % g_xy ( itr ) = 0.0D0 THIS % g_xz ( itr ) = 0.0D0 THIS % g_yz ( itr ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN THIS % lapse ( itr ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN THIS % shift_x ( itr ) = 0.0D0 THIS % shift_y ( itr ) = 0.0D0 THIS % shift_z ( itr ) = 0.0D0 ENDIF ! !-- Convert the extrinsic curvature from |lorene| units to !-- |sphincs| units ! THIS % k_xx ( itr ) = THIS % k_xx ( itr ) * Msun_geo THIS % k_xy ( itr ) = THIS % k_xy ( itr ) * Msun_geo THIS % k_xz ( itr ) = THIS % k_xz ( itr ) * Msun_geo THIS % k_yy ( itr ) = THIS % k_yy ( itr ) * Msun_geo THIS % k_yz ( itr ) = THIS % k_yz ( itr ) * Msun_geo THIS % k_zz ( itr ) = THIS % k_zz ( itr ) * Msun_geo ! Print progress on screen perc = 100 * itr / n IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn ELSE PRINT * , \"** ERROR: Memory was not allocated before calling \" & // \"import_id in import_lorene_id (TYPE particles).\" PRINT * STOP ENDIF PRINT * , \"** Subroutine import_lorene_id executed.\" PRINT * ENDIF END PROCEDURE import_id_int MODULE PROCEDURE import_id_full !************************************************** ! !# Stores the ID in non-[[bnslorene]]-member arrays !  with the same shape as the [[bnslorene]] member arrays ! !  FT 5.10.2020 ! !************************************************** USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN IF ( SIZE ( x ) /= SIZE ( y ) . OR . SIZE ( x ) /= SIZE ( z ) & . OR . SIZE ( y ) /= SIZE ( z ) ) THEN PRINT * , \"** ERROR: The sizes of the arrays of positions\" & // \"passed to import_lorene_id are not the same.\" PRINT * STOP ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( n, THIS, x, y, z, lapse, & !$OMP                     shift_x, shift_y, shift_z, & !$OMP                     g_xx, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, & !$OMP                     baryon_density, energy_density, & !$OMP                     specific_energy, & !$OMP                     u_euler_x, u_euler_y, u_euler_z ) & !$OMP             PRIVATE( itr ) import_id_loop : DO itr = 1 , n , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_lorene_id ( THIS % bns_ptr , & x ( itr ) * Msun_geo , & y ( itr ) * Msun_geo , & z ( itr ) * Msun_geo , & lapse ( itr ), & shift_x ( itr ), & shift_y ( itr ), & shift_z ( itr ), & g_xx ( itr ), & k_xx ( itr ), & k_xy ( itr ), & k_xz ( itr ), & k_yy ( itr ), & k_yz ( itr ), & k_zz ( itr ), & baryon_density ( itr ), & energy_density ( itr ), & specific_energy ( itr ), & u_euler_x ( itr ), & u_euler_y ( itr ), & u_euler_z ( itr ) ) ENDDO import_id_loop !$OMP END PARALLEL DO DO itr = 1 , n , 1 ! !-- The following follows from the assumption of conformal !-- flatness in |lorene| ! g_yy ( itr ) = g_xx ( itr ) g_zz ( itr ) = g_xx ( itr ) g_xy ( itr ) = 0.0D0 g_xz ( itr ) = 0.0D0 g_yz ( itr ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN lapse ( itr ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN shift_x ( itr ) = 0.0D0 shift_y ( itr ) = 0.0D0 shift_z ( itr ) = 0.0D0 ENDIF ! !-- Convert the extrinsic curvature from |lorene| units to !-- |sphincs| units ! k_xx ( itr ) = k_xx ( itr ) * Msun_geo k_xy ( itr ) = k_xy ( itr ) * Msun_geo k_xz ( itr ) = k_xz ( itr ) * Msun_geo k_yy ( itr ) = k_yy ( itr ) * Msun_geo k_yz ( itr ) = k_yz ( itr ) * Msun_geo k_zz ( itr ) = k_zz ( itr ) * Msun_geo ! Print progress on screen perc = 100 * itr / n IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \"** Subroutine import_lorene_id executed.\" PRINT * ENDIF END PROCEDURE import_id_full MODULE PROCEDURE import_id_spacetime !******************************************************* ! !# Stores the spacetime ID in multi-dimensional arrays !  needed to compute the BSSN variables and constraints ! !  FT 22.11.2020 ! !******************************************************* USE constants , ONLY : Msun_geo USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , n_sym4x4 IMPLICIT NONE INTEGER :: i , j , k DOUBLE PRECISION :: detg DOUBLE PRECISION :: detg4 DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: g4 ! g4 is allocatable to allocate it on the heap ! Allocating it on the stack might exceed stack memory, ! causing a segmentation fault ALLOCATE ( g4 ( nx , ny , nz , n_sym4x4 ) ) IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN IF ( . FALSE . & !SHAPE( pos(:,:,:,1) ) /= SHAPE( lapse ) .OR. & !SHAPE( pos(:,:,:,1) ) /= SHAPE( shift(:,:,:,jx) ) & ! .OR. & ! SHAPE( pos(:,:,:,1) ) /= SHAPE( g(:,:,:,1) ) .OR. & ! SHAPE( pos(:,:,:,1) ) /= SHAPE( k(:,:,:,1) ) & ) THEN PRINT * , \"** ERROR: Mismatch in array dimensions\" & // \"in import_id_spacetime.\" PRINT * STOP ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nx, ny, nz, THIS, pos, & !$OMP                     lapse, shift, g, ek ) & !$OMP             PRIVATE( i, j, k ) coords_z : DO k = 1 , nz , 1 coords_y : DO j = 1 , ny , 1 coords_x : DO i = 1 , nx , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_lorene_id_spacetime ( THIS % bns_ptr , & pos ( i , j , k , jx ) * Msun_geo , & pos ( i , j , k , jy ) * Msun_geo , & pos ( i , j , k , jz ) * Msun_geo , & lapse ( i , j , k ), & shift ( i , j , k , jx ), & shift ( i , j , k , jy ), & shift ( i , j , k , jz ), & g ( i , j , k , jxx ), & ek ( i , j , k , jxx ), & ek ( i , j , k , jxy ), & ek ( i , j , k , jxz ), & ek ( i , j , k , jyy ), & ek ( i , j , k , jyz ), & ek ( i , j , k , jzz ) ) ENDDO coords_x ENDDO coords_y ENDDO coords_z !$OMP END PARALLEL DO DO k = 1 , nz , 1 DO j = 1 , ny , 1 DO i = 1 , nx , 1 ! !-- The following follows from the assumption of !-- conformal flatness in |lorene| ! g ( i , j , k , jyy ) = g ( i , j , k , jxx ) g ( i , j , k , jzz ) = g ( i , j , k , jxx ) g ( i , j , k , jxy ) = 0.0D0 g ( i , j , k , jxz ) = 0.0D0 g ( i , j , k , jyz ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN lapse ( i , j , k ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN shift ( i , j , k , jx ) = 0.0D0 shift ( i , j , k , jy ) = 0.0D0 shift ( i , j , k , jz ) = 0.0D0 ENDIF ! !-- Convert the extrinsic curvature from |lorene| units to !-- |sphincs| units ! ek ( i , j , k , jxx ) = ek ( i , j , k , jxx ) * Msun_geo ek ( i , j , k , jxy ) = ek ( i , j , k , jxy ) * Msun_geo ek ( i , j , k , jxz ) = ek ( i , j , k , jxz ) * Msun_geo ek ( i , j , k , jyy ) = ek ( i , j , k , jyy ) * Msun_geo ek ( i , j , k , jyz ) = ek ( i , j , k , jyz ) * Msun_geo ek ( i , j , k , jzz ) = ek ( i , j , k , jzz ) * Msun_geo detg = 2.0D0 * g ( i , j , k , jxy ) * g ( i , j , k , jxz ) * g ( i , j , k , jyz ) & - g ( i , j , k , jzz ) * g ( i , j , k , jxy ) ** 2 + g ( i , j , k , jyy ) & * ( g ( i , j , k , jxx ) * g ( i , j , k , jzz ) - g ( i , j , k , jxz ) ** 2 ) & - g ( i , j , k , jxx ) * g ( i , j , k , jyz ) ** 2 IF ( ABS ( detg ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spatial metric \" & // \"is effectively 0 at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg=\" , detg PRINT * STOP ELSEIF ( detg < 0 ) THEN PRINT * , \"The determinant of the spatial metric \" & // \"is negative at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg=\" , detg PRINT * STOP ENDIF CALL compute_g4 ( i , j , k , lapse , shift , g , g4 ) CALL determinant_sym4x4_grid ( i , j , k , g4 , detg4 ) IF ( ABS ( detg4 ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spacetime metric \" & // \"is effectively 0 at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg4=\" , detg4 PRINT * STOP ELSEIF ( detg4 > 0 ) THEN PRINT * , \"The determinant of the spacetime metric \" & // \"is positive at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg4=\" , detg4 PRINT * STOP ENDIF ! Print progress on screen perc = 100 * ( nx * ny * ( k - 1 ) + nx * ( j - 1 ) + i ) / ( nx * ny * nz ) !perc2= 100.0*DBLE(nx*ny*(iz - 1) + nx*(iy - 1) + ix) & !       /DBLE( nx*ny*nz ) !perc= 100*cnt/( nx*ny*nz ) IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" !WRITE( *, \"(A2,F5.2,A1)\", ADVANCE= \"NO\" ) & !        creturn//\" \", perc2, \"%\" ENDIF ENDDO ENDDO ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \"** Subroutine import_lorene_id executed.\" PRINT * ENDIF END PROCEDURE import_id_spacetime MODULE PROCEDURE import_id_hydro !******************************************************* ! !# Stores the hydro ID in the arrays needed to compute !  the constraints on the refined mesh ! !  FT 25.11.2020 ! !******************************************************* USE constants , ONLY : Msun_geo USE tensor , ONLY : jx , jy , jz IMPLICIT NONE INTEGER :: ix , iy , iz IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nx, ny, nz, THIS, pos, & !$OMP                     baryon_density, energy_density, & !$OMP                     specific_energy, pressure, u_euler ) & !$OMP             PRIVATE( ix, iy, iz ) coords_z : DO iz = 1 , nz , 1 coords_y : DO iy = 1 , ny , 1 coords_x : DO ix = 1 , nx , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_lorene_id_hydro ( THIS % bns_ptr , & pos ( ix , iy , iz , jx ) * Msun_geo , & pos ( ix , iy , iz , jy ) * Msun_geo , & pos ( ix , iy , iz , jz ) * Msun_geo , & baryon_density ( ix , iy , iz ), & energy_density ( ix , iy , iz ), & specific_energy ( ix , iy , iz ), & pressure ( ix , iy , iz ), & u_euler ( ix , iy , iz , jx ), & u_euler ( ix , iy , iz , jy ), & u_euler ( ix , iy , iz , jz ) ) ENDDO coords_x ENDDO coords_y ENDDO coords_z !$OMP END PARALLEL DO !      ! Print progress on screen !      perc= 100*(nx*ny*(iz - 1) & !            + nx*(iy - 1) + ix)/( nx*ny*nz ) !      IF( show_progress .AND. MOD( perc, 10 ) == 0 )THEN !        WRITE( *, \"(A2,I2,A1)\", ADVANCE= \"NO\" ) & !                creturn//\" \", perc, \"%\" !      ENDIF ! !    ENDDO coords_x !  ENDDO coords_y !ENDDO coords_z !IF( show_progress ) WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn PRINT * , \"** Subroutine import_lorene_id_hydro executed.\" PRINT * ENDIF END PROCEDURE import_id_hydro MODULE PROCEDURE import_id_particles !**************************************************** ! !# Stores the hydro ID in the arrays needed to !  compute the SPH ID ! !  FT 19.11.2020 ! !**************************************************** USE constants , ONLY : Msun_geo IMPLICIT NONE DOUBLE PRECISION :: detg IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN IF ( SIZE ( x ) /= SIZE ( y ) . OR . SIZE ( x ) /= SIZE ( z ) & . OR . SIZE ( y ) /= SIZE ( z ) ) THEN PRINT * , \"** ERROR: The sizes of the arrays of positions\" & // \"passed to import_lorene_id are not the same.\" PRINT * STOP ENDIF PRINT * , \"** Importing ID on particles...\" !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( n, THIS, x, y, z, lapse, & !$OMP                     shift_x, shift_y, shift_z, & !$OMP                     g_xx, & !$OMP                     baryon_density, energy_density, & !$OMP                     specific_energy, pressure, & !$OMP                     u_euler_x, u_euler_y, u_euler_z ) & !$OMP             PRIVATE( itr ) import_id_loop : DO itr = 1 , n , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_lorene_id_particles ( THIS % bns_ptr , & x ( itr ) * Msun_geo , & y ( itr ) * Msun_geo , & z ( itr ) * Msun_geo , & lapse ( itr ), & shift_x ( itr ), & shift_y ( itr ), & shift_z ( itr ), & g_xx ( itr ), & baryon_density ( itr ), & energy_density ( itr ), & specific_energy ( itr ), & pressure ( itr ), & u_euler_x ( itr ), & u_euler_y ( itr ), & u_euler_z ( itr ) ) ENDDO import_id_loop !$OMP END PARALLEL DO DO itr = 1 , n , 1 ! !-- The following follows from the assumption of conformal !-- flatness in |lorene| ! g_yy ( itr ) = g_xx ( itr ) g_zz ( itr ) = g_xx ( itr ) g_xy ( itr ) = 0.0D0 g_xz ( itr ) = 0.0D0 g_yz ( itr ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN lapse ( itr ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN shift_x ( itr ) = 0.0D0 shift_y ( itr ) = 0.0D0 shift_z ( itr ) = 0.0D0 ENDIF detg = 2 * g_xy ( itr ) * g_xz ( itr ) * g_yz ( itr ) & - g_zz ( itr ) * g_xy ( itr ) ** 2 & + g_yy ( itr ) * ( g_xx ( itr ) * g_zz ( itr ) - g_xz ( itr ) ** 2 ) & - g_xx ( itr ) * g_yz ( itr ) ** 2 IF ( ABS ( detg ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spatial metric is \" & // \"effectively 0 at the particle \" , itr PRINT * , \"detg=\" , detg PRINT * STOP ELSEIF ( detg < 0 ) THEN PRINT * , \"The determinant of the spatial metric is \" & // \"negative at the particle \" , itr PRINT * , \"detg=\" , detg PRINT * STOP ENDIF ! Print progress on screen perc = 100 * itr / n IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \"** Subroutine import_id_particles executed.\" PRINT * ENDIF END PROCEDURE import_id_particles MODULE PROCEDURE import_id_mass_b !**************************************************** ! !# Stores the hydro ID in the arrays needed to !  compute the baryon mass, storing it to variables !  (not arrays as the others SUBROUTINES in !  the [[bns_import]] SUBMODULE). ! !  FT 15.04.2021 ! !**************************************************** USE constants , ONLY : Msun_geo , lorene2hydrobase IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_lorene_id_mass_b ( THIS % bns_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo , & g_xx , & baryon_density , & gamma_euler ) baryon_density = baryon_density * lorene2hydrobase ENDIF END PROCEDURE import_id_mass_b MODULE PROCEDURE import_id_k !**************************************************** ! !# Stores the components of the extrinsic curvature !  in arrays ! !  FT 25.11.2020 ! !**************************************************** USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN IF ( SIZE ( x ) /= SIZE ( y ) . OR . SIZE ( x ) /= SIZE ( z ) & . OR . SIZE ( y ) /= SIZE ( z ) ) THEN PRINT * , \"** ERROR: The sizes of the arrays of positions\" & // \"passed to import_lorene_id are not the same.\" PRINT * STOP ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( n, THIS, x, y, z, & !$OMP                     k_xx, k_xy, k_xz, k_yy, k_yz, k_zz ) & !$OMP             PRIVATE( itr ) import_id_loop : DO itr = 1 , n , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_lorene_id_k ( THIS % bns_ptr , & x ( itr ) * Msun_geo , & y ( itr ) * Msun_geo , & z ( itr ) * Msun_geo , & k_xx ( itr ), & k_xy ( itr ), & k_xz ( itr ), & k_yy ( itr ), & k_yz ( itr ), & k_zz ( itr ) ) ENDDO import_id_loop !$OMP END PARALLEL DO DO itr = 1 , n , 1 ! !-- Convert the extrinsic curvature from |lorene| units to !-- |sphincs| units ! k_xx ( itr ) = k_xx ( itr ) * Msun_geo k_xy ( itr ) = k_xy ( itr ) * Msun_geo k_xz ( itr ) = k_xz ( itr ) * Msun_geo k_yy ( itr ) = k_yy ( itr ) * Msun_geo k_yz ( itr ) = k_yz ( itr ) * Msun_geo k_zz ( itr ) = k_zz ( itr ) * Msun_geo ! Print progress on screen perc = 100 * itr / n IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \"** Subroutine import_lorene_id_k executed.\" PRINT * ENDIF END PROCEDURE import_id_k !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE import_mass_density !*********************************************** ! !# Returns the |lorene| mass density at the point !  given as argument, in units of !  M_\\odot/L_\\odot&#94;3. ! !  FT ! !*********************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED USE constants , ONLY : Msun_geo , lorene2hydrobase IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo res = get_lorene_mass_density ( THIS % bns_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo ) * lorene2hydrobase ENDIF END PROCEDURE import_mass_density MODULE PROCEDURE import_spatial_metric !*********************************************** ! !# Returns the |lorene| conformal factor to the !  4th power, equal to the diagonal components !  of the conformally flat spatial ADM metric. ! !  FT 15.04.2021 ! !*********************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo res = get_lorene_spatial_metric ( THIS % bns_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo ) ENDIF END PROCEDURE import_spatial_metric MODULE PROCEDURE is_hydro_negative !************************************************ ! !# Return 1 if the energy density is nonpositive !  or if the specific energy is nonpositive, !  or if the pressure is nonpositive !  at the specified point ! !  FT 12.03.2021 ! !************************************************ USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo res = negative_hydro ( THIS % bns_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo ) ENDIF END PROCEDURE is_hydro_negative END SUBMODULE bns_lorene_import","tags":"","loc":"sourcefile/submodule_bns_lorene_import.f90.html"},{"title":"module_bns_lorene.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_bns_lorene.f90~~EfferentGraph sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_bns_lorene.f90~~AfferentGraph sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~submodule_bns_lorene_constructor.f90 submodule_bns_lorene_constructor.f90 sourcefile~submodule_bns_lorene_constructor.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_access.f90 submodule_bns_lorene_access.f90 sourcefile~submodule_bns_lorene_access.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_params.f90 submodule_bns_lorene_params.f90 sourcefile~submodule_bns_lorene_params.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_import.f90 submodule_bns_lorene_import.f90 sourcefile~submodule_bns_lorene_import.f90->sourcefile~module_bns_lorene.f90 sourcefile~submodule_bns_lorene_memory.f90 submodule_bns_lorene_memory.f90 sourcefile~submodule_bns_lorene_memory.f90->sourcefile~module_bns_lorene.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules bns_lorene Source Code module_bns_lorene.f90 Source Code ! File:         module_bns_lorene.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE bns_lorene !*********************************************************** ! !#  This module contains the definition of TYPE bnslorene, !   and the SUBROUTINES that bind to the methods !   of |lorene|'s class |binns|, defined in !   Lorene/Export/BinNS ! !   [|lorene| official repository](https://lorene.obspm.fr/index.html){:target=\"_blank\"} ! !*********************************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_INT , C_DOUBLE , C_CHAR , C_NULL_CHAR , & C_PTR , C_NULL_PTR , C_ASSOCIATED USE bns_base , ONLY : bnsbase USE id_base , ONLY : idbase USE utility , ONLY : itr , ios , err_msg , test_status , & perc , creturn , compute_g4 , & determinant_sym4x4_grid , show_progress USE timing , ONLY : timer IMPLICIT NONE !******************************************************* !                                                      * !            Definition of TYPE bnslorene              * !                                                      * !   This class imports and stores the |lorene| BNS ID  * !                                                      * !******************************************************* TYPE , EXTENDS ( bnsbase ) :: bnslorene !! TYPE representing a binary system of neutron stars (bns) PRIVATE !> Identifier of the bnslorene object INTEGER :: bns_identifier = 0 !> |lorene| identifiers for the EoS INTEGER :: eos1_loreneid , eos2_loreneid ! !-- Spacetime fields ! !> 1-D array storing the lapse function DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: lapse !> 1-D array storing the x component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_x !> 1-D array storing the y component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_y !> 1-D array storing the z component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_z !> 1-D array storing the xx component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xx !> 1-D array storing the xy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xy !> 1-D array storing the xz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xz !> 1-D array storing the yy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yy !> 1-D array storing the yz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yz !> 1-D array storing the zz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_zz !& 1-D array storing the xx component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xx !& 1-D array storing the xy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xy !& 1-D array storing the xz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xz !& 1-D array storing the yy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yy !& 1-D array storing the yz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yz !& 1-D array storing the zz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_zz ! !-- Hydro fields ! !> 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: baryon_density !> 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: energy_density !> 1-D array storing the specific internal energy [c&#94;2] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: specific_energy !> 1-D array storing the x component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_x !> 1-D array storing the y component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_y !> 1-D array storing the z component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_z !& C pointer to the |lorene|'s |binns| object ! N.B. This variable is global. The pointer to the second |lorene| |binns| !      object will overwrite the first one, and so on. !      This variable stores the pointer to the last defined |lorene| |binns| !      object. That's why it is not freed in the destructor of a bns object. !      Presently, it has to be freed by the user at the end of the PROGRAM. !      See the last part of the PROGRAM in setup_lorene_id.f90, for example. TYPE ( C_PTR ) :: bns_ptr CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: construct_binary !! Constructs the |lorene| |binns| object PROCEDURE :: destruct_binary !! Destructs the |lorene| |binns| object PROCEDURE :: allocate_lorene_id_memory !! Allocates memory for the [[bnslorene]] member arrays PROCEDURE :: deallocate_lorene_id_memory !! Deallocates memory for the [[bnslorene]] member arrays PROCEDURE :: import_id_params !! Imports the parameters of the BNS from |lorene| !PROCEDURE:: integrate_field_on_star => integrate_baryon_mass_density !# Integrates the |lorene| baryon mass density and computes the !  radial mass profile PROCEDURE , PUBLIC :: print_id_params !! Prints the parameters of the BNS to the standard output PROCEDURE :: import_id_int !! Stores the ID in the [[bnslorene]] member arrays PROCEDURE :: read_id_full => import_id_full PROCEDURE :: read_id_spacetime => import_id_spacetime PROCEDURE :: read_id_particles => import_id_particles PROCEDURE :: read_id_hydro => import_id_hydro PROCEDURE :: read_id_mass_b => import_id_mass_b PROCEDURE :: read_id_k => import_id_k !-----------------! !--  FUNCTIONS  --! !-----------------! !> Returns the |lorene|'s mass density at the given point PROCEDURE :: read_mass_density => import_mass_density !> Returns the |lorene|'s conformally flat spatial ADM metric PROCEDURE :: import_spatial_metric !& Returns 1 if the energy density or the specific energy or the pressure !  are negative PROCEDURE :: test_position => is_hydro_negative !PROCEDURE, NOPASS:: derived_type_constructor => construct_bnslorene2 ! !-- Overloaded FUNCTION to access the fields as arrays and as values ! GENERIC , PUBLIC :: get_field => get_fa , get_fv !# GENERIC PROCEDURE, overloded to access the [[bnslorene]]-member variables !  as arrays and as values PROCEDURE :: get_fa => get_field_array !! Access the [[bnslorene]]-member arrays PROCEDURE :: get_fv => get_field_value !! Access the components of the [[bnslorene]]-member arrays ! !-- FUNCTIONS that access member variables ! PROCEDURE :: get_eos1_id => get_eos1_loreneid !! Returns the |lorene| identifier for the EOS of star 1 PROCEDURE :: get_eos2_id => get_eos2_loreneid !! Returns the |lorene| identifier for the EOS of star 2 PROCEDURE :: return_eos_parameters => get_eos_parameters PROCEDURE , PUBLIC :: get_eos1_loreneid !! Returns [[bnslorene:eos1_loreneid]] PROCEDURE , PUBLIC :: get_eos2_loreneid !! Returns [[bnslorene:eos2_loreneid]] PROCEDURE , PUBLIC :: get_bns_identifier !! Returns [[bnslorene:bns_identifier]] !PROCEDURE, PUBLIC:: get_bns_ptr FINAL :: destruct_bnslorene !! Finalizer (Destructor) of a [[bnslorene]] object END TYPE bnslorene ! !-- Interface of the TYPE bnslorene (i.e., declaration of the constructor) !-- (see https://dannyvanpoucke.be/oop-fortran-tut4-en/) ! INTERFACE bnslorene !! Interface of TYPE [[bnslorene]] MODULE PROCEDURE :: construct_bnslorene !! Constructs a [[bnslorene]] object END INTERFACE bnslorene ! !-- Interfaces of the constructor and destructor of the TYPE bnslorene ! INTERFACE ! MODULE SUBROUTINE construct_bnslorene2( this ) ! !! Constructs a [[bnslorene]] object ! !   TYPE(bnslorene), INTENT( IN OUT ):: this !   !! Constructed [[bnslorene]] object ! ! END SUBROUTINE construct_bnslorene2 MODULE FUNCTION construct_bnslorene ( resu_file ) RESULT ( bns_obj ) !! Constructs a [[bnslorene]] object CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: resu_file !! |lorene| binary file containing the spectral BNS ID TYPE ( bnslorene ) :: bns_obj !! Constructed [[bnslorene]] object END FUNCTION construct_bnslorene MODULE SUBROUTINE destruct_bnslorene ( THIS ) !! Destruct a [[bnslorene]] object TYPE ( bnslorene ), INTENT ( IN OUT ) :: THIS !! [[bnslorene]] object to be destructed END SUBROUTINE destruct_bnslorene END INTERFACE ! !-- Interfaces of the methods of the TYPE bnslorene !-- Their implementations are in submodule_bnslorene_methods.f90 ! INTERFACE ! !-- SUBROUTINES ! MODULE SUBROUTINE construct_binary ( THIS , resu_file ) !! Interface of the subroutine that constructs the |lorene| |binns| object !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS !> |lorene| binary file containing the spectral BNS ID CHARACTER ( KIND = C_CHAR , LEN =* ), INTENT ( IN ), OPTIONAL :: resu_file END SUBROUTINE construct_binary MODULE SUBROUTINE destruct_binary ( THIS ) !! Destructs a |lorene| |binns| object !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE destruct_binary MODULE SUBROUTINE allocate_lorene_id_memory ( THIS , d ) !! Allocates allocatable arrays member of a [[bnslorene]] object !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS !> Dimension of the arrays INTEGER , INTENT ( IN ) :: d END SUBROUTINE allocate_lorene_id_memory MODULE SUBROUTINE deallocate_lorene_id_memory ( THIS ) !! Deallocates allocatable arrays member of a [[bnslorene]] object !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE deallocate_lorene_id_memory MODULE SUBROUTINE import_id_params ( THIS ) !! Imports the BNS parameters from |lorene| !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE import_id_params MODULE SUBROUTINE print_id_params ( THIS ) !! Prints the BNS parameters to the standard output !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE print_id_params !  MODULE SUBROUTINE integrate_baryon_mass_density( THIS, center, radius, & !                                                   central_density, & !                                                   dr, dth, dphi, & !                                                   mass, mass_profile, & !                                                   mass_profile_idx ) !  !# Integrates the |lorene| baryon mass density to compute the radial mass !  !  profile. TODO: Improve integration algorithm. ! !    !> [[bnslorene]] object which this PROCEDURE is a member of !    CLASS(bnslorene), INTENT( IN OUT )      :: THIS !    !& Array to store the indices for array mass_profile, sorted so that !    !  mass_profile[mass_profile_idx] is in increasing order !    INTEGER, DIMENSION(:), ALLOCATABLE, INTENT( IN OUT ):: mass_profile_idx !    !> Center of the star !    DOUBLE PRECISION, INTENT( IN )    :: center !    !> Central density of the star !    DOUBLE PRECISION, INTENT( IN )    :: central_density !    !> Radius of the star !    DOUBLE PRECISION, INTENT( IN )    :: radius !    !> Integration steps !    DOUBLE PRECISION, INTENT( IN )    :: dr, dth, dphi !    !> Integrated mass of the star !    DOUBLE PRECISION, INTENT( IN OUT ):: mass !    !> Array storing the radial mass profile of the star !    DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE, INTENT( IN OUT ):: & !                                     mass_profile ! !  END SUBROUTINE integrate_baryon_mass_density MODULE SUBROUTINE import_id_int ( THIS , n , x , y , z ) !! Stores the ID in the [[bnslorene]] member arrays !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z END SUBROUTINE import_id_int ! BE CAREFUL! Look at the following page: ! ! https://www.ibm.com/support/knowledgecenter/SSAT4T_15.1.5/com.ibm.xlf1515.lelinux.doc/language_ref/allocobj.html ! where you can find the following statement, ! ! \"On procedure entry, the allocation status of an allocatable dummy !  argument becomes that of the associated actual argument. If the !  dummy argument is INTENT(OUT) and the associated actual argument is !  allocated, the actual argument is deallocated on procedure invocation !  so that the dummy argument has an allocation status of not allocated. !  If the dummy argument is not INTENT(OUT) and the actual argument is !  allocated, the value of the dummy argument is that of the associated !  actual argument.\" ! Hence, the intent of allocatable array arguments  has to be IN OUT, ! not OUT. The array arguments are not allocatable anymore MODULE SUBROUTINE import_id_full ( THIS , n , x , y , z ,& lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz , & baryon_density , & energy_density , & specific_energy , & u_euler_x , u_euler_y , u_euler_z ) !# Stores the ID in non [[bnslorene]]-member arrays with the same shape as the !  [[bnslorene]] member arrays !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_z END SUBROUTINE import_id_full MODULE SUBROUTINE import_id_spacetime ( THIS , nx , ny , nz , & pos , & lapse , & shift , & g , & ek ) !# Stores the spacetime ID in multi-dimensional arrays needed to compute !  the BSSN variables and constraints !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: nx INTEGER , INTENT ( IN ) :: ny INTEGER , INTENT ( IN ) :: nz DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: shift DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: g DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: ek END SUBROUTINE import_id_spacetime MODULE SUBROUTINE import_id_hydro ( THIS , nx , ny , nz , & pos , & baryon_density , & energy_density , & specific_energy , & pressure , & u_euler ) !# Stores the hydro ID in the arrays needed to compute the constraints !  on the refined mesh !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: nx INTEGER , INTENT ( IN ) :: ny INTEGER , INTENT ( IN ) :: nz DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: pressure DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: u_euler END SUBROUTINE import_id_hydro MODULE SUBROUTINE import_id_particles ( THIS , n , x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & baryon_density , & energy_density , & specific_energy , & pressure , & u_euler_x , u_euler_y , u_euler_z ) !! Stores the hydro ID in the arrays needed to compute the SPH ID !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n REAL ( C_DOUBLE ), DIMENSION (:), INTENT ( IN ) :: x REAL ( C_DOUBLE ), DIMENSION (:), INTENT ( IN ) :: y REAL ( C_DOUBLE ), DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: pressure DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_z END SUBROUTINE import_id_particles MODULE SUBROUTINE import_id_mass_b ( THIS , x , y , z , & g_xx , & baryon_density , & gamma_euler ) !! Stores the hydro ID in the arrays needed to compute the baryon mass !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z DOUBLE PRECISION , INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , INTENT ( IN OUT ) :: gamma_euler END SUBROUTINE import_id_mass_b MODULE SUBROUTINE import_id_k ( THIS , n , x , y , z ,& k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz ) !! Stores the components of the extrinsic curvature in arrays !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_zz END SUBROUTINE import_id_k ! !-- FUNCTIONS ! MODULE FUNCTION import_mass_density ( THIS , x , y , z ) RESULT ( res ) !! Returns the |lorene| baryon mass density at a point (x,y,z) !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS !> x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: x !> y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: y !> z coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: z !> Baryon mass density at (x,y,z) DOUBLE PRECISION :: res END FUNCTION import_mass_density MODULE FUNCTION import_spatial_metric ( THIS , x , y , z ) RESULT ( res ) !# Returns the |lorene| conformally flat spatial metric component !  g_{xx}=g_{yy}=g_{zz} at a point (x,y,z) !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !> g_{xx}=g_{yy}=g_{zz} at (x,y,z) REAL ( C_DOUBLE ) :: res END FUNCTION import_spatial_metric MODULE FUNCTION is_hydro_negative ( THIS , x , y , z ) RESULT ( res ) !# Returns 1 if the energy density or the specific energy or the pressure !  are negative, 0 otherwise !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS !> x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: x !> y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: y !> z coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: z !& 1 if the energy density or the specific energy or the pressure !  are negative, 0 otherwise INTEGER :: res END FUNCTION is_hydro_negative MODULE FUNCTION get_field_array ( THIS , field ) RESULT ( field_array ) !! Returns the [[bnslorene]] member arrays named field !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS !> Name of the desired [[bnslorene]] member array CHARACTER ( LEN = : ), INTENT ( IN ), ALLOCATABLE :: field !> Desired [[bnslorene]] member array DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: field_array END FUNCTION get_field_array MODULE FUNCTION get_field_value ( THIS , field , n ) RESULT ( field_value ) !! Returns the component n of the [[bnslorene]] member arrays named field !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS !> Name of the desired [[bnslorene]] member array CHARACTER ( LEN = : ), INTENT ( IN ), ALLOCATABLE :: field !> Component of the desired [[bnslorene]] member array INTEGER , INTENT ( IN ) :: n !> Component n of the desired [[bnslorene]] member array DOUBLE PRECISION :: field_value END FUNCTION get_field_value MODULE FUNCTION get_bns_identifier ( THIS ) !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_bns_identifier END FUNCTION get_bns_identifier MODULE FUNCTION get_eos1_loreneid ( THIS ) !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_eos1_loreneid END FUNCTION get_eos1_loreneid MODULE FUNCTION get_eos2_loreneid ( THIS ) !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_eos2_loreneid END FUNCTION get_eos2_loreneid MODULE SUBROUTINE get_eos_parameters ( THIS , i_matter , eos_params ) !> [[bnslorene]] object which this PROCEDURE is a member of CLASS ( bnslorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: eos_params !# Array containing the parameters of the |eos| for the `i_matter`-th !  matter object END SUBROUTINE get_eos_parameters !MODULE FUNCTION get_bns_ptr( THIS ) ! !  ! Argument !  CLASS(bnslorene), INTENT( IN ):: THIS !  ! Result !  TYPE(C_PTR):: get_bns_ptr ! !END FUNCTION get_bns_ptr END INTERFACE !------------------------------------------------------------------! !--  PRIVATE interfaces to the methods of |lorene|'s class |binns|  --! !------------------------------------------------------------------! PRIVATE :: construct_bin_ns , get_lorene_id , get_lorene_id_spacetime , & get_lorene_id_particles , get_lorene_id_mass_b , & get_lorene_id_hydro , get_lorene_id_k , get_lorene_mass_density , & get_lorene_spatial_metric , negative_hydro , get_lorene_id_params , & destruct_bin_ns INTERFACE FUNCTION construct_bin_ns ( c_resu_file ) RESULT ( optr ) & BIND ( C , NAME = \"construct_bin_ns\" ) !*********************************************** ! !# Interface to the |lorene| method of class !  |binns| with the same name, that constructs !  the |lorene| |binns| object ! !  FT ! !*********************************************** IMPORT :: C_PTR , C_CHAR IMPLICIT NONE !& C string of the name of the |lorene| binary file storing the spectral !  BNS ID CHARACTER ( KIND = C_CHAR ), DIMENSION ( * ), INTENT ( IN ), OPTIONAL :: & c_resu_file !> C pointer pointing to the constructed |lorene| |binns| object TYPE ( C_PTR ) :: optr END FUNCTION construct_bin_ns SUBROUTINE get_lorene_id ( optr , & x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_diag , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz , & baryon_density , & energy_density , & specific_energy , & v_euler_x , v_euler_y , v_euler_z ) & BIND ( C , NAME = \"get_lorene_id\" ) !************************************************* ! !# Interface to the |lorene| method of class !  |binns| with the same name, that reads the full !  |lorene| ID at the specified point. !  That is, imports the metric fields, the !  components of the extrinsic curvature [c/km], !  and the hydro fields. ! !  - shift vector [c] !  - baryon mass density [kg m&#94;{-3}] !  - energy density [kg c&#94;2 m&#94;{-3}] !  - pressure [kg c&#94;2 m&#94;{-3}] !  - specific internal energy [c&#94;2] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT ! !************************************************* IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: lapse REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xx REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_zz REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_z END SUBROUTINE get_lorene_id SUBROUTINE get_lorene_id_spacetime ( optr , & x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_diag , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz ) & BIND ( C , NAME = \"get_lorene_id_spacetime\" ) !************************************************* ! !# Interface to the |lorene| method of class !  |binns| with the same name, that reads the !  metric fields and the components !  of the extrinsic curvature [c/km] from |lorene|, !  at the specified point ! !  FT ! !************************************************* IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: lapse REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xx REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_zz END SUBROUTINE get_lorene_id_spacetime SUBROUTINE get_lorene_id_particles ( optr , & x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_diag , & baryon_density , & energy_density , & specific_energy , & pressure , & v_euler_x , v_euler_y , v_euler_z ) & BIND ( C , NAME = \"get_lorene_id_particles\" ) !********************************************** ! !# Interface to the |lorene| method of class !  |binns| with the same name, that reads the !  hydro fields and the metric fields * !  from |lorene|, at the specified point ! !  - shift vector [c] !  - baryon mass density [kg m&#94;{-3}] !  - energy density [kg c&#94;2 m&#94;{-3}] !  - pressure [kg c&#94;2 m&#94;{-3}] !  - specific internal energy [c&#94;2] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT ! !********************************************** IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: lapse REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy REAL ( C_DOUBLE ), INTENT ( OUT ) :: pressure REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_z END SUBROUTINE get_lorene_id_particles SUBROUTINE get_lorene_id_mass_b ( optr , & x , y , z , & g_diag , & baryon_density , & gamma_euler ) & BIND ( C , NAME = \"get_lorene_id_mass_b\" ) !************************************************ ! !# Interface to the |lorene| method of class !  |binns| with the same name, that reads the !  hydro fields and the metric fields !  from |lorene|, at the specified point, !  needed to compute the baryon mass. ! !  - shift vector [c] !  - baryon mass density [kg m&#94;{-3}] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT ! !************************************************ IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !> g_{xx}=g_{yy}=g_{zz} at x,y,z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag !> Baryon mass density at x,y,z REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density !& Relative Lorentz factor between the 4-velocity of the fluid !  wrt the Eulerian observer and the 4-velocity of the Eulerian observer !  at x,y,z REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma_euler END SUBROUTINE get_lorene_id_mass_b SUBROUTINE get_lorene_id_hydro ( optr , & x , y , z , & baryon_density , & energy_density , & specific_energy , & pressure , & v_euler_x , v_euler_y , v_euler_z ) & BIND ( C , NAME = \"get_lorene_id_hydro\" ) !*********************************************** ! !# Interface to the |lorene| method of class !  |binns| with the same name, that reads the !  hydro fields from |lorene|, at the !  specified point ! !  - baryon mass density [kg m&#94;{-3}] !  - energy density [kg c&#94;2 m&#94;{-3}] !  - pressure [kg c&#94;2 m&#94;{-3}] !  - specific internal energy [c&#94;2] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT ! !*********************************************** IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy REAL ( C_DOUBLE ), INTENT ( OUT ) :: pressure REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_z END SUBROUTINE get_lorene_id_hydro SUBROUTINE get_lorene_id_k ( optr , & x , y , z , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz ) & BIND ( C , NAME = \"get_lorene_id_k\" ) !*********************************************** ! !# Interface to the |lorene| method of class !  |binns| with the same name, that reads the !  components of the extrinsic !  curvature [c/km] from |lorene|, at the !  specified point ! !  FT ! !*********************************************** IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xx REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_zz END SUBROUTINE get_lorene_id_k FUNCTION get_lorene_mass_density ( optr , x , y , z ) RESULT ( res ) & BIND ( C , NAME = \"get_mass_density\" ) !******************************************** ! !# Interface to the |lorene| method of class !  |binns| with the same name, that returns !  the baryon mass density [\\mathrm{kg}\\, !  \\mathrm{m}&#94;{-3}] from |lorene|, !  at the specified point ! !  FT ! !******************************************** IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !& Baryon mass density [\\mathrm{kg}\\, \\mathrm{m}&#94;{-3}] at the desired !  point (x,y,z) REAL ( C_DOUBLE ) :: res END FUNCTION get_lorene_mass_density FUNCTION get_lorene_spatial_metric ( optr , x , y , z ) RESULT ( res ) & BIND ( C , NAME = \"get_lorene_id_g\" ) !************************************************ ! !# Interface to the |lorene| method of class !  |binns| with the same name, that returns the !  diagonal components of the metric, !  all equal to the |lorene| conformal factor to !  the 4th power. ! !  FT ! !************************************************ IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !& Spatial metric component !  g_{xx}=g_{yy}=g_{zz} at the point (x,y,z) REAL ( C_DOUBLE ) :: res END FUNCTION get_lorene_spatial_metric FUNCTION negative_hydro ( optr , x , y , z ) RESULT ( res ) & BIND ( C , NAME = \"negative_hydro\" ) !************************************************ ! !# Interface to the |lorene| method of class !  |binns| with the same name, that returns 1 !  if the energy density is nonpositive, !  or if the specific energy is nonpositive, !  or if the pressure is nonpositive, !  at the specified point; it returns 0 otherwise ! !  FT 12.03.2021 ! !************************************************ IMPORT :: C_INT , C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !& 1 if the energy density or the specific energy or the pressure !  are negative, 0 otherwise INTEGER ( C_INT ) :: res END FUNCTION negative_hydro SUBROUTINE get_lorene_id_params ( optr , & angular_vel , & distance , & distance_com , & mass1 , & mass2 , & mass_grav1 , & mass_grav2 , & adm_mass , & angular_momentum , & area_radius1 , & radius1_x_comp , & radius1_y , & radius1_z , & radius1_x_opp , & center1_x , & barycenter1_x , & area_radius2 , & radius2_x_comp , & radius2_y , & radius2_z , & radius2_x_opp , & center2_x , & barycenter2_x , & ent_center1 , & nbar_center1 , & rho_center1 , & energy_density_center1 , & specific_energy_center1 , & pressure_center1 , & ent_center2 , & nbar_center2 , & rho_center2 , & energy_density_center2 , & specific_energy_center2 , & pressure_center2 , & eos1 , & eos2 , & eos1_id , & eos2_id , & gamma_1 , & kappa_1 , & gamma_2 , & kappa_2 , & npeos_1 , & gamma0_1 , & gamma1_1 , & gamma2_1 , & gamma3_1 , & kappa0_1 , & kappa1_1 , & kappa2_1 , & kappa3_1 , & logP1_1 , & logRho0_1 , & logRho1_1 , & logRho2_1 , & npeos_2 , & gamma0_2 , & gamma1_2 , & gamma2_2 , & gamma3_2 , & kappa0_2 , & kappa1_2 , & kappa2_2 , & kappa3_2 , & logP1_2 , & logRho0_2 , & logRho1_2 , & logRho2_2 ) & BIND ( C , NAME = \"get_lorene_id_params\" ) !********************************************** ! !# Interface to the |lorene| method of class !  |binns| with the same name, that stores !  the physical parameters of the binary !  system from |lorene| in the desired variables ! !  FT ! !********************************************** IMPORT :: C_INT , C_DOUBLE , C_PTR , C_CHAR IMPLICIT NONE !> C pointer pointing to a |lorene| |binns| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr REAL ( C_DOUBLE ), INTENT ( OUT ) :: angular_vel REAL ( C_DOUBLE ), INTENT ( OUT ) :: distance REAL ( C_DOUBLE ), INTENT ( OUT ) :: distance_com REAL ( C_DOUBLE ), INTENT ( OUT ) :: mass1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: mass2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: mass_grav1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: mass_grav2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: adm_mass REAL ( C_DOUBLE ), INTENT ( OUT ) :: angular_momentum REAL ( C_DOUBLE ), INTENT ( OUT ) :: area_radius1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius1_x_comp REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius1_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius1_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius1_x_opp REAL ( C_DOUBLE ), INTENT ( OUT ) :: center1_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: barycenter1_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: area_radius2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius2_x_comp REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius2_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius2_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: radius2_x_opp REAL ( C_DOUBLE ), INTENT ( OUT ) :: center2_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: barycenter2_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: ent_center1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: nbar_center1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: rho_center1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density_center1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy_center1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: pressure_center1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: ent_center2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: nbar_center2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: rho_center2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density_center2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy_center2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: pressure_center2 CHARACTER ( KIND = C_CHAR ), DIMENSION ( 100 ), INTENT ( OUT ) :: eos1 CHARACTER ( KIND = C_CHAR ), DIMENSION ( 100 ), INTENT ( OUT ) :: eos2 INTEGER ( C_INT ) :: eos1_id INTEGER ( C_INT ) :: eos2_id REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa_2 INTEGER ( C_INT ) :: npeos_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma0_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma1_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma2_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma3_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa0_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa1_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa2_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa3_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logP1_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho0_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho1_1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho2_1 INTEGER ( C_INT ) :: npeos_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma0_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma1_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma2_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma3_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa0_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa1_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa2_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa3_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logP1_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho0_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho1_2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho2_2 END SUBROUTINE get_lorene_id_params SUBROUTINE destruct_bin_ns ( optr ) & BIND ( C , NAME = \"destruct_bin_ns\" ) !********************************************** ! !# Interface to the |lorene| method of class !  |binns| with the same name, that destructs !  the |lorene| |binns| object ! ! FT ! !********************************************** IMPORT :: C_PTR IMPLICIT NONE !> C pointer pointing to the |lorene| |binns| object to destruct TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr END SUBROUTINE destruct_bin_ns END INTERFACE END MODULE bns_lorene","tags":"","loc":"sourcefile/module_bns_lorene.f90.html"},{"title":"submodule_bns_lorene_access.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bns_lorene_access.f90~~EfferentGraph sourcefile~submodule_bns_lorene_access.f90 submodule_bns_lorene_access.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~submodule_bns_lorene_access.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_bns_lorene_accessf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bns_lorene_accessf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bns_lorene_access Source Code submodule_bns_lorene_access.f90 Source Code ! File:         submodule_bnslorene_access.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( bns_lorene ) bns_lorene_access !*************************************************** ! !# The module contains the implementation of the !  methods of TYPE bns that allow to access PRIVATE !  members. ! !  FT 12.07.2021 ! !*************************************************** IMPLICIT NONE CONTAINS !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE get_field_array !*********************************************** ! !# Returns one of the member arrays, selected !  with the string input. ! !  FT ! !*********************************************** IMPLICIT NONE select_field : SELECT CASE ( field ) CASE ( \"lapse\" ) field_array = THIS % lapse CASE ( \"shift_x\" ) field_array = THIS % shift_x CASE ( \"shift_y\" ) field_array = THIS % shift_y CASE ( \"shift_z\" ) field_array = THIS % shift_z CASE ( \"g_xx\" ) field_array = THIS % g_xx CASE ( \"g_xy\" ) field_array = THIS % g_xy CASE ( \"g_xz\" ) field_array = THIS % g_xz CASE ( \"g_yy\" ) field_array = THIS % g_yy CASE ( \"g_yz\" ) field_array = THIS % g_yz CASE ( \"g_zz\" ) field_array = THIS % g_zz CASE ( \"k_xx\" ) field_array = THIS % k_xx CASE ( \"k_xy\" ) field_array = THIS % k_xy CASE ( \"k_xz\" ) field_array = THIS % k_xz CASE ( \"k_yy\" ) field_array = THIS % k_yy CASE ( \"k_yz\" ) field_array = THIS % k_yz CASE ( \"k_zz\" ) field_array = THIS % k_zz CASE ( \"baryon_density\" ) field_array = THIS % baryon_density CASE ( \"energy_density\" ) field_array = THIS % energy_density CASE ( \"specific_energy\" ) field_array = THIS % specific_energy CASE ( \"v_euler_x\" ) field_array = THIS % v_euler_x CASE ( \"v_euler_y\" ) field_array = THIS % v_euler_y CASE ( \"v_euler_z\" ) field_array = THIS % v_euler_z CASE DEFAULT PRINT * , \"** There is no field named \" , field , \"in TYPE bns.\" STOP END SELECT select_field END PROCEDURE get_field_array MODULE PROCEDURE get_field_value !************************************************ ! !# Returns the value of one of the member arrays, !  selected with the string input, at the point !  given as argument. ! !  FT ! !************************************************ IMPLICIT NONE select_field : SELECT CASE ( field ) CASE ( \"lapse\" ) field_value = THIS % lapse ( n ) CASE ( \"shift_x\" ) field_value = THIS % shift_x ( n ) CASE ( \"shift_y\" ) field_value = THIS % shift_y ( n ) CASE ( \"shift_z\" ) field_value = THIS % shift_z ( n ) CASE ( \"g_xx\" ) field_value = THIS % g_xx ( n ) CASE ( \"g_xy\" ) field_value = THIS % g_xy ( n ) CASE ( \"g_xz\" ) field_value = THIS % g_xz ( n ) CASE ( \"g_yy\" ) field_value = THIS % g_yy ( n ) CASE ( \"g_yz\" ) field_value = THIS % g_yz ( n ) CASE ( \"g_zz\" ) field_value = THIS % g_zz ( n ) CASE ( \"k_xx\" ) field_value = THIS % k_xx ( n ) CASE ( \"k_xy\" ) field_value = THIS % k_xy ( n ) CASE ( \"k_xz\" ) field_value = THIS % k_xz ( n ) CASE ( \"k_yy\" ) field_value = THIS % k_yy ( n ) CASE ( \"k_yz\" ) field_value = THIS % k_yz ( n ) CASE ( \"k_zz\" ) field_value = THIS % k_zz ( n ) CASE ( \"baryon_density\" ) field_value = THIS % baryon_density ( n ) CASE ( \"energy_density\" ) field_value = THIS % energy_density ( n ) CASE ( \"specific_energy\" ) field_value = THIS % specific_energy ( n ) CASE ( \"v_euler_x\" ) field_value = THIS % v_euler_x ( n ) CASE ( \"v_euler_y\" ) field_value = THIS % v_euler_y ( n ) CASE ( \"v_euler_z\" ) field_value = THIS % v_euler_z ( n ) CASE DEFAULT PRINT * , \"** There is no field named \" , field , \"in TYPE bns.\" STOP END SELECT select_field END PROCEDURE get_field_value MODULE PROCEDURE get_bns_identifier !************************************************ ! !# Returns the value of [[bns_identifier]], the !  integer identifier of the bns object ! !  FT ! !************************************************ IMPLICIT NONE get_bns_identifier = THIS % bns_identifier END PROCEDURE get_bns_identifier !MODULE PROCEDURE get_bns_ptr ! !  !************************************************ !  ! !  !# Returns the value of [[bns_ptr]], the C pointer !  ! to the |lorene|'s Bin_NS object !  ! N.B. This variable is global. The pointer !  !      to the second |lorene| Bin_NS object will !  !      overwrite the first one, and so on. !  !      This variable stores the pointer to !  !      the last defined |lorene| Bin_NS object. !  !      That's why it is not freed in the !  !      destructor of a bns object. Presently, it !  !      has to be freed by the user at the end of !  !      the PROGRAM. See the last part of the !  !      PROGRAM in setup_lorene_id.f90, for !  !      example. !  ! !  !  FT !  ! !  !************************************************ ! !  IMPLICIT NONE ! !  get_bns_ptr= THIS% bns_ptr ! !END PROCEDURE get_bns_ptr MODULE PROCEDURE get_eos1_loreneid !************************************************** ! !# Returns the |lorene| ID-number of the EOS for NS 1 ! !  FT ! !************************************************** IMPLICIT NONE get_eos1_loreneid = THIS % eos1_loreneid END PROCEDURE get_eos1_loreneid MODULE PROCEDURE get_eos2_loreneid !************************************************** ! !# Returns the |lorene| ID-number of the EOS for NS 2 ! !  FT ! !************************************************** IMPLICIT NONE get_eos2_loreneid = THIS % eos2_loreneid END PROCEDURE get_eos2_loreneid MODULE PROCEDURE get_eos_parameters !************************************************** ! !# Returns the |eos| parameters of the !  `i_matter`-s star ! !  FT ! !************************************************** IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) IF ( i_matter == 1 ) THEN IF ( THIS % eos1_loreneid == 1 ) THEN eos_params = [ DBLE ( THIS % eos1_loreneid ), THIS % gamma_1 , THIS % kappa_1 ] ELSEIF ( THIS % eos1_loreneid == 110 ) THEN eos_params = [ DBLE ( THIS % eos1_loreneid ), DBLE ( THIS % npeos_1 ), & THIS % gamma0_1 , THIS % gamma1_1 , THIS % gamma2_1 , THIS % gamma3_1 , & THIS % kappa0_1 , THIS % kappa1_1 , THIS % kappa2_1 , THIS % kappa3_1 , & THIS % logP1_1 , & THIS % logRho0_1 , THIS % logRho1_1 , THIS % logRho2_1 ] ELSEIF ( THIS % eos1_loreneid == 17 . OR . THIS % eos1_loreneid == 20 ) THEN eos_params = [ DBLE ( THIS % eos1_loreneid ) ] ELSE PRINT * , \"** ERROR in SUBROUTINE get_eos_parameters!\" , & \" The EOS on star 1 is unknown! LORENE EOS ID=\" , & THIS % eos1_loreneid STOP ENDIF ELSEIF ( i_matter == 2 ) THEN IF ( THIS % eos2_loreneid == 1 ) THEN eos_params = [ DBLE ( THIS % eos2_loreneid ), THIS % gamma_2 , THIS % kappa_2 ] ELSEIF ( THIS % eos2_loreneid == 110 ) THEN eos_params = [ DBLE ( THIS % eos2_loreneid ), DBLE ( THIS % npeos_2 ), & THIS % gamma0_2 , THIS % gamma1_2 , THIS % gamma2_2 , THIS % gamma3_2 , & THIS % kappa0_2 , THIS % kappa1_2 , THIS % kappa2_2 , THIS % kappa3_2 , & THIS % logP1_2 , & THIS % logRho0_2 , THIS % logRho1_2 , THIS % logRho2_2 ] ELSEIF ( THIS % eos2_loreneid == 17 . OR . THIS % eos2_loreneid == 20 ) THEN eos_params = [ DBLE ( THIS % eos2_loreneid ) ] ELSE PRINT * , \"** ERROR in SUBROUTINE get_eos_parameters!\" , & \" The EOS on star 2 is unknown! LORENE EOS ID=\" , & THIS % eos2_loreneid STOP ENDIF ENDIF END PROCEDURE get_eos_parameters END SUBMODULE bns_lorene_access","tags":"","loc":"sourcefile/submodule_bns_lorene_access.f90.html"},{"title":"submodule_bns_lorene_params.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bns_lorene_params.f90~~EfferentGraph sourcefile~submodule_bns_lorene_params.f90 submodule_bns_lorene_params.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~submodule_bns_lorene_params.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_bns_lorene_paramsf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bns_lorene_paramsf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bns_lorene_params Source Code submodule_bns_lorene_params.f90 Source Code ! File:         submodule_bns_params.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( bns_lorene ) bns_lorene_params !******************************************** ! !# Implementation of the methods of TYPE bns !  that import from |lorene| the !  parameters of the binary system, !  and print them to the standard output. ! !  FT 09.07.2021 ! !******************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE import_id_params !*************************************************** ! !# Store the parameters of the binary neutron !  stars' |lorene| ID into member variables ! !  FT 5.10.2020 ! !*************************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_CHAR USE constants , ONLY : Msun_geo , km2m , lorene2hydrobase , k_lorene2hydrobase , & c_light , cm2km , k_lorene2hydrobase_piecewisepolytrope IMPLICIT NONE INTEGER :: i , nchars INTEGER , PARAMETER :: str_length = 100 CHARACTER ( KIND = C_CHAR ), DIMENSION ( str_length ) :: eos1_tmp_c CHARACTER ( KIND = C_CHAR ), DIMENSION ( str_length ) :: eos2_tmp_c !CHARACTER, DIMENSION(:), ALLOCATABLE:: eos1_tmp !CHARACTER, DIMENSION(:), ALLOCATABLE:: eos2_tmp PRINT * , \"** Executing the import_lorene_id_params subroutine...\" CALL get_lorene_id_params ( THIS % bns_ptr , & THIS % angular_vel , & THIS % distance , & THIS % distance_com , & THIS % mass1 , & THIS % mass2 , & THIS % mass_grav1 , & THIS % mass_grav2 , & THIS % adm_mass , & THIS % angular_momentum , & THIS % area_radius1 , & THIS % radius1_x_comp , & THIS % radius1_y , & THIS % radius1_z , & THIS % radius1_x_opp , & THIS % center1_x , & THIS % barycenter1_x , & THIS % area_radius2 , & THIS % radius2_x_comp , & THIS % radius2_y , & THIS % radius2_z , & THIS % radius2_x_opp , & THIS % center2_x , & THIS % barycenter2_x , & THIS % ent_center1 , & THIS % nbar_center1 , & THIS % rho_center1 , & THIS % energy_density_center1 , & THIS % specific_energy_center1 , & THIS % pressure_center1 , & THIS % ent_center2 , & THIS % nbar_center2 , & THIS % rho_center2 , & THIS % energy_density_center2 , & THIS % specific_energy_center2 , & THIS % pressure_center2 , & eos1_tmp_c , & eos2_tmp_c , & THIS % eos1_loreneid , & THIS % eos2_loreneid , & THIS % gamma_1 , & THIS % kappa_1 , & THIS % gamma_2 , & THIS % kappa_2 , & THIS % npeos_1 , & THIS % gamma0_1 , & THIS % gamma1_1 , & THIS % gamma2_1 , & THIS % gamma3_1 , & THIS % kappa0_1 , & THIS % kappa1_1 , & THIS % kappa2_1 , & THIS % kappa3_1 , & THIS % logP1_1 , & THIS % logRho0_1 ,& THIS % logRho1_1 ,& THIS % logRho2_1 ,& THIS % npeos_2 , & THIS % gamma0_2 , & THIS % gamma1_2 , & THIS % gamma2_2 , & THIS % gamma3_2 , & THIS % kappa0_2 , & THIS % kappa1_2 , & THIS % kappa2_2 , & THIS % kappa3_2 , & THIS % logP1_2 , & THIS % logRho0_2 ,& THIS % logRho1_2 ,& THIS % logRho2_2 ) ! Convert distances from |lorene| units (km) to SPHINCS units (Msun_geo) ! See MODULE constants for the definition of Msun_geo THIS % distance = THIS % distance / Msun_geo THIS % distance_com = THIS % distance_com / Msun_geo THIS % area_radius1 = THIS % area_radius1 / Msun_geo THIS % radius1_x_comp = THIS % radius1_x_comp / Msun_geo THIS % radius1_y = THIS % radius1_y / Msun_geo THIS % radius1_z = THIS % radius1_z / Msun_geo THIS % radius1_x_opp = THIS % radius1_x_opp / Msun_geo THIS % center1_x = THIS % center1_x / Msun_geo THIS % barycenter1_x = THIS % barycenter1_x / Msun_geo THIS % area_radius2 = THIS % area_radius2 / Msun_geo THIS % radius2_x_comp = THIS % radius2_x_comp / Msun_geo THIS % radius2_y = THIS % radius2_y / Msun_geo THIS % radius2_z = THIS % radius2_z / Msun_geo THIS % radius2_x_opp = THIS % radius2_x_opp / Msun_geo THIS % center2_x = THIS % center2_x / Msun_geo THIS % barycenter2_x = THIS % barycenter2_x / Msun_geo THIS % mass ( 1 ) = THIS % mass1 THIS % mass ( 2 ) = THIS % mass2 THIS % radii ( 1 ,:) = [ THIS % radius1_x_opp , THIS % radius1_x_comp , & THIS % radius1_y , THIS % radius1_y , & THIS % radius1_z , THIS % radius1_z ] THIS % radii ( 2 ,:) = [ THIS % radius2_x_opp , THIS % radius2_x_comp , & THIS % radius2_y , THIS % radius2_y , & THIS % radius2_z , THIS % radius2_z ] THIS % center ( 1 ,:) = [ THIS % center1_x , 0.0D0 , 0.0D0 ] THIS % center ( 2 ,:) = [ THIS % center2_x , 0.0D0 , 0.0D0 ] THIS % barycenter ( 1 ,:) = [ THIS % barycenter1_x , 0.0D0 , 0.0D0 ] THIS % barycenter ( 2 ,:) = [ THIS % barycenter2_x , 0.0D0 , 0.0D0 ] ! Convert hydro quantities from |lorene| units to SPHINCS units THIS % nbar_center1 = THIS % nbar_center1 * ( MSun_geo * km2m ) ** 3 THIS % rho_center1 = THIS % rho_center1 * lorene2hydrobase THIS % energy_density_center1 = THIS % energy_density_center1 * lorene2hydrobase THIS % pressure_center1 = THIS % pressure_center1 * lorene2hydrobase THIS % nbar_center2 = THIS % nbar_center2 * ( MSun_geo * km2m ) ** 3 THIS % rho_center2 = THIS % rho_center2 * lorene2hydrobase THIS % energy_density_center2 = THIS % energy_density_center2 * lorene2hydrobase THIS % pressure_center2 = THIS % pressure_center2 * lorene2hydrobase ! Convert polytropic constants from |lorene| units to SPHINCS units IF ( THIS % eos1_loreneid == 1 ) THEN ! If the EOS is polytropic THIS % kappa_1 = THIS % kappa_1 * k_lorene2hydrobase ( THIS % gamma_1 ) THIS % kappa_2 = THIS % kappa_2 * k_lorene2hydrobase ( THIS % gamma_2 ) ELSEIF ( THIS % gamma0_1 /= 0 ) THEN ! If the EOS is piecewise polytropic THIS % kappa0_1 = THIS % kappa0_1 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma0_1 ) THIS % kappa1_1 = THIS % kappa1_1 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma1_1 ) THIS % kappa2_1 = THIS % kappa2_1 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma2_1 ) THIS % kappa3_1 = THIS % kappa3_1 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma3_1 ) THIS % kappa0_2 = THIS % kappa0_2 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma0_2 ) THIS % kappa1_2 = THIS % kappa1_2 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma1_2 ) THIS % kappa2_2 = THIS % kappa2_2 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma2_2 ) THIS % kappa3_2 = THIS % kappa3_2 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma3_2 ) ELSEIF ( THIS % eos1_loreneid == 17 . OR . THIS % eos1_loreneid == 20 ) THEN ! If the EOS is tabulated ELSE PRINT * , \"** ERROR in SUBROUTINE import_lorene_id_params!\" , & \" The equation of state is unknown! LORENE EOS IDs=\" , & THIS % eos1_loreneid , \", \" , THIS % eos2_loreneid STOP ENDIF ! Compute mOmega THIS % mOmega = THIS % angular_vel / ( c_light * cm2km ) & * ( THIS % mass_grav1 + THIS % mass_grav2 ) * Msun_geo ! Compute t_merger THIS % t_merger = 5.0D0 / 25 6.0D0 * ( THIS % distance ** 4.0D0 ) & / ( THIS % mass_grav1 * THIS % mass_grav2 * & ( THIS % mass_grav1 + THIS % mass_grav2 ) ) ! Convert C++ strings to FORTRAN strings i = 1 DO IF ( eos1_tmp_c ( i ) == C_NULL_CHAR . OR . i == str_length ) EXIT i = i + 1 ENDDO nchars = i - 1 !ALLOCATE( eos1_tmp( nchars ), STAT= ios, ERRMSG= err_msg ) !IF( ios > 0 )THEN !   PRINT *, \"...allocation error for array eos1_tmp. \", & !            \"The error message is \", err_msg !   PRINT *, \"The STAT variable is \", ios !   STOP !ENDIF !eos1_tmp = TRANSFER( eos1_tmp_c(1:nchars), eos1_tmp ) ALLOCATE ( CHARACTER ( nchars ) :: THIS % eos1 , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for string eos1. \" , & \"The error message is \" , err_msg PRINT * , \"The STAT variable is \" , ios STOP ENDIF THIS % eos1 = TRANSFER ( eos1_tmp_c ( 1 : nchars ), THIS % eos1 ) !DO i= 1, nchars, 1 !  THIS% eos1(i:i)= eos1_tmp(i) !ENDDO i = 1 DO IF ( eos2_tmp_c ( i ) == C_NULL_CHAR . OR . i == str_length ) EXIT i = i + 1 ENDDO nchars = i - 1 !ALLOCATE( eos2_tmp( nchars ), STAT= ios, ERRMSG= err_msg ) !IF( ios > 0 )THEN !   PRINT *, \"...allocation error for array eos2_tmp. \", & !            \"The error message is \", err_msg !   PRINT *, \"The STAT variable is \", ios !   STOP !ENDIF !eos2_tmp = TRANSFER( eos2_tmp_c(1:nchars), eos2_tmp ) ALLOCATE ( CHARACTER ( nchars ) :: THIS % eos2 , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for string eos2. \" , & \"The error message is \" , err_msg PRINT * , \"The STAT variable is \" , ios STOP ENDIF THIS % eos2 = TRANSFER ( eos2_tmp_c ( 1 : nchars ), THIS % eos2 ) !DO i= 1, nchars, 1 !  THIS% eos2(i:i)= eos2_tmp(i) !ENDDO CALL print_id_params ( THIS ) PRINT * , \"** Subroutine import_lorene_id_params executed.\" PRINT * END PROCEDURE import_id_params MODULE PROCEDURE print_id_params !**************************************************** ! !# Print the parameters of the binary neutron !  stars' initial data computed by |lorene| ! !  FT 8.10.2020 ! !**************************************************** USE constants , ONLY : k_lorene2hydrobase , Msun_geo , km2m , m2cm , kg2g , & lorene2hydrobase , c_light , cm2km IMPLICIT NONE IF ( THIS % angular_momentum == 0.0D0 ) THEN PRINT * PRINT * , \" ** The parameters have not ben read yet. \" , & \"Call the SUBROUTINE import_lorene_id_params to read them.\" PRINT * ELSE PRINT * PRINT * , \" ** The parameters of the binary system are:\" PRINT * PRINT * , \" Distance between the points of highest density = \" ,& THIS % distance , \" M_sun&#94;geo = \" , THIS % distance * Msun_geo , \" km\" PRINT * , \" Distance between the barycenters = \" , & THIS % distance_com , \" M_sun&#94;geo\" , THIS % distance_com * Msun_geo , & \" km\" PRINT * PRINT * , \" Baryonic mass of NS 1 = \" , THIS % mass1 , \" M_sun\" PRINT * , \" Baryonic mass of NS 2 = \" , THIS % mass2 , \" M_sun\" PRINT * , \" Gravitational mass of NS 1 = \" , THIS % mass_grav1 , \" M_sun\" PRINT * , \" Gravitational mass of NS 2 = \" , THIS % mass_grav2 , \" M_sun\" PRINT * , \" ADM mass = \" , THIS % adm_mass , \" M_sun\" PRINT * PRINT * , \" Stellar center of NS 1 = \" , THIS % center1_x , \" M_sun&#94;geo\" PRINT * , \" Stellar center of NS 2 = \" , THIS % center2_x , \" M_sun&#94;geo\" PRINT * , \" Barycenter of NS 1 = \" , THIS % barycenter1_x , \" M_sun&#94;geo\" PRINT * , \" Barycenter of NS 2 = \" , THIS % barycenter2_x , \" M_sun&#94;geo\" PRINT * , \" Angular velocity Omega_0 = \" , THIS % angular_vel , \" rad/s = \" , & THIS % angular_vel / ( c_light * cm2km ), \"km&#94;{-1}\" PRINT * , \" mOmega = \" , & \"Omega_0[km&#94;{-1}]*(mass_grav1[km] + mass_grav2[km]) = \" ,& THIS % mOmega , \"[pure number]\" PRINT * , \" Angular momentum of the system = \" , & THIS % angular_momentum , \" G M_sun&#94;2 /c\" PRINT * , \" Estimated time of the merger t_merger = \" , THIS % t_merger , & \" M_sun&#94;geo = \" , THIS % t_merger * MSun_geo / ( c_light * cm2km ) * 100 0.0 ,& \" ms, from Peters_PR_136_B1224_1964, eq. (5.10)\" PRINT * PRINT * , \" Estimated separation to have the merger at t_merger = 2000\" , & \" Msun_geo = \" , 200 0.0D0 * MSun_geo / ( c_light * cm2km ) * 100 0.0 , & \" ms :\" , & ( 200 0.0D0 * ( THIS % mass_grav1 * THIS % mass_grav2 * & ( THIS % mass_grav1 + THIS % mass_grav2 ) ) / ( 5.0D0 / 25 6.0D0 ) ) & ** ( 1.0D0 / 4.0D0 ), \"M_sun&#94;geo = \" , & ( 200 0.0D0 * ( THIS % mass_grav1 * THIS % mass_grav2 * & ( THIS % mass_grav1 + THIS % mass_grav2 ) ) / ( 5.0D0 / 25 6.0D0 ) ) & ** ( 1.0D0 / 4.0D0 ) * Msun_geo , & \"km, from Peters_PR_136_B1224_1964, eq. (5.10)\" PRINT * PRINT * , \" Radii of star 1: \" PRINT * , \"  Areal (or circumferential) radius for the star in the\" , & \"  binary system [the one used in the\" , & \"  (gravitational)mass-(areal)radius diagrams\" ,& \"  is for a TOV star], x direction:\" , & THIS % area_radius1 , \" M_sun&#94;geo = \" , & THIS % area_radius1 * Msun_geo , \" km\" PRINT * , \"  x direction, towards companion = \" , & THIS % radius1_x_comp , \" M_sun&#94;geo\" PRINT * , \"  x direction, opposite to companion = \" , & THIS % radius1_x_opp , \" M_sun&#94;geo\" PRINT * , \"  y direction = \" , THIS % radius1_y , \" M_sun&#94;geo\" PRINT * , \"  z direction = \" , THIS % radius1_z , \" M_sun&#94;geo\" PRINT * , \" Radii of star 2 :\" PRINT * , \"  Areal (or circumferential) radius for the star in the\" , & \"  binary system [the one used in the\" , & \"  (gravitational)mass-(areal)radius diagrams\" ,& \"  is for a TOV star], x direction:\" , & THIS % area_radius2 , \" M_sun&#94;geo\" , & THIS % area_radius2 * Msun_geo , \" km\" PRINT * , \"  x direction, towards companion = \" , & THIS % radius2_x_comp , \" M_sun&#94;geo\" PRINT * , \"  x direction, opposite to companion = \" , & THIS % radius2_x_opp , \" M_sun&#94;geo\" PRINT * , \"  y direction = \" , THIS % radius2_y , \" M_sun&#94;geo\" PRINT * , \"  z direction = \" , THIS % radius2_z , \" M_sun&#94;geo\" PRINT * PRINT * , \" Hydro quantities at the center of star 1: \" PRINT * , \"  Central enthalpy = \" , THIS % ent_center1 , \" c&#94;2\" PRINT * , \"  Central baryon number density = \" , THIS % nbar_center1 , & \" (M_sun&#94;geo)&#94;{-3} =\" , & THIS % nbar_center1 / ( MSun_geo * km2m * m2cm ) ** 3 , \"cm&#94;{-3}\" PRINT * , \"  Central baryon mass density = \" , THIS % rho_center1 , & \" M_sun&#94;geo (M_sun&#94;geo)&#94;{-3} =\" , & THIS % rho_center1 / lorene2hydrobase * kg2g / ( m2cm ** 3 ), \"g cm&#94;{-3}\" PRINT * , \"  Central energy density = \" , THIS % energy_density_center1 , & \" M_sun&#94;geo c&#94;2 (M_sun&#94;geo)&#94;{-3}\" , & THIS % energy_density_center1 / lorene2hydrobase * kg2g / ( m2cm ** 3 ), & \"g c&#94;2 cm&#94;{-3}\" PRINT * , \"  Central specific energy = \" , THIS % specific_energy_center1 , & \" c&#94;2\" PRINT * , \"  Central pressure = \" , THIS % pressure_center1 , & \" M_sun&#94;geo c&#94;2 (M_sun&#94;geo)&#94;{-3}\" , & THIS % pressure_center1 / lorene2hydrobase * kg2g / ( m2cm ** 3 ), & \"g c&#94;2 cm&#94;{-3}\" PRINT * , \" Hydro quantities at the center of star 2: \" PRINT * , \"  Central enthalpy = \" , THIS % ent_center2 , \" c&#94;2\" PRINT * , \"  Central baryon number density = \" , THIS % nbar_center2 , & \" (M_sun&#94;geo)&#94;{-3} =\" , & THIS % nbar_center2 / ( MSun_geo * km2m * m2cm ) ** 3 , \"cm&#94;{-3}\" PRINT * , \"  Central baryon mass density = \" , THIS % rho_center2 , & \" M_sun&#94;geo (M_sun&#94;geo)&#94;{-3} =\" , & THIS % rho_center2 / lorene2hydrobase * kg2g / ( m2cm ** 3 ), \"g cm&#94;{-3}\" PRINT * , \"  Central energy density = \" , THIS % energy_density_center2 , & \" M_sun&#94;geo c&#94;2 (M_sun&#94;geo)&#94;{-3}\" , & THIS % energy_density_center2 / lorene2hydrobase * kg2g / ( m2cm ** 3 ), & \"g c&#94;2 cm&#94;{-3}\" PRINT * , \"  Central specific energy = \" , THIS % specific_energy_center2 , & \" c&#94;2\" PRINT * , \"  Central pressure = \" , THIS % pressure_center2 , & \" M_sun&#94;geo c&#94;2 (M_sun&#94;geo)&#94;{-3}\" , & THIS % pressure_center2 / lorene2hydrobase * kg2g / ( m2cm ** 3 ), & \"g c&#94;2 cm&#94;{-3}\" PRINT * !IF( show_progress ) & PRINT * , \" Equations of state for star 1 (EOS1) = \" , TRIM ( THIS % eos1 ) !IF( show_progress ) & PRINT * , \" Equations of state for star 2 (EOS2) = \" , TRIM ( THIS % eos2 ) !IF( show_progress ) PRINT * IF ( THIS % eos1_loreneid == 1 ) THEN ! If the EOS is polytropic PRINT * , \" Parameters for EOS1: \" PRINT * , \"  Polytopic index gamma_1 = \" , THIS % gamma_1 PRINT * , \"  Pressure coefficient = \" ,& THIS % kappa_1 / k_lorene2hydrobase ( THIS % gamma_1 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma_1 = \" , THIS % kappa_1 , & \"[pure number]\" PRINT * , \" Parameters for EOS2: \" PRINT * , \"  Polytopic index gamma_2 = \" , THIS % gamma_2 PRINT * , \"  Pressure coefficient = \" ,& THIS % kappa_2 / k_lorene2hydrobase ( THIS % gamma_2 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma_2 = \" , THIS % kappa_2 , & \"[pure number]\" PRINT * ELSEIF ( THIS % gamma0_1 /= 0 ) THEN ! If the EOS is piecewise polytropic PRINT * , \" Parameters for EOS1: \" PRINT * , \"  Number of polytropic indexes = \" , THIS % npeos_1 PRINT * , \"  Polytopic index gamma0_1 = \" , THIS % gamma0_1 PRINT * , \"  Polytopic index gamma1_1 = \" , THIS % gamma1_1 PRINT * , \"  Polytopic index gamma2_1 = \" , THIS % gamma2_1 PRINT * , \"  Polytopic index gamma3_1 = \" , THIS % gamma3_1 PRINT * , \"  Pressure coefficient for the crust (here from SLy) = \" ,& THIS % kappa0_1 / k_lorene2hydrobase ( THIS % gamma0_1 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma0_1 = \" , THIS % kappa0_1 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the first polytrope = \" ,& THIS % kappa1_1 / k_lorene2hydrobase ( THIS % gamma1_1 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma1_1\" , THIS % kappa1_1 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the second polytrope = \" ,& THIS % kappa2_1 / k_lorene2hydrobase ( THIS % gamma2_1 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma2_1\" , THIS % kappa2_1 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the third polytrope = \" ,& THIS % kappa3_1 / k_lorene2hydrobase ( THIS % gamma3_1 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma3_1\" , THIS % kappa3_1 , & \"[pure number]\" PRINT * , \"  Base 10 exponent of the pressure at the first fiducial \" & // \"density (between gamma_0 and gamma_1) (dyne/cm&#94;2)= \" , & THIS % logP1_1 PRINT * , \"  Base 10 exponent of first fiducial density (g/cm&#94;3) = \" , & THIS % logRho0_1 PRINT * , \"  Base 10 exponent of second fiducial density (g/cm&#94;3) = \" ,& THIS % logRho1_1 PRINT * , \"  Base 10 exponent of third fiducial density (g/cm&#94;3) = \" , & THIS % logRho2_1 PRINT * PRINT * , \" Parameters for EOS2: \" PRINT * , \"  Number of polytropic indexes = \" , THIS % npeos_2 PRINT * , \"  Polytopic index gamma0_2 = \" , THIS % gamma0_2 PRINT * , \"  Polytopic index gamma1_2 = \" , THIS % gamma1_2 PRINT * , \"  Polytopic index gamma2_2 = \" , THIS % gamma2_2 PRINT * , \"  Polytopic index gamma3_2 = \" , THIS % gamma3_2 PRINT * , \"  Pressure coefficient for the crust (here from SLy) = \" ,& THIS % kappa0_2 / k_lorene2hydrobase ( THIS % gamma0_2 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma0_2 = \" , THIS % kappa0_2 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the first polytrope = \" ,& THIS % kappa1_2 / k_lorene2hydrobase ( THIS % gamma1_2 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma1_2\" , THIS % kappa1_2 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the second polytrope = \" ,& THIS % kappa2_2 / k_lorene2hydrobase ( THIS % gamma2_2 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma2_2\" , THIS % kappa2_2 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the third polytrope = \" ,& THIS % kappa3_2 / k_lorene2hydrobase ( THIS % gamma3_2 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma3_2\" , THIS % kappa3_2 , & \"[pure number]\" PRINT * , \"  Base 10 exponent of the pressure at the first fiducial \" & // \"density (between gamma_0 and gamma_1) (dyne/cm&#94;2)= \" , & THIS % logP1_2 PRINT * , \"  Base 10 exponent of first fiducial density (g/cm&#94;3) = \" , & THIS % logRho0_2 PRINT * , \"  Base 10 exponent of second fiducial density (g/cm&#94;3) = \" ,& THIS % logRho1_2 PRINT * , \"  Base 10 exponent of third fiducial density (g/cm&#94;3) = \" , & THIS % logRho2_2 PRINT * ELSEIF ( THIS % eos1_loreneid == 17 . OR . THIS % eos1_loreneid == 20 ) THEN ! If the EOS is tabulated ELSE PRINT * , \"** ERROR in SUBROUTINE import_lorene_id_params!\" , & \" The equation of state is unknown!\" STOP ENDIF ENDIF END PROCEDURE print_id_params END SUBMODULE bns_lorene_params","tags":"","loc":"sourcefile/submodule_bns_lorene_params.f90.html"},{"title":"submodule_bns_lorene_memory.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bns_lorene_memory.f90~~EfferentGraph sourcefile~submodule_bns_lorene_memory.f90 submodule_bns_lorene_memory.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~submodule_bns_lorene_memory.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_bns_lorene_memoryf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bns_lorene_memoryf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bns_lorene_memory Source Code submodule_bns_lorene_memory.f90 Source Code ! File:         submodule_bns_lorene_memory.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( bns_lorene ) bns_lorene_memory !*********************************************** ! !# Implementation of the methods of TYPE bns !  that (de)allocate memory ! ! FT 9.07.2021 ! !*********************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE allocate_lorene_id_memory !*********************************************** ! !# Allocate the memory to store the LORENE ID !  in the member arrays ! !  FT 17.09.2020 ! !*********************************************** IMPLICIT NONE PRINT * , \"** Executing the allocate_lorene_id_memory subroutine...\" IF (. NOT . ALLOCATED ( THIS % lapse )) THEN ALLOCATE ( THIS % lapse ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array lapse. \" , & \"The error message is\" , err_msg STOP ENDIF !  CALL test_status( ios, err_msg, & !              \"...allocation error for array lapse\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_x )) THEN ALLOCATE ( THIS % shift_x ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_x. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array shift_x\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_y )) THEN ALLOCATE ( THIS % shift_y ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_y. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array shift_y\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_z )) THEN ALLOCATE ( THIS % shift_z ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_z. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array shift_z\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xx )) THEN ALLOCATE ( THIS % g_xx ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xx. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_xx\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xy )) THEN ALLOCATE ( THIS % g_xy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xy. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_xy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xz )) THEN ALLOCATE ( THIS % g_xz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_xz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_yy )) THEN ALLOCATE ( THIS % g_yy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_yy. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_yy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_yz )) THEN ALLOCATE ( THIS % g_yz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_yz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_yz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_zz )) THEN ALLOCATE ( THIS % g_zz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_zz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_zz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_xx )) THEN ALLOCATE ( THIS % k_xx ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_xx. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_xx\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_xy )) THEN ALLOCATE ( THIS % k_xy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_xy. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_xy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_xz )) THEN ALLOCATE ( THIS % k_xz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_xz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_xz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_yy )) THEN ALLOCATE ( THIS % k_yy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_yy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_yy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_yz )) THEN ALLOCATE ( THIS % k_yz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_yz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_yz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_zz )) THEN ALLOCATE ( THIS % k_zz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_zz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_zz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % baryon_density )) THEN ALLOCATE ( THIS % baryon_density ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array baryon_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array baryon_density\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % energy_density )) THEN ALLOCATE ( THIS % energy_density ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array energy_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array energy_density\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % specific_energy )) THEN ALLOCATE ( THIS % specific_energy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array specific_energy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array specific_energy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_x )) THEN ALLOCATE ( THIS % v_euler_x ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_x \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array v_euler_x\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_y )) THEN ALLOCATE ( THIS % v_euler_y ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_y \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array v_euler_y\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_z )) THEN ALLOCATE ( THIS % v_euler_z ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_z \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array v_euler_z\" ) ENDIF IF ( SIZE ( THIS % lapse ) /= d ) THEN PRINT * , \"** ERROR in memory allocation in allocate_lorene_id_memory\" ENDIF PRINT * , \"** Subroutine allocate_lorene_id_memory executed.\" PRINT * END PROCEDURE allocate_lorene_id_memory MODULE PROCEDURE deallocate_lorene_id_memory !*********************************************** ! !# Deallocate the memory for the member arrays ! !  FT 17.09.2020 ! !*********************************************** IMPLICIT NONE PRINT * , \"** Executing the deallocate_lorene_id_memory subroutine...\" IF ( ALLOCATED ( THIS % lapse )) THEN DEALLOCATE ( THIS % lapse , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array lapse \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                  \"...deallocation error for array lapse\" ) ENDIF IF ( ALLOCATED ( THIS % shift_x )) THEN DEALLOCATE ( THIS % shift_x , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_x \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_x\" ) ENDIF IF ( ALLOCATED ( THIS % shift_y )) THEN DEALLOCATE ( THIS % shift_y , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_y \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_y\" ) ENDIF IF ( ALLOCATED ( THIS % shift_z )) THEN DEALLOCATE ( THIS % shift_z , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_z \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_z\" ) ENDIF IF ( ALLOCATED ( THIS % g_xx )) THEN DEALLOCATE ( THIS % g_xx , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xx \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_xx\" ) ENDIF IF ( ALLOCATED ( THIS % g_xy )) THEN DEALLOCATE ( THIS % g_xy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !               \"...deallocation error for array g_xy\" ) ENDIF IF ( ALLOCATED ( THIS % g_xz )) THEN DEALLOCATE ( THIS % g_xz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_xz\" ) ENDIF IF ( ALLOCATED ( THIS % g_yy )) THEN DEALLOCATE ( THIS % g_yy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_yy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_yy\" ) ENDIF IF ( ALLOCATED ( THIS % g_yz )) THEN DEALLOCATE ( THIS % g_yz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_yz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_yz\" ) ENDIF IF ( ALLOCATED ( THIS % g_zz )) THEN DEALLOCATE ( THIS % g_zz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_zz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_zz\" ) ENDIF IF ( ALLOCATED ( THIS % k_xx )) THEN DEALLOCATE ( THIS % k_xx , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_xx \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_xx\" ) ENDIF IF ( ALLOCATED ( THIS % k_xy )) THEN DEALLOCATE ( THIS % k_xy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_xy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_xy\" ) ENDIF IF ( ALLOCATED ( THIS % k_xz )) THEN DEALLOCATE ( THIS % k_xz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_xz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_xz\" ) ENDIF IF ( ALLOCATED ( THIS % k_yy )) THEN DEALLOCATE ( THIS % k_yy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_yy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_yy\" ) ENDIF IF ( ALLOCATED ( THIS % k_yz )) THEN DEALLOCATE ( THIS % k_yz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_yz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_yz\" ) ENDIF IF ( ALLOCATED ( THIS % k_zz )) THEN DEALLOCATE ( THIS % k_zz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_zz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_zz\" ) ENDIF IF ( ALLOCATED ( THIS % baryon_density )) THEN DEALLOCATE ( THIS % baryon_density , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array baryon_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array baryon_density\" ) ENDIF IF ( ALLOCATED ( THIS % energy_density )) THEN DEALLOCATE ( THIS % energy_density , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array energy_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array energy_density\" ) ENDIF IF ( ALLOCATED ( THIS % specific_energy )) THEN DEALLOCATE ( THIS % specific_energy , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array specific_energy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array specific_energy\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_x )) THEN DEALLOCATE ( THIS % v_euler_x , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_x \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array v_euler_x\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_y )) THEN DEALLOCATE ( THIS % v_euler_y , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_y \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v_euler_y\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_z )) THEN DEALLOCATE ( THIS % v_euler_z , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_z \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v_euler_z\" ) ENDIF PRINT * , \"** Subroutine deallocate_lorene_id_memory executed.\" PRINT * END PROCEDURE deallocate_lorene_id_memory END SUBMODULE bns_lorene_memory","tags":"","loc":"sourcefile/submodule_bns_lorene_memory.f90.html"},{"title":"submodule_bns_lorene_constructor.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_bns_lorene_constructor.f90~~EfferentGraph sourcefile~submodule_bns_lorene_constructor.f90 submodule_bns_lorene_constructor.f90 sourcefile~module_bns_lorene.f90 module_bns_lorene.f90 sourcefile~submodule_bns_lorene_constructor.f90->sourcefile~module_bns_lorene.f90 sourcefile~module_bns_base.f90 module_bns_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_bns_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_bns_lorene.f90->sourcefile~module_id_base.f90 sourcefile~module_bns_base.f90->sourcefile~module_utility.f90 sourcefile~module_bns_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_bns_lorene_constructorf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_bns_lorene_constructorf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules bns_lorene_constructor Source Code submodule_bns_lorene_constructor.f90 Source Code ! File:         submodule_bns_constructor.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( bns_lorene ) bns_lorene_constructor !********************************************************* ! !# Implementation of the constructor and !  destructor of TYPE [[bnslorene]], and of the !  [[bnslorene]]-member !  PROCEDURES that call the C-bound PROCEDURES !  constructig and destructing the |lorene| !  |binns| object ! !  FT 23.10.2020 ! !********************************************************* IMPLICIT NONE CONTAINS ! MODULE PROCEDURE construct_bnslorene2 ! !   !**************************************************** !   ! !   !# Constructs an object of TYPE [[bnslorene]] !   ! !   !  FT !   ! !   !**************************************************** ! !   IMPLICIT NONE ! !   CHARACTER(LEN=10) :: resu_file ! !   derived_type => construct_bnslorene( resu_file ) ! ! END PROCEDURE construct_bnslorene2 ! !-- Implementation of the constructor of the bns object ! MODULE PROCEDURE construct_bnslorene !**************************************************** ! !# Constructs an object of TYPE [[bnslorene]] ! !  FT ! !**************************************************** IMPLICIT NONE INTEGER , SAVE :: bns_counter = 1 !DOUBLE PRECISION:: tmp CALL bns_obj % set_n_matter ( 2 ) bns_obj % construction_timer = timer ( \"binary_construction_timer\" ) ! Construct |lorene| |binns| object IF ( PRESENT ( resu_file ) ) THEN CALL bns_obj % construct_binary ( resu_file ) ELSE CALL bns_obj % construct_binary () ENDIF ! Import the parameters of the binary system CALL import_id_params ( bns_obj ) ! Assign a unique identifier to the bns object bns_obj % bns_identifier = bns_counter bns_counter = bns_counter + 1 ! Do not use the geodesic gauge by default CALL bns_obj % set_one_lapse ( . FALSE . ) CALL bns_obj % set_zero_shift ( . FALSE . ) !   bns_obj% total_spatial_extent(1)= bns_obj% get_center1_x() & !                               - bns_obj% get_radius1_x_opp() !   bns_obj% total_spatial_extent(2)= bns_obj% get_center2_x() & !                               + bns_obj% get_radius2_x_opp() !   bns_obj% total_spatial_extent(3)= - MAX( bns_obj% get_radius1_y(), & !                                      bns_obj% get_radius2_y() ) !   bns_obj% total_spatial_extent(4)= - bns_obj% total_spatial_extent(3) !   bns_obj% total_spatial_extent(5)= - MAX( bns_obj% get_radius1_z(), & !                                      bns_obj% get_radius2_z() ) !   bns_obj% total_spatial_extent(6)= - bns_obj% total_spatial_extent(5) !PRINT *, \"End of bns constructor.\" !PRINT * END PROCEDURE construct_bnslorene ! !-- Implementation of the destructor of the bns object ! MODULE PROCEDURE destruct_bnslorene !*********************************************** ! !# Destructs an object of TYPE [[bnslorene]] ! !  FT ! !*********************************************** IMPLICIT NONE !PRINT *, \"Inside destructor of bns.\" !PRINT * ! Deallocate memory CALL THIS % deallocate_lorene_id_memory () END PROCEDURE destruct_bnslorene MODULE PROCEDURE construct_binary !*********************************************** ! !# Construct the |lorene| |binns| object ! !  FT ! !*********************************************** IMPLICIT NONE CHARACTER ( KIND = C_CHAR , LEN = 7 ) :: default_case LOGICAL :: exist !PRINT *, \"** Executing the construct_binary subroutine...\" #ifdef __INTEL_COMPILER IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN CALL destruct_bin_ns ( THIS % bns_ptr ) ENDIF #endif ! !-- If the name of the |lorene| binary file resu_file is given as argument to !-- construct_binary, use it. Otherwise, give the string \"read_it\" !-- to construct_bin_ns as argument, which makes |lorene| read the name of !-- the file from the parameter file read_bin_ns.par ! IF ( PRESENT ( resu_file ) ) THEN INQUIRE ( FILE = resu_file , EXIST = exist ) IF ( exist ) THEN CALL THIS % construction_timer % start_timer () THIS % bns_ptr = construct_bin_ns ( resu_file // C_NULL_CHAR ) CALL THIS % construction_timer % stop_timer () ELSE PRINT * , \"** ERROR in SUBROUTINE construct_binary: file \" , & resu_file , \" cannot be found!\" PRINT * STOP ENDIF ELSE default_case = \"read_it\" CALL THIS % construction_timer % start_timer () THIS % bns_ptr = construct_bin_ns ( default_case // C_NULL_CHAR ) CALL THIS % construction_timer % stop_timer () ENDIF !PRINT *, \"** Subroutine construct_binary executed.\" !PRINT * END PROCEDURE construct_binary MODULE PROCEDURE destruct_binary !************************************************ ! !# Destructs the |lorene| |binns| object and frees !  the pointer [[bns:bns_ptr]] pointing to it ! !  FT ! !************************************************ IMPLICIT NONE !PRINT *, \"** Executing the destruct_binary subroutine.\" IF ( C_ASSOCIATED ( THIS % bns_ptr ) ) THEN CALL destruct_bin_ns ( THIS % bns_ptr ) THIS % bns_ptr = C_NULL_PTR ENDIF !PRINT *, \"** Subroutine destruct_binary executed.\" !PRINT * END PROCEDURE destruct_binary END SUBMODULE bns_lorene_constructor","tags":"","loc":"sourcefile/submodule_bns_lorene_constructor.f90.html"},{"title":"module_diffstar_base.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_diffstar_base.f90~~EfferentGraph sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_diffstar_base.f90~~AfferentGraph sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~submodule_diffstar_base_access.f90 submodule_diffstar_base_access.f90 sourcefile~submodule_diffstar_base_access.f90->sourcefile~module_diffstar_base.f90 sourcefile~submodule_diffstar_lorene_access.f90 submodule_diffstar_lorene_access.f90 sourcefile~submodule_diffstar_lorene_access.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_memory.f90 submodule_diffstar_lorene_memory.f90 sourcefile~submodule_diffstar_lorene_memory.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_params.f90 submodule_diffstar_lorene_params.f90 sourcefile~submodule_diffstar_lorene_params.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_constructor.f90 submodule_diffstar_lorene_constructor.f90 sourcefile~submodule_diffstar_lorene_constructor.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_import.f90 submodule_diffstar_lorene_import.f90 sourcefile~submodule_diffstar_lorene_import.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 var pansourcefilemodule_diffstar_basef90AfferentGraph = svgPanZoom('#sourcefilemodule_diffstar_basef90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules diffstar_base Source Code module_diffstar_base.f90 Source Code ! File:         module_diffstar_base.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE diffstar_base !******************************************************** ! !# This MODULE contains the definition of TYPE diffstarbase, !  which is an ABSTRACT TYPE representing any possible !  type of initial data (ID) for a differentially rotating !  star (DRS) to be set up for |sphincsbssn|. That is, DRS ID !  produced with |lorene|, with |fuka|, etc. ! !  PROCEDURES and variables shared by all the types !  of DRS ID should belong to TYPE diffstarbase, as !  they are inherited by its EXTENDED TYPES that !  represent more specific typesof DRS ID. ! !  FT 22.10.2021 ! !******************************************************** USE id_base , ONLY : idbase USE utility , ONLY : ios , err_msg IMPLICIT NONE !******************************************************************** !                                                                   * !  Definition of TYPE diffstarbase  (differentially rotating star)  * !                                                                   * !******************************************************************** TYPE , ABSTRACT , EXTENDS ( idbase ) :: diffstarbase !# Base TYPE for DRS ID for |sphincsbssn| (produced with |lorene|, or with !  |fuka|, etc.; or produced with the same tool, but read in different ways, !  for example by linking to the |lorene| library, or reading the ID from !  a lattice, etc.) !-----------------------------! !--  Parameters of the DRS  --! !-----------------------------! DOUBLE PRECISION :: omega_c !! Central angular velocity [{\\rm rad/s}] DOUBLE PRECISION :: mass !! Baryonic mass of DRS [M_\\odot] DOUBLE PRECISION :: mass_grav !! Gravitational mass of DRS [M_\\odot] DOUBLE PRECISION :: angular_momentum = 0.0D0 !! Angular momentum of the DRS [G M_\\odot&#94;2/c] DOUBLE PRECISION :: tsw !# Ratio between the kinetic and gravitatial potential energy T/W. ! !  See Section 6 in !  [Gourgoulhon et al, Astron.Astrophys.349:851,1999](https://arxiv.org/abs/astro-ph/9907225v1){:target=\"_blank\"} DOUBLE PRECISION :: grv2 !# Error on the virial identity {\\rm GRV2}. ! !  See Section 3.5 in !  [Gourgoulhon et al, Astron.Astrophys.349:851,1999](https://arxiv.org/abs/astro-ph/9907225v1){:target=\"_blank\"}. DOUBLE PRECISION :: grv3 !# Error on the virial identity {\\rm GRV3}. ! !  See Section 3.5 in !  [Gourgoulhon et al, Astron.Astrophys.349:851,1999](https://arxiv.org/abs/astro-ph/9907225v1){:target=\"_blank\"} . ! !  The error is computed as the integral defined !  by Eq. (43) of [Gourgoulhon and Bonazzola, Class. Quantum Grav. 11, 443 (1994)](https://iopscience.iop.org/article/10.1088/0264-9381/11/2/015?pageTitle=IOPscience){:target=\"_blank\"} !  divided by the integral of the matter terms. DOUBLE PRECISION , DIMENSION ( 3 ) :: center !# Array containing the centers of the stars !  @todo add details DOUBLE PRECISION , DIMENSION ( 3 ) :: barycenter !# Array containing the barycenters of the stars !  @todo add details DOUBLE PRECISION , DIMENSION ( 6 ) :: radii DOUBLE PRECISION :: r_circ !# Circumferential radius DOUBLE PRECISION :: r_mean !# Mean radius DOUBLE PRECISION :: r_eq !# Equatorial radius at \\phi=0 DOUBLE PRECISION :: r_eq_pi2 !# Equatorial radius at \\phi=\\dfrac{\\pi}{2} DOUBLE PRECISION :: r_eq_pi !# Equatorial radius at \\phi=\\pi DOUBLE PRECISION :: r_eq_3pi2 !# Equatorial radius at \\phi=\\dfrac{3\\pi}{2} DOUBLE PRECISION :: r_pole !# Polar radius DOUBLE PRECISION :: r_ratio !# Ratio [[diffstarbase:r_pole]]/[[diffstarbase:r_eq]] DOUBLE PRECISION :: r_isco !# Radius of the Innermost Stable Circular Orbit (ISCO) DOUBLE PRECISION :: f_isco !# Orbital frequency of the Innermost Stable Circular Orbit (ISCO) DOUBLE PRECISION :: specific_energy_isco !# Specific energy of a test particle at the Innermost Stable Circular !  Orbit (ISCO) DOUBLE PRECISION :: specific_angular_momentum_isco !# Specific angular momentum of a test particle at the Innermost Stable !  Circular Orbit (ISCO) DOUBLE PRECISION :: surface_area !# Surface area DOUBLE PRECISION :: area_radius !# Areal (or circumferential) radius of DRS [Msun_geo] !  Note that these is the areal radius of the star in the binary system, !  which is different than that of an isolated star. The latter is used !  in the mass-radius diagrams, together with the gravitatonal mass DOUBLE PRECISION :: ent_center !! Central enthalpy [c&#94;2] DOUBLE PRECISION :: nbar_center !! Central baryon number density [L_\\odot&#94;{-3}] DOUBLE PRECISION :: rho_center !! Central baryon mass density [M_\\odot L_\\odot&#94;{-3}] DOUBLE PRECISION :: energy_density_center !! Central energy density [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: specific_energy_center !! Central specific energy [c&#94;2] DOUBLE PRECISION :: pressure_center !! Central pressure [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: redshift_eqf !! Forward redshift factor at equator DOUBLE PRECISION :: redshift_eqb !! Backward redshift factor at equator DOUBLE PRECISION :: redshift_pole !! Redshift factor at North pole CHARACTER ( LEN = : ), ALLOCATABLE :: eos !! Name of the equation of state (EoS) of star 1 ! !-- Parameters of single polytropic equations of state for the two NSs ! DOUBLE PRECISION :: gamma !! Single polytrope: polytropic index DOUBLE PRECISION :: kappa !! Single polytrope: polytropic constant [pure number] ! !-- Parameters of the piecewise polytropic equation of state for NS 1 ! INTEGER :: npeos !! Piecewise polytrope: Number of polytropic pieces DOUBLE PRECISION :: gamma0 !! Piecewise polytrope: polytropic index \\gamma_0 DOUBLE PRECISION :: gamma1 !! Piecewise polytrope: polytropic index \\gamma_1 DOUBLE PRECISION :: gamma2 !! Piecewise polytrope: polytropic index \\gamma_2 DOUBLE PRECISION :: gamma3 !! Piecewise polytrope: polytropic index \\gamma_3 DOUBLE PRECISION :: kappa0 !# Piecewise polytrope: polytropic constant \\kappa_0 !  [pure number] DOUBLE PRECISION :: kappa1 !# Piecewise polytrope: polytropic constant \\kappa_1 !  [pure number] DOUBLE PRECISION :: kappa2 !# Piecewise polytrope: polytropic constant \\kappa_2 !  [pure number] DOUBLE PRECISION :: kappa3 !# Piecewise polytrope: polytropic constant \\kappa_3 !  [pure number] DOUBLE PRECISION :: logP1 !# Piecewise polytrope: Base 10 exponent of the pressure at the first !  fiducial density (between \\gamma_0 and \\gamma_1) !  [{\\rm dyne/cm&#94;2}] DOUBLE PRECISION :: logRho0 !# Piecewise polytrope: Base 10 exponent of the first fiducial density !  (between \\gamma_0 and \\gamma_1) [{\\rm g/cm&#94;3}] DOUBLE PRECISION :: logRho1 !# Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] DOUBLE PRECISION :: logRho2 !# Piecewise polytrope: Base 10 exponent of the third fiducial density !  (between \\gamma_2 and \\gamma_3) [{\\rm g/cm&#94;3}] CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE ( get_eos_id_int ), DEFERRED :: get_eos_id !! Returns an integer that identifies the equation of state !PROCEDURE:: integrate_field_on_star => integrate_baryon_mass_density !# Integrates the baryon mass density over the starand computes the radial !  mass profile !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE :: return_mass => get_mass PROCEDURE :: return_center => get_center PROCEDURE :: return_barycenter => get_barycenter PROCEDURE :: return_eos_name => get_eos PROCEDURE :: return_spatial_extent => get_radii PROCEDURE , PUBLIC :: get_omega_c !! Returns [[diffstarbase:omega_c]] !PROCEDURE, PUBLIC:: get_mass !! Returns [[diffstarbase:mass]] PROCEDURE , PUBLIC :: get_mass_grav !! Returns [[diffstarbase:mass_grav]] PROCEDURE , PUBLIC :: get_angular_momentum !! Returns [[diffstarbase:angular_momentum]] PROCEDURE , PUBLIC :: get_tsw !! Returns [[diffstarbase:tsw]] PROCEDURE , PUBLIC :: get_grv2 !! Returns [[diffstarbase:grv2]] PROCEDURE , PUBLIC :: get_grv3 !! Returns [[diffstarbase:grv3]] PROCEDURE , PUBLIC :: get_r_circ !! Returns [[diffstarbase:r_circ]] PROCEDURE , PUBLIC :: get_r_mean !! Returns [[diffstarbase:r_mean]] PROCEDURE , PUBLIC :: get_r_eq !! Returns [[diffstarbase:r_eq]] PROCEDURE , PUBLIC :: get_r_eq_pi2 !! Returns [[diffstarbase:r_eq_pi2]] PROCEDURE , PUBLIC :: get_r_eq_pi !! Returns [[diffstarbase:r_eq_pi]] PROCEDURE , PUBLIC :: get_r_eq_3pi2 !! Returns [[diffstarbase:r_eq_3pi2]] PROCEDURE , PUBLIC :: get_r_pole !! Returns [[diffstarbase:r_pole]] PROCEDURE , PUBLIC :: get_r_ratio !! Returns [[diffstarbase:r_ratio]] PROCEDURE , PUBLIC :: get_r_isco !! Returns [[diffstarbase:r_isco]] PROCEDURE , PUBLIC :: get_f_isco !! Returns [[diffstarbase:f_isco]] PROCEDURE , PUBLIC :: get_specific_energy_isco !! Returns [[diffstarbase:specific_energy_isco]] PROCEDURE , PUBLIC :: get_specific_angular_momentum_isco !! Returns [[diffstarbase:specific_angular_momentum_isco]] PROCEDURE , PUBLIC :: get_surface_area !! Returns [[diffstarbase:surface_area]] PROCEDURE , PUBLIC :: get_area_radius !! Returns [[diffstarbase:area_radius]] PROCEDURE , PUBLIC :: get_ent_center !! Returns [[diffstarbase:ent_center]] PROCEDURE , PUBLIC :: get_nbar_center !! Returns [[diffstarbase:nbar_center]] PROCEDURE , PUBLIC :: get_rho_center !! Returns [[diffstarbase:rho_center]] PROCEDURE , PUBLIC :: get_energy_density_center !! Returns [[diffstarbase:energy_density_center]] PROCEDURE , PUBLIC :: get_specific_energy_center !! Returns [[diffstarbase:specific_energy_center]] PROCEDURE , PUBLIC :: get_pressure_center !! Returns [[diffstarbase:pressure_center]] !PROCEDURE, PUBLIC:: get_eos !! Returns [[diffstarbase:eos]] ! !-- PROCEDURES to be used for single polytropic EOS ! PROCEDURE , PUBLIC :: get_gamma !! Returns [[diffstarbase:gamma]] PROCEDURE , PUBLIC :: get_kappa !! Returns [[diffstarbase:kappa]] ! !-- PROCEDURES to be used for piecewise polytropic EOS ! PROCEDURE , PUBLIC :: get_npeos !! Returns [[diffstarbase:npeos]] PROCEDURE , PUBLIC :: get_gamma0 !! Returns [[diffstarbase:gamma0]] PROCEDURE , PUBLIC :: get_gamma1 !! Returns [[diffstarbase:gamma1]] PROCEDURE , PUBLIC :: get_gamma2 !! Returns [[diffstarbase:gamma2]] PROCEDURE , PUBLIC :: get_gamma3 !! Returns [[diffstarbase:gamma3]] PROCEDURE , PUBLIC :: get_kappa0 !! Returns [[diffstarbase:kappa0]] PROCEDURE , PUBLIC :: get_kappa1 !! Returns [[diffstarbase:kappa1]] PROCEDURE , PUBLIC :: get_kappa2 !! Returns [[diffstarbase:kappa2]] PROCEDURE , PUBLIC :: get_kappa3 !! Returns [[diffstarbase:kappa3]] PROCEDURE , PUBLIC :: get_logP1 !! Returns [[diffstarbase:logP1]] PROCEDURE , PUBLIC :: get_logRho0 !! Returns [[diffstarbase:logRho0]] PROCEDURE , PUBLIC :: get_logRho1 !! Returns [[diffstarbase:logRho1]] PROCEDURE , PUBLIC :: get_logRho2 !! Returns [[diffstarbase:logRho2]] END TYPE diffstarbase ABSTRACT INTERFACE FUNCTION get_eos_id_int ( THIS ) IMPORT :: diffstarbase !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_eos_id_int END FUNCTION get_eos_id_int END INTERFACE INTERFACE !   MODULE SUBROUTINE integrate_baryon_mass_density( THIS, center, radius, & !                                                    central_density, & !                                                    dr, dth, dphi, & !                                                    mass, mass_profile, & !                                                    mass_profile_idx ) !   !# Integrates the |lorene| baryon mass density to compute the radial mass !   !  profile. TODO: Improve integration algorithm. ! !     !> [[diffstarbase]] object which this PROCEDURE is a member of !     CLASS(diffstarbase), INTENT( IN OUT )      :: THIS !     !& Array to store the indices for array mass_profile, sorted so that !     !  mass_profile[mass_profile_idx] is in increasing order !     INTEGER, DIMENSION(:), ALLOCATABLE, INTENT( IN OUT ):: mass_profile_idx !     !> Center of the star !     DOUBLE PRECISION, INTENT( IN )    :: center !     !> Central density of the star !     DOUBLE PRECISION, INTENT( IN )    :: central_density !     !> Radius of the star !     DOUBLE PRECISION, INTENT( IN )    :: radius !     !> Integration steps !     DOUBLE PRECISION, INTENT( IN )    :: dr, dth, dphi !     !> Integrated mass of the star !     DOUBLE PRECISION, INTENT( IN OUT ):: mass !     !> Array storing the radial mass profile of the star !     DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE, INTENT( IN OUT ):: & !                                      mass_profile ! !   END SUBROUTINE integrate_baryon_mass_density !----------------------------! !--  OVERRIDING FUNCTIONS  --! !----------------------------! MODULE FUNCTION get_mass ( THIS , i_matter ) !! Returns [[diffstarbase:mass]] !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter ! Result DOUBLE PRECISION :: get_mass END FUNCTION get_mass MODULE FUNCTION get_center ( THIS , i_matter ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION ( 3 ) :: get_center END FUNCTION get_center MODULE FUNCTION get_barycenter ( THIS , i_matter ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION ( 3 ) :: get_barycenter END FUNCTION get_barycenter MODULE FUNCTION get_radii ( THIS , i_matter ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose string is to return DOUBLE PRECISION , DIMENSION ( 6 ) :: get_radii END FUNCTION get_radii MODULE FUNCTION get_eos ( THIS , i_matter ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose string is to return CHARACTER ( LEN = : ), ALLOCATABLE :: get_eos END FUNCTION get_eos !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE FUNCTION get_gamma ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma END FUNCTION get_gamma MODULE FUNCTION get_kappa ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa END FUNCTION get_kappa MODULE FUNCTION get_omega_c ( THIS ) !! Returns [[diffstarbase:omega_c]] !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_omega_c END FUNCTION get_omega_c MODULE FUNCTION get_mass_grav ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_mass_grav END FUNCTION get_mass_grav MODULE FUNCTION get_angular_momentum ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_angular_momentum END FUNCTION get_angular_momentum MODULE FUNCTION get_tsw ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_tsw END FUNCTION get_tsw MODULE FUNCTION get_grv2 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_grv2 END FUNCTION get_grv2 MODULE FUNCTION get_grv3 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_grv3 END FUNCTION get_grv3 MODULE FUNCTION get_r_circ ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_circ END FUNCTION get_r_circ MODULE FUNCTION get_r_mean ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_mean END FUNCTION get_r_mean MODULE FUNCTION get_r_eq ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_eq END FUNCTION get_r_eq MODULE FUNCTION get_r_eq_pi2 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_eq_pi2 END FUNCTION get_r_eq_pi2 MODULE FUNCTION get_r_eq_pi ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_eq_pi END FUNCTION get_r_eq_pi MODULE FUNCTION get_r_eq_3pi2 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_eq_3pi2 END FUNCTION get_r_eq_3pi2 MODULE FUNCTION get_r_pole ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_pole END FUNCTION get_r_pole MODULE FUNCTION get_r_ratio ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_ratio END FUNCTION get_r_ratio MODULE FUNCTION get_r_isco ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_r_isco END FUNCTION get_r_isco MODULE FUNCTION get_f_isco ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_f_isco END FUNCTION get_f_isco MODULE FUNCTION get_specific_energy_isco ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_specific_energy_isco END FUNCTION get_specific_energy_isco MODULE FUNCTION get_specific_angular_momentum_isco ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_specific_angular_momentum_isco END FUNCTION get_specific_angular_momentum_isco MODULE FUNCTION get_surface_area ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_surface_area END FUNCTION get_surface_area MODULE FUNCTION get_area_radius ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_area_radius END FUNCTION get_area_radius MODULE FUNCTION get_ent_center ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_ent_center END FUNCTION get_ent_center MODULE FUNCTION get_nbar_center ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_nbar_center END FUNCTION get_nbar_center MODULE FUNCTION get_rho_center ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_rho_center END FUNCTION get_rho_center MODULE FUNCTION get_energy_density_center ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_energy_density_center END FUNCTION get_energy_density_center MODULE FUNCTION get_specific_energy_center ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_specific_energy_center END FUNCTION get_specific_energy_center MODULE FUNCTION get_pressure_center ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_pressure_center END FUNCTION get_pressure_center MODULE FUNCTION get_npeos ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_npeos END FUNCTION get_npeos MODULE FUNCTION get_gamma0 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma0 END FUNCTION get_gamma0 MODULE FUNCTION get_gamma1 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma1 END FUNCTION get_gamma1 MODULE FUNCTION get_gamma2 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma2 END FUNCTION get_gamma2 MODULE FUNCTION get_gamma3 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_gamma3 END FUNCTION get_gamma3 MODULE FUNCTION get_kappa0 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa0 END FUNCTION get_kappa0 MODULE FUNCTION get_kappa1 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa1 END FUNCTION get_kappa1 MODULE FUNCTION get_kappa2 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa2 END FUNCTION get_kappa2 MODULE FUNCTION get_kappa3 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_kappa3 END FUNCTION get_kappa3 MODULE FUNCTION get_logP1 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logP1 END FUNCTION get_logP1 MODULE FUNCTION get_logRho0 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho0 END FUNCTION get_logRho0 MODULE FUNCTION get_logRho1 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho1 END FUNCTION get_logRho1 MODULE FUNCTION get_logRho2 ( THIS ) !> [[diffstarbase]] object which this PROCEDURE is a member of CLASS ( diffstarbase ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_logRho2 END FUNCTION get_logRho2 END INTERFACE END MODULE diffstar_base","tags":"","loc":"sourcefile/module_diffstar_base.f90.html"},{"title":"submodule_diffstar_base_access.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_diffstar_base_access.f90~~EfferentGraph sourcefile~submodule_diffstar_base_access.f90 submodule_diffstar_base_access.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~submodule_diffstar_base_access.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules diffstar_base_access Source Code submodule_diffstar_base_access.f90 Source Code ! File:         submodule_diffstar_base_access.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( diffstar_base ) diffstar_base_access !*************************************************** ! !# The module contains the implementation of the !  methods of TYPE diffstarbase that allow to !  access PRIVATE members. ! !  FT 22.10.2021 ! !*************************************************** IMPLICIT NONE CONTAINS !----------------------------! !--  OVERRIDING FUNCTIONS  --! !----------------------------! MODULE PROCEDURE get_mass !************************************************ ! !# Returns the baryon mass of the DRS [M_\\odot] ! !  FT 2.11.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_mass = THIS % mass END PROCEDURE get_mass MODULE PROCEDURE get_radii !************************************************ ! !# Returns the radii of the DRS [L_\\odot] ! !  FT 2.11.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_radii = THIS % radii (:) END PROCEDURE get_radii MODULE PROCEDURE get_center !************************************************ ! !# Returns the center of the DRS [L_\\odot] ! !  FT 2.11.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_center = THIS % center (:) END PROCEDURE get_center MODULE PROCEDURE get_barycenter !************************************************ ! !# Returns the barycenter of the DRS [L_\\odot] ! !  FT 2.11.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_barycenter = THIS % barycenter (:) END PROCEDURE get_barycenter MODULE PROCEDURE get_eos !************************************************ ! !# Returns the |eos| name of the DRS ! !  FT 2.11.2021 ! !************************************************ IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) get_eos = THIS % eos END PROCEDURE get_eos !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE get_gamma !************************************************ ! !# Returns the value of [[gamma]], the !  polytropic index for polytropic EOS, !  not piecewise polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_gamma = THIS % gamma END PROCEDURE get_gamma MODULE PROCEDURE get_kappa !************************************************ ! !# Returns the value of [[kappa]], the !  polytropic constant for polytropic !  EOS, not piecewise polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_kappa = THIS % kappa END PROCEDURE get_kappa MODULE PROCEDURE get_omega_c !************************************************ ! !# Returns [[omega_c]], the central  angular !  velocity of the system ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_omega_c = THIS % omega_c END PROCEDURE get_omega_c MODULE PROCEDURE get_mass_grav !************************************************ ! !# Returns the gravitational mass of the DRS [M_\\odot] ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_mass_grav = THIS % mass_grav END PROCEDURE get_mass_grav MODULE PROCEDURE get_angular_momentum !************************************************ ! !# Returns the angular momentum of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_angular_momentum = THIS % angular_momentum END PROCEDURE get_angular_momentum MODULE PROCEDURE get_tsw !************************************************ ! !# Returns [[diffstarbase:tsw]], the ratio T/W !  between the kinetic and gravitational potential !  energy of the DRS !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_tsw = THIS % tsw END PROCEDURE get_tsw MODULE PROCEDURE get_grv2 !************************************************ ! !# Returns [[diffstarbase:grv2]], the error on the !  virial identity  {\\rm GRV2}. ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_grv2 = THIS % grv2 END PROCEDURE get_grv2 MODULE PROCEDURE get_grv3 !************************************************ ! !# Returns [[diffstarbase:grv3]], the error on the !  virial identity  {\\rm GRV3}. ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_grv3 = THIS % grv3 END PROCEDURE get_grv3 MODULE PROCEDURE get_r_circ !************************************************ ! !# Returns [[diffstarbase:r_circ]], the !  circumferential radius of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_circ = THIS % r_circ END PROCEDURE get_r_circ MODULE PROCEDURE get_r_mean !************************************************ ! !# Returns [[diffstarbase:r_mean]], the !  circumferential radius of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_mean = THIS % r_mean END PROCEDURE get_r_mean MODULE PROCEDURE get_r_eq !************************************************ ! !# Returns [[diffstarbase:r_eq]], the !  equatorial radius of the DRS at \\phi=0 ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_eq = THIS % r_eq END PROCEDURE get_r_eq MODULE PROCEDURE get_r_eq_pi2 !************************************************ ! !# Returns [[diffstarbase:r_eq_pi2]], the !  equatorial radius of the DRS at \\phi=\\dfrac{\\pi}{2} ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_eq_pi2 = THIS % r_eq_pi2 END PROCEDURE get_r_eq_pi2 MODULE PROCEDURE get_r_eq_pi !************************************************ ! !# Returns [[diffstarbase:r_eq_pi]], the !  equatorial radius of the DRS at \\phi=\\pi ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_eq_pi = THIS % r_eq_pi END PROCEDURE get_r_eq_pi MODULE PROCEDURE get_r_eq_3pi2 !************************************************ ! !# Returns [[diffstarbase:r_eq_3pi2]], the !  equatorial radius of the DRS at \\phi=\\dfrac{3\\pi}{2} ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_eq_3pi2 = THIS % r_eq_3pi2 END PROCEDURE get_r_eq_3pi2 MODULE PROCEDURE get_r_pole !************************************************ ! !# Returns [[diffstarbase:r_pole]], the !  polar radius of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_pole = THIS % r_pole END PROCEDURE get_r_pole MODULE PROCEDURE get_r_ratio !************************************************ ! !# Returns [[diffstarbase:r_ratio]], the !  Ratio [[diffstarbase:r_pole]]/[[diffstarbase:r_eq]] ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_ratio = THIS % r_ratio END PROCEDURE get_r_ratio MODULE PROCEDURE get_r_isco !************************************************ ! !# Returns [[diffstarbase:r_isco]], the !  radius of the Innermost Stable Circular Orbit (ISCO) ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_r_isco = THIS % r_isco END PROCEDURE get_r_isco MODULE PROCEDURE get_f_isco !************************************************ ! !# Returns [[diffstarbase:f_isco]], the orbital !  frequency of the Innermost Stable Circular Orbit !  (ISCO) ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_f_isco = THIS % f_isco END PROCEDURE get_f_isco MODULE PROCEDURE get_specific_energy_isco !************************************************ ! !# Returns [[diffstarbase:specific_energy_isco]], !  the specific energy of a test particle at the !  Innermost Stable Circular Orbit (ISCO) ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_specific_energy_isco = THIS % specific_energy_isco END PROCEDURE get_specific_energy_isco MODULE PROCEDURE get_specific_angular_momentum_isco !************************************************ ! !# Returns [[diffstarbase:specific_angular_momentum_isco]], !  the specific angular momentum of a test particle !  at the Innermost Stable Circular Orbit (ISCO) ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_specific_angular_momentum_isco = THIS % specific_angular_momentum_isco END PROCEDURE get_specific_angular_momentum_isco MODULE PROCEDURE get_surface_area !************************************************ ! !# Returns [[diffstarbase:surface_area]], the !  surface area of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_surface_area = THIS % surface_area END PROCEDURE get_surface_area MODULE PROCEDURE get_area_radius !************************************************ ! !# Returns [[diffstarbase:area_radius]], the !  areal radius of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_area_radius = THIS % area_radius END PROCEDURE get_area_radius MODULE PROCEDURE get_ent_center !************************************************ ! !# Returns the central enthalpy of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_ent_center = THIS % ent_center END PROCEDURE get_ent_center MODULE PROCEDURE get_nbar_center !************************************************ ! !# Returns the central baryon number density !  of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_nbar_center = THIS % nbar_center END PROCEDURE get_nbar_center MODULE PROCEDURE get_rho_center !************************************************ ! !# Returns the central baryon mass density !  of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_rho_center = THIS % rho_center END PROCEDURE get_rho_center MODULE PROCEDURE get_energy_density_center !************************************************ ! !# Returns the central energy density of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_energy_density_center = THIS % energy_density_center END PROCEDURE get_energy_density_center MODULE PROCEDURE get_specific_energy_center !************************************************ ! !# Returns the central specific energy of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_specific_energy_center = THIS % specific_energy_center END PROCEDURE get_specific_energy_center MODULE PROCEDURE get_pressure_center !************************************************ ! !# Returns the central pressure of the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_pressure_center = THIS % pressure_center END PROCEDURE get_pressure_center MODULE PROCEDURE get_npeos !************************************************ ! !# Returns the identifier of the EOS for the DRS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_npeos = THIS % npeos END PROCEDURE get_npeos MODULE PROCEDURE get_gamma0 !************************************************ ! !# Returns the value of [[gamma0]], the crust's !  polytropic index for the DRS with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_gamma0 = THIS % gamma0 END PROCEDURE get_gamma0 MODULE PROCEDURE get_gamma1 !************************************************ ! !# Returns the value of [[gamma1]], the first !  polytropic index for the DRS with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_gamma1 = THIS % gamma1 END PROCEDURE get_gamma1 MODULE PROCEDURE get_gamma2 !************************************************ ! !# Returns the value of [[gamma2]], the second !  polytropic index for NS 2 with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_gamma2 = THIS % gamma2 END PROCEDURE get_gamma2 MODULE PROCEDURE get_gamma3 !************************************************ ! !# Returns the value of [[gamma3]], the third !  polytropic index for the DRS with piecewise !  polytropic EOS (innermost index) ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_gamma3 = THIS % gamma3 END PROCEDURE get_gamma3 MODULE PROCEDURE get_kappa0 !************************************************ ! !# Returns the value of [[kappa0]], the crust's !  polytropic constant for the DRS with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_kappa0 = THIS % kappa0 END PROCEDURE get_kappa0 MODULE PROCEDURE get_kappa1 !************************************************ ! !# Returns the value of [[kappa1]], the first !  polytropic constant for the DRS with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_kappa1 = THIS % kappa1 END PROCEDURE get_kappa1 MODULE PROCEDURE get_kappa2 !************************************************ ! !# Returns the value of [[kappa2]], the second !  polytropic constant for the DRS with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_kappa2 = THIS % kappa2 END PROCEDURE get_kappa2 MODULE PROCEDURE get_kappa3 !************************************************ ! !# Returns the value of [[kappa3]], the third !  polytropic constant for the DRS with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_kappa3 = THIS % kappa3 END PROCEDURE get_kappa3 MODULE PROCEDURE get_logp1 !************************************************ ! !# Returns the value of [[logp1]], the base 10 !  logarithm of the pressure where the gamma1 !  polytrope starts, for the DRS with piecewise !  polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_logp1 = THIS % logp1 END PROCEDURE get_logp1 MODULE PROCEDURE get_logRho0 !************************************************ ! !# Returns the value of [[logRho0]], the base 10 !  logarithm of the mass density where the !  gamma1 polytrope starts, for the DRS with !  piecewise polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_logRho0 = THIS % logRho0 END PROCEDURE get_logRho0 MODULE PROCEDURE get_logRho1 !************************************************ ! !# Returns the value of [[logRho1]], the base 10 !  logarithm of the mass density where the !  gamma2 polytrope starts, for the DRS with !  piecewise polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_logRho1 = THIS % logRho1 END PROCEDURE get_logRho1 MODULE PROCEDURE get_logRho2 !************************************************ ! !# Returns the value of [[logRho2]], the base 10 !  logarithm of the mass density where the !  gamma3 polytrope starts, for the DRS with !  piecewise polytropic EOS ! !  FT 22.10.2021 ! !************************************************ IMPLICIT NONE get_logRho2 = THIS % logRho2 END PROCEDURE get_logRho2 END SUBMODULE diffstar_base_access","tags":"","loc":"sourcefile/submodule_diffstar_base_access.f90.html"},{"title":"submodule_diffstar_lorene_memory.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_diffstar_lorene_memory.f90~~EfferentGraph sourcefile~submodule_diffstar_lorene_memory.f90 submodule_diffstar_lorene_memory.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_memory.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_diffstar_lorene_memoryf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_diffstar_lorene_memoryf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules diffstar_lorene_memory Source Code submodule_diffstar_lorene_memory.f90 Source Code ! File:         submodule_diffstar_lorene_memory.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( diffstar_lorene ) diffstar_lorene_memory !*********************************************** ! !# Implementation of the methods of TYPE diffstar !  that (de)allocate memory ! ! FT 25.10.2021 ! !*********************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE allocate_diffstar_memory !*********************************************** ! !# Allocate the memory to store the LORENE ID !  in the member arrays ! !  FT 25.10.2021 ! !*********************************************** IMPLICIT NONE PRINT * , \"** Executing the allocate_diffstar_memory subroutine...\" IF (. NOT . ALLOCATED ( THIS % lapse )) THEN ALLOCATE ( THIS % lapse ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array lapse. \" , & \"The error message is\" , err_msg STOP ENDIF !  CALL test_status( ios, err_msg, & !              \"...allocation error for array lapse\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_x )) THEN ALLOCATE ( THIS % shift_x ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_x. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array shift_x\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_y )) THEN ALLOCATE ( THIS % shift_y ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_y. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array shift_y\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % shift_z )) THEN ALLOCATE ( THIS % shift_z ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array shift_z. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array shift_z\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xx )) THEN ALLOCATE ( THIS % g_xx ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xx. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_xx\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xy )) THEN ALLOCATE ( THIS % g_xy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xy. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_xy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_xz )) THEN ALLOCATE ( THIS % g_xz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_xz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_xz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_yy )) THEN ALLOCATE ( THIS % g_yy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_yy. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_yy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_yz )) THEN ALLOCATE ( THIS % g_yz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_yz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_yz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % g_zz )) THEN ALLOCATE ( THIS % g_zz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array g_zz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array g_zz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_xx )) THEN ALLOCATE ( THIS % k_xx ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_xx. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_xx\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_xy )) THEN ALLOCATE ( THIS % k_xy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_xy. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_xy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_xz )) THEN ALLOCATE ( THIS % k_xz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_xz. \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_xz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_yy )) THEN ALLOCATE ( THIS % k_yy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_yy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_yy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_yz )) THEN ALLOCATE ( THIS % k_yz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_yz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_yz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % k_zz )) THEN ALLOCATE ( THIS % k_zz ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array k_zz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array k_zz\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % baryon_density )) THEN ALLOCATE ( THIS % baryon_density ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array baryon_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array baryon_density\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % energy_density )) THEN ALLOCATE ( THIS % energy_density ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array energy_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array energy_density\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % specific_energy )) THEN ALLOCATE ( THIS % specific_energy ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array specific_energy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array specific_energy\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_x )) THEN ALLOCATE ( THIS % v_euler_x ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_x \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array v_euler_x\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_y )) THEN ALLOCATE ( THIS % v_euler_y ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_y \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array v_euler_y\" ) ENDIF IF (. NOT . ALLOCATED ( THIS % v_euler_z )) THEN ALLOCATE ( THIS % v_euler_z ( d ), STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for array v_euler_z \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !            \"...allocation error for array v_euler_z\" ) ENDIF IF ( SIZE ( THIS % lapse ) /= d ) THEN PRINT * , \"** ERROR in memory allocation in allocate_diffstar_memory\" ENDIF PRINT * , \"** Subroutine allocate_diffstar_memory executed.\" PRINT * END PROCEDURE allocate_diffstar_memory MODULE PROCEDURE deallocate_diffstar_memory !*********************************************** ! !# Deallocate the memory for the member arrays ! !  FT 25.10.2021 ! !*********************************************** IMPLICIT NONE PRINT * , \"** Executing the deallocate_diffstar_memory subroutine...\" IF ( ALLOCATED ( THIS % lapse )) THEN DEALLOCATE ( THIS % lapse , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array lapse \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                  \"...deallocation error for array lapse\" ) ENDIF IF ( ALLOCATED ( THIS % shift_x )) THEN DEALLOCATE ( THIS % shift_x , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_x \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_x\" ) ENDIF IF ( ALLOCATED ( THIS % shift_y )) THEN DEALLOCATE ( THIS % shift_y , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_y \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_y\" ) ENDIF IF ( ALLOCATED ( THIS % shift_z )) THEN DEALLOCATE ( THIS % shift_z , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array shift_z \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array shift_z\" ) ENDIF IF ( ALLOCATED ( THIS % g_xx )) THEN DEALLOCATE ( THIS % g_xx , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xx \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_xx\" ) ENDIF IF ( ALLOCATED ( THIS % g_xy )) THEN DEALLOCATE ( THIS % g_xy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !               \"...deallocation error for array g_xy\" ) ENDIF IF ( ALLOCATED ( THIS % g_xz )) THEN DEALLOCATE ( THIS % g_xz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_xz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_xz\" ) ENDIF IF ( ALLOCATED ( THIS % g_yy )) THEN DEALLOCATE ( THIS % g_yy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_yy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_yy\" ) ENDIF IF ( ALLOCATED ( THIS % g_yz )) THEN DEALLOCATE ( THIS % g_yz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_yz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_yz\" ) ENDIF IF ( ALLOCATED ( THIS % g_zz )) THEN DEALLOCATE ( THIS % g_zz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array g_zz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array g_zz\" ) ENDIF IF ( ALLOCATED ( THIS % k_xx )) THEN DEALLOCATE ( THIS % k_xx , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_xx \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_xx\" ) ENDIF IF ( ALLOCATED ( THIS % k_xy )) THEN DEALLOCATE ( THIS % k_xy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_xy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_xy\" ) ENDIF IF ( ALLOCATED ( THIS % k_xz )) THEN DEALLOCATE ( THIS % k_xz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_xz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_xz\" ) ENDIF IF ( ALLOCATED ( THIS % k_yy )) THEN DEALLOCATE ( THIS % k_yy , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_yy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_yy\" ) ENDIF IF ( ALLOCATED ( THIS % k_yz )) THEN DEALLOCATE ( THIS % k_yz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_yz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_yz\" ) ENDIF IF ( ALLOCATED ( THIS % k_zz )) THEN DEALLOCATE ( THIS % k_zz , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array k_zz \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array k_zz\" ) ENDIF IF ( ALLOCATED ( THIS % baryon_density )) THEN DEALLOCATE ( THIS % baryon_density , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array baryon_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array baryon_density\" ) ENDIF IF ( ALLOCATED ( THIS % energy_density )) THEN DEALLOCATE ( THIS % energy_density , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array energy_density \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array energy_density\" ) ENDIF IF ( ALLOCATED ( THIS % specific_energy )) THEN DEALLOCATE ( THIS % specific_energy , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array specific_energy \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array specific_energy\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_x )) THEN DEALLOCATE ( THIS % v_euler_x , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_x \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !        \"...deallocation error for array v_euler_x\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_y )) THEN DEALLOCATE ( THIS % v_euler_y , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_y \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v_euler_y\" ) ENDIF IF ( ALLOCATED ( THIS % v_euler_z )) THEN DEALLOCATE ( THIS % v_euler_z , STAT = ios , & ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error for array v_euler_z \" , & \"The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, & !                \"...deallocation error for array v_euler_z\" ) ENDIF PRINT * , \"** Subroutine deallocate_diffstar_memory executed.\" PRINT * END PROCEDURE deallocate_diffstar_memory END SUBMODULE diffstar_lorene_memory","tags":"","loc":"sourcefile/submodule_diffstar_lorene_memory.f90.html"},{"title":"submodule_diffstar_lorene_access.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_diffstar_lorene_access.f90~~EfferentGraph sourcefile~submodule_diffstar_lorene_access.f90 submodule_diffstar_lorene_access.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_access.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_diffstar_lorene_accessf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_diffstar_lorene_accessf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules diffstar_lorene_access Source Code submodule_diffstar_lorene_access.f90 Source Code ! File:         submodule_diffstar_access.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( diffstar_lorene ) diffstar_lorene_access !*************************************************** ! !# The module contains the implementation of the !  methods of TYPE diffstar that allow to access PRIVATE !  members. ! !  FT 25.10.2021 ! !*************************************************** IMPLICIT NONE CONTAINS !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE get_field_array !*********************************************** ! !# Returns one of the member arrays, selected !  with the string input. ! !  FT 25.10.2021 ! !*********************************************** IMPLICIT NONE select_field : SELECT CASE ( field ) CASE ( \"lapse\" ) field_array = THIS % lapse CASE ( \"shift_x\" ) field_array = THIS % shift_x CASE ( \"shift_y\" ) field_array = THIS % shift_y CASE ( \"shift_z\" ) field_array = THIS % shift_z CASE ( \"g_xx\" ) field_array = THIS % g_xx CASE ( \"g_xy\" ) field_array = THIS % g_xy CASE ( \"g_xz\" ) field_array = THIS % g_xz CASE ( \"g_yy\" ) field_array = THIS % g_yy CASE ( \"g_yz\" ) field_array = THIS % g_yz CASE ( \"g_zz\" ) field_array = THIS % g_zz CASE ( \"k_xx\" ) field_array = THIS % k_xx CASE ( \"k_xy\" ) field_array = THIS % k_xy CASE ( \"k_xz\" ) field_array = THIS % k_xz CASE ( \"k_yy\" ) field_array = THIS % k_yy CASE ( \"k_yz\" ) field_array = THIS % k_yz CASE ( \"k_zz\" ) field_array = THIS % k_zz CASE ( \"baryon_density\" ) field_array = THIS % baryon_density CASE ( \"energy_density\" ) field_array = THIS % energy_density CASE ( \"specific_energy\" ) field_array = THIS % specific_energy CASE ( \"v_euler_x\" ) field_array = THIS % v_euler_x CASE ( \"v_euler_y\" ) field_array = THIS % v_euler_y CASE ( \"v_euler_z\" ) field_array = THIS % v_euler_z CASE DEFAULT PRINT * , \"** There is no field named \" , field , \"in TYPE diffstar.\" STOP END SELECT select_field END PROCEDURE get_field_array MODULE PROCEDURE get_field_value !************************************************ ! !# Returns the value of one of the member arrays, !  selected with the string input, at the point !  given as argument. ! !  FT 25.10.2021 ! !************************************************ IMPLICIT NONE select_field : SELECT CASE ( field ) CASE ( \"lapse\" ) field_value = THIS % lapse ( n ) CASE ( \"shift_x\" ) field_value = THIS % shift_x ( n ) CASE ( \"shift_y\" ) field_value = THIS % shift_y ( n ) CASE ( \"shift_z\" ) field_value = THIS % shift_z ( n ) CASE ( \"g_xx\" ) field_value = THIS % g_xx ( n ) CASE ( \"g_xy\" ) field_value = THIS % g_xy ( n ) CASE ( \"g_xz\" ) field_value = THIS % g_xz ( n ) CASE ( \"g_yy\" ) field_value = THIS % g_yy ( n ) CASE ( \"g_yz\" ) field_value = THIS % g_yz ( n ) CASE ( \"g_zz\" ) field_value = THIS % g_zz ( n ) CASE ( \"k_xx\" ) field_value = THIS % k_xx ( n ) CASE ( \"k_xy\" ) field_value = THIS % k_xy ( n ) CASE ( \"k_xz\" ) field_value = THIS % k_xz ( n ) CASE ( \"k_yy\" ) field_value = THIS % k_yy ( n ) CASE ( \"k_yz\" ) field_value = THIS % k_yz ( n ) CASE ( \"k_zz\" ) field_value = THIS % k_zz ( n ) CASE ( \"baryon_density\" ) field_value = THIS % baryon_density ( n ) CASE ( \"energy_density\" ) field_value = THIS % energy_density ( n ) CASE ( \"specific_energy\" ) field_value = THIS % specific_energy ( n ) CASE ( \"v_euler_x\" ) field_value = THIS % v_euler_x ( n ) CASE ( \"v_euler_y\" ) field_value = THIS % v_euler_y ( n ) CASE ( \"v_euler_z\" ) field_value = THIS % v_euler_z ( n ) CASE DEFAULT PRINT * , \"** There is no field named \" , field , \"in TYPE diffstar.\" STOP END SELECT select_field END PROCEDURE get_field_value MODULE PROCEDURE get_diffstar_identifier !************************************************ ! !# Returns the value of [[diffstar_identifier]], the !  integer identifier of the diffstar object ! !  FT 25.10.2021 ! !************************************************ IMPLICIT NONE get_diffstar_identifier = THIS % diffstar_identifier END PROCEDURE get_diffstar_identifier !MODULE PROCEDURE get_diffstar_ptr ! !  !************************************************ !  ! !  !# Returns the value of [[diffstar_ptr]], the C pointer !  ! to the |lorene|'s |etdiffrot| object !  ! N.B. This variable is global. The pointer !  !      to the second |lorene| |etdiffrot| object will !  !      overwrite the first one, and so on. !  !      This variable stores the pointer to !  !      the last defined |lorene| |etdiffrot| object. !  !      That's why it is not freed in the !  !      destructor of a diffstar object. Presently, it !  !      has to be freed by the user at the end of !  !      the PROGRAM. See the last part of the !  !      PROGRAM in setup_lorene_id.f90, for !  !      example. !  ! !  !  FT 25.10.2021 !  ! !  !************************************************ ! !  IMPLICIT NONE ! !  get_diffstar_ptr= THIS% diffstar_ptr ! !END PROCEDURE get_diffstar_ptr MODULE PROCEDURE get_eos_loreneid !************************************************** ! !# Returns the |lorene| ID-number of the EOS of the DRS ! !  FT ! !************************************************** IMPLICIT NONE get_eos_loreneid = THIS % eos_loreneid END PROCEDURE get_eos_loreneid MODULE PROCEDURE get_eos_parameters !************************************************** ! !# Returns the |eos| parameters of the DRS ! !  FT 2.11.2021 ! !************************************************** IMPLICIT NONE CALL THIS % check_i_matter ( i_matter ) IF ( THIS % eos_loreneid == 1 ) THEN eos_params = [ DBLE ( THIS % eos_loreneid ), THIS % gamma , THIS % kappa ] ELSEIF ( THIS % eos_loreneid == 110 ) THEN eos_params = [ DBLE ( THIS % eos_loreneid ), DBLE ( THIS % npeos ), & THIS % gamma0 , THIS % gamma1 , THIS % gamma2 , THIS % gamma3 , & THIS % kappa0 , THIS % kappa1 , THIS % kappa2 , THIS % kappa3 , & THIS % logP1 , & THIS % logRho0 , THIS % logRho1 , THIS % logRho2 ] ELSEIF ( THIS % eos_loreneid == 17 . OR . THIS % eos_loreneid == 20 ) THEN eos_params = [ DBLE ( THIS % eos_loreneid ) ] ELSE PRINT * , \"** ERROR in SUBROUTINE get_eos_parameters!\" , & \" The EOS on the DRS is unknown! LORENE EOS ID=\" , & THIS % eos_loreneid STOP ENDIF END PROCEDURE get_eos_parameters END SUBMODULE diffstar_lorene_access","tags":"","loc":"sourcefile/submodule_diffstar_lorene_access.f90.html"},{"title":"submodule_diffstar_lorene_params.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_diffstar_lorene_params.f90~~EfferentGraph sourcefile~submodule_diffstar_lorene_params.f90 submodule_diffstar_lorene_params.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_params.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_diffstar_lorene_paramsf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_diffstar_lorene_paramsf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules diffstar_lorene_params Source Code submodule_diffstar_lorene_params.f90 Source Code ! File:         submodule_diffstar_params.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( diffstar_lorene ) diffstar_lorene_params !******************************************** ! !# Implementation of the methods of TYPE diffstar !  that import from |lorene| the !  parameters of the binary system, !  and print them to the standard output. ! !  FT 09.07.2021 ! !******************************************** IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE import_diffstar_params !*************************************************** ! !# Store the parameters of the binary neutron !  stars' |lorene| ID into member variables ! !  FT 5.10.2020 ! !*************************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_CHAR , C_NULL_CHAR USE constants , ONLY : Msun_geo , km2m , lorene2hydrobase , k_lorene2hydrobase , & c_light , cm2km , k_lorene2hydrobase_piecewisepolytrope IMPLICIT NONE INTEGER :: i , nchars INTEGER , PARAMETER :: str_length = 100 CHARACTER ( KIND = C_CHAR ), DIMENSION ( str_length ) :: eos_tmp_c PRINT * PRINT * , \"** Executing the import_diffstar_params subroutine...\" CALL get_diffstar_params ( THIS % diffstar_ptr , & THIS % omega_c , & THIS % mass , & THIS % mass_grav , & THIS % angular_momentum , & THIS % tsw , & THIS % grv2 , & THIS % grv3 , & THIS % r_circ , & THIS % surface_area , & THIS % r_mean , & THIS % r_eq , & THIS % r_eq_pi2 , & THIS % r_eq_pi , & THIS % r_eq_3pi2 , & THIS % r_pole , & THIS % r_ratio , & THIS % r_isco , & THIS % f_isco , & THIS % specific_energy_isco , & THIS % specific_angular_momentum_isco , & THIS % area_radius , & THIS % ent_center , & THIS % nbar_center , & THIS % rho_center , & THIS % energy_density_center , & THIS % specific_energy_center , & THIS % pressure_center , & THIS % redshift_eqf , & THIS % redshift_eqb , & THIS % redshift_pole , & eos_tmp_c , & THIS % eos_loreneid , & THIS % gamma , & THIS % kappa , & THIS % npeos , & THIS % gamma0 , & THIS % gamma1 , & THIS % gamma2 , & THIS % gamma3 , & THIS % kappa0 , & THIS % kappa1 , & THIS % kappa2 , & THIS % kappa3 , & THIS % logP1 , & THIS % logRho0 , & THIS % logRho1 , & THIS % logRho2 ) ! Convert distances from |lorene| units (km) to SPHINCS units (Msun_geo) ! See MODULE constants for the definition of Msun_geo THIS % r_circ = THIS % r_circ / Msun_geo THIS % r_mean = THIS % r_mean / Msun_geo THIS % area_radius = THIS % area_radius / Msun_geo THIS % r_eq = THIS % r_eq / Msun_geo THIS % r_eq_pi2 = THIS % r_eq_pi2 / Msun_geo THIS % r_eq_pi = THIS % r_eq_pi / Msun_geo THIS % r_eq_3pi2 = THIS % r_eq_3pi2 / Msun_geo THIS % r_pole = THIS % r_pole / Msun_geo THIS % r_isco = THIS % r_isco / Msun_geo THIS % surface_area = THIS % surface_area / ( Msun_geo ** 2.0D0 ) THIS % radii (:) = [ THIS % r_eq_pi , THIS % r_eq , & THIS % r_eq_pi2 , THIS % r_eq_pi2 , & THIS % r_pole , THIS % r_pole ] THIS % center (:) = [ 0.0D0 , 0.0D0 , 0.0D0 ] THIS % barycenter (:) = [ 0.0D0 , 0.0D0 , 0.0D0 ] ! Convert hydro quantities from |lorene| units to SPHINCS units THIS % nbar_center = THIS % nbar_center * ( MSun_geo * km2m ) ** 3 THIS % rho_center = THIS % rho_center * lorene2hydrobase THIS % energy_density_center = THIS % energy_density_center * lorene2hydrobase THIS % pressure_center = THIS % pressure_center * lorene2hydrobase ! Convert polytropic constants from |lorene| units to SPHINCS units IF ( THIS % eos_loreneid == 1 ) THEN ! If the EOS is polytropic THIS % kappa = THIS % kappa * k_lorene2hydrobase ( THIS % gamma ) ELSEIF ( THIS % gamma0 /= 0 ) THEN ! If the EOS is piecewise polytropic THIS % kappa0 = THIS % kappa0 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma0 ) THIS % kappa1 = THIS % kappa1 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma1 ) THIS % kappa2 = THIS % kappa2 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma2 ) THIS % kappa3 = THIS % kappa3 & * k_lorene2hydrobase_piecewisepolytrope ( THIS % gamma3 ) ELSEIF ( THIS % eos_loreneid == 17 . OR . THIS % eos_loreneid == 20 ) THEN ! If the EOS is tabulated ELSE PRINT * , \"** ERROR in SUBROUTINE import_lorene_id_params!\" , & \" The equation of state is unknown! LORENE EOS IDs=\" , & THIS % eos_loreneid , \", \" , THIS % eos_loreneid STOP ENDIF ! Convert C++ strings to FORTRAN strings i = 1 DO IF ( eos_tmp_c ( i ) == C_NULL_CHAR . OR . i == str_length ) EXIT i = i + 1 ENDDO nchars = i - 1 ALLOCATE ( CHARACTER ( nchars ) :: THIS % eos , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error for string eos. \" , & \"The error message is \" , err_msg PRINT * , \"The STAT variable is \" , ios STOP ENDIF THIS % eos = TRANSFER ( eos_tmp_c ( 1 : nchars ), THIS % eos ) CALL print_diffstar_params ( THIS ) PRINT * , \"** Subroutine import_diffstar_params executed.\" PRINT * END PROCEDURE import_diffstar_params MODULE PROCEDURE print_diffstar_params !**************************************************** ! !# Print the parameters of the binary neutron !  stars' initial data computed by |lorene| ! !  FT 8.10.2020 ! !**************************************************** USE constants , ONLY : k_lorene2hydrobase , Msun_geo , km2m , m2cm , kg2g , & lorene2hydrobase , c_light , cm2km IMPLICIT NONE IF ( THIS % angular_momentum == 0.0D0 ) THEN PRINT * PRINT * , \" ** The parameters have not ben read yet. \" , & \"Call the SUBROUTINE import_diffstar_params to read them.\" PRINT * ELSE PRINT * PRINT * , \" ** The parameters of the differentially rotating star are:\" PRINT * PRINT * , \" Baryonic mass = \" , THIS % mass , \" M_sun\" PRINT * , \" Gravitational mass = \" , THIS % mass_grav , \" M_sun\" PRINT * , \" Angular momentum = \" , THIS % angular_momentum , \" G M_sun&#94;2 /c\" PRINT * , \" Surface area = \" , THIS % surface_area , \" M_sun&#94;2\" , & THIS % surface_area * Msun_geo ** 2.0D0 , \" km&#94;2\" PRINT * PRINT * , \" Radii: \" PRINT * , \"  Areal (or circumferential) radius for the star in the\" , & \"  binary system [the one used in the\" , & \"  (gravitational)mass-(areal)radius diagrams\" ,& \"  is for a TOV star], x direction:\" , & THIS % area_radius , \" M_sun&#94;geo = \" , & THIS % area_radius * Msun_geo , \" km\" , & THIS % r_circ , \" M_sun&#94;geo = \" , & THIS % r_circ * Msun_geo , \" km\" PRINT * , \"  Mean radius = \" , THIS % r_mean , \" M_sun&#94;geo\" PRINT * , \"  Equatorial radius at phi=0 = \" , THIS % r_eq , \" M_sun&#94;geo\" PRINT * , \"  Equatorial radius at phi=pi/2 = \" , THIS % r_eq_pi2 , & \" M_sun&#94;geo\" PRINT * , \"  Equatorial radius at phi=pi = \" , THIS % r_eq_pi , \" M_sun&#94;geo\" PRINT * , \"  Equatorial radius at phi=3pi/2 = \" , THIS % r_eq_3pi2 , & \" M_sun&#94;geo\" PRINT * , \"  Polar radius = \" , THIS % r_pole , \" M_sun&#94;geo\" PRINT * , \"  Polar radius/(Equatorial radius at phi=0) = \" , & THIS % r_ratio PRINT * , \" Radius of the Innermost Stable Circular Orbit (ISCO) = \" , & THIS % r_isco , \" M_sun&#94;geo\" PRINT * , \" Orbital frequency of the Innermost Stable Circular Orbit \" , & \"(ISCO) = \" , THIS % f_isco , \" M_sun&#94;geo\" PRINT * , \" Specific energy of a test particle at the Innermost Stable \" , & \"Circular Orbit (ISCO) \" , THIS % specific_energy_isco , & \" c&#94;2\" PRINT * , \" Specific angular momentum of a test particle at the \" , & \"Innermost Stable Circular Orbit (ISCO) \" , & THIS % specific_angular_momentum_isco , \" G M_sun /c\" PRINT * PRINT * , \" Hydro quantities at the center of the star: \" PRINT * , \"  Central enthalpy = \" , THIS % ent_center , \" c&#94;2\" PRINT * , \"  Central baryon number density = \" , THIS % nbar_center , & \" (M_sun&#94;geo)&#94;{-3} =\" , & THIS % nbar_center / ( MSun_geo * km2m * m2cm ) ** 3 , \"cm&#94;{-3}\" PRINT * , \"  Central baryon mass density = \" , THIS % rho_center , & \" M_sun&#94;geo (M_sun&#94;geo)&#94;{-3} =\" , & THIS % rho_center / lorene2hydrobase * kg2g / ( m2cm ** 3 ), \"g cm&#94;{-3}\" PRINT * , \"  Central energy density = \" , THIS % energy_density_center , & \" M_sun&#94;geo c&#94;2 (M_sun&#94;geo)&#94;{-3}\" , & THIS % energy_density_center / lorene2hydrobase * kg2g / ( m2cm ** 3 ), & \"g c&#94;2 cm&#94;{-3}\" PRINT * , \"  Central specific energy = \" , THIS % specific_energy_center , & \" c&#94;2\" PRINT * , \"  Central pressure = \" , THIS % pressure_center , & \" M_sun&#94;geo c&#94;2 (M_sun&#94;geo)&#94;{-3}\" , & THIS % pressure_center / lorene2hydrobase * kg2g / ( m2cm ** 3 ), & \"g c&#94;2 cm&#94;{-3}\" PRINT * , \" Equations of state for star 1 (EOS1) = \" , TRIM ( THIS % eos ) IF ( THIS % eos_loreneid == 1 ) THEN ! If the EOS is polytropic PRINT * , \" Parameters for EOS: \" PRINT * , \"  Polytopic index gamma = \" , THIS % gamma PRINT * , \"  Pressure coefficient = \" ,& THIS % kappa / k_lorene2hydrobase ( THIS % gamma ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma = \" , THIS % kappa , & \"[pure number]\" PRINT * ELSEIF ( THIS % gamma0 /= 0 ) THEN ! If the EOS is piecewise polytropic PRINT * , \" Parameters for EOS1: \" PRINT * , \"  Number of polytropic indexes = \" , THIS % npeos PRINT * , \"  Polytopic index gamma0 = \" , THIS % gamma0 PRINT * , \"  Polytopic index gamma1 = \" , THIS % gamma1 PRINT * , \"  Polytopic index gamma2 = \" , THIS % gamma2 PRINT * , \"  Polytopic index gamma3 = \" , THIS % gamma3 PRINT * , \"  Pressure coefficient for the crust (here from SLy) = \" ,& THIS % kappa0 / k_lorene2hydrobase ( THIS % gamma0 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma0 = \" , THIS % kappa0 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the first polytrope = \" ,& THIS % kappa1 / k_lorene2hydrobase ( THIS % gamma1 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma1\" , THIS % kappa1 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the second polytrope = \" ,& THIS % kappa2 / k_lorene2hydrobase ( THIS % gamma2 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma2\" , THIS % kappa2 , & \"[pure number]\" PRINT * , \"  Pressure coefficient for the third polytrope = \" ,& THIS % kappa3 / k_lorene2hydrobase ( THIS % gamma3 ), & \"rho_nuc c&#94;2 / n_nuc&#94;gamma3\" , THIS % kappa3 , & \"[pure number]\" PRINT * , \"  Base 10 exponent of the pressure at the first fiducial \" & // \"density (between gamma_0 and gamma_1) (dyne/cm&#94;2)= \" , & THIS % logP1 PRINT * , \"  Base 10 exponent of first fiducial density (g/cm&#94;3) = \" , & THIS % logRho0 PRINT * , \"  Base 10 exponent of second fiducial density (g/cm&#94;3) = \" ,& THIS % logRho1 PRINT * , \"  Base 10 exponent of third fiducial density (g/cm&#94;3) = \" , & THIS % logRho2 PRINT * ELSEIF ( THIS % eos_loreneid == 17 . OR . THIS % eos_loreneid == 20 ) THEN ! If the EOS is tabulated ELSE PRINT * , \"** ERROR in SUBROUTINE import_lorene_id_params!\" , & \" The equation of state is unknown!\" STOP ENDIF ENDIF END PROCEDURE print_diffstar_params END SUBMODULE diffstar_lorene_params","tags":"","loc":"sourcefile/submodule_diffstar_lorene_params.f90.html"},{"title":"submodule_diffstar_lorene_import.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_diffstar_lorene_import.f90~~EfferentGraph sourcefile~submodule_diffstar_lorene_import.f90 submodule_diffstar_lorene_import.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_import.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_diffstar_lorene_importf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_diffstar_lorene_importf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules diffstar_lorene_import Source Code submodule_diffstar_lorene_import.f90 Source Code ! File:         submodule_bns_methods.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( diffstar_lorene ) diffstar_lorene_import !**************************************************** ! !# Implementation of the methods of TYPE bns that !  import BNS data using |lorene| ! !  FT 25.10.2021 ! !**************************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED IMPLICIT NONE CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! MODULE PROCEDURE import_id_int !************************************************** ! !# Stores the ID in the [[diffstarlorene]] member arrays ! !  FT 25.10.2021 ! !************************************************** USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN IF ( SIZE ( x ) /= SIZE ( y ) . OR . SIZE ( x ) /= SIZE ( z ) & . OR . SIZE ( y ) /= SIZE ( z ) ) THEN PRINT * , \"** ERROR: The sizes of the arrays of positions\" & // \"passed to import_lorene_id are not the same.\" PRINT * STOP ENDIF IF ( ALLOCATED ( THIS % lapse ) . AND . & ALLOCATED ( THIS % shift_x ) . AND . & ALLOCATED ( THIS % shift_y ) . AND . & ALLOCATED ( THIS % shift_z ) . AND . & ALLOCATED ( THIS % g_xx ) . AND . ALLOCATED ( THIS % g_xy ) . AND . & ALLOCATED ( THIS % g_xz ) . AND . ALLOCATED ( THIS % g_yy ) . AND . & ALLOCATED ( THIS % g_yz ) . AND . ALLOCATED ( THIS % g_zz ) . AND . & ALLOCATED ( THIS % k_xx ) . AND . ALLOCATED ( THIS % k_xy ) . AND . & ALLOCATED ( THIS % k_xz ) . AND . ALLOCATED ( THIS % k_yy ) . AND . & ALLOCATED ( THIS % k_yz ) . AND . ALLOCATED ( THIS % k_zz ) . AND . & ALLOCATED ( THIS % baryon_density ) . AND . & ALLOCATED ( THIS % energy_density ) . AND . & ALLOCATED ( THIS % specific_energy ) . AND . & ALLOCATED ( THIS % v_euler_x ) . AND . & ALLOCATED ( THIS % v_euler_y ) . AND . & ALLOCATED ( THIS % v_euler_z ) & ) THEN !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( n, THIS, x, y, z ) & !$OMP             PRIVATE( itr ) import_id_loop : DO itr = 1 , n , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_diffstar_full ( THIS % diffstar_ptr , & x ( itr ) * Msun_geo , & y ( itr ) * Msun_geo , & z ( itr ) * Msun_geo , & THIS % lapse ( itr ), & THIS % shift_x ( itr ), & THIS % shift_y ( itr ), & THIS % shift_z ( itr ), & THIS % g_xx ( itr ), & THIS % k_xx ( itr ), & THIS % k_xy ( itr ), & THIS % k_xz ( itr ), & THIS % k_yy ( itr ), & THIS % k_yz ( itr ), & THIS % k_zz ( itr ), & THIS % baryon_density ( itr ), & THIS % energy_density ( itr ), & THIS % specific_energy ( itr ), & THIS % v_euler_x ( itr ), & THIS % v_euler_y ( itr ), & THIS % v_euler_z ( itr ) ) ENDDO import_id_loop !$OMP END PARALLEL DO DO itr = 1 , n , 1 ! !-- The following follows from the assumption of conformal !-- flatness in |lorene| ! THIS % g_yy ( itr ) = THIS % g_xx ( itr ) THIS % g_zz ( itr ) = THIS % g_xx ( itr ) THIS % g_xy ( itr ) = 0.0D0 THIS % g_xz ( itr ) = 0.0D0 THIS % g_yz ( itr ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN THIS % lapse ( itr ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN THIS % shift_x ( itr ) = 0.0D0 THIS % shift_y ( itr ) = 0.0D0 THIS % shift_z ( itr ) = 0.0D0 ENDIF ! !-- Convert the extrinsic curvature from |lorene| units to !-- |sphincs| units ! THIS % k_xx ( itr ) = THIS % k_xx ( itr ) * Msun_geo THIS % k_xy ( itr ) = THIS % k_xy ( itr ) * Msun_geo THIS % k_xz ( itr ) = THIS % k_xz ( itr ) * Msun_geo THIS % k_yy ( itr ) = THIS % k_yy ( itr ) * Msun_geo THIS % k_yz ( itr ) = THIS % k_yz ( itr ) * Msun_geo THIS % k_zz ( itr ) = THIS % k_zz ( itr ) * Msun_geo ! Print progress on screen perc = 100 * itr / n IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn ELSE PRINT * , \"** ERROR: Memory was not allocated before calling \" & // \"import_id in import_lorene_id (TYPE particles).\" PRINT * STOP ENDIF PRINT * , \"** Subroutine import_lorene_id executed.\" PRINT * ENDIF END PROCEDURE import_id_int MODULE PROCEDURE import_id_full !************************************************** ! !# Stores the ID in non-[[diffstarlorene]]-member arrays !  with the same shape as the [[diffstarlorene]] member arrays ! !  FT 25.10.2021 ! !************************************************** USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN IF ( SIZE ( x ) /= SIZE ( y ) . OR . SIZE ( x ) /= SIZE ( z ) & . OR . SIZE ( y ) /= SIZE ( z ) ) THEN PRINT * , \"** ERROR: The sizes of the arrays of positions\" & // \"passed to import_lorene_id are not the same.\" PRINT * STOP ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( n, THIS, x, y, z, lapse, & !$OMP                     shift_x, shift_y, shift_z, & !$OMP                     g_xx, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, & !$OMP                     baryon_density, energy_density, & !$OMP                     specific_energy, & !$OMP                     u_euler_x, u_euler_y, u_euler_z ) & !$OMP             PRIVATE( itr ) import_id_loop : DO itr = 1 , n , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_diffstar_full ( THIS % diffstar_ptr , & x ( itr ) * Msun_geo , & y ( itr ) * Msun_geo , & z ( itr ) * Msun_geo , & lapse ( itr ), & shift_x ( itr ), & shift_y ( itr ), & shift_z ( itr ), & g_xx ( itr ), & k_xx ( itr ), & k_xy ( itr ), & k_xz ( itr ), & k_yy ( itr ), & k_yz ( itr ), & k_zz ( itr ), & baryon_density ( itr ), & energy_density ( itr ), & specific_energy ( itr ), & u_euler_x ( itr ), & u_euler_y ( itr ), & u_euler_z ( itr ) ) ENDDO import_id_loop !$OMP END PARALLEL DO DO itr = 1 , n , 1 ! !-- The following follows from the assumption of conformal !-- flatness in |lorene| ! g_yy ( itr ) = g_xx ( itr ) g_zz ( itr ) = g_xx ( itr ) g_xy ( itr ) = 0.0D0 g_xz ( itr ) = 0.0D0 g_yz ( itr ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN lapse ( itr ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN shift_x ( itr ) = 0.0D0 shift_y ( itr ) = 0.0D0 shift_z ( itr ) = 0.0D0 ENDIF ! !-- Convert the extrinsic curvature from |lorene| units to !-- |sphincs| units ! k_xx ( itr ) = k_xx ( itr ) * Msun_geo k_xy ( itr ) = k_xy ( itr ) * Msun_geo k_xz ( itr ) = k_xz ( itr ) * Msun_geo k_yy ( itr ) = k_yy ( itr ) * Msun_geo k_yz ( itr ) = k_yz ( itr ) * Msun_geo k_zz ( itr ) = k_zz ( itr ) * Msun_geo ! Print progress on screen perc = 100 * itr / n IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \"** Subroutine import_lorene_id executed.\" PRINT * ENDIF END PROCEDURE import_id_full MODULE PROCEDURE import_id_spacetime !******************************************************* ! !# Stores the spacetime ID in multi-dimensional arrays !  needed to compute the BSSN variables and constraints ! !  FT 22.11.2020 ! !******************************************************* USE constants , ONLY : Msun_geo USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , n_sym4x4 IMPLICIT NONE INTEGER :: i , j , k DOUBLE PRECISION :: detg DOUBLE PRECISION :: detg4 DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: g4 ! g4 is allocatable to allocate it on the heap ! Allocating it on the stack might exceed stack memory, ! causing a segmentation fault ALLOCATE ( g4 ( nx , ny , nz , n_sym4x4 ) ) IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN IF ( . FALSE . & !SHAPE( pos(:,:,:,1) ) /= SHAPE( lapse ) .OR. & !SHAPE( pos(:,:,:,1) ) /= SHAPE( shift(:,:,:,jx) ) & ! .OR. & ! SHAPE( pos(:,:,:,1) ) /= SHAPE( g(:,:,:,1) ) .OR. & ! SHAPE( pos(:,:,:,1) ) /= SHAPE( k(:,:,:,1) ) & ) THEN PRINT * , \"** ERROR: Mismatch in array dimensions\" & // \"in import_id_spacetime.\" PRINT * STOP ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nx, ny, nz, THIS, pos, & !$OMP                     lapse, shift, g, ek ) & !$OMP             PRIVATE( i, j, k ) coords_z : DO k = 1 , nz , 1 coords_y : DO j = 1 , ny , 1 coords_x : DO i = 1 , nx , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_diffstar_spacetime ( THIS % diffstar_ptr , & pos ( i , j , k , jx ) * Msun_geo , & pos ( i , j , k , jy ) * Msun_geo , & pos ( i , j , k , jz ) * Msun_geo , & lapse ( i , j , k ), & shift ( i , j , k , jx ), & shift ( i , j , k , jy ), & shift ( i , j , k , jz ), & g ( i , j , k , jxx ), & ek ( i , j , k , jxx ), & ek ( i , j , k , jxy ), & ek ( i , j , k , jxz ), & ek ( i , j , k , jyy ), & ek ( i , j , k , jyz ), & ek ( i , j , k , jzz ) ) ENDDO coords_x ENDDO coords_y ENDDO coords_z !$OMP END PARALLEL DO DO k = 1 , nz , 1 DO j = 1 , ny , 1 DO i = 1 , nx , 1 ! !-- The following follows from the assumption of !-- conformal flatness in |lorene| ! g ( i , j , k , jyy ) = g ( i , j , k , jxx ) g ( i , j , k , jzz ) = g ( i , j , k , jxx ) g ( i , j , k , jxy ) = 0.0D0 g ( i , j , k , jxz ) = 0.0D0 g ( i , j , k , jyz ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN lapse ( i , j , k ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN shift ( i , j , k , jx ) = 0.0D0 shift ( i , j , k , jy ) = 0.0D0 shift ( i , j , k , jz ) = 0.0D0 ENDIF ! !-- Convert the extrinsic curvature from |lorene| units to !-- |sphincs| units ! ek ( i , j , k , jxx ) = ek ( i , j , k , jxx ) * Msun_geo ek ( i , j , k , jxy ) = ek ( i , j , k , jxy ) * Msun_geo ek ( i , j , k , jxz ) = ek ( i , j , k , jxz ) * Msun_geo ek ( i , j , k , jyy ) = ek ( i , j , k , jyy ) * Msun_geo ek ( i , j , k , jyz ) = ek ( i , j , k , jyz ) * Msun_geo ek ( i , j , k , jzz ) = ek ( i , j , k , jzz ) * Msun_geo detg = 2.0D0 * g ( i , j , k , jxy ) * g ( i , j , k , jxz ) * g ( i , j , k , jyz ) & - g ( i , j , k , jzz ) * g ( i , j , k , jxy ) ** 2 + g ( i , j , k , jyy ) & * ( g ( i , j , k , jxx ) * g ( i , j , k , jzz ) - g ( i , j , k , jxz ) ** 2 ) & - g ( i , j , k , jxx ) * g ( i , j , k , jyz ) ** 2 IF ( ABS ( detg ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spatial metric \" & // \"is effectively 0 at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg=\" , detg PRINT * STOP ELSEIF ( detg < 0 ) THEN PRINT * , \"The determinant of the spatial metric \" & // \"is negative at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg=\" , detg PRINT * STOP ENDIF CALL compute_g4 ( i , j , k , lapse , shift , g , g4 ) CALL determinant_sym4x4_grid ( i , j , k , g4 , detg4 ) IF ( ABS ( detg4 ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spacetime metric \" & // \"is effectively 0 at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg4=\" , detg4 PRINT * STOP ELSEIF ( detg4 > 0 ) THEN PRINT * , \"The determinant of the spacetime metric \" & // \"is positive at the grid point \" & // \"(ix,iy,iz)= (\" , i , \",\" , j , \",\" , k , \").\" PRINT * , \"detg4=\" , detg4 PRINT * STOP ENDIF ! Print progress on screen perc = 100 * ( nx * ny * ( k - 1 ) + nx * ( j - 1 ) + i ) / ( nx * ny * nz ) !perc2= 100.0*DBLE(nx*ny*(iz - 1) + nx*(iy - 1) + ix) & !       /DBLE( nx*ny*nz ) !perc= 100*cnt/( nx*ny*nz ) IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" !WRITE( *, \"(A2,F5.2,A1)\", ADVANCE= \"NO\" ) & !        creturn//\" \", perc2, \"%\" ENDIF ENDDO ENDDO ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \"** Subroutine import_lorene_id executed.\" PRINT * ENDIF END PROCEDURE import_id_spacetime MODULE PROCEDURE import_id_hydro !******************************************************* ! !# Stores the hydro ID in the arrays needed to compute !  the constraints on the refined mesh ! !  FT 25.11.2020 ! !******************************************************* USE constants , ONLY : Msun_geo USE tensor , ONLY : jx , jy , jz IMPLICIT NONE INTEGER :: ix , iy , iz IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( nx, ny, nz, THIS, pos, & !$OMP                     baryon_density, energy_density, & !$OMP                     specific_energy, pressure, u_euler ) & !$OMP             PRIVATE( ix, iy, iz ) coords_z : DO iz = 1 , nz , 1 coords_y : DO iy = 1 , ny , 1 coords_x : DO ix = 1 , nx , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_diffstar_hydro ( THIS % diffstar_ptr , & pos ( ix , iy , iz , jx ) * Msun_geo , & pos ( ix , iy , iz , jy ) * Msun_geo , & pos ( ix , iy , iz , jz ) * Msun_geo , & baryon_density ( ix , iy , iz ), & energy_density ( ix , iy , iz ), & specific_energy ( ix , iy , iz ), & pressure ( ix , iy , iz ), & u_euler ( ix , iy , iz , jx ), & u_euler ( ix , iy , iz , jy ), & u_euler ( ix , iy , iz , jz ) ) ENDDO coords_x ENDDO coords_y ENDDO coords_z !$OMP END PARALLEL DO !      ! Print progress on screen !      perc= 100*(nx*ny*(iz - 1) & !            + nx*(iy - 1) + ix)/( nx*ny*nz ) !      IF( show_progress .AND. MOD( perc, 10 ) == 0 )THEN !        WRITE( *, \"(A2,I2,A1)\", ADVANCE= \"NO\" ) & !                creturn//\" \", perc, \"%\" !      ENDIF ! !    ENDDO coords_x !  ENDDO coords_y !ENDDO coords_z !IF( show_progress ) WRITE( *, \"(A1)\", ADVANCE= \"NO\" ) creturn PRINT * , \"** Subroutine import_lorene_id_hydro executed.\" PRINT * ENDIF END PROCEDURE import_id_hydro MODULE PROCEDURE import_id_particles !**************************************************** ! !# Stores the hydro ID in the arrays needed to !  compute the SPH ID ! !  FT 19.11.2020 ! !**************************************************** USE constants , ONLY : Msun_geo IMPLICIT NONE DOUBLE PRECISION :: detg IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN IF ( SIZE ( x ) /= SIZE ( y ) . OR . SIZE ( x ) /= SIZE ( z ) & . OR . SIZE ( y ) /= SIZE ( z ) ) THEN PRINT * , \"** ERROR: The sizes of the arrays of positions\" & // \"passed to import_lorene_id are not the same.\" PRINT * STOP ENDIF PRINT * , \"** Importing ID on particles...\" !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( n, THIS, x, y, z, lapse, & !$OMP                     shift_x, shift_y, shift_z, & !$OMP                     g_xx, & !$OMP                     baryon_density, energy_density, & !$OMP                     specific_energy, pressure, & !$OMP                     u_euler_x, u_euler_y, u_euler_z ) & !$OMP             PRIVATE( itr ) import_id_loop : DO itr = 1 , n , 1 ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_diffstar_particles ( THIS % diffstar_ptr , & x ( itr ) * Msun_geo , & y ( itr ) * Msun_geo , & z ( itr ) * Msun_geo , & lapse ( itr ), & shift_x ( itr ), & shift_y ( itr ), & shift_z ( itr ), & g_xx ( itr ), & baryon_density ( itr ), & energy_density ( itr ), & specific_energy ( itr ), & pressure ( itr ), & u_euler_x ( itr ), & u_euler_y ( itr ), & u_euler_z ( itr ) ) ENDDO import_id_loop !$OMP END PARALLEL DO DO itr = 1 , n , 1 ! !-- The following follows from the assumption of conformal !-- flatness in |lorene| ! g_yy ( itr ) = g_xx ( itr ) g_zz ( itr ) = g_xx ( itr ) g_xy ( itr ) = 0.0D0 g_xz ( itr ) = 0.0D0 g_yz ( itr ) = 0.0D0 ! !- Set/unset the geodesic gauge ! IF ( THIS % get_one_lapse () ) THEN lapse ( itr ) = 1.0D0 ENDIF IF ( THIS % get_zero_shift () ) THEN shift_x ( itr ) = 0.0D0 shift_y ( itr ) = 0.0D0 shift_z ( itr ) = 0.0D0 ENDIF detg = 2 * g_xy ( itr ) * g_xz ( itr ) * g_yz ( itr ) & - g_zz ( itr ) * g_xy ( itr ) ** 2 & + g_yy ( itr ) * ( g_xx ( itr ) * g_zz ( itr ) - g_xz ( itr ) ** 2 ) & - g_xx ( itr ) * g_yz ( itr ) ** 2 IF ( ABS ( detg ) < 1 D - 10 ) THEN PRINT * , \"The determinant of the spatial metric is \" & // \"effectively 0 at the particle \" , itr PRINT * , \"detg=\" , detg PRINT * STOP ELSEIF ( detg < 0 ) THEN PRINT * , \"The determinant of the spatial metric is \" & // \"negative at the particle \" , itr PRINT * , \"detg=\" , detg PRINT * STOP ENDIF ! Print progress on screen perc = 100 * itr / n IF ( show_progress . AND . MOD ( perc , 10 ) == 0 ) THEN WRITE ( * , \"(A2,I2,A1)\" , ADVANCE = \"NO\" ) & creturn // \" \" , perc , \"%\" ENDIF ENDDO IF ( show_progress ) WRITE ( * , \"(A1)\" , ADVANCE = \"NO\" ) creturn PRINT * , \"** Subroutine import_id_particles executed.\" PRINT * ENDIF END PROCEDURE import_id_particles MODULE PROCEDURE import_id_mass_b !**************************************************** ! !# Stores the hydro ID in the arrays needed to !  compute the baryon mass, storing it to variables !  (not arrays as the others SUBROUTINES in !  the [[bns_import]] SUBMODULE). ! !  FT 15.04.2021 ! !**************************************************** USE constants , ONLY : Msun_geo , lorene2hydrobase IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo CALL get_diffstar_mass_b ( THIS % diffstar_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo , & g_xx , & baryon_density , & gamma_euler ) baryon_density = baryon_density * lorene2hydrobase ENDIF END PROCEDURE import_id_mass_b MODULE PROCEDURE import_id_k !**************************************************** ! !# Stores the components of the extrinsic curvature !  in arrays ! !  @warning DEPRECATED ! !  FT 25.10.2021 ! !**************************************************** END PROCEDURE import_id_k !-----------------! !--  FUNCTIONS  --! !-----------------! MODULE PROCEDURE import_mass_density !*********************************************** ! !# Returns the |lorene| mass density at the point !  given as argument, in units of !  M_\\odot/L_\\odot&#94;3. ! !  FT ! !*********************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED USE constants , ONLY : Msun_geo , lorene2hydrobase IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo res = get_diffstar_mass_density ( THIS % diffstar_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo ) * lorene2hydrobase ENDIF END PROCEDURE import_mass_density MODULE PROCEDURE import_spatial_metric !*********************************************** ! !# Returns the |lorene| conformal factor to the !  4th power, equal to the diagonal components !  of the conformally flat spatial ADM metric. ! !  FT 15.04.2021 ! !*********************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo res = get_diffstar_spatial_metric ( THIS % diffstar_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo ) ENDIF END PROCEDURE import_spatial_metric MODULE PROCEDURE is_hydro_negative !************************************************ ! !# Return 1 if the energy density is nonpositive !  or if the specific energy is nonpositive, !  or if the pressure is nonpositive !  at the specified point ! !  FT 25.10.2021 ! !************************************************ USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED USE constants , ONLY : Msun_geo IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN ! The coordinates need to be converted from |sphincs| units (Msun_geo) ! to |lorene| units (\\mathrm{km}). See MODULE constants for the definition of ! Msun_geo res = negative_hydro ( THIS % diffstar_ptr , & x * Msun_geo , & y * Msun_geo , & z * Msun_geo ) ENDIF END PROCEDURE is_hydro_negative END SUBMODULE diffstar_lorene_import","tags":"","loc":"sourcefile/submodule_diffstar_lorene_import.f90.html"},{"title":"module_diffstar_lorene.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~module_diffstar_lorene.f90~~EfferentGraph sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~module_diffstar_lorene.f90~~AfferentGraph sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_access.f90 submodule_diffstar_lorene_access.f90 sourcefile~submodule_diffstar_lorene_access.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_memory.f90 submodule_diffstar_lorene_memory.f90 sourcefile~submodule_diffstar_lorene_memory.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_params.f90 submodule_diffstar_lorene_params.f90 sourcefile~submodule_diffstar_lorene_params.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_sphincs_lorene.f90 module_sphincs_lorene.f90 sourcefile~module_sphincs_lorene.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_constructor.f90 submodule_diffstar_lorene_constructor.f90 sourcefile~submodule_diffstar_lorene_constructor.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_import.f90 submodule_diffstar_lorene_import.f90 sourcefile~submodule_diffstar_lorene_import.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~convergence_test.f90 convergence_test.f90 sourcefile~convergence_test.f90->sourcefile~module_sphincs_lorene.f90 sourcefile~sphincs_lorene_bns.f90 sphincs_lorene_bns.f90 sourcefile~sphincs_lorene_bns.f90->sourcefile~module_sphincs_lorene.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules diffstar_lorene Source Code module_diffstar_lorene.f90 Source Code ! File:         module_diffstar_lorene.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) MODULE diffstar_lorene !*********************************************************** ! !#  This module contains the definition of TYPE diffstarlorene, !   and the SUBROUTINES that bind to the methods !   of |lorene|'s class |etrotdiff|, defined in !   Lorene/Export/C++/Source/Etoile ! !   [|lorene| official repository](https://lorene.obspm.fr/index.html){:target=\"_blank\"} ! !*********************************************************** USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_INT , C_DOUBLE , C_CHAR , C_PTR USE diffstar_base , ONLY : diffstarbase USE utility , ONLY : itr , ios , err_msg , test_status , & perc , creturn , compute_g4 , & determinant_sym4x4_grid , show_progress USE timing , ONLY : timer IMPLICIT NONE !******************************************************* !                                                      * !            Definition of TYPE diffstarlorene         * !                                                      * !   This class imports and stores the |lorene| DRS ID  * !                                                      * !******************************************************* TYPE , EXTENDS ( diffstarbase ) :: diffstarlorene !! TYPE representing a differentially rotating star (DRS) PRIVATE INTEGER :: diffstar_identifier = 0 !! Identifier of the diffstarlorene object INTEGER :: eos_loreneid !! |lorene| identifier for the EoS ! !-- Spacetime fields ! !> 1-D array storing the lapse function DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: lapse !> 1-D array storing the x component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_x !> 1-D array storing the y component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_y !> 1-D array storing the z component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_z !> 1-D array storing the xx component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xx !> 1-D array storing the xy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xy !> 1-D array storing the xz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xz !> 1-D array storing the yy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yy !> 1-D array storing the yz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yz !> 1-D array storing the zz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_zz !& 1-D array storing the xx component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xx !& 1-D array storing the xy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xy !& 1-D array storing the xz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xz !& 1-D array storing the yy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yy !& 1-D array storing the yz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yz !& 1-D array storing the zz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_zz ! !-- Hydro fields ! !> 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: baryon_density !> 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: energy_density !> 1-D array storing the specific internal energy [c&#94;2] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: specific_energy !> 1-D array storing the x component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_x !> 1-D array storing the y component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_y !> 1-D array storing the z component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_z !& C pointer to the |lorene|'s Etdiffrot object ! N.B. This variable is global. The pointer to the second |lorene| Etdiffrot !      object will overwrite the first one, and so on. !      This variable stores the pointer to the last defined |lorene| Etdiffrot !      object. That's why it is not freed in the destructor of a bns object. !      Presently, it has to be freed by the user at the end of the PROGRAM. !      See the last part of the PROGRAM in setup_diffstar.f90, for example. TYPE ( C_PTR ) :: diffstar_ptr CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: construct_drs !! Constructs the |lorene| Etdiffrot object PROCEDURE :: destruct_drs !! Destructs the |lorene| Etdiffrot object PROCEDURE :: allocate_diffstar_memory !! Allocates memory for the [[diffstarlorene]] member arrays PROCEDURE :: deallocate_diffstar_memory !! Deallocates memory for the [[diffstarlorene]] member arrays PROCEDURE :: import_diffstar_params !! Imports the parameters of the DRS from |lorene| PROCEDURE , PUBLIC :: print_diffstar_params !! Prints the parameters of the DRS to the standard output PROCEDURE :: import_id_int !! Stores the ID in the [[diffstarlorene]] member arrays PROCEDURE :: read_id_full => import_id_full PROCEDURE :: read_id_spacetime => import_id_spacetime PROCEDURE :: read_id_particles => import_id_particles PROCEDURE :: read_id_hydro => import_id_hydro PROCEDURE :: read_id_mass_b => import_id_mass_b PROCEDURE :: read_id_k => import_id_k !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE :: read_mass_density => import_mass_density !! Returns the |lorene|'s mass density at the given point PROCEDURE :: import_spatial_metric !! Returns the |lorene|'s conformally flat spatial ADM metric PROCEDURE :: test_position => is_hydro_negative !# Returns 1 if the energy density or the specific energy or the pressure !  are negative ! !-- Overloaded FUNCTION to access the fields as arrays and as values ! GENERIC , PUBLIC :: get_field => get_fa , get_fv !# GENERIC PROCEDURE, overloded to access the [[diffstarlorene]]-member !  variables as arrays and as values PROCEDURE :: get_fa => get_field_array !! Access the [[diffstarlorene]]-member arrays PROCEDURE :: get_fv => get_field_value !! Access the components of the [[diffstarlorene]]-member arrays ! !-- FUNCTIONS that access member variables ! PROCEDURE :: get_eos_id => get_eos_loreneid !! Returns the |lorene| identifier for the EOS PROCEDURE :: return_eos_parameters => get_eos_parameters PROCEDURE , PUBLIC :: get_eos_loreneid !! Returns [[diffstarlorene:eos_loreneid]] PROCEDURE , PUBLIC :: get_diffstar_identifier !! Returns [[diffstarlorene:diffstar_identifier]]] !PROCEDURE, PUBLIC:: get_diffstar_ptr FINAL :: destruct_diffstarlorene !! Finalizer (Destructor) of a [[diffstarlorene]] object END TYPE diffstarlorene ! !-- Interface of the TYPE diffstarlorene !-- (i.e., declaration of the constructor) ! INTERFACE diffstarlorene !! Interface of TYPE [[diffstarlorene]] MODULE PROCEDURE :: construct_diffstarlorene !! Constructs a [[diffstarlorene]] object END INTERFACE diffstarlorene ! !-- Interfaces of the constructor and destructor of the TYPE diffstarlorene ! INTERFACE MODULE FUNCTION construct_diffstarlorene ( resu_file ) RESULT ( drs ) !! Constructs a [[diffstarlorene]] object CHARACTER ( LEN =* ), INTENT ( IN ), OPTIONAL :: resu_file !! |lorene| binary file containing the spectral DRS ID TYPE ( diffstarlorene ) :: drs !! Constructed [[diffstarlorene]] object END FUNCTION construct_diffstarlorene MODULE SUBROUTINE destruct_diffstarlorene ( THIS ) !! Destruct a [[diffstarlorene]] object TYPE ( diffstarlorene ), INTENT ( IN OUT ) :: THIS !! [[diffstarlorene]] object to be destructed END SUBROUTINE destruct_diffstarlorene END INTERFACE ! !-- Interfaces of the methods of the TYPE diffstarlorene !-- Their implementations are in submodule_diffstarlorene_methods.f90 ! INTERFACE ! !-- SUBROUTINES ! MODULE SUBROUTINE construct_drs ( THIS , resu_file ) !! Interface of the subroutine that constructs the |lorene| Etdiffrot object !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS !> |lorene| binary file containing the spectral DRS ID CHARACTER ( KIND = C_CHAR , LEN =* ), INTENT ( IN ), OPTIONAL :: resu_file END SUBROUTINE construct_drs MODULE SUBROUTINE destruct_drs ( THIS ) !! Destructs a |lorene| Etdiffrot object !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE destruct_drs MODULE SUBROUTINE allocate_diffstar_memory ( THIS , d ) !! Allocates allocatable arrays member of a [[diffstarlorene]] object !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS !> Dimension of the arrays INTEGER , INTENT ( IN ) :: d END SUBROUTINE allocate_diffstar_memory MODULE SUBROUTINE deallocate_diffstar_memory ( THIS ) !! Deallocates allocatable arrays member of a [[diffstarlorene]] object !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE deallocate_diffstar_memory MODULE SUBROUTINE import_diffstar_params ( THIS ) !! Imports the DRS parameters from |lorene| !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE import_diffstar_params MODULE SUBROUTINE print_diffstar_params ( THIS ) !! Prints the DRS parameters to the standard output !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS END SUBROUTINE print_diffstar_params MODULE SUBROUTINE import_id_int ( THIS , n , x , y , z ) !! Stores the ID in the [[diffstarlorene]] member arrays !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z END SUBROUTINE import_id_int MODULE SUBROUTINE import_id_full ( THIS , n , x , y , z ,& lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz , & baryon_density , & energy_density , & specific_energy , & u_euler_x , u_euler_y , u_euler_z ) !# Stores the ID in non [[diffstarlorene]]-member arrays with the same !  shape as the [[diffstarlorene]] member arrays !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_z END SUBROUTINE import_id_full MODULE SUBROUTINE import_id_spacetime ( THIS , nx , ny , nz , & pos , & lapse , & shift , & g , & ek ) !# Stores the spacetime ID in multi-dimensional arrays needed to compute !  the BSSN variables and constraints !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: nx INTEGER , INTENT ( IN ) :: ny INTEGER , INTENT ( IN ) :: nz DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: shift DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: g DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: ek END SUBROUTINE import_id_spacetime MODULE SUBROUTINE import_id_hydro ( THIS , nx , ny , nz , & pos , & baryon_density , & energy_density , & specific_energy , & pressure , & u_euler ) !# Stores the hydro ID in the arrays needed to compute the constraints !  on the refined mesh !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: nx INTEGER , INTENT ( IN ) :: ny INTEGER , INTENT ( IN ) :: nz DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: pressure DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: u_euler END SUBROUTINE import_id_hydro MODULE SUBROUTINE import_id_particles ( THIS , n , x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_xx , g_xy , g_xz , & g_yy , g_yz , g_zz , & baryon_density , & energy_density , & specific_energy , & pressure , & u_euler_x , u_euler_y , u_euler_z ) !! Stores the hydro ID in the arrays needed to compute the SPH ID !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n REAL ( C_DOUBLE ), DIMENSION (:), INTENT ( IN ) :: x REAL ( C_DOUBLE ), DIMENSION (:), INTENT ( IN ) :: y REAL ( C_DOUBLE ), DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: lapse DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: shift_z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: g_zz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: energy_density DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: specific_energy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: pressure DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: u_euler_z END SUBROUTINE import_id_particles MODULE SUBROUTINE import_id_mass_b ( THIS , x , y , z , & g_xx , & baryon_density , & gamma_euler ) !! Stores the hydro ID in the arrays needed to compute the baryon mass !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z DOUBLE PRECISION , INTENT ( IN OUT ) :: g_xx DOUBLE PRECISION , INTENT ( IN OUT ) :: baryon_density DOUBLE PRECISION , INTENT ( IN OUT ) :: gamma_euler END SUBROUTINE import_id_mass_b MODULE SUBROUTINE import_id_k ( THIS , n , x , y , z ,& k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz ) !! Stores the components of the extrinsic curvature in arrays !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: n DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: x DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: y DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: z DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xx DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_xz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yy DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_yz DOUBLE PRECISION , DIMENSION (:), INTENT ( IN OUT ) :: k_zz END SUBROUTINE import_id_k ! !-- FUNCTIONS ! MODULE FUNCTION import_mass_density ( THIS , x , y , z ) RESULT ( res ) !! Returns the |lorene| baryon mass density at a point (x,y,z) !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN ) :: THIS !> x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: x !> y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: y !> z coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: z !> Baryon mass density at (x,y,z) DOUBLE PRECISION :: res END FUNCTION import_mass_density MODULE FUNCTION import_spatial_metric ( THIS , x , y , z ) RESULT ( res ) !# Returns the |lorene| conformally flat spatial metric component !  g_{xx}=g_{yy}=g_{zz} at a point (x,y,z) !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN ) :: THIS !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !> g_{xx}=g_{yy}=g_{zz} at (x,y,z) REAL ( C_DOUBLE ) :: res END FUNCTION import_spatial_metric MODULE FUNCTION is_hydro_negative ( THIS , x , y , z ) RESULT ( res ) !# Returns 1 if the energy density or the specific energy or the pressure !  are negative, 0 otherwise !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN ) :: THIS !> x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: x !> y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: y !> z coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ), VALUE :: z !& 1 if the energy density or the specific energy or the pressure !  are negative, 0 otherwise INTEGER :: res END FUNCTION is_hydro_negative MODULE FUNCTION get_field_array ( THIS , field ) RESULT ( field_array ) !! Returns the [[diffstarlorene]] member arrays named field !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN ) :: THIS !> Name of the desired [[diffstarlorene]] member array CHARACTER ( LEN = : ), INTENT ( IN ), ALLOCATABLE :: field !> Desired [[diffstarlorene]] member array DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: field_array END FUNCTION get_field_array MODULE FUNCTION get_field_value ( THIS , field , n ) RESULT ( field_value ) !! Returns the component n of the [[diffstarlorene]] member arrays named field !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN ) :: THIS !> Name of the desired [[diffstarlorene]] member array CHARACTER ( LEN = : ), INTENT ( IN ), ALLOCATABLE :: field !> Component of the desired [[diffstarlorene]] member array INTEGER , INTENT ( IN ) :: n !> Component n of the desired [[diffstarlorene]] member array DOUBLE PRECISION :: field_value END FUNCTION get_field_value MODULE FUNCTION get_diffstar_identifier ( THIS ) !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN ) :: THIS ! Result DOUBLE PRECISION :: get_diffstar_identifier END FUNCTION get_diffstar_identifier MODULE FUNCTION get_eos_loreneid ( THIS ) !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN ) :: THIS ! Result INTEGER :: get_eos_loreneid END FUNCTION get_eos_loreneid MODULE SUBROUTINE get_eos_parameters ( THIS , i_matter , eos_params ) !> [[diffstarlorene]] object which this PROCEDURE is a member of CLASS ( diffstarlorene ), INTENT ( IN OUT ) :: THIS INTEGER , INTENT ( IN ) :: i_matter !! Index of the matter object whose parameter is to return DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( OUT ) :: eos_params !# Array containing the parameters of the |eos| for the DRS END SUBROUTINE get_eos_parameters !MODULE FUNCTION get_diffstar_ptr( THIS ) ! !  ! Argument !  CLASS(diffstarlorene), INTENT( IN ):: THIS !  ! Result !  TYPE(C_PTR):: get_diffstar_ptr ! !END FUNCTION get_diffstar_ptr END INTERFACE PRIVATE :: construct_etdiffrot , get_diffstar_full , get_diffstar_spacetime , & get_diffstar_particles , get_diffstar_mass_b , & get_diffstar_hydro , get_diffstar_mass_density , & get_diffstar_spatial_metric , negative_hydro , get_diffstar_params , & destruct_etdiffrot !-----------------------------------------------------------------! !--  Interfaces to the methods of |lorene|'s class |etdiffrot|  --! !-----------------------------------------------------------------! INTERFACE FUNCTION construct_etdiffrot ( c_resu_file ) RESULT ( optr ) & BIND ( C , NAME = \"construct_et_diffrot\" ) !*********************************************** ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that constructs !  the |lorene| |etdiffrot| object ! !  FT 24.10.2021 ! !*********************************************** IMPORT :: C_PTR , C_CHAR IMPLICIT NONE !& C string of the name of the |lorene| binary file storing the spectral !  DRS ID CHARACTER ( KIND = C_CHAR ), DIMENSION ( * ), INTENT ( IN ), OPTIONAL :: & c_resu_file !> C pointer pointing to the constructed |lorene| |etdiffrot| object TYPE ( C_PTR ) :: optr END FUNCTION construct_etdiffrot SUBROUTINE get_diffstar_full ( optr , & x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_diag , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz , & baryon_density , & energy_density , & specific_energy , & v_euler_x , v_euler_y , v_euler_z ) & BIND ( C , NAME = \"get_rotdiff_id\" ) !************************************************* ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that reads the full !  |lorene| ID at the specified point. !  That is, imports the metric fields, the !  components of the extrinsic curvature [c/km], !  and the hydro fields. ! !  - shift vector [c] !  - baryon mass density [kg m&#94;{-3}] !  - energy density [kg c&#94;2 m&#94;{-3}] !  - pressure [kg c&#94;2 m&#94;{-3}] !  - specific internal energy [c&#94;2] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT 24.10.2021 ! !************************************************* IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: lapse REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xx REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_zz REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_z END SUBROUTINE get_diffstar_full SUBROUTINE get_diffstar_spacetime ( optr , & x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_diag , & k_xx , k_xy , k_xz , & k_yy , k_yz , k_zz ) & BIND ( C , NAME = \"get_rotdiff_spacetime\" ) !************************************************* ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that reads the !  metric fields and the components !  of the extrinsic curvature [c/km] from |lorene|, !  at the specified point ! !  FT 24.10.2021 ! !************************************************* IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: lapse REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xx REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_xz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yy REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_yz REAL ( C_DOUBLE ), INTENT ( OUT ) :: k_zz END SUBROUTINE get_diffstar_spacetime SUBROUTINE get_diffstar_particles ( optr , & x , y , z , & lapse , & shift_x , shift_y , shift_z , & g_diag , & baryon_density , & energy_density , & specific_energy , & pressure , & v_euler_x , v_euler_y , v_euler_z ) & BIND ( C , NAME = \"get_rotdiff_particles\" ) !********************************************** ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that reads the !  hydro fields and the metric fields * !  from |lorene|, at the specified point ! !  - shift vector [c] !  - baryon mass density [kg m&#94;{-3}] !  - energy density [kg c&#94;2 m&#94;{-3}] !  - pressure [kg c&#94;2 m&#94;{-3}] !  - specific internal energy [c&#94;2] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT 24.10.2021 ! !********************************************** IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: lapse REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: shift_z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy REAL ( C_DOUBLE ), INTENT ( OUT ) :: pressure REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_z END SUBROUTINE get_diffstar_particles SUBROUTINE get_diffstar_mass_b ( optr , & x , y , z , & g_diag , & baryon_density , & gamma_euler ) & BIND ( C , NAME = \"get_rotdiff_mass_b\" ) !************************************************ ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that reads the !  hydro fields and the metric fields !  from |lorene|, at the specified point, !  needed to compute the baryon mass. ! !  - shift vector [c] !  - baryon mass density [kg m&#94;{-3}] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT 24.10.2021 ! !************************************************ IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !> g_{xx}=g_{yy}=g_{zz} at x,y,z REAL ( C_DOUBLE ), INTENT ( OUT ) :: g_diag !> Baryon mass density at x,y,z REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density !& Relative Lorentz factor between the 4-velocity of the fluid !  wrt the Eulerian observer and the 4-velocity of the Eulerian observer !  at x,y,z REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma_euler END SUBROUTINE get_diffstar_mass_b SUBROUTINE get_diffstar_hydro ( optr , & x , y , z , & baryon_density , & energy_density , & specific_energy , & pressure , & v_euler_x , v_euler_y , v_euler_z ) & BIND ( C , NAME = \"get_rotdiff_hydro\" ) !*********************************************** ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that reads the !  hydro fields from |lorene|, at the !  specified point ! !  - baryon mass density [kg m&#94;{-3}] !  - energy density [kg c&#94;2 m&#94;{-3}] !  - pressure [kg c&#94;2 m&#94;{-3}] !  - specific internal energy [c&#94;2] !  - fluid 3-velocity with respect to the !    Eulerian observer [c] ! !  FT 24.10.2021 ! !*********************************************** IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z REAL ( C_DOUBLE ), INTENT ( OUT ) :: baryon_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy REAL ( C_DOUBLE ), INTENT ( OUT ) :: pressure REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_x REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_y REAL ( C_DOUBLE ), INTENT ( OUT ) :: v_euler_z END SUBROUTINE get_diffstar_hydro FUNCTION get_diffstar_mass_density ( optr , x , y , z ) RESULT ( res ) & BIND ( C , NAME = \"get_rotdiff_mass_density\" ) !******************************************** ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that returns !  the baryon mass density [\\mathrm{kg}\\, !  \\mathrm{m}&#94;{-3}] from |lorene|, !  at the specified point ! !  FT 24.10.2021 ! !******************************************** IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !& Baryon mass density [\\mathrm{kg}\\, \\mathrm{m}&#94;{-3}] at the desired !  point (x,y,z) REAL ( C_DOUBLE ) :: res END FUNCTION get_diffstar_mass_density FUNCTION get_diffstar_spatial_metric ( optr , x , y , z ) RESULT ( res ) & BIND ( C , NAME = \"get_g_diag\" ) !************************************************ ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that returns the !  diagonal components of the metric, !  all equal to the |lorene| conformal factor to !  the 4th power. ! !  FT 24.10.2021 ! !************************************************ IMPORT :: C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !& Spatial metric component !  g_{xx}=g_{yy}=g_{zz} at the point (x,y,z) REAL ( C_DOUBLE ) :: res END FUNCTION get_diffstar_spatial_metric FUNCTION negative_hydro ( optr , x , y , z ) RESULT ( res ) & BIND ( C , NAME = \"is_hydro_negative\" ) !************************************************ ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that returns 1 !  if the energy density is nonpositive, !  or if the specific energy is nonpositive, !  or if the pressure is nonpositive, !  at the specified point; it returns 0 otherwise ! !  FT 24.10.2021 ! !************************************************ IMPORT :: C_INT , C_DOUBLE , C_PTR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !> x coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: x !> y coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: y !> z coordinate of the desired point REAL ( C_DOUBLE ), INTENT ( IN ), VALUE :: z !& 1 if the energy density or the specific energy or the pressure !  are negative, 0 otherwise INTEGER ( C_INT ) :: res END FUNCTION negative_hydro SUBROUTINE get_diffstar_params ( optr , & omega_c , & mass , & mass_grav , & angular_momentum , & tsw , & grv2 , & grv3 , & r_circ , & surface_area , & r_mean , & r_eq , & r_eq_pi2 , & r_eq_pi , & r_eq_3pi2 , & r_eq_pole , & r_ratio , & r_isco , & f_isco , & specific_energy_isco , & specific_angular_momentum_isco , & area_radius , & ent_center , & nbar_center , & rho_center , & energy_density_center , & specific_energy_center , & pressure_center , & redshift_eqf , & redshift_eqb , & redshift_pole , & eos , & eos_id , & gamma , & kappa , & npeos , & gamma0 , & gamma1 , & gamma2 , & gamma3 , & kappa0 , & kappa1 , & kappa2 , & kappa3 , & logP1 , & logRho0 , & logRho1 , & logRho2 ) & BIND ( C , NAME = \"get_rotdiff_params\" ) !********************************************** ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that stores !  the physical parameters of the binary !  system from |lorene| in the desired variables ! !  FT 24.10.2021 ! !********************************************** IMPORT :: C_INT , C_DOUBLE , C_PTR , C_CHAR IMPLICIT NONE !> C pointer pointing to a |lorene| |etdiffrot| object TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr REAL ( C_DOUBLE ), INTENT ( OUT ) :: omega_c REAL ( C_DOUBLE ), INTENT ( OUT ) :: mass REAL ( C_DOUBLE ), INTENT ( OUT ) :: mass_grav REAL ( C_DOUBLE ), INTENT ( OUT ) :: angular_momentum REAL ( C_DOUBLE ), INTENT ( OUT ) :: tsw REAL ( C_DOUBLE ), INTENT ( OUT ) :: grv2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: grv3 REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_circ REAL ( C_DOUBLE ), INTENT ( OUT ) :: surface_area REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_mean REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_eq REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_eq_pi2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_eq_pi REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_eq_3pi2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_eq_pole REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_ratio REAL ( C_DOUBLE ), INTENT ( OUT ) :: r_isco REAL ( C_DOUBLE ), INTENT ( OUT ) :: f_isco REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy_isco REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_angular_momentum_isco REAL ( C_DOUBLE ), INTENT ( OUT ) :: area_radius REAL ( C_DOUBLE ), INTENT ( OUT ) :: ent_center REAL ( C_DOUBLE ), INTENT ( OUT ) :: nbar_center REAL ( C_DOUBLE ), INTENT ( OUT ) :: rho_center REAL ( C_DOUBLE ), INTENT ( OUT ) :: energy_density_center REAL ( C_DOUBLE ), INTENT ( OUT ) :: specific_energy_center REAL ( C_DOUBLE ), INTENT ( OUT ) :: pressure_center REAL ( C_DOUBLE ), INTENT ( OUT ) :: redshift_eqf REAL ( C_DOUBLE ), INTENT ( OUT ) :: redshift_eqb REAL ( C_DOUBLE ), INTENT ( OUT ) :: redshift_pole CHARACTER ( KIND = C_CHAR ), DIMENSION ( 100 ), INTENT ( OUT ) :: eos INTEGER ( C_INT ) :: eos_id REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa INTEGER ( C_INT ) :: npeos REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma0 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: gamma3 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa0 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa2 REAL ( C_DOUBLE ), INTENT ( OUT ) :: kappa3 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logP1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho0 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho1 REAL ( C_DOUBLE ), INTENT ( OUT ) :: logRho2 END SUBROUTINE get_diffstar_params SUBROUTINE destruct_etdiffrot ( optr ) & BIND ( C , NAME = \"destruct_et_diffrot\" ) !********************************************** ! !# Interface to the |lorene| method of class !  |etdiffrot| with the same name, that destructs !  the |lorene| |etdiffrot| object ! ! FT 24.10.2021 ! !********************************************** IMPORT :: C_PTR IMPLICIT NONE TYPE ( C_PTR ), INTENT ( IN ), VALUE :: optr !! C pointer pointing to the |lorene| |etdiffrot| object to destruct END SUBROUTINE destruct_etdiffrot END INTERFACE END MODULE diffstar_lorene","tags":"","loc":"sourcefile/module_diffstar_lorene.f90.html"},{"title":"submodule_diffstar_lorene_constructor.f90 – SPHINCS_LORENE","text":"This file depends on sourcefile~~submodule_diffstar_lorene_constructor.f90~~EfferentGraph sourcefile~submodule_diffstar_lorene_constructor.f90 submodule_diffstar_lorene_constructor.f90 sourcefile~module_diffstar_lorene.f90 module_diffstar_lorene.f90 sourcefile~submodule_diffstar_lorene_constructor.f90->sourcefile~module_diffstar_lorene.f90 sourcefile~module_diffstar_base.f90 module_diffstar_base.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_diffstar_base.f90 sourcefile~module_utility.f90 module_utility.f90 sourcefile~module_diffstar_lorene.f90->sourcefile~module_utility.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_utility.f90 sourcefile~module_id_base.f90 module_id_base.f90 sourcefile~module_diffstar_base.f90->sourcefile~module_id_base.f90 var pansourcefilesubmodule_diffstar_lorene_constructorf90EfferentGraph = svgPanZoom('#sourcefilesubmodule_diffstar_lorene_constructorf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Submodules diffstar_lorene_constructor Source Code submodule_diffstar_lorene_constructor.f90 Source Code ! File:         submodule_diffstar_constructor.f90 ! Authors:      Francesco Torsello (FT) ! Copyright:    GNU General Public License (GPLv3) SUBMODULE ( diffstar_lorene ) diffstar_lorene_constructor !********************************************************* ! !# Implementation of the constructor and !  destructor of TYPE [[diffstarlorene]], and of the !  [[diffstarlorene]]-member !  PROCEDURES that call the C-bound PROCEDURES !  constructig and destructing the |lorene| !  |etdiffrot| object ! !  FT 25.10.2021 ! !********************************************************* USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_ASSOCIATED , C_NULL_CHAR , C_NULL_PTR IMPLICIT NONE CONTAINS ! !-- Implementation of the constructor of the bns object ! MODULE PROCEDURE construct_diffstarlorene !**************************************************** ! !# Constructs an object of TYPE [[diffstarlorene]] ! !  FT 25.10.2021 ! !**************************************************** IMPLICIT NONE INTEGER , SAVE :: diffstar_counter = 1 CALL drs % set_n_matter ( 1 ) drs % construction_timer = timer ( \"drs_construction_timer\" ) ! Construct |lorene| |etdiffrot| object IF ( PRESENT ( resu_file ) ) THEN CALL drs % construct_drs ( resu_file ) ELSE CALL drs % construct_drs () ENDIF ! Import the parameters of the binary system CALL import_diffstar_params ( drs ) ! Assign a unique identifier to the bns object drs % diffstar_identifier = diffstar_counter diffstar_counter = diffstar_counter + 1 ! Do not use the geodesic gauge by default CALL drs % set_one_lapse ( . FALSE . ) CALL drs % set_zero_shift ( . FALSE . ) END PROCEDURE construct_diffstarlorene ! !-- Implementation of the destructor of the bns object ! MODULE PROCEDURE destruct_diffstarlorene !*********************************************** ! !# Destructs an object of TYPE [[diffstarlorene]] ! !  FT 25.10.2021 ! !*********************************************** IMPLICIT NONE ! Deallocate memory CALL THIS % deallocate_diffstar_memory () END PROCEDURE destruct_diffstarlorene MODULE PROCEDURE construct_drs !*********************************************** ! !# Construct the |lorene| |etdiffrot| object ! !  FT 25.10.2021 ! !*********************************************** IMPLICIT NONE CHARACTER ( KIND = C_CHAR , LEN = 7 ) :: default_case LOGICAL :: exist !PRINT *, \"** Executing the construct_binary subroutine...\" #ifdef __INTEL_COMPILER IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN CALL destruct_etdiffrot ( THIS % diffstar_ptr ) ENDIF #endif ! !-- If the name of the |lorene| binary file resu_file is given as argument to !-- construct_binary, use it. Otherwise, give the string \"read_it\" !-- to construct_drs as argument, which makes |lorene| read the name of !-- the file from the parameter file read_bin_ns.par ! IF ( PRESENT ( resu_file ) ) THEN INQUIRE ( FILE = resu_file , EXIST = exist ) IF ( exist ) THEN CALL THIS % construction_timer % start_timer () THIS % diffstar_ptr = construct_etdiffrot ( resu_file // C_NULL_CHAR ) CALL THIS % construction_timer % stop_timer () ELSE PRINT * , \"** ERROR in SUBROUTINE construct_binary: file \" , & resu_file , \" cannot be found!\" PRINT * STOP ENDIF ELSE default_case = \"read_it\" CALL THIS % construction_timer % start_timer () THIS % diffstar_ptr = construct_etdiffrot ( default_case // C_NULL_CHAR ) CALL THIS % construction_timer % stop_timer () ENDIF END PROCEDURE construct_drs MODULE PROCEDURE destruct_drs !************************************************ ! !# Destructs the |lorene| |etdiffrot| object and frees !  the pointer [[diffstar:diffstar_ptr]] pointing to it ! !  FT 25.10.2021 ! !************************************************ IMPLICIT NONE IF ( C_ASSOCIATED ( THIS % diffstar_ptr ) ) THEN CALL destruct_etdiffrot ( THIS % diffstar_ptr ) THIS % diffstar_ptr = C_NULL_PTR ENDIF END PROCEDURE destruct_drs END SUBMODULE diffstar_lorene_constructor","tags":"","loc":"sourcefile/submodule_diffstar_lorene_constructor.f90.html"},{"title":"formul_3p1 – SPHINCS_LORENE ","text":"type, public, ABSTRACT :: formul_3p1 ABSTRACT TYPE representing a generic 3+1 formulation of the Einsten\n equations Inherits type~~formul_3p1~~InheritsGraph type~formul_3p1 formul_3p1 grid_function grid_function type~formul_3p1->grid_function coords, shift_u, g_phys3_ll, K_phys3_ll, MC, MC_parts level level type~formul_3p1->level levels timer timer type~formul_3p1->timer grid_timer, importer_timer grid_function_scalar grid_function_scalar type~formul_3p1->grid_function_scalar rad_coord, lapse, HC, HC_parts Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~formul_3p1~~InheritedByGraph type~formul_3p1 formul_3p1 type~bssn_id bssn_id type~bssn_id->type~formul_3p1 Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables HC HC_l2 HC_loo HC_parts HC_parts_l2 HC_parts_loo K_phys3_ll MC MC_l2 MC_loo MC_parts MC_parts_l2 MC_parts_loo cons_step coords export_constraints export_constraints_details export_constraints_x export_constraints_xy g_phys3_ll grid_timer importer_timer lapse levels nlevels rad_coord shift_u Type-Bound Procedures abs_values_in analyze_constraint compute_and_export_3p1_constraints compute_and_export_3p1_constraints_grid compute_and_export_3p1_constraints_particles compute_and_export_3p1_variables deallocate_fields deallocate_standard3p1_variables define_allocate_fields get_HC get_HC_parts get_MC get_MC_parts get_dx get_dy get_dz get_grid_point get_levels get_ngrid_x get_ngrid_y get_ngrid_z get_nlevels get_xR get_yR get_zR print_formatted_lorene_id_3p1_variables setup_standard3p1_variables Source Code formul_3p1 Components Type Visibility Attributes Name Initial type(grid_function_scalar), public :: HC Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh\n (i.e., its maximum) type(grid_function_scalar), public :: HC_parts Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) type(grid_function), public :: K_phys3_ll Grid function storing the extrinsic curvature type(grid_function), public :: MC Grid function storing the momentum constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_l2 \\ell_2 norm of the momentum constraint computed on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_loo \\ell_\\infty norm of the momentum constraint computed on the mesh\n (i.e., its maximum) type(grid_function), public :: MC_parts Grid function storing the momentum constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_loo \\ell_\\infty norm of the momentum constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) integer, public :: cons_step Constraint violations are printed to file every cons_step-th grid point type(grid_function), public :: coords Grid function storing the Cartesian coordinates logical, public :: export_constraints .TRUE. if the constraint violations  are to be printed to file, .FALSE. otherwise logical, public :: export_constraints_details .TRUE. if the points at which the constraints violations are within the\n intervals [0,10&#94;{-7}],[10&#94;3,\\infty],[10&#94;n,10&#94;m] , with n\\in\\{-7,2\\} and m=n+1 , are to be printed to file; .FALSE. otherwise logical, public :: export_constraints_x .TRUE. if only the constrain violations on the x axis are to be logical, public :: export_constraints_xy .TRUE. if only the constrain violations on the xy plane are to be type(grid_function), public :: g_phys3_ll Grid function storing the spatial metric type(timer), public :: grid_timer Timer that times how long it takes to set up the grid and allocate\n the grid functions type(timer), public :: importer_timer Timer that times how long it takes to import the \\texttt{LORENE} ID\n on the mesh type(grid_function_scalar), public :: lapse Grid scalar function storing the lapse function type(level), public, DIMENSION(:), ALLOCATABLE :: levels Array containing the information on each refinement level integer, public :: nlevels Number of refinement levels type(grid_function_scalar), public :: rad_coord Grid scalar function storing the radial coordinates of each grid point type(grid_function), public :: shift_u Grid function storing the shift vector Type-Bound Procedures procedure, public :: abs_values_in interface public module module subroutine abs_values_in(THIS, lower_bound, upper_bound, constraint, l, export, unit_analysis, cnt) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS double precision :: lower_bound double precision :: upper_bound double precision, intent(in), DIMENSION(:,:,:) :: constraint integer, intent(in) :: l logical, intent(in) :: export integer, intent(in) :: unit_analysis integer, intent(out) :: cnt procedure, public, NON_OVERRIDABLE :: analyze_constraint interface public module module subroutine analyze_constraint(THIS, l, constraint, name_constraint, unit_logfile, name_analysis, l2_norm, loo_norm) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l double precision, intent(in), DIMENSION(:,:,:) :: constraint character(len=*), intent(in) :: name_constraint integer, intent(in) :: unit_logfile character(len=*), intent(in) :: name_analysis double precision, intent(out) :: l2_norm double precision, intent(out) :: loo_norm generic, public :: compute_and_export_3p1_constraints => compute_and_export_3p1_constraints_grid , compute_and_export_3p1_constraints_particles public interface compute_and_export_bssn_constraints_grid () Arguments None public interface compute_and_export_bssn_constraints_particles () Arguments None procedure( compute_and_export_3p1_constraints_grid_interface ), public, deferred :: compute_and_export_3p1_constraints_grid subroutine compute_and_export_3p1_constraints_grid_interface(THIS, id, namefile, name_logfile) Prototype Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile procedure( compute_and_export_3p1_constraints_particles_interface ), public, deferred :: compute_and_export_3p1_constraints_particles subroutine compute_and_export_3p1_constraints_particles_interface(THIS, parts_obj, namefile, name_logfile) Prototype Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile procedure( compute_and_export_3p1_variables_interface ), public, deferred :: compute_and_export_3p1_variables subroutine compute_and_export_3p1_variables_interface(THIS, namefile) Prototype Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile procedure( deallocate_fields_interface ), public, deferred :: deallocate_fields subroutine deallocate_fields_interface(THIS) Prototype Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS procedure, public, NON_OVERRIDABLE :: deallocate_standard3p1_variables interface public module module subroutine deallocate_standard3p1_variables(f3p1) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 procedure( define_allocate_fields_interface ), public, deferred :: define_allocate_fields subroutine define_allocate_fields_interface(THIS) Prototype Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS procedure, public :: get_HC interface public module module function get_HC(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision procedure, public :: get_HC_parts interface public module module function get_HC_parts(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision procedure, public :: get_MC interface public module module function get_MC(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) procedure, public :: get_MC_parts interface public module module function get_MC_parts(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) procedure, public :: get_dx interface public module module function get_dx(THIS, l) result(dx) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision procedure, public :: get_dy interface public module module function get_dy(THIS, l) result(dy) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision procedure, public :: get_dz interface public module module function get_dz(THIS, l) result(dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision procedure, public :: get_grid_point interface public module module function get_grid_point(THIS, i, j, k, l) result(grid_point) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) procedure, public :: get_levels interface public module module function get_levels(THIS, l) result(levels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value type(level),\n  DIMENSION(:), ALLOCATABLE procedure, public :: get_ngrid_x interface public module module function get_ngrid_x(THIS, l) result(ngrid_x) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_ngrid_y interface public module module function get_ngrid_y(THIS, l) result(ngrid_y) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_ngrid_z interface public module module function get_ngrid_z(THIS, l) result(ngrid_z) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_nlevels interface public module module function get_nlevels(THIS) result(nlevels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS Return Value double precision procedure, public :: get_xR interface public module module function get_xR(THIS, l) result(xR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_yR interface public module module function get_yR(THIS, l) result(yR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_zR interface public module module function get_zR(THIS, l) result(zR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure( print_formatted_lorene_id_3p1_variables_interface ), public, deferred :: print_formatted_lorene_id_3p1_variables subroutine print_formatted_lorene_id_3p1_variables_interface(THIS, namefile) Prototype Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile procedure, public, NON_OVERRIDABLE :: setup_standard3p1_variables interface public module module subroutine setup_standard3p1_variables(f3p1, id, dx, dy, dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Source Code TYPE , ABSTRACT :: formul_3p1 !# ABSTRACT TYPE representing a generic 3+1 formulation of the Einsten !  equations ! !-- Mesh variables ! INTEGER :: nlevels !! Number of refinement levels TYPE ( level ), DIMENSION (:), ALLOCATABLE :: levels !! Array containing the information on each refinement level TYPE ( grid_function ) :: coords !! Grid function storing the Cartesian coordinates TYPE ( grid_function_scalar ) :: rad_coord !! Grid scalar function storing the radial coordinates of each grid point ! !-- ADM fields ! TYPE ( grid_function_scalar ) :: lapse !! Grid scalar function storing the lapse function TYPE ( grid_function ) :: shift_u !! Grid function storing the shift vector TYPE ( grid_function ) :: g_phys3_ll !! Grid function storing the spatial metric TYPE ( grid_function ) :: K_phys3_ll !! Grid function storing the extrinsic curvature ! !-- Constraint violations ! TYPE ( grid_function_scalar ) :: HC !# Grid scalar function storing the Hamiltonian constraint (violations) !  computed using the full |lorene| ID on the mesh TYPE ( grid_function_scalar ) :: HC_parts !# Grid scalar function storing the Hamiltonian constraint (violations) !  computed using the stress-energy tensor mapped from the particles to the !  mesh TYPE ( grid_function ) :: MC !# Grid function storing the momentum constraint (violations) !  computed using the full |lorene| ID on the mesh TYPE ( grid_function ) :: MC_parts !# Grid function storing the momentum constraint (violations) !  computed using the stress-energy tensor mapped from the particles to the !  mesh ! !-- Norms of constraint violations ! DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_l2 !! \\ell_2 norm of the Hamiltonian constraint computed on the mesh DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_parts_l2 !# \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using !  the stress-energy tensor mapped from the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_loo !# \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh !  (i.e., its maximum) DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: HC_parts_loo !# \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh, !  using the stress-energy tensor mapped from the particles !  (i.e., its maximum) DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_l2 !! \\ell_2 norm of the momentum constraint computed on the mesh DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_parts_l2 !# \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using !  the stress-energy tensor mapped from the particles DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_loo !# \\ell_\\infty norm of the momentum constraint computed on the mesh !  (i.e., its maximum) DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: MC_parts_loo !# \\ell_\\infty norm of the momentum constraint computed on the mesh, !  using the stress-energy tensor mapped from the particles !  (i.e., its maximum) ! !-- Steering variables ! ! Variables to decide if and how to export the constraints INTEGER , PUBLIC :: cons_step !! Constraint violations are printed to file every cons_step-th grid point !  along each Cartesian direction LOGICAL , PUBLIC :: export_constraints !# `.TRUE.` if the constraint violations  are to be printed to file, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_constraints_details !# `.TRUE.` if the points at which the constraints violations are within the !  intervals [0,10&#94;{-7}],[10&#94;3,\\infty],[10&#94;n,10&#94;m], with !  n\\in\\{-7,2\\} and m=n+1, are to be printed to file; !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_constraints_xy !! `.TRUE.` if only the constrain violations on the xy plane are to be !  printed to file, `.FALSE.` otherwise LOGICAL , PUBLIC :: export_constraints_x !! `.TRUE.` if only the constrain violations on the x axis are to be !  printed to file, `.FALSE.` otherwise ! !-- Timers ! TYPE ( timer ) :: grid_timer !# Timer that times how long it takes to set up the grid and allocate !  the grid functions TYPE ( timer ) :: importer_timer !# Timer that times how long it takes to import the |lorene| ID !  on the mesh CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! !GENERIC, PUBLIC:: construct_formul_3p1 => & !                                    construct_formul_3p1_bns_ptr!, & !                                    !construct_formul_3p1_bns_spacings_ptr !PROCEDURE::       construct_formul_3p1_bns_ptr => & PROCEDURE , NON_OVERRIDABLE :: setup_standard3p1_variables !PROCEDURE::       construct_formul_3p1_bns_spacings_ptr => & !                                    construct_formul_3p1_bns_spacings PROCEDURE , NON_OVERRIDABLE :: analyze_constraint PROCEDURE ( define_allocate_fields_interface ), DEFERRED :: & define_allocate_fields PROCEDURE ( compute_and_export_3p1_variables_interface ), PUBLIC , & DEFERRED :: compute_and_export_3p1_variables PROCEDURE ( print_formatted_lorene_id_3p1_variables_interface ), PUBLIC , & DEFERRED :: print_formatted_lorene_id_3p1_variables GENERIC , PUBLIC :: compute_and_export_3p1_constraints => & compute_and_export_3p1_constraints_grid , & compute_and_export_3p1_constraints_particles PROCEDURE ( compute_and_export_3p1_constraints_grid_interface ), & DEFERRED :: compute_and_export_3p1_constraints_grid PROCEDURE ( compute_and_export_3p1_constraints_particles_interface ), & DEFERRED :: compute_and_export_3p1_constraints_particles PROCEDURE ( deallocate_fields_interface ), DEFERRED :: deallocate_fields PROCEDURE , NON_OVERRIDABLE :: deallocate_standard3p1_variables !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE :: abs_values_in PROCEDURE , PUBLIC :: get_grid_point PROCEDURE , PUBLIC :: get_nlevels PROCEDURE , PUBLIC :: get_levels PROCEDURE , PUBLIC :: get_dx PROCEDURE , PUBLIC :: get_dy PROCEDURE , PUBLIC :: get_dz PROCEDURE , PUBLIC :: get_ngrid_x PROCEDURE , PUBLIC :: get_ngrid_y PROCEDURE , PUBLIC :: get_ngrid_z PROCEDURE , PUBLIC :: get_xR PROCEDURE , PUBLIC :: get_yR PROCEDURE , PUBLIC :: get_zR PROCEDURE , PUBLIC :: get_HC PROCEDURE , PUBLIC :: get_MC PROCEDURE , PUBLIC :: get_HC_parts PROCEDURE , PUBLIC :: get_MC_parts END TYPE formul_3p1","tags":"","loc":"type/formul_3p1.html"},{"title":"bssn_id – SPHINCS_LORENE ","text":"type, public, extends( formul_3p1 ) :: bssn_id Inherits type~~bssn_id~~InheritsGraph type~bssn_id bssn_id grid_function grid_function type~bssn_id->grid_function Gamma_u, A_BSSN3_ll, g_BSSN3_ll, GC, GC_parts timer timer type~bssn_id->timer bssn_computer_timer type~formul_3p1 formul_3p1 type~bssn_id->type~formul_3p1 grid_function_scalar grid_function_scalar type~bssn_id->grid_function_scalar phi, trK type~formul_3p1->grid_function coords, shift_u, g_phys3_ll, K_phys3_ll, MC, MC_parts type~formul_3p1->timer grid_timer, importer_timer type~formul_3p1->grid_function_scalar rad_coord, lapse, HC, HC_parts level level type~formul_3p1->level levels var pantypebssn_idInheritsGraph = svgPanZoom('#typebssn_idInheritsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables A_BSSN3_ll GC GC_l2 GC_loo GC_parts GC_parts_l2 GC_parts_loo Gamma_u HC HC_l2 HC_loo HC_parts HC_parts_l2 HC_parts_loo K_phys3_ll MC MC_l2 MC_loo MC_parts MC_parts_l2 MC_parts_loo bssn_computer_timer call_flag cons_step coords export_bin export_constraints export_constraints_details export_constraints_x export_constraints_xy export_form_x export_form_xy g_BSSN3_ll g_phys3_ll grid_timer importer_timer lapse levels nlevels phi rad_coord shift_u trK Constructor bssn_id Finalization Procedures destructor Type-Bound Procedures abs_values_in analyze_constraint compute_and_export_3p1_constraints compute_and_export_3p1_constraints_grid compute_and_export_3p1_constraints_particles compute_and_export_3p1_variables deallocate_fields deallocate_standard3p1_variables define_allocate_fields destruct_bssn_id get_HC get_HC_parts get_MC get_MC_parts get_dx get_dy get_dz get_grid_point get_levels get_ngrid_x get_ngrid_y get_ngrid_z get_nlevels get_xR get_yR get_zR print_formatted_lorene_id_3p1_variables read_bssn_dump_print_formatted setup_standard3p1_variables Source Code bssn_id Components Type Visibility Attributes Name Initial type(grid_function), public :: A_BSSN3_ll Conformal traceless extrinsic curvature type(grid_function), public :: GC double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_l2 double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_loo type(grid_function), public :: GC_parts double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_parts_l2 double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_parts_loo type(grid_function), public :: Gamma_u Conformal connection type(grid_function_scalar), public :: HC Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh\n (i.e., its maximum) type(grid_function_scalar), public :: HC_parts Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) type(grid_function), public :: K_phys3_ll Grid function storing the extrinsic curvature type(grid_function), public :: MC Grid function storing the momentum constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_l2 \\ell_2 norm of the momentum constraint computed on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_loo \\ell_\\infty norm of the momentum constraint computed on the mesh\n (i.e., its maximum) type(grid_function), public :: MC_parts Grid function storing the momentum constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_loo \\ell_\\infty norm of the momentum constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) type(timer), public :: bssn_computer_timer integer, public :: call_flag = 0 integer, public :: cons_step Constraint violations are printed to file every cons_step-th grid point type(grid_function), public :: coords Grid function storing the Cartesian coordinates logical, public :: export_bin logical, public :: export_constraints .TRUE. if the constraint violations  are to be printed to file, .FALSE. otherwise logical, public :: export_constraints_details .TRUE. if the points at which the constraints violations are within the\n intervals [0,10&#94;{-7}],[10&#94;3,\\infty],[10&#94;n,10&#94;m] , with n\\in\\{-7,2\\} and m=n+1 , are to be printed to file; .FALSE. otherwise logical, public :: export_constraints_x .TRUE. if only the constrain violations on the x axis are to be logical, public :: export_constraints_xy .TRUE. if only the constrain violations on the xy plane are to be logical, public :: export_form_x logical, public :: export_form_xy type(grid_function), public :: g_BSSN3_ll Conformal spatial metric type(grid_function), public :: g_phys3_ll Grid function storing the spatial metric type(timer), public :: grid_timer Timer that times how long it takes to set up the grid and allocate\n the grid functions type(timer), public :: importer_timer Timer that times how long it takes to import the \\texttt{LORENE} ID\n on the mesh type(grid_function_scalar), public :: lapse Grid scalar function storing the lapse function type(level), public, DIMENSION(:), ALLOCATABLE :: levels Array containing the information on each refinement level integer, public :: nlevels Number of refinement levels type(grid_function_scalar), public :: phi Conformal factor type(grid_function_scalar), public :: rad_coord Grid scalar function storing the radial coordinates of each grid point type(grid_function), public :: shift_u Grid function storing the shift vector type(grid_function_scalar), public :: trK Trace of extrinsic curvature Constructor public interface bssn_id public interface construct_bssn_id () Arguments None Finalization Procedures final :: destructor Destructor; finalizes members from both CLASSES formul_3p1, and bssn_id,\n by calling destruct_formul_3p1 and destruct_bssn_id public interface destructor () Arguments None Type-Bound Procedures procedure, public :: abs_values_in interface public module module subroutine abs_values_in(THIS, lower_bound, upper_bound, constraint, l, export, unit_analysis, cnt) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS double precision :: lower_bound double precision :: upper_bound double precision, intent(in), DIMENSION(:,:,:) :: constraint integer, intent(in) :: l logical, intent(in) :: export integer, intent(in) :: unit_analysis integer, intent(out) :: cnt procedure, public, NON_OVERRIDABLE :: analyze_constraint interface public module module subroutine analyze_constraint(THIS, l, constraint, name_constraint, unit_logfile, name_analysis, l2_norm, loo_norm) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l double precision, intent(in), DIMENSION(:,:,:) :: constraint character(len=*), intent(in) :: name_constraint integer, intent(in) :: unit_logfile character(len=*), intent(in) :: name_analysis double precision, intent(out) :: l2_norm double precision, intent(out) :: loo_norm generic, public :: compute_and_export_3p1_constraints => compute_and_export_3p1_constraints_grid , compute_and_export_3p1_constraints_particles public interface compute_and_export_bssn_constraints_grid () Arguments None public interface compute_and_export_bssn_constraints_particles () Arguments None procedure, public :: compute_and_export_3p1_constraints_grid => compute_and_export_bssn_constraints_grid interface public module module subroutine compute_and_export_bssn_constraints_grid(THIS, id, namefile, name_logfile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile procedure, public :: compute_and_export_3p1_constraints_particles => compute_and_export_bssn_constraints_particles interface public module module subroutine compute_and_export_bssn_constraints_particles(THIS, parts_obj, namefile, name_logfile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile procedure, public :: compute_and_export_3p1_variables => compute_and_export_bssn_variables interface public module module subroutine compute_and_export_bssn_variables(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile procedure, public :: deallocate_fields => deallocate_bssn_fields interface public module module subroutine deallocate_bssn_fields(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS procedure, public, NON_OVERRIDABLE :: deallocate_standard3p1_variables interface public module module subroutine deallocate_standard3p1_variables(f3p1) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 procedure, public :: define_allocate_fields => allocate_bssn_fields interface public module module subroutine allocate_bssn_fields(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS procedure, public :: destruct_bssn_id Finalizer for members of the extended class bssn_id, not the\n primitive class formul_3p1 interface public module module subroutine destruct_bssn_id(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS procedure, public :: get_HC interface public module module function get_HC(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision procedure, public :: get_HC_parts interface public module module function get_HC_parts(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision procedure, public :: get_MC interface public module module function get_MC(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) procedure, public :: get_MC_parts interface public module module function get_MC_parts(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) procedure, public :: get_dx interface public module module function get_dx(THIS, l) result(dx) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision procedure, public :: get_dy interface public module module function get_dy(THIS, l) result(dy) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision procedure, public :: get_dz interface public module module function get_dz(THIS, l) result(dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision procedure, public :: get_grid_point interface public module module function get_grid_point(THIS, i, j, k, l) result(grid_point) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) procedure, public :: get_levels interface public module module function get_levels(THIS, l) result(levels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value type(level),\n  DIMENSION(:), ALLOCATABLE procedure, public :: get_ngrid_x interface public module module function get_ngrid_x(THIS, l) result(ngrid_x) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_ngrid_y interface public module module function get_ngrid_y(THIS, l) result(ngrid_y) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_ngrid_z interface public module module function get_ngrid_z(THIS, l) result(ngrid_z) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_nlevels interface public module module function get_nlevels(THIS) result(nlevels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS Return Value double precision procedure, public :: get_xR interface public module module function get_xR(THIS, l) result(xR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_yR interface public module module function get_yR(THIS, l) result(yR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: get_zR interface public module module function get_zR(THIS, l) result(zR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer procedure, public :: print_formatted_lorene_id_3p1_variables => print_formatted_lorene_id_bssn_variables interface public module module subroutine print_formatted_lorene_id_bssn_variables(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile procedure, public :: read_bssn_dump_print_formatted interface public module module subroutine read_bssn_dump_print_formatted(THIS, namefile_bin, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile_bin character(len=*), intent(inout), optional :: namefile procedure, public, NON_OVERRIDABLE :: setup_standard3p1_variables interface public module module subroutine setup_standard3p1_variables(f3p1, id, dx, dy, dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Source Code TYPE , EXTENDS ( formul_3p1 ) :: bssn_id INTEGER :: call_flag = 0 ! Flag set to a value different than 0 if the SUBROUTINE ! compute_and_export_bssn_variables is called ! !-- Arrays storing the BSSN variables for the LORENE ID on the grid ! TYPE ( grid_function ) :: Gamma_u !! Conformal connection TYPE ( grid_function_scalar ) :: phi !! Conformal factor TYPE ( grid_function_scalar ) :: trK !! Trace of extrinsic curvature TYPE ( grid_function ) :: A_BSSN3_ll !! Conformal traceless extrinsic curvature TYPE ( grid_function ) :: g_BSSN3_ll !! Conformal spatial metric ! !-- Connection constraints and its l2 norm and loo norm ! TYPE ( grid_function ) :: GC TYPE ( grid_function ) :: GC_parts DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_l2 DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_parts_l2 DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_loo DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: GC_parts_loo LOGICAL , PUBLIC :: export_bin LOGICAL , PUBLIC :: export_form_xy , export_form_x TYPE ( timer ) :: bssn_computer_timer CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: define_allocate_fields => allocate_bssn_fields PROCEDURE :: compute_and_export_3p1_variables & => compute_and_export_bssn_variables PROCEDURE , PUBLIC :: read_bssn_dump_print_formatted PROCEDURE :: print_formatted_lorene_id_3p1_variables & => print_formatted_lorene_id_bssn_variables PROCEDURE :: compute_and_export_3p1_constraints_grid & => compute_and_export_bssn_constraints_grid PROCEDURE :: compute_and_export_3p1_constraints_particles & => compute_and_export_bssn_constraints_particles PROCEDURE :: deallocate_fields => deallocate_bssn_fields PROCEDURE :: destruct_bssn_id !# Finalizer for members of the extended class bssn_id, not the !  primitive class formul_3p1 FINAL :: destructor !# Destructor; finalizes members from both CLASSES formul_3p1, and bssn_id, !  by calling destruct_formul_3p1 and destruct_bssn_id END TYPE bssn_id","tags":"","loc":"type/bssn_id.html"},{"title":"eos – SPHINCS_LORENE ","text":"type, public :: eos Data structure representing an EoS Inherited by type~~eos~~InheritedByGraph type~eos eos type~particles particles type~particles->type~eos all_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables eos_name eos_parameters Components Type Visibility Attributes Name Initial character(len=:), public, ALLOCATABLE :: eos_name The EoS name double precision, public, DIMENSION(:), ALLOCATABLE :: eos_parameters The EoS parameters, in the following order: Todo complete the list","tags":"","loc":"type/eos.html"},{"title":"particles – SPHINCS_LORENE ","text":"type, public :: particles TYPE representing a particle distribution Inherits type~~particles~~InheritsGraph type~particles particles type~eos eos type~particles->type~eos all_eos timer timer type~particles->timer placer_timer, same_particle_timer, apm_timers, importer_timer, sph_computer_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables Theta Ye Ye_table all_eos apm_iterate apm_timers baryon_density_index baryon_density_parts call_flag compose_eos compose_filename compose_path correct_nu distribution_id empty_object energy_density_parts export_bin export_form_x export_form_xy g_xx_parts g_xy_parts g_xz_parts g_yy_parts g_yz_parts g_zz_parts h importer_timer lapse_parts lorene_bns_id_parfile mass_fractions mass_ratios masses n_matter nb_table nbar_i nbar_tot nlrf nlrf_int npart npart_i nstar nstar_int nu nu_ratio nuratio nuratio_i particle_density particle_density_int placer_timer pmass pos pos_x1 pos_x2 pressure_length_scale_x1 pressure_length_scale_x2 pressure_parts pressure_parts_cu pressure_parts_x1 pressure_parts_x2 pressure_parts_x_der1 pressure_parts_x_der2 pvol randomize_phi randomize_r randomize_theta read_nu redistribute_nu reflect_particles_x same_particle_timer shift_parts_x shift_parts_y shift_parts_z specific_energy_parts sph_computer_timer u_pwp use_thres v v_euler_parts_x v_euler_parts_y v_euler_parts_z Constructor particles Finalization Procedures destruct_particles Type-Bound Procedures allocate_lorene_id_parts_memory analyze_hydro compute_Ye compute_and_export_SPH_variables deallocate_lorene_id_parts_memory get_h get_nlrf get_npart get_npart1 get_npart2 get_nu get_nuratio get_nuratio1 get_nuratio2 get_pos get_pressure get_pressure_cu get_theta get_u get_vel is_empty perform_apm place_particles_lattice place_particles_spherical_surfaces print_formatted_lorene_id_particles read_compose_composition read_sphincs_dump_print_formatted Source Code particles Components Type Visibility Attributes Name Initial double precision, private, DIMENSION(:), ALLOCATABLE :: Theta 1-D array storing the generalized Lorentz factor double precision, private, DIMENSION(:), ALLOCATABLE :: Ye 1-D array storing the electron fraction double precision, private, DIMENSION(:), ALLOCATABLE :: Ye_table Array storing the values of the electron fraction in the CompOSE table type( eos ), private, DIMENSION(:), ALLOCATABLE :: all_eos String containing the \\texttt{LORENE} name of the EOS for star 1\nString containing the \\texttt{LORENE} name of the EOS for star 2 logical, private, DIMENSION(:), ALLOCATABLE :: apm_iterate .TRUE. if the Artificial Pressure Method (APM) has to be applied to the\n particles on star 1, .FALSE. otherwise type(timer), public, DIMENSION(:), ALLOCATABLE :: apm_timers Timer that times how long it takes to perform the APM on the matter\n objects integer, private, DIMENSION(:), ALLOCATABLE :: baryon_density_index Array storing the indices to use with baryon_density_parts to sort the elements of baryon_density_parts in increasing\n order double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density_parts 1-D array storing the baryon mass density in the fluid frame [\\mathrm{kg}\\,\\mathrm{m}&#94;{-3}] integer, private :: call_flag = 0 logical, private :: compose_eos .TRUE. if the electron fraction Y_e should be read from the CompOSE\n table with extension.beta, .FALSE. otherwise Todo Chamge name of this variable to assign_Ye_compose. Check that\n       the used EOS is indeed the one used to read Y_e character(len=:), private, ALLOCATABLE :: compose_filename String storing the subpath of compose_path to the CompOSE file with character(len=:), private, ALLOCATABLE :: compose_path String storing the local path to the directory containing the CompOSE EOS logical, private :: correct_nu .TRUE. if the baryon number per particle should be corrected to account\n for the total baryon masses of the stars, .FALSE. otherwise integer, private :: distribution_id Identification number for the particle distribution \\texttt{LORENE} identification number for the EOS of star 1 \\texttt{LORENE} identification number for the EOS of star 1 logical, private :: empty_object .TRUE. if the object is empty, .FALSE. if it's not empty double precision, private, DIMENSION(:), ALLOCATABLE :: energy_density_parts 1-D array storing the energy density logical, public :: export_bin .TRUE. if the binary files for SPHINCS_BSSN are to be exported, .FALSE. otherwise logical, public :: export_form_x .TRUE. if the ID in the formatted files is to be on the x axis only, .FALSE. otherwise logical, public :: export_form_xy .TRUE. if the ID in the formatted files is to be on the xy plane only, .FALSE. otherwise double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx_parts Array storing the values of the xx component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_xy_parts Array storing the values of the xy component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_xz_parts Array storing the values of the xz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_yy_parts Array storing the values of the xz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_yz_parts Array storing the values of the yz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_zz_parts Array storing the values of the zz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: h 1-D array storing the smoothing length L_\\odot type(timer), public :: importer_timer Timer that times how long it takes to import the \\texttt{\\texttt{LORENE}} ID\n at the particle positions double precision, private, DIMENSION(:), ALLOCATABLE :: lapse_parts Array storing the values of the lapse function on the particles character(len=50), private :: lorene_bns_id_parfile Polytropic index for single polytropic EOS for star 1\nPolytropic constant for single polytropic EOS for star 1 Todo add units\nPolytropic index for single polytropic EOS for star 2\nPolytropic constant for single polytropic EOS for star 2 @todo add units\nString containing the name of the particles parameter file double precision, private, DIMENSION(:), ALLOCATABLE :: mass_fractions double precision, private, DIMENSION(:), ALLOCATABLE :: mass_ratios Ratio of baryonic masses of the stars M_\\odot Warning always < 1 double precision, private, DIMENSION(:), ALLOCATABLE :: masses Baryonic masses of the matter objects M_\\odot integer, private :: n_matter Particle number for star 1 double precision, private, DIMENSION(:), ALLOCATABLE :: nb_table Array storing the values of the baryon number density in the CompOSE\n table. Todo ADD UNITS double precision, private, DIMENSION(:), ALLOCATABLE :: nbar_i Baryon number on star 1 double precision, private :: nbar_tot Total baryon number double precision, private, DIMENSION(:), ALLOCATABLE :: nlrf 1-D array storing baryon density in the local rest frame [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] , computed directly from\n the \\texttt{LORENE} density double precision, private, DIMENSION(:), ALLOCATABLE :: nlrf_int 1-D array storing baryon density in the local rest frame [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] , computed from the kernel\n interpolated proper baryon number density nstar_int integer, private :: npart Total particle number Particle number for star 1 Particle number for star 1 integer, private, DIMENSION(:), ALLOCATABLE :: npart_i Particle number for star 2 double precision, private, DIMENSION(:), ALLOCATABLE :: nstar 1-D array storing the SPH estimate of the proper baryon number density [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: nstar_int 1-D array storing the SPH estimate of the proper baryon number density,\n from kernel interpolation [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: nu 1-D array storing the baryon number per particle double precision, private :: nu_ratio Total grid volume\nVolume per particle\nRatio between the max and min of the baryon number per particle double precision, private :: nuratio Baryon number on star 2\nBaryon number ratio on both stars double precision, private, DIMENSION(:), ALLOCATABLE :: nuratio_i Baryon number ratio on star 1\nBaryon number ratio on star 2 double precision, private, DIMENSION(:), ALLOCATABLE :: particle_density 1-D array storing the particle number density [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: particle_density_int 1-D array storing the SPH estimate of the particle number density, from\n kernel interpolation [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] type(timer), public :: placer_timer Timer that times how long it takes to place particles on the stars double precision, private, DIMENSION(:), ALLOCATABLE :: pmass 1-D array storing the particle masses M_\\odot double precision, private, DIMENSION(:,:), ALLOCATABLE :: pos 2-D array storing the particle positions double precision, private, DIMENSION(:), ALLOCATABLE :: pos_x1 1-D array storing the position of the particles on the x axis for S 1 double precision, private, DIMENSION(:), ALLOCATABLE :: pos_x2 1-D array storing the position of the particles on the x axis for NS2 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_length_scale_x1 1-D array storing the typical length scale for the pressure change double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_length_scale_x2 1-D array storing the typical length scale for the pressure change double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts 1-D array storing the pressure [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_cu 1-D array storing the pressure in code units [\\mathrm{amu}\\,c&#94;2\\,\\mathrm{L_\\odot}&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x1 1-D array storing the pressure on the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x2 1-D array storing the pressure on the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 2 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x_der1 1-D array storing the first derivative of the pressure\n along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x_der2 1-D array storing the first derivative of the pressure\n along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS2 double precision, private, DIMENSION(:), ALLOCATABLE :: pvol 1-D array storing the particle volumes L_\\odot&#94;3 logical, private :: randomize_phi .TRUE. if the particle positions on spherical surfaces are randomized\n in the \\phi direction, .FALSE. otherwise logical, private :: randomize_r .TRUE. if the particle positions on spherical surfaces are randomized\n in the r direction, .FALSE. otherwise logical, private :: randomize_theta .TRUE. if the particle positions on spherical surfaces are randomized\n in the \\theta direction, .FALSE. otherwise logical, private :: read_nu .TRUE. if the baryon number per particle \\nu has to be read from the\n formatted file containing the particle positions, .FALSE. otherwise logical, private :: redistribute_nu .TRUE. if the baryon number per particle should be reassigned, trying\n to obtain a baryon number ratio no larger than nu_ratio,\n when placing particles on lattices; .FALSE. otherwise logical, private :: reflect_particles_x .TRUE. if the particles on star 2 should be the reflection of the\n particles on star 1 with respect to the yz plane, only if the baryon\n masses of the stars differe less than 0.2\\% ; .FALSE. otherwise type(timer), public :: same_particle_timer Timer that times how long it takes to check if there are multiple\n particles at the same positions double precision, private, DIMENSION(:), ALLOCATABLE :: shift_parts_x Array storing the values of the x component of the shift vector\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: shift_parts_y Array storing the values of the y component of the shift vector\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: shift_parts_z Array storing the values of the z component of the shift vector\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: specific_energy_parts 1-D array storing the specific internal energy [c&#94;2] type(timer), public :: sph_computer_timer Timer that times how long it takes to compute the SPH variables at the\n particle pitions double precision, private, DIMENSION(:), ALLOCATABLE :: u_pwp 1-D array storing the specific internal energy [c&#94;2] computed using\n formula (9) in Read et al., Phys.Rev.D79:124032,2009,\n [arXiv:0812.2163][https://arxiv.org/abs/0812.2163]{:target=\"_blank\"} logical, private :: use_thres .TRUE. if the threshold on the baryon mass density should e applied\n when placing particles on lattices, .FALSE. otherwise double precision, private, DIMENSION(:,:), ALLOCATABLE :: v 2-D array storing the coordinate fluid 4-velocity [c] double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_parts_x 1-D array storing the x component of the fluid 3-velocity wrt\n the Eulerian observer [c] double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_parts_y 1-D array storing the y component of the fluid 3-velocity wrt\n the Eulerian observer [c] double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_parts_z 1-D array storing the z component of the fluid 3-velocity wrt\n the Eulerian observer [c] Constructor public interface particles Interface of TYPE particles public interface construct_particles () Arguments None Finalization Procedures final :: destruct_particles Finalizer (Destructor) of [[particles]] object public interface destruct_particles () Arguments None Type-Bound Procedures procedure, public :: allocate_lorene_id_parts_memory Allocates memory for the particles member arrays interface public module module subroutine allocate_lorene_id_parts_memory(THIS) Implementation → Allocates allocatable arrays member of a particles object Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of procedure, public :: analyze_hydro Scans the hydro fields taken from \\texttt{\\texttt{LORENE}} to look\n for negative or zero values interface public module module subroutine analyze_hydro(THIS, namefile) Implementation → Scans the hydro fields taken from \\texttt{\\texttt{LORENE}} to look\n for negative or zero values Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the particle positions at which\n some of the hydro fields are negative or zero are printed to procedure, public :: compute_Ye Interpates linearly the electron fraction Y_e at the particle\n densities; that is, assigns Y_e at the particle positions interface public module module subroutine compute_Ye(THIS) Implementation → Interpolates linearly the electron fraction Y_e at the particle\n densities; that is, assigns Y_e at the particle positions Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of procedure, public :: compute_and_export_SPH_variables Computes the SPH variables at the particle positions, and optionally\n prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} and \\texttt{splash} , and to a formatted file to be read by \\texttt{gnuplot} , by calling print_formatted_lorene_id_particles interface public module module subroutine compute_and_export_SPH_variables(THIS, namefile) Implementation → Computes the SPH variables at the particle positions, and optionally\n prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} and \\texttt{splash} , and to a formatted file to be read by \\texttt{gnuplot} , by calling print_formatted_lorene_id_particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the SPH ID is printed to procedure, public :: deallocate_lorene_id_parts_memory Deallocates memory for the particles member arrays interface public module module subroutine deallocate_lorene_id_parts_memory(THIS) Implementation → Deallocates allocatable arrays member of a particles object Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of procedure, public :: get_h Returns h interface public module module function get_h(THIS) result(h) Implementation → Returns h Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE h procedure, public :: get_nlrf Returns nlrf interface public module module function get_nlrf(THIS) result(nlrf) Implementation → Returns nlrf Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE nlrf procedure, public :: get_npart Returns npart interface public module module function get_npart(THIS) result(n_part) Implementation → Returns npart Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer npart procedure, public :: get_npart1 Returns particles interface public module module function get_npart1(THIS) result(n_part) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles procedure, public :: get_npart2 Returns particles interface public module module function get_npart2(THIS) result(n_part) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles procedure, public :: get_nu Returns nu interface public module module function get_nu(THIS) result(nu) Implementation → Returns nu Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE nu procedure, public :: get_nuratio Returns nuratio interface public module module function get_nuratio(THIS) result(nuratio) Implementation → Returns nuratio Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision nuratio procedure, public :: get_nuratio1 Returns particles interface public module module function get_nuratio1(THIS) result(nuratio1) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles procedure, public :: get_nuratio2 Returns particles interface public module module function get_nuratio2(THIS) result(nuratio2) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles procedure, public :: get_pos Returns pos interface public module module function get_pos(THIS) result(pos_u) Implementation → Returns pos Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:), ALLOCATABLE pos procedure, public :: get_pressure Returns pressure_parts interface public module module function get_pressure(THIS) result(pressure) Implementation → Returns pressure_parts Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE pressure_parts procedure, public :: get_pressure_cu Returns pressure_parts_cu interface public module module function get_pressure_cu(THIS) result(pressure_cu) Implementation → Returns pressure_parts_cu Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE pressure_parts_cu procedure, public :: get_theta Returns Theta interface public module module function get_theta(THIS) result(theta) Implementation → Returns Theta Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Theta procedure, public :: get_u Returns specific_energy_parts interface public module module function get_u(THIS) result(u) Implementation → Returns specific_energy_parts Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE specific_energy_parts procedure, public :: get_vel Returns v interface public module module function get_vel(THIS) result(vel) Implementation → Returns v Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:), ALLOCATABLE v procedure, public :: is_empty Returns .TRUE if the particles object is empty, .FALSE otherwise Warning experimental, not actively used in the code yet interface public module module function is_empty(THIS) result(answer) Implementation → Returns .TRUE if the particles object is empty, .FALSE otherwise Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(in) :: THIS particles object which this PROCEDURE is a member of Return Value logical .TRUE if the particles object is empty, .FALSE otherwise procedure, public, NOPASS :: perform_apm Performs the Artificial Pressure Method (APM) on one star's particles interface public module module subroutine perform_apm(get_density, get_nstar_p, pos_input, pvol, h_output, nu_output, center, com_star, mass, radx_comp, radx_opp, rady, radz, apm_max_it, max_inc, mass_it, correct_nu, nuratio_thres, nuratio_des, nx_gh, ny_gh, nz_gh, namefile_pos_id, namefile_pos, namefile_results, validate_position) Implementation → Performs the Artificial Pressure Method (APM) on one star's particles Arguments Type Intent Optional Attributes Name function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine get_nstar_p(npart_real, x, y, z, nstar_p) Computes the proper baryon number density at the particle positions Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real Number of real particles (i.e., no ghost particles included here) double precision, intent(in) :: x (npart_real) Array of x coordinates double precision, intent(in) :: y (npart_real) Array of y coordinates double precision, intent(in) :: z (npart_real) Array of z coordinates double precision, intent(out) :: nstar_p (npart_real) Array to store the computed proper baryon number density double precision, intent(inout), DIMENSION(:,:) :: pos_input Initial particle positions double precision, intent(inout), DIMENSION(:) :: pvol Initial particle volume double precision, intent(out), DIMENSION(:) :: h_output Array to store the smoothing lengths computed at the end of the\n APM iteration double precision, intent(out), DIMENSION(:) :: nu_output Array to store the baryon number per particle computed at the end of\n the APM iteration double precision, intent(in) :: center Center of the star (point of highest density), computed by \\texttt{LORENE} double precision, intent(in) :: com_star Center of mass of the star, computed by \\texttt{LORENE} double precision, intent(in) :: mass Mass of the star double precision, intent(in) :: radx_comp Radius of the star in the x direction, towards the companion double precision, intent(in) :: radx_opp Radius of the star in the x direction, opposite to companion double precision, intent(in) :: rady Radius of the star in the y direction double precision, intent(in) :: radz Radius of the star in the z direction integer, intent(in) :: apm_max_it Maximum number of APM iterations, irrespective of the EXIT condition integer, intent(in) :: max_inc Sets the EXIT condition: If the average over all the\n particles of the relative error in the density estimate\n grows max_inc times, exit the iteration. logical, intent(in) :: mass_it If .TRUE. performs a second iteration after the APM one, without moving\n the particles, changing their mass in order to better match\n the star density. The mass ratio grows very fast in all the tried\n experiments, hence the suggested value is .FALSE. logical, intent(in) :: correct_nu If .TRUE., the baryon number per particle nu is corrected\n to include the total baryonic masses of the\n stars. double precision, intent(in) :: nuratio_thres Maximum mass ratio (equivalently baryon number ratio)\n to be used in the one-time-only final correction\n of the particle masses to match the star density even\n better (without moving the particles) double precision, intent(in) :: nuratio_des Sets the EXIT condition: If the baryon number ratio\n is within 2.5% of nuratio_des, exit the iteration\n Set nuratio_des to 0 to deactivate and exit the APM\n iteration using max_inc integer, intent(in) :: nx_gh Number of lattice points in the x direction for ghosts integer, intent(in) :: ny_gh Number of lattice points in the y direction for ghosts integer, intent(in) :: nz_gh Number of lattice points in the z direction for ghosts character(len=*), intent(inout), optional :: namefile_pos_id Name for the formatted file where the initial particle positions character(len=*), intent(inout), optional :: namefile_pos Name for the formatted file where the particle positions character(len=*), intent(inout), optional :: namefile_results Name for the formatted file where various quantities related procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise procedure, public :: place_particles_lattice Places particles on a single lattice that surrounds both stars Places particles on two lattices, each one surrounding one star interface public module module subroutine place_particles_lattice(THIS, central_density, xmin, xmax, ymin, ymax, zmin, zmax, npart_des, npart_out, stretch, thres, pos, pvol, get_density, validate_position) Implementation → Places particles on a lattice containing a physical object Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: central_density Maximum baryon mass density of the system double precision, intent(in) :: xmin Left x boundary of the lattice double precision, intent(in) :: xmax Right x boundary of the lattice double precision, intent(in) :: ymin Left y boundary of the lattice double precision, intent(in) :: ymax Right y boundary of the lattice double precision, intent(in) :: zmin Left z boundary of the lattice double precision, intent(in) :: zmax Right z boundary of the lattice integer, intent(in) :: npart_des Desired particle number integer, intent(out) :: npart_out Real, output particle number double precision, intent(in) :: stretch Stretching factor fo the lattice. xmin to zmax are multiplied by it double precision, intent(in) :: thres (~rho_max)/thres is the minimum mass density considered\nwhen placing particles. Used only when redistribute_nu is\n.FALSE. . When redistribute_nu is .TRUE. thres= 100*nu_ratio double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes\nArray storing the final particle volumes function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise procedure, public :: place_particles_spherical_surfaces Places particles on spherical surfaces on one star interface public module module subroutine place_particles_spherical_surfaces(THIS, mass_star, radius, center, central_density, npart_approx, npart_out, pos, pvol, pmass, last_r, upper_bound, lower_bound, upper_factor, lower_factor, max_steps, filename_mass_profile, filename_shells_radii, filename_shells_pos, get_density, integrate_density, get_id, validate_position) Implementation → Places particles on spherical surfaces on one star Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: mass_star Baryonic mass of the star double precision, intent(in) :: radius Radius of the star in the x direction towards the companion double precision, intent(in) :: center (x|) coordinate of the center of the star, i.e.,\n of the point with highest density double precision, intent(in) :: central_density Central density of the star, i.e., highest density integer, intent(in) :: npart_approx idbase object needed to access the BNS data Todo Remove the idbase argument as done in SUBROUTINE perform_apm\nCLASS(idbase),       INTENT( IN OUT ):: id\n Approximate particle number on the star integer, intent(out) :: npart_out Final number of particles on the star double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos Array string the final positions double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pmass Array storing the final particle masses double precision, intent(in) :: last_r Radius of the last spherical surface double precision, intent(inout) :: upper_bound Desired upper bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(inout) :: lower_bound Desired lower bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(in) :: upper_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. upper_factor >= 1, usually an increase of 1% works double precision, intent(in) :: lower_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. lower_factor <= 1, usually a decrease of 1% works integer, intent(in) :: max_steps If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. max_steps >= 10. 100 is a nice value character(len=*), intent(inout), optional :: filename_mass_profile Name of the file to store the radial mass profile character(len=*), intent(inout), optional :: filename_shells_radii Name of the file to store the surface radii Todo change name of variable to filename_surfaces_radii character(len=*), intent(inout), optional :: filename_shells_pos Name of the file to store the final particle positions Todo change name of variable to filename_surfaces_pos function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine integrate_density(center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order subroutine get_id(x, y, z, g_xx, baryon_density, gamma_euler) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise procedure, public :: print_formatted_lorene_id_particles Prints the SPH ID to a formatted file interface public module module subroutine print_formatted_lorene_id_particles(THIS, namefile) Implementation → Prints the SPH ID to a formatted file Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted output file procedure, public :: read_compose_composition Reads the Y_e(n_b) table in the CompOSE file with extension .beta interface public module module subroutine read_compose_composition(THIS, namefile) Implementation → Reads the Y_e(n_b) table in the CompOSE file with extension .beta Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile To read the file great_eos.beta in directory compose_path/GREAT_EoS,\n namefile=\"GREAT_EoS/great_eos\" procedure, public :: read_sphincs_dump_print_formatted Reads the binary ID file printed by compute_and_export_SPH_variables interface public module module subroutine read_sphincs_dump_print_formatted(THIS, namefile_bin, namefile) Implementation → Reads the binary ID file printed by compute_and_export_SPH_variables and prints the data stored in it to a formatted file Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile_bin Name of the binary file to be read character(len=*), intent(inout), optional :: namefile Name of the formatted file to be printed Source Code TYPE :: particles !! TYPE representing a particle distribution PRIVATE INTEGER :: npart !! Total particle number !INTEGER:: npart1 !! Particle number for star 1 !INTEGER:: npart2 !! Particle number for star 1 INTEGER :: n_matter !! Particle number for star 1 INTEGER , DIMENSION (:), ALLOCATABLE :: npart_i !! Particle number for star 2 INTEGER :: distribution_id !! Identification number for the particle distribution !  INTEGER:: eos1_id !! |lorene| identification number for the EOS of star 1 !  INTEGER:: eos2_id !! |lorene| identification number for the EOS of star 1 INTEGER :: call_flag = 0 ! Flag that is set different than 0 if the SUBROUTINE ! compute_and_export_SPH_variables is called INTEGER , DIMENSION (:), ALLOCATABLE :: baryon_density_index !# Array storing the indices to use with [[particles:baryon_density_parts]] !  to sort the elements of [[particles:baryon_density_parts]] in increasing !  order ! !-- Hydro variables on the particles ! !> 2-D array storing the particle positions DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: pos !> 1-D array storing the position of the particles on the x axis for S 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pos_x1 !> 1-D array storing the position of the particles on the x axis for NS2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pos_x2 !& 1-D array storing the baryon mass density in the fluid frame !  [\\mathrm{kg}\\,\\mathrm{m}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: baryon_density_parts !> 1-D array storing the energy density !  [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: energy_density_parts !> 1-D array storing the specific internal energy [c&#94;2] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: specific_energy_parts !& 1-D array storing the specific internal energy [c&#94;2] computed using !  formula (9) in Read et al., Phys.Rev.D79:124032,2009, !  [arXiv:0812.2163][https://arxiv.org/abs/0812.2163]{:target=\"_blank\"} DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: u_pwp !> 1-D array storing the pressure [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts !& 1-D array storing the pressure on the x axis !  [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x1 !& 1-D array storing the pressure on the x axis !  [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x2 !& 1-D array storing the first derivative of the pressure !  along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x_der1 !& 1-D array storing the first derivative of the pressure !  along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_x_der2 !> 1-D array storing the typical length scale for the pressure change DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_length_scale_x1 !> 1-D array storing the typical length scale for the pressure change DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_length_scale_x2 !& 1-D array storing the pressure in code units !  [\\mathrm{amu}\\,c&#94;2\\,\\mathrm{L_\\odot}&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pressure_parts_cu !& 1-D array storing the x component of the fluid 3-velocity wrt !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_parts_x !& 1-D array storing the y component of the fluid 3-velocity wrt !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_parts_y !& 1-D array storing the z component of the fluid 3-velocity wrt !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_parts_z ! !-- Arrays to store the electron fraction Ye as a function of the !-- baryon number density for beta-equilibrated EoS at T~0, !-- imported from the CompOSE database's and software's files ! !& Array storing the values of the baryon number density in the CompOSE !  table. @todo ADD UNITS DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nb_table !> Array storing the values of the electron fraction in the CompOSE table DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: Ye_table ! !-- Spacetime fields ! !> Array storing the values of the lapse function on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: lapse_parts !& Array storing the values of the x component of the shift vector !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_parts_x !& Array storing the values of the y component of the shift vector !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_parts_y !& Array storing the values of the z component of the shift vector !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_parts_z !& Array storing the values of the xx component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xx_parts !& Array storing the values of the xy component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xy_parts !& Array storing the values of the xz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xz_parts !& Array storing the values of the xz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yy_parts !& Array storing the values of the yz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yz_parts !& Array storing the values of the zz component of the spatial metric !  on the particles DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_zz_parts ! !-- SPH fields ! !& 1-D array storing baryon density in the local rest frame !  [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}], computed directly from !  the |lorene| density DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nlrf !& 1-D array storing baryon density in the local rest frame !  [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}], computed from the kernel !  interpolated proper baryon number density [[particles:nstar_int]] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nlrf_int !> 1-D array storing the baryon number per particle DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nu !& 1-D array storing the SPH estimate of the proper baryon number density !  [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nstar !& 1-D array storing the particle number density !  [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: particle_density !& 1-D array storing the SPH estimate of the proper baryon number density, !  from kernel interpolation [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nstar_int !& 1-D array storing the SPH estimate of the particle number density, from !  kernel interpolation [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: particle_density_int !> 2-D array storing the coordinate fluid 4-velocity [c] DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE :: v !> 1-D array storing the generalized Lorentz factor DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: Theta !> 1-D array storing the electron fraction DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: Ye !> 1-D array storing the smoothing length L_\\odot DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: h !> 1-D array storing the particle volumes L_\\odot&#94;3 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pvol !> 1-D array storing the particle masses M_\\odot DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: pmass !> Baryonic masses of the matter objects M_\\odot DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: masses !& Ratio of baryonic masses of the stars M_\\odot !  @warning always < 1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: mass_ratios DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: mass_fractions !> Total grid volume !DOUBLE PRECISION:: vol, vol1, vol2 !> Volume per particle !DOUBLE PRECISION:: vol_a, vol1_a, vol2_a !> Ratio between the max and min of the baryon number per particle DOUBLE PRECISION :: nu_ratio !> Total baryon number DOUBLE PRECISION :: nbar_tot !> Baryon number on star 1 !DOUBLE PRECISION:: nbar1 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nbar_i !> Baryon number on star 2 !DOUBLE PRECISION:: nbar2 !> Baryon number ratio on both stars DOUBLE PRECISION :: nuratio !> Baryon number ratio on star 1 !DOUBLE PRECISION:: nuratio1 !> Baryon number ratio on star 2 !DOUBLE PRECISION:: nuratio2 DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: nuratio_i !> Polytropic index for single polytropic EOS for star 1 !DOUBLE PRECISION:: gamma_sp1= 0.0D0 !> Polytropic constant for single polytropic EOS for star 1 @todo add units !DOUBLE PRECISION:: kappa_sp1= 0.0D0 !> Polytropic index for single polytropic EOS for star 2 !DOUBLE PRECISION:: gamma_sp2= 0.0D0 !> Polytropic constant for single polytropic EOS for star 2 @todo add units !DOUBLE PRECISION:: kappa_sp2= 0.0D0 ! !-- Strings ! !> String containing the name of the particles parameter file CHARACTER ( LEN = 50 ) :: lorene_bns_id_parfile !> String storing the local path to the directory containing the CompOSE EOS CHARACTER ( LEN = : ), ALLOCATABLE :: compose_path !> String storing the subpath of compose_path to the CompOSE file with !  .beta extension CHARACTER ( LEN = : ), ALLOCATABLE :: compose_filename !> String containing the |lorene| name of the EOS for star 1 !   CHARACTER( LEN= : ), ALLOCATABLE:: eos1 !> String containing the |lorene| name of the EOS for star 2 !   CHARACTER( LEN= : ), ALLOCATABLE:: eos2 TYPE ( eos ), DIMENSION (:), ALLOCATABLE :: all_eos ! !-- Steering variables ! !> `.TRUE.` if the object is empty, `.FALSE.` if it's not empty LOGICAL :: empty_object !& `.TRUE.` if the binary files for SPHINCS_BSSN are to be exported, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_bin !& `.TRUE.` if the ID in the formatted files is to be on the xy plane only, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_form_xy !& `.TRUE.` if the ID in the formatted files is to be on the x axis only, !  `.FALSE.` otherwise LOGICAL , PUBLIC :: export_form_x !& `.TRUE.` if the threshold on the baryon mass density should e applied !  when placing particles on lattices, `.FALSE.` otherwise LOGICAL :: use_thres !& `.TRUE.` if the baryon number per particle should be reassigned, trying !  to obtain a baryon number ratio no larger than nu_ratio, !  when placing particles on lattices; `.FALSE.` otherwise LOGICAL :: redistribute_nu !& `.TRUE.` if the baryon number per particle should be corrected to account !  for the total baryon masses of the stars, `.FALSE.` otherwise LOGICAL :: correct_nu !& `.TRUE.` if the electron fraction Y_e should be read from the CompOSE !  table with extension.beta, `.FALSE.` otherwise !  @todo Chamge name of this variable to assign_Ye_compose. Check that !        the used EOS is indeed the one used to read Y_e LOGICAL :: compose_eos !& `.TRUE.` if the particle positions on spherical surfaces are randomized !  in the \\phi direction, `.FALSE.` otherwise LOGICAL :: randomize_phi !& `.TRUE.` if the particle positions on spherical surfaces are randomized !  in the \\theta direction, `.FALSE.` otherwise LOGICAL :: randomize_theta !& `.TRUE.` if the particle positions on spherical surfaces are randomized !  in the r direction, `.FALSE.` otherwise LOGICAL :: randomize_r !& `.TRUE.` if the Artificial Pressure Method (APM) has to be applied to the !  particles on star 1, `.FALSE.` otherwise LOGICAL , DIMENSION (:), ALLOCATABLE :: apm_iterate !& `.TRUE.` if the baryon number per particle \\nu has to be read from the !  formatted file containing the particle positions, `.FALSE.` otherwise LOGICAL :: read_nu !& `.TRUE.` if the particles on star 2 should be the reflection of the !  particles on star 1 with respect to the yz plane, only if the baryon !  masses of the stars differe less than 0.2\\%; `.FALSE.` otherwise LOGICAL :: reflect_particles_x ! !-- Timers ! !> Timer that times how long it takes to place particles on the stars TYPE ( timer ), PUBLIC :: placer_timer !& Timer that times how long it takes to check if there are multiple !  particles at the same positions TYPE ( timer ), PUBLIC :: same_particle_timer !& Timer that times how long it takes to perform the APM on the matter !  objects TYPE ( timer ), DIMENSION (:), ALLOCATABLE , PUBLIC :: apm_timers !& Timer that times how long it takes to import the \\texttt{|lorene|} ID !  at the particle positions TYPE ( timer ), PUBLIC :: importer_timer !& Timer that times how long it takes to compute the SPH variables at the !  particle pitions TYPE ( timer ), PUBLIC :: sph_computer_timer CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: place_particles_lattice !! Places particles on a single lattice that surrounds both stars !  PROCEDURE:: place_particles_lattices !! Places particles on two lattices, each one surrounding one star PROCEDURE :: place_particles_spherical_surfaces !! Places particles on spherical surfaces on one star PROCEDURE , NOPASS :: perform_apm !! Performs the Artificial Pressure Method (APM) on one star's particles !  GENERIC:: reshape_sph_field => reshape_sph_field_1d_ptr, & !                                 reshape_sph_field_2d_ptr !  !# GENERIC PROCEDURE, overloded to reallocate 1d and 2d arrays !  PROCEDURE:: reshape_sph_field_1d_ptr => reshape_sph_field_1d !  !! Reallocates a 1d array !  PROCEDURE:: reshape_sph_field_2d_ptr => reshape_sph_field_2d !  !! Reallocates a 2d array PROCEDURE :: allocate_lorene_id_parts_memory !! Allocates memory for the [[particles]] member arrays PROCEDURE :: deallocate_lorene_id_parts_memory !! Deallocates memory for the [[particles]] member arrays PROCEDURE :: read_compose_composition !! Reads the Y_e(n_b) table in the CompOSE file with extension .beta PROCEDURE :: compute_Ye !# Interpates linearly the electron fraction Y_e at the particle !  densities; that is, assigns Y_e at the particle positions PROCEDURE , PUBLIC :: analyze_hydro !# Scans the hydro fields taken from \\texttt{|lorene|} to look !  for negative or zero values PROCEDURE , PUBLIC :: compute_and_export_SPH_variables !# Computes the SPH variables at the particle positions, and optionally !  prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} !  and \\texttt{splash}, and to a formatted file to be read by !  \\texttt{gnuplot}, by calling !  [[particles:print_formatted_lorene_id_particles]] PROCEDURE , PUBLIC :: read_sphincs_dump_print_formatted !# Reads the binary ID file printed by !  [[particles:compute_and_export_SPH_variables]] PROCEDURE , PUBLIC :: print_formatted_lorene_id_particles !! Prints the SPH ID to a formatted file PROCEDURE , PUBLIC :: is_empty !# Returns `.TRUE` if the [[particles]] object is empty, `.FALSE` otherwise !  @warning experimental, not actively used in the code yet !PROCEDURE, PUBLIC:: write_lorene_bns_id_dump !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE , PUBLIC :: get_npart !! Returns [[particles:npart]] PROCEDURE , PUBLIC :: get_npart1 !! Returns [[particles:npart1]] PROCEDURE , PUBLIC :: get_npart2 !! Returns [[particles:npart2]] PROCEDURE , PUBLIC :: get_nuratio !! Returns [[particles:nuratio]] PROCEDURE , PUBLIC :: get_nuratio1 !! Returns [[particles:nuratio1]] PROCEDURE , PUBLIC :: get_nuratio2 !! Returns [[particles:nuratio2]] PROCEDURE , PUBLIC :: get_pos !! Returns [[particles:pos]] PROCEDURE , PUBLIC :: get_vel !! Returns [[particles:v]] PROCEDURE , PUBLIC :: get_nlrf !! Returns [[particles:nlrf]] PROCEDURE , PUBLIC :: get_nu !! Returns [[particles:nu]] PROCEDURE , PUBLIC :: get_u !! Returns [[particles:specific_energy_parts]] PROCEDURE , PUBLIC :: get_pressure !! Returns [[particles:pressure_parts]] PROCEDURE , PUBLIC :: get_pressure_cu !! Returns [[particles:pressure_parts_cu]] PROCEDURE , PUBLIC :: get_theta !! Returns [[particles:theta]] PROCEDURE , PUBLIC :: get_h !! Returns [[particles:h]] FINAL :: destruct_particles !! Finalizer (Destructor) of [[particles]] object END TYPE particles","tags":"","loc":"type/particles.html"},{"title":"idbase – SPHINCS_LORENE ","text":"type, public, ABSTRACT :: idbase Represents a generic ID for \\texttt{SPHINCS_BSSN} (binary neutron star, rotating\n star, etc.) Inherits type~~idbase~~InheritsGraph type~idbase idbase timer timer type~idbase->timer construction_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~idbase~~InheritedByGraph type~idbase idbase type~diffstarbase diffstarbase type~diffstarbase->type~idbase type~bnsbase bnsbase type~bnsbase->type~idbase type~diffstarlorene diffstarlorene type~diffstarlorene->type~diffstarbase type~bnslorene bnslorene type~bnslorene->type~bnsbase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables construction_timer n_matter one_lapse zero_shift Type-Bound Procedures check_i_matter get_n_matter get_one_lapse get_total_spatial_extent get_zero_shift integrate_baryon_mass_density read_id_full read_id_hydro read_id_k read_id_mass_b read_id_particles read_id_spacetime read_mass_density return_barycenter return_center return_eos_name return_eos_parameters return_mass return_spatial_extent set_n_matter set_one_lapse set_zero_shift test_position Source Code idbase Components Type Visibility Attributes Name Initial type(timer), public :: construction_timer Timer that times the construction of the appropriate object integer, private :: n_matter = 0 Number of matter objects belonging the physical system.\n For example, n_objects= 2 for a binary system of stars, and n_objects= 1\n for a single star or for a binary system of a black hole and a star. logical, private :: one_lapse Logical variable that determines if the lapse function \\alpha=1 , logical, private :: zero_shift Logical variable that determines if the shift \\beta&#94;i=0 Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. interface public module module subroutine check_i_matter(THIS, i_matter) Implementation → Checks that the given index i_matter is between 1 and n_matter , included. If not, it stops the execution of the\n program. Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system interface public module module function get_n_matter(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module function get_one_lapse(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} interface public module module function get_total_spatial_extent(THIS) result(box) Implementation → INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module function get_zero_shift(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star interface public module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Implementation → INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order procedure( read_id_full_int ), public, deferred :: read_id_full Reads the full ID subroutine read_id_full_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Prototype INTERFACE or the SUBROUTINE reading the full ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure( read_id_hydro_int ), public, deferred :: read_id_hydro Reads the hydro ID needed to compute the constraints on the refined mesh subroutine read_id_hydro_int(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Prototype INTERFACE or the SUBROUTINE reading the the hydro ID needed to compute\n the constraints on the refined mesh Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler procedure( read_id_k_int ), public, deferred :: read_id_k Reads the components of the extrinsic curvature subroutine read_id_k_int(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Prototype INTERFACE or the SUBROUTINE reading the components of the extrinsic\n curvature Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz procedure( read_id_mass_b_int ), public, deferred :: read_id_mass_b Reads the hydro ID needed to compute the baryon mass subroutine read_id_mass_b_int(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Prototype INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n baryon mass Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure( read_id_particles_int ), public, deferred :: read_id_particles Reads the hydro ID needed to compute the SPH ID subroutine read_id_particles_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Prototype INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n SPH ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure( read_id_spacetime_int ), public, deferred :: read_id_spacetime Reads the spacetime ID needed to compute\n the BSSN variables and constraints subroutine read_id_spacetime_int(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Prototype INTERFACE or the SUBROUTINE reading the spacetime ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek procedure( read_double_at_pos ), public, deferred :: read_mass_density Returns the baryon mass density at the given point function read_double_at_pos(THIS, x, y, z) result(res) Prototype INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION at a given\n position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Real number at (x,y,z) procedure( return_position ), public, deferred :: return_barycenter Returns the barycenters (centers of mass) of the matter objects. function return_position(THIS, i_matter) result(res) Prototype INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Centers of the matter objects. The first index runs over the matter\n objects, the second index over (x,y,z) . procedure( return_position ), public, deferred :: return_center Returns the centers of the matter objects. function return_position(THIS, i_matter) result(res) Prototype INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Centers of the matter objects. The first index runs over the matter\n objects, the second index over (x,y,z) . procedure( return_string_parameter ), public, deferred :: return_eos_name Returns the name of the EoS of the matter objects. Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} function return_string_parameter(THIS, i_matter) result(string) Prototype INTERFACE for a PROCEDURE that returns a CHARACTER( LEN= : ) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE procedure( return_eos_parameters_int ), public, deferred :: return_eos_parameters Returns the identification number of the EoS of the matter objects. Todo Set up a convention for the identification number subroutine return_eos_parameters_int(THIS, i_matter, eos_params) Prototype INTERFACE for a PROCEDURE that returns an array containing the\n parametersf the EoS for the matter objects Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object procedure( return_double_parameter ), public, deferred :: return_mass Returns the masses of the matter objects. function return_double_parameter(THIS, i_matter) result(res) Prototype INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision Real number. Parameter of the i_matter -th matter object procedure( return_spatial_extent_int ), public, deferred :: return_spatial_extent Returns the spatial extent of the matter objects,\n  returning the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} function return_spatial_extent_int(THIS, i_matter) result(box) Prototype INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  matter objects, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value interface public module module subroutine set_n_matter(THIS, value) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module subroutine set_one_lapse(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module subroutine set_zero_shift(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure( read_integer_at_pos ), public, deferred :: test_position Returns 1 if the position has physically acceptable properties,\n 0 otherwise function read_integer_at_pos(THIS, x, y, z) result(res) Prototype INTERFACE for a PROCEDURE that returns an INTEGER at a given position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer Integer at (x,y,z) Source Code TYPE , ABSTRACT :: idbase !# Represents a generic ID for |sphincsbssn| (binary neutron star, rotating !  star, etc.) PRIVATE INTEGER :: n_matter = 0 !# Number of matter objects belonging the physical system. !  For example, n_objects= 2 for a binary system of stars, and n_objects= 1 !  for a single star or for a binary system of a black hole and a star. LOGICAL :: one_lapse !! Logical variable that determines if the lapse function \\alpha=1, !  i.e., if the geodesic gauge is to be used LOGICAL :: zero_shift !! Logical variable that determines if the shift \\beta&#94;i=0 TYPE ( timer ), PUBLIC :: construction_timer !! Timer that times the construction of the appropriate object CONTAINS !---------------------------! !--  DEFERRED PROCEDURES  --! !---------------------------! ! !-- PROCEDURES to read the value of a field at a point ! PROCEDURE ( read_double_at_pos ), DEFERRED :: read_mass_density !# Returns the baryon mass density at the given point PROCEDURE ( read_integer_at_pos ), DEFERRED :: test_position !# Returns 1 if the position has physically acceptable properties, !  0 otherwise ! !-- PROCEDURES to read the value of several fields at several points ! PROCEDURE ( read_id_full_int ), DEFERRED :: read_id_full !# Reads the full ID PROCEDURE ( read_id_particles_int ), DEFERRED :: read_id_particles !! Reads the hydro ID needed to compute the SPH ID PROCEDURE ( read_id_mass_b_int ), DEFERRED :: read_id_mass_b !! Reads the hydro ID needed to compute the baryon mass PROCEDURE ( read_id_spacetime_int ), DEFERRED :: read_id_spacetime !# Reads the spacetime ID needed to compute !  the BSSN variables and constraints PROCEDURE ( read_id_hydro_int ), DEFERRED :: read_id_hydro !# Reads the hydro ID needed to compute the constraints on the refined mesh PROCEDURE ( read_id_k_int ), DEFERRED :: read_id_k !! Reads the components of the extrinsic curvature ! !-- PROCEDURES returning the values of some parameters of a matter object ! PROCEDURE ( return_spatial_extent_int ), DEFERRED :: return_spatial_extent !# Returns the spatial extent of the matter objects, !  returning the array of 6 numbers !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} PROCEDURE ( return_double_parameter ), DEFERRED :: return_mass !! Returns the masses of the matter objects. PROCEDURE ( return_position ), DEFERRED :: return_center !! Returns the centers of the matter objects. PROCEDURE ( return_position ), DEFERRED :: return_barycenter !! Returns the barycenters (centers of mass) of the matter objects. PROCEDURE ( return_eos_parameters_int ), DEFERRED :: return_eos_parameters !# Returns the identification number of the |eos| of the matter objects. !  @todo Set up a convention for the identification number PROCEDURE ( return_string_parameter ), DEFERRED :: return_eos_name !! Returns the name of the |eos| of the matter objects. ! !-- PROCEDURES returning the values of some parameters of the entire system ! !   PROCEDURE(return_total_spatial_extent_int), DEFERRED:: & !                                                   return_total_spatial_extent !# Returns the spatial extent of the physical system considered, !  as the array of 6 numbers !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} !PROCEDURE(derived_type_constructor_int), NOPASS, DEFERRED:: derived_type_constructor !# !-------------------------------! !--  NON-DEFERRED PROCEDURES  --! !-------------------------------! !PROCEDURE, NON_OVERRIDABLE:: sanity_check !# !PROCEDURE, NON_OVERRIDABLE:: initialize !# PROCEDURE , NON_OVERRIDABLE :: get_total_spatial_extent !# Returns the spatial extent of the physical system considered, !  as the array of 6 numbers !x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} PROCEDURE , NON_OVERRIDABLE :: set_n_matter !# Sets [[idbase:n_matter]], the number of matter objects in the !  physical system, to a value PROCEDURE , NON_OVERRIDABLE :: get_n_matter !# Returns [[idbase:n_matter]], the number of matter objects in the !  physical system PROCEDURE , NON_OVERRIDABLE :: set_one_lapse !# Sets [[idbase:one_lapse]], the logical variable that determines if !  the lapse \\alpha=1, i.e., if the geodesic gauge is to be used PROCEDURE , NON_OVERRIDABLE :: get_one_lapse !# Returns [[idbase:one_lapse]], the logical variable that determines if ! the lapse function \\alpha=1, i.e., if the geodesic gauge is to be used PROCEDURE , NON_OVERRIDABLE :: set_zero_shift !# Sets [[idbase:zero_shift]], the logical variable that determines if !  the shift \\beta&#94;i=0 PROCEDURE , NON_OVERRIDABLE :: get_zero_shift !# Returns [[idbase:zero_shift]], the logical variable that determines if !  the shift \\beta&#94;i=0 PROCEDURE , NON_OVERRIDABLE :: check_i_matter !# Checks that the given index is between 1 and [[idbase:n_matter]], !  included. If not, it stops the execution of the program. PROCEDURE :: integrate_baryon_mass_density !# Integrates the baryon mass density over a matter object, using spherical !  coordinates, and computes its radial profile inside the star END TYPE idbase","tags":"","loc":"type/idbase.html"},{"title":"bnsbase – SPHINCS_LORENE ","text":"type, public, ABSTRACT, extends( idbase ) :: bnsbase Represents a generic BNS ID for \\texttt{SPHINCS_BSSN} (produced with LORENE, or with\n \\texttt{FUKA}, etc.; or produced with the same tool, but read in different ways,\n for example by linking to the LORENE library, or reading the ID from\n a lattice, etc.) Inherits type~~bnsbase~~InheritsGraph type~bnsbase bnsbase type~idbase idbase type~bnsbase->type~idbase timer timer type~idbase->timer construction_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~bnsbase~~InheritedByGraph type~bnsbase bnsbase type~bnslorene bnslorene type~bnslorene->type~bnsbase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables adm_mass angular_momentum angular_vel area_radius1 area_radius2 barycenter barycenter1_x barycenter2_x center center1_x center2_x construction_timer distance distance_com energy_density_center1 energy_density_center2 ent_center1 ent_center2 eos1 eos2 gamma0_1 gamma0_2 gamma1_1 gamma1_2 gamma2_1 gamma2_2 gamma3_1 gamma3_2 gamma_1 gamma_2 kappa0_1 kappa0_2 kappa1_1 kappa1_2 kappa2_1 kappa2_2 kappa3_1 kappa3_2 kappa_1 kappa_2 logP1_1 logP1_2 logRho0_1 logRho0_2 logRho1_1 logRho1_2 logRho2_1 logRho2_2 mOmega mass mass1 mass2 mass_grav mass_grav1 mass_grav2 nbar_center1 nbar_center2 npeos_1 npeos_2 pressure_center1 pressure_center2 radii radius1_x_comp radius1_x_opp radius1_y radius1_z radius2_x_comp radius2_x_opp radius2_y radius2_z rho_center1 rho_center2 specific_energy_center1 specific_energy_center2 t_merger Type-Bound Procedures check_i_matter get_adm_mass get_angular_momentum get_angular_vel get_barycenter1_x get_barycenter2_x get_center1_x get_center2_x get_distance get_distance_com get_energy_density_center1 get_energy_density_center2 get_ent_center1 get_ent_center2 get_eos1 get_eos1_id get_eos2 get_eos2_id get_gamma0_1 get_gamma0_2 get_gamma1_1 get_gamma1_2 get_gamma2_1 get_gamma2_2 get_gamma3_1 get_gamma3_2 get_gamma_1 get_gamma_2 get_grav_mass1 get_grav_mass2 get_kappa0_1 get_kappa0_2 get_kappa1_1 get_kappa1_2 get_kappa2_1 get_kappa2_2 get_kappa3_1 get_kappa3_2 get_kappa_1 get_kappa_2 get_logP1_1 get_logP1_2 get_logRho0_1 get_logRho0_2 get_logRho1_1 get_logRho1_2 get_logRho2_1 get_logRho2_2 get_mass1 get_mass2 get_n_matter get_nbar_center1 get_nbar_center2 get_npeos_1 get_npeos_2 get_one_lapse get_pressure_center1 get_pressure_center2 get_radius1_x_comp get_radius1_x_opp get_radius1_y get_radius1_z get_radius2_x_comp get_radius2_x_opp get_radius2_y get_radius2_z get_rho_center1 get_rho_center2 get_specific_energy_center1 get_specific_energy_center2 get_total_spatial_extent get_zero_shift integrate_baryon_mass_density read_id_full read_id_hydro read_id_k read_id_mass_b read_id_particles read_id_spacetime read_mass_density return_barycenter return_center return_eos_name return_eos_parameters return_mass return_spatial_extent set_n_matter set_one_lapse set_zero_shift test_position Source Code bnsbase Components Type Visibility Attributes Name Initial double precision, public :: adm_mass ADM mass of the BNS [M_\\odot] double precision, public :: angular_momentum = 0.0D0 Angular momentum of the BNS system [G M_\\odot&#94;2/c] double precision, public :: angular_vel Angular velocity [{\\rm rad/s}] double precision, public :: area_radius1 Areal (or circumferential) radius of star 1 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public :: area_radius2 Areal (or circumferential) radius of star 2 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(2,3) :: barycenter Array containing the barycenters of the stars Todo add details double precision, public :: barycenter1_x Barycenter of star 1 [L_\\odot] double precision, public :: barycenter2_x Barycenter of star 2 [L_\\odot] double precision, public, DIMENSION(2,3) :: center Array containing the centers of the stars Todo add details double precision, public :: center1_x Stellar center of star 1 (origin of the LORENE chart centered on star 1) [L_\\odot] double precision, public :: center2_x Stellar center of star 2 (origin of the LORENE chart centered on star 2) [L_\\odot] type(timer), public :: construction_timer Timer that times the construction of the appropriate object double precision, public :: distance Distance d between the points of maximum baryon density [{\\rm km}] double precision, public :: distance_com Distance between the centers of mass [L_\\odot(=1.47662503825040{\\rm km})] double precision, public :: energy_density_center1 Central energy density for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: energy_density_center2 Central energy density for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center1 Central enthalpy for star 1 [c&#94;2] double precision, public :: ent_center2 Central enthalpy for star 2 [c&#94;2] character(len=:), public, ALLOCATABLE :: eos1 Name of the equation of state (EoS) of star 1 character(len=:), public, ALLOCATABLE :: eos2 Name of the equation of state (EoS) of star 2 double precision, public :: gamma0_1 Piecewise polytrope: polytropic index \\gamma_0 for star 1 double precision, public :: gamma0_2 Piecewise polytrope: polytropic index \\gamma_0 for star 2 double precision, public :: gamma1_1 Piecewise polytrope: polytropic index \\gamma_1 for star 1 double precision, public :: gamma1_2 Piecewise polytrope: polytropic index \\gamma_1 for star 2 double precision, public :: gamma2_1 Piecewise polytrope: polytropic index \\gamma_2 for star 1 double precision, public :: gamma2_2 Piecewise polytrope: polytropic index \\gamma_2 for star 2 double precision, public :: gamma3_1 Piecewise polytrope: polytropic index \\gamma_3 for star 1 double precision, public :: gamma3_2 Piecewise polytrope: polytropic index \\gamma_3 for star 2 double precision, public :: gamma_1 Single polytrope: polytropic index for star 1 double precision, public :: gamma_2 Single polytrope: polytropic index for star 2 double precision, public :: kappa0_1 Piecewise polytrope: polytropic constant \\kappa_0 for star 1\n [pure number] double precision, public :: kappa0_2 Piecewise polytrope: polytropic constant \\kappa_0 for star 2\n [pure number] double precision, public :: kappa1_1 Piecewise polytrope: polytropic constant \\kappa_1 for star 1\n [pure number] double precision, public :: kappa1_2 Piecewise polytrope: polytropic constant \\kappa_1 for star 2\n [pure number] double precision, public :: kappa2_1 Piecewise polytrope: polytropic constant \\kappa_2 for star 1\n [pure number] double precision, public :: kappa2_2 Piecewise polytrope: polytropic constant \\kappa_2 for star 2\n [pure number] double precision, public :: kappa3_1 Piecewise polytrope: polytropic constant \\kappa_3 for star 1\n [pure number] double precision, public :: kappa3_2 Piecewise polytrope: polytropic constant \\kappa_3 for star 2\n [pure number] double precision, public :: kappa_1 Single polytrope: polytropic constant for star 1 [pure number] double precision, public :: kappa_2 Single polytrope: polytropic constant for star 2 [pure number] double precision, public :: logP1_1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 1 double precision, public :: logP1_2 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 2 double precision, public :: logRho0_1 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho0_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho1_1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho1_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho2_1 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho2_2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: mOmega mOmega= ( angular_vel [{\\rm km&#94;{-1}}] ) \\times ( mass_grav1 [{\\rm km}] + mass_grav2 [{\\rm km}] ) [pure number] Constant used in K. Hotokezaka et al, Phys. Rev. D 87, 024001 (see Sec. IIB) to determine when\n the BNS is at approximately 3-4 quasicircular orbits from merger. For the\nEOS APR4 and ALF2, this requirement is approximately satisfied for\nmOmega =0.026 ; for the EOS H4 and MS1, for mOmega =0.025 . double precision, public, DIMENSION(2) :: mass Array containing the baryonic masses [M_\\odot] double precision, public :: mass1 Baryonic mass of star 1 [M_\\odot] double precision, public :: mass2 Baryonic mass of star 2 [M_\\odot] double precision, public, DIMENSION(2) :: mass_grav Array containing the gravitatil masses [M_\\odot] double precision, public :: mass_grav1 Gravitational mass of star 1 [M_\\odot] double precision, public :: mass_grav2 Gravitational mass of star 2 [M_\\odot] double precision, public :: nbar_center1 Central baryon number density for star 1 [L_\\odot&#94;{-3}] double precision, public :: nbar_center2 Central baryon number density for star 2 [L_\\odot&#94;{-3}] integer, public :: npeos_1 Piecewise polytrope: Number of polytropic pieces for star 1 integer, public :: npeos_2 Piecewise polytrope: Number of polytropic pieces for star 2 double precision, public :: pressure_center1 Central pressure for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: pressure_center2 Central pressure for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public, DIMENSION(2,6) :: radii Array containing the signed radii of the stars Todo add details double precision, public :: radius1_x_comp Radius of star 1, in the x direction, towards the companion [L_\\odot] double precision, public :: radius1_x_opp Radius of star 1, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius1_y Radius of star 1, in the y direction [L_\\odot] double precision, public :: radius1_z Radius of star 1, in the z direction [L_\\odot] double precision, public :: radius2_x_comp Radius of star 2, in the x direction, towards the companion [L_\\odot] double precision, public :: radius2_x_opp Radius of star 2, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius2_y Radius of star 2, in the y direction [L_\\odot] double precision, public :: radius2_z Radius of star 2, in the z direction [L_\\odot] double precision, public :: rho_center1 Central baryon mass density for star 1 [M_\\odot L_\\odot&#94;{-3}] double precision, public :: rho_center2 Central baryon mass density for star 2 [M_\\odot L_\\odot&#94;{-3}] double precision, public :: specific_energy_center1 Central specific energy for star 1 [c&#94;2] double precision, public :: specific_energy_center2 Central specific energy for star 2 [c&#94;2] double precision, public :: t_merger Estimated time of the merger [M_\\odot] t_\\mathrm{merger}=\\dfrac{5}{256}\n \\dfrac{d&#94;4}{M&#94;1_\\mathrm{g}M&#94;2_\\mathrm{g}(M&#94;1_\\mathrm{g}+M&#94;2_\\mathrm{g})} P. C. Peters, \"Gravitational Radiation and the Motion of Two Point\n Masses\", Phys. Rev. 136, B1224 (1964) Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. interface public module module subroutine check_i_matter(THIS, i_matter) Implementation → Checks that the given index i_matter is between 1 and n_matter , included. If not, it stops the execution of the\n program. Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked procedure, public :: get_adm_mass Returns adm_mass interface public module module function get_adm_mass(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_angular_momentum Returns angular_momentum interface public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_angular_vel Returns angular_vel interface public module module function get_angular_vel(THIS) Implementation → Returns angular_vel Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_barycenter1_x Returns barycenter1_x interface public module module function get_barycenter1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_barycenter2_x Returns barycenter2_x interface public module module function get_barycenter2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_center1_x Returns center1_x interface public module module function get_center1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_center2_x Returns center2_x interface public module module function get_center2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_distance Returns distance interface public module module function get_distance(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_distance_com Returns distance_com interface public module module function get_distance_com(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_energy_density_center1 Returns energy_density_center1 interface public module module function get_energy_density_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_energy_density_center2 Returns energy_density_center2 interface public module module function get_energy_density_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_ent_center1 Returns ent_center1 interface public module module function get_ent_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_ent_center2 Returns ent_center2 interface public module module function get_ent_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_eos1 Returns eos1 interface public module module function get_eos1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE procedure( get_eos_id_int ), public, deferred :: get_eos1_id Returns an integer that identifies the equation of state of star 1 function get_eos_id_int(THIS) Prototype Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer procedure, public :: get_eos2 Returns eos2 interface public module module function get_eos2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE procedure( get_eos_id_int ), public, deferred :: get_eos2_id Returns an integer that identifies the equation of state of star 2 Integrates the LORENE baryon mass density and computes the\n radial mass profile Access the components of the bns member arrays function get_eos_id_int(THIS) Prototype Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer procedure, public :: get_gamma0_1 Returns gamma0_1 interface public module module function get_gamma0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma0_2 Returns gamma0_2 interface public module module function get_gamma0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma1_1 Returns gamma1_1 interface public module module function get_gamma1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma1_2 Returns gamma1_2 interface public module module function get_gamma1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma2_1 Returns gamma2_1 interface public module module function get_gamma2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma2_2 Returns gamma2_2 interface public module module function get_gamma2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma3_1 Returns gamma3_1 interface public module module function get_gamma3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma3_2 Returns gamma3_2 interface public module module function get_gamma3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma_1 Returns gamma_1 interface public module module function get_gamma_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma_2 Returns gamma_2 interface public module module function get_gamma_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grav_mass1 Returns mass_grav1 interface public module module function get_grav_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grav_mass2 Returns mass_grav2 interface public module module function get_grav_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa0_1 Returns kappa0_1 interface public module module function get_kappa0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa0_2 Returns kappa0_2 interface public module module function get_kappa0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa1_1 Returns kappa1_1 interface public module module function get_kappa1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa1_2 Returns kappa1_2 interface public module module function get_kappa1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa2_1 Returns kappa2_1 interface public module module function get_kappa2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa2_2 Returns kappa2_2 interface public module module function get_kappa2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa3_1 Returns kappa3_1 interface public module module function get_kappa3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa3_2 Returns kappa3_2 interface public module module function get_kappa3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa_1 Returns kappa_1 interface public module module function get_kappa_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa_2 Returns kappa_2 interface public module module function get_kappa_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logP1_1 Returns logP1_1 interface public module module function get_logP1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logP1_2 Returns logP1_2 interface public module module function get_logP1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho0_1 Returns logRho0_1 interface public module module function get_logRho0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho0_2 Returns logRho0_2 interface public module module function get_logRho0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho1_1 Returns logRho1_1 interface public module module function get_logRho1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho1_2 Returns logRho1_2 interface public module module function get_logRho1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho2_1 Returns logRho2_1 interface public module module function get_logRho2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho2_2 Returns logRho2_2 interface public module module function get_logRho2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_mass1 Returns mass1 interface public module module function get_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_mass2 Returns mass2 interface public module module function get_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system interface public module module function get_n_matter(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the procedure, public :: get_nbar_center1 Returns nbar_center1 interface public module module function get_nbar_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_nbar_center2 Returns nbar_center2 interface public module module function get_nbar_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_npeos_1 Returns npeos_1 interface public module module function get_npeos_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer procedure, public :: get_npeos_2 Returns npeos_2 interface public module module function get_npeos_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module function get_one_lapse(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: get_pressure_center1 Returns pressure_center1 interface public module module function get_pressure_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_pressure_center2 Returns pressure_center2 interface public module module function get_pressure_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_x_comp Returns radius1_x_comp interface public module module function get_radius1_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_x_opp Returns radius1_x_opp interface public module module function get_radius1_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_y Returns radius1_y interface public module module function get_radius1_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_z Returns radius1_z interface public module module function get_radius1_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_x_comp Returns radius2_x_comp interface public module module function get_radius2_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_x_opp Returns radius2_x_opp interface public module module function get_radius2_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_y Returns radius2_y interface public module module function get_radius2_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_z Returns radius2_y interface public module module function get_radius2_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_rho_center1 Returns rho_center1 interface public module module function get_rho_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_rho_center2 Returns rho_center2 interface public module module function get_rho_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_center1 Returns specific_energy_center1 interface public module module function get_specific_energy_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_center2 Returns specific_energy_center2 interface public module module function get_specific_energy_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} interface public module module function get_total_spatial_extent(THIS) result(box) Implementation → INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module function get_zero_shift(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star interface public module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Implementation → INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order procedure( read_id_full_int ), public, deferred :: read_id_full Reads the full ID subroutine read_id_full_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Prototype INTERFACE or the SUBROUTINE reading the full ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure( read_id_hydro_int ), public, deferred :: read_id_hydro Reads the hydro ID needed to compute the constraints on the refined mesh subroutine read_id_hydro_int(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Prototype INTERFACE or the SUBROUTINE reading the the hydro ID needed to compute\n the constraints on the refined mesh Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler procedure( read_id_k_int ), public, deferred :: read_id_k Reads the components of the extrinsic curvature subroutine read_id_k_int(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Prototype INTERFACE or the SUBROUTINE reading the components of the extrinsic\n curvature Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz procedure( read_id_mass_b_int ), public, deferred :: read_id_mass_b Reads the hydro ID needed to compute the baryon mass subroutine read_id_mass_b_int(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Prototype INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n baryon mass Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure( read_id_particles_int ), public, deferred :: read_id_particles Reads the hydro ID needed to compute the SPH ID subroutine read_id_particles_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Prototype INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n SPH ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure( read_id_spacetime_int ), public, deferred :: read_id_spacetime Reads the spacetime ID needed to compute\n the BSSN variables and constraints subroutine read_id_spacetime_int(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Prototype INTERFACE or the SUBROUTINE reading the spacetime ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek procedure( read_double_at_pos ), public, deferred :: read_mass_density Returns the baryon mass density at the given point function read_double_at_pos(THIS, x, y, z) result(res) Prototype INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION at a given\n position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Real number at (x,y,z) procedure, public :: return_barycenter => get_barycenter interface public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_center => get_center interface public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_eos_name => get_eos interface public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE procedure( return_eos_parameters_int ), public, deferred :: return_eos_parameters Returns the identification number of the EoS of the matter objects. Todo Set up a convention for the identification number subroutine return_eos_parameters_int(THIS, i_matter, eos_params) Prototype INTERFACE for a PROCEDURE that returns an array containing the\n parametersf the EoS for the matter objects Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object procedure, public :: return_mass => get_mass interface public module module function get_mass(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision procedure, public :: return_spatial_extent => get_radii interface public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value interface public module module subroutine set_n_matter(THIS, value) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module subroutine set_one_lapse(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module subroutine set_zero_shift(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure( read_integer_at_pos ), public, deferred :: test_position Returns 1 if the position has physically acceptable properties,\n 0 otherwise function read_integer_at_pos(THIS, x, y, z) result(res) Prototype INTERFACE for a PROCEDURE that returns an INTEGER at a given position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer Integer at (x,y,z) Source Code TYPE , ABSTRACT , EXTENDS ( idbase ) :: bnsbase !# Represents a generic BNS ID for |sphincsbssn| (produced with LORENE, or with !  |fuka|, etc.; or produced with the same tool, but read in different ways, !  for example by linking to the LORENE library, or reading the ID from !  a lattice, etc.) !-----------------------------! !--  Parameters of the BNS  --! !-----------------------------! !> Angular velocity [{\\rm rad/s}] DOUBLE PRECISION :: angular_vel !> Distance d between the points of maximum baryon density [{\\rm km}] DOUBLE PRECISION :: distance !> Distance between the centers of mass [L_\\odot(=1.47662503825040{\\rm km})] DOUBLE PRECISION :: distance_com DOUBLE PRECISION , DIMENSION ( 2 ) :: mass !! Array containing the baryonic masses [M_\\odot] !> Baryonic mass of star 1 [M_\\odot] DOUBLE PRECISION :: mass1 !> Baryonic mass of star 2 [M_\\odot] DOUBLE PRECISION :: mass2 DOUBLE PRECISION , DIMENSION ( 2 ) :: mass_grav !! Array containing the gravitatil masses [M_\\odot] !> Gravitational mass of star 1 [M_\\odot] DOUBLE PRECISION :: mass_grav1 !> Gravitational mass of star 2 [M_\\odot] DOUBLE PRECISION :: mass_grav2 !> ADM mass of the BNS [M_\\odot] DOUBLE PRECISION :: adm_mass !& mOmega= ( [[bnsbase:angular_vel]][{\\rm km&#94;{-1}}] ) !  \\times ( [[bnsbase:mass_grav1]][{\\rm km}] !      + [[bnsbase:mass_grav2]][{\\rm km}] ) [pure number] ! !  Constant used in [K. Hotokezaka et al, Phys. Rev. D 87, 024001](https://arxiv.org/abs/1212.0905){:target=\"_blank\"} (see Sec. IIB) to determine when !  the BNS is at approximately 3-4 quasicircular orbits from merger. For the ! EOS APR4 and ALF2, this requirement is approximately satisfied for ! mOmega =0.026; for the EOS H4 and MS1, for mOmega =0.025. DOUBLE PRECISION :: mOmega !& Estimated time of the merger [M_\\odot] !   !  t_\\mathrm{merger}=\\dfrac{5}{256} !  \\dfrac{d&#94;4}{M&#94;1_\\mathrm{g}M&#94;2_\\mathrm{g}(M&#94;1_\\mathrm{g}+M&#94;2_\\mathrm{g})} !   !  [P. C. Peters, \"Gravitational Radiation and the Motion of Two Point !  Masses\", Phys. Rev. 136, B1224 (1964)](http://gravity.psu.edu/numrel/jclub/jc/Peters_PR_136_B1224_1964.pdf){:target=\"_blank\"} DOUBLE PRECISION :: t_merger !> Angular momentum of the BNS system [G M_\\odot&#94;2/c] DOUBLE PRECISION :: angular_momentum = 0.0D0 !& Areal (or circumferential) radius of star 1 [L_\\odot] ! Note that these is the areal radius of the star in the binary system, ! which is different than that of an isolated star. The latter is used ! in the mass-radius diagrams, together with the gravitatonal mass DOUBLE PRECISION :: area_radius1 DOUBLE PRECISION , DIMENSION ( 2 , 6 ) :: radii !# Array containing the **signed** radii of the stars !  @todo add details !> Radius of star 1, in the x direction, towards the companion [L_\\odot] DOUBLE PRECISION :: radius1_x_comp !> Radius of star 1, in the y direction [L_\\odot] DOUBLE PRECISION :: radius1_y !> Radius of star 1, in the z direction [L_\\odot] DOUBLE PRECISION :: radius1_z !> Radius of star 1, in the x direction, opposite to companion [L_\\odot] DOUBLE PRECISION :: radius1_x_opp !& Stellar center of star 1 (origin of the LORENE chart centered on star 1) !  [L_\\odot] DOUBLE PRECISION :: center1_x DOUBLE PRECISION , DIMENSION ( 2 , 3 ) :: center !# Array containing the centers of the stars !  @todo add details DOUBLE PRECISION , DIMENSION ( 2 , 3 ) :: barycenter !# Array containing the barycenters of the stars !  @todo add details !> Barycenter of star 1 [L_\\odot] DOUBLE PRECISION :: barycenter1_x !& Areal (or circumferential) radius of star 2 [L_\\odot] ! Note that these is the areal radius of the star in the binary system, ! which is different than that of an isolated star. The latter is used ! in the mass-radius diagrams, together with the gravitatonal mass DOUBLE PRECISION :: area_radius2 !> Radius of star 2, in the x direction, towards the companion [L_\\odot] DOUBLE PRECISION :: radius2_x_comp !> Radius of star 2, in the y direction [L_\\odot] DOUBLE PRECISION :: radius2_y !> Radius of star 2, in the z direction [L_\\odot] DOUBLE PRECISION :: radius2_z !> Radius of star 2, in the x direction, opposite to companion [L_\\odot] DOUBLE PRECISION :: radius2_x_opp !& Stellar center of star 2 (origin of the LORENE chart centered on star 2) !  [L_\\odot] DOUBLE PRECISION :: center2_x !> Barycenter of star 2 [L_\\odot] DOUBLE PRECISION :: barycenter2_x !> Central enthalpy for star 1 [c&#94;2] DOUBLE PRECISION :: ent_center1 !> Central baryon number density for star 1 [L_\\odot&#94;{-3}] DOUBLE PRECISION :: nbar_center1 !> Central baryon mass density for star 1 [M_\\odot L_\\odot&#94;{-3}] DOUBLE PRECISION :: rho_center1 !> Central energy density for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: energy_density_center1 !> Central specific energy for star 1 [c&#94;2] DOUBLE PRECISION :: specific_energy_center1 !> Central pressure for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: pressure_center1 !> Central enthalpy for star 2 [c&#94;2] DOUBLE PRECISION :: ent_center2 !> Central baryon number density for star 2 [L_\\odot&#94;{-3}] DOUBLE PRECISION :: nbar_center2 !> Central baryon mass density for star 2 [M_\\odot L_\\odot&#94;{-3}] DOUBLE PRECISION :: rho_center2 !> Central energy density for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: energy_density_center2 !> Central specific energy for star 2 [c&#94;2] DOUBLE PRECISION :: specific_energy_center2 !> Central pressure for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: pressure_center2 !> Name of the equation of state (|eos|) of star 1 CHARACTER ( LEN = : ), ALLOCATABLE :: eos1 !> Name of the equation of state (|eos|) of star 2 CHARACTER ( LEN = : ), ALLOCATABLE :: eos2 ! !-- Parameters of single polytropic equations of state for the two NSs ! !> Single polytrope: polytropic index for star 1 DOUBLE PRECISION :: gamma_1 !> Single polytrope: polytropic index for star 2 DOUBLE PRECISION :: gamma_2 !> Single polytrope: polytropic constant for star 1 [pure number] DOUBLE PRECISION :: kappa_1 !> Single polytrope: polytropic constant for star 2 [pure number] DOUBLE PRECISION :: kappa_2 ! !-- Parameters of the piecewise polytropic equation of state for NS 1 ! !> Piecewise polytrope: Number of polytropic pieces for star 1 INTEGER :: npeos_1 !> Piecewise polytrope: polytropic index \\gamma_0 for star 1 DOUBLE PRECISION :: gamma0_1 !> Piecewise polytrope: polytropic index \\gamma_1 for star 1 DOUBLE PRECISION :: gamma1_1 !> Piecewise polytrope: polytropic index \\gamma_2 for star 1 DOUBLE PRECISION :: gamma2_1 !> Piecewise polytrope: polytropic index \\gamma_3 for star 1 DOUBLE PRECISION :: gamma3_1 !& Piecewise polytrope: polytropic constant \\kappa_0 for star 1 !  [pure number] DOUBLE PRECISION :: kappa0_1 !& Piecewise polytrope: polytropic constant \\kappa_1 for star 1 !  [pure number] DOUBLE PRECISION :: kappa1_1 !& Piecewise polytrope: polytropic constant \\kappa_2 for star 1 !  [pure number] DOUBLE PRECISION :: kappa2_1 !& Piecewise polytrope: polytropic constant \\kappa_3 for star 1 !  [pure number] DOUBLE PRECISION :: kappa3_1 !& Piecewise polytrope: Base 10 exponent of the pressure at the first !  fiducial density (between \\gamma_0 and \\gamma_1) [{\\rm dyne/cm&#94;2}] !  for star 1 DOUBLE PRECISION :: logP1_1 !& Piecewise polytrope: Base 10 exponent of the first fiducial density !  (between \\gamma_0 and \\gamma_1) [{\\rm g/cm&#94;3}] for star 1 DOUBLE PRECISION :: logRho0_1 !& Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] for star 1 DOUBLE PRECISION :: logRho1_1 !& Piecewise polytrope: Base 10 exponent of the third fiducial density !  (between \\gamma_2 and \\gamma_3) [{\\rm g/cm&#94;3}] for star 1 DOUBLE PRECISION :: logRho2_1 ! !-- Parameters of the piecewise polytropic equation of state for NS 2 ! !> Piecewise polytrope: Number of polytropic pieces for star 2 INTEGER :: npeos_2 !> Piecewise polytrope: polytropic index \\gamma_0 for star 2 DOUBLE PRECISION :: gamma0_2 !> Piecewise polytrope: polytropic index \\gamma_1 for star 2 DOUBLE PRECISION :: gamma1_2 !> Piecewise polytrope: polytropic index \\gamma_2 for star 2 DOUBLE PRECISION :: gamma2_2 !> Piecewise polytrope: polytropic index \\gamma_3 for star 2 DOUBLE PRECISION :: gamma3_2 !& Piecewise polytrope: polytropic constant \\kappa_0 for star 2 !  [pure number] DOUBLE PRECISION :: kappa0_2 !& Piecewise polytrope: polytropic constant \\kappa_1 for star 2 !  [pure number] DOUBLE PRECISION :: kappa1_2 !& Piecewise polytrope: polytropic constant \\kappa_2 for star 2 !  [pure number] DOUBLE PRECISION :: kappa2_2 !& Piecewise polytrope: polytropic constant \\kappa_3 for star 2 !  [pure number] DOUBLE PRECISION :: kappa3_2 !& Piecewise polytrope: Base 10 exponent of the pressure at the first !  fiducial density (between \\gamma_0 and \\gamma_1) [{\\rm dyne/cm&#94;2}] !  for star 2 DOUBLE PRECISION :: logP1_2 !& Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] for star 2 DOUBLE PRECISION :: logRho0_2 !& Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] for star 2 DOUBLE PRECISION :: logRho1_2 !& Piecewise polytrope: Base 10 exponent of the third fiducial density !  (between \\gamma_2 and \\gamma_3) [{\\rm g/cm&#94;3}] for star 2 DOUBLE PRECISION :: logRho2_2 CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE ( get_eos_id_int ), DEFERRED :: get_eos1_id !! Returns an integer that identifies the equation of state of star 1 PROCEDURE ( get_eos_id_int ), DEFERRED :: get_eos2_id !! Returns an integer that identifies the equation of state of star 2 !PROCEDURE:: integrate_field_on_star => integrate_baryon_mass_density !# Integrates the LORENE baryon mass density and computes the !  radial mass profile !-----------------! !--  FUNCTIONS  --! !-----------------! ! !-- Overloaded FUNCTION to access the fields as arrays and as values ! !     GENERIC, PUBLIC:: get_field => get_fa, get_fv !     !# GENERIC PROCEDURE, overloded to access the bns member variables as arrays !     !  and as values !     PROCEDURE::       get_fa    => get_field_array !     !! Access the bns member arrays !     PROCEDURE::       get_fv    => get_field_value !! Access the components of the bns member arrays ! !-- FUNCTIONS that access member variables ! !PROCEDURE, PUBLIC:: get_bns_identifier !PROCEDURE, PUBLIC:: get_bns_ptr PROCEDURE :: return_mass => get_mass PROCEDURE :: return_center => get_center PROCEDURE :: return_barycenter => get_barycenter PROCEDURE :: return_eos_name => get_eos PROCEDURE :: return_spatial_extent => get_radii !PROCEDURE:: return_total_spatial_extent => get_bounding_box PROCEDURE , PUBLIC :: get_angular_vel !! Returns [[bnsbase:angular_vel]] PROCEDURE , PUBLIC :: get_distance !! Returns [[bnsbase:distance]] PROCEDURE , PUBLIC :: get_distance_com !! Returns [[bnsbase:distance_com]] PROCEDURE , PUBLIC :: get_mass1 !! Returns [[bnsbase:mass1]] PROCEDURE , PUBLIC :: get_mass2 !! Returns [[bnsbase:mass2]] PROCEDURE , PUBLIC :: get_grav_mass1 !! Returns [[bnsbase:mass_grav1]] PROCEDURE , PUBLIC :: get_grav_mass2 !! Returns [[bnsbase:mass_grav2]] PROCEDURE , PUBLIC :: get_adm_mass !! Returns [[bnsbase:adm_mass]] PROCEDURE , PUBLIC :: get_angular_momentum !! Returns [[bnsbase:angular_momentum]] PROCEDURE , PUBLIC :: get_radius1_x_comp !! Returns [[bnsbase:radius1_x_comp]] PROCEDURE , PUBLIC :: get_radius1_y !! Returns [[bnsbase:radius1_y]] PROCEDURE , PUBLIC :: get_radius1_z !! Returns [[bnsbase:radius1_z]] PROCEDURE , PUBLIC :: get_radius1_x_opp !! Returns [[bnsbase:radius1_x_opp]] PROCEDURE , PUBLIC :: get_center1_x !! Returns [[bnsbase:center1_x]] PROCEDURE , PUBLIC :: get_barycenter1_x !! Returns [[bnsbase:barycenter1_x]] PROCEDURE , PUBLIC :: get_radius2_x_comp !! Returns [[bnsbase:radius2_x_comp]] PROCEDURE , PUBLIC :: get_radius2_y !! Returns [[bnsbase:radius2_y]] PROCEDURE , PUBLIC :: get_radius2_z !! Returns [[bnsbase:radius2_y]] PROCEDURE , PUBLIC :: get_radius2_x_opp !! Returns [[bnsbase:radius2_x_opp]] PROCEDURE , PUBLIC :: get_center2_x !! Returns [[bnsbase:center2_x]] PROCEDURE , PUBLIC :: get_barycenter2_x !! Returns [[bnsbase:barycenter2_x]] PROCEDURE , PUBLIC :: get_ent_center1 !! Returns [[bnsbase:ent_center1]] PROCEDURE , PUBLIC :: get_nbar_center1 !! Returns [[bnsbase:nbar_center1]] PROCEDURE , PUBLIC :: get_rho_center1 !! Returns [[bnsbase:rho_center1]] PROCEDURE , PUBLIC :: get_energy_density_center1 !! Returns [[bnsbase:energy_density_center1]] PROCEDURE , PUBLIC :: get_specific_energy_center1 !! Returns [[bnsbase:specific_energy_center1]] PROCEDURE , PUBLIC :: get_pressure_center1 !! Returns [[bnsbase:pressure_center1]] PROCEDURE , PUBLIC :: get_ent_center2 !! Returns [[bnsbase:ent_center2]] PROCEDURE , PUBLIC :: get_nbar_center2 !! Returns [[bnsbase:nbar_center2]] PROCEDURE , PUBLIC :: get_rho_center2 !! Returns [[bnsbase:rho_center2]] PROCEDURE , PUBLIC :: get_energy_density_center2 !! Returns [[bnsbase:energy_density_center2]] PROCEDURE , PUBLIC :: get_specific_energy_center2 !! Returns [[bnsbase:specific_energy_center2]] PROCEDURE , PUBLIC :: get_pressure_center2 !! Returns [[bnsbase:pressure_center2]] PROCEDURE , PUBLIC :: get_eos1 !! Returns [[bnsbase:eos1]] PROCEDURE , PUBLIC :: get_eos2 !! Returns [[bnsbase:eos2]] ! !-- PROCEDURES to be used for single polytropic EOS ! PROCEDURE , PUBLIC :: get_gamma_1 !! Returns [[bnsbase:gamma_1]] PROCEDURE , PUBLIC :: get_gamma_2 !! Returns [[bnsbase:gamma_2]] PROCEDURE , PUBLIC :: get_kappa_1 !! Returns [[bnsbase:kappa_1]] PROCEDURE , PUBLIC :: get_kappa_2 !! Returns [[bnsbase:kappa_2]] ! !-- PROCEDURES to be used for piecewise polytropic EOS ! PROCEDURE , PUBLIC :: get_npeos_1 !! Returns [[bnsbase:npeos_1]] PROCEDURE , PUBLIC :: get_gamma0_1 !! Returns [[bnsbase:gamma0_1]] PROCEDURE , PUBLIC :: get_gamma1_1 !! Returns [[bnsbase:gamma1_1]] PROCEDURE , PUBLIC :: get_gamma2_1 !! Returns [[bnsbase:gamma2_1]] PROCEDURE , PUBLIC :: get_gamma3_1 !! Returns [[bnsbase:gamma3_1]] PROCEDURE , PUBLIC :: get_kappa0_1 !! Returns [[bnsbase:kappa0_1]] PROCEDURE , PUBLIC :: get_kappa1_1 !! Returns [[bnsbase:kappa1_1]] PROCEDURE , PUBLIC :: get_kappa2_1 !! Returns [[bnsbase:kappa2_1]] PROCEDURE , PUBLIC :: get_kappa3_1 !! Returns [[bnsbase:kappa3_1]] PROCEDURE , PUBLIC :: get_logP1_1 !! Returns [[bnsbase:logP1_1]] PROCEDURE , PUBLIC :: get_logRho0_1 !! Returns [[bnsbase:logRho0_1]] PROCEDURE , PUBLIC :: get_logRho1_1 !! Returns [[bnsbase:logRho1_1]] PROCEDURE , PUBLIC :: get_logRho2_1 !! Returns [[bnsbase:logRho2_1]] PROCEDURE , PUBLIC :: get_npeos_2 !! Returns [[bnsbase:npeos_2]] PROCEDURE , PUBLIC :: get_gamma0_2 !! Returns [[bnsbase:gamma0_2]] PROCEDURE , PUBLIC :: get_gamma1_2 !! Returns [[bnsbase:gamma1_2]] PROCEDURE , PUBLIC :: get_gamma2_2 !! Returns [[bnsbase:gamma2_2]] PROCEDURE , PUBLIC :: get_gamma3_2 !! Returns [[bnsbase:gamma3_2]] PROCEDURE , PUBLIC :: get_kappa0_2 !! Returns [[bnsbase:kappa0_2]] PROCEDURE , PUBLIC :: get_kappa1_2 !! Returns [[bnsbase:kappa1_2]] PROCEDURE , PUBLIC :: get_kappa2_2 !! Returns [[bnsbase:kappa2_2]] PROCEDURE , PUBLIC :: get_kappa3_2 !! Returns [[bnsbase:kappa3_2]] PROCEDURE , PUBLIC :: get_logP1_2 !! Returns [[bnsbase:logP1_2]] PROCEDURE , PUBLIC :: get_logRho0_2 !! Returns [[bnsbase:logRho0_2]] PROCEDURE , PUBLIC :: get_logRho1_2 !! Returns [[bnsbase:logRho1_2]] PROCEDURE , PUBLIC :: get_logRho2_2 !! Returns [[bnsbase:logRho2_2]] END TYPE bnsbase","tags":"","loc":"type/bnsbase.html"},{"title":"bnslorene – SPHINCS_LORENE ","text":"type, public, extends( bnsbase ) :: bnslorene TYPE representing a binary system of neutron stars (bns) Inherits type~~bnslorene~~InheritsGraph type~bnslorene bnslorene C_PTR C_PTR type~bnslorene->C_PTR bns_ptr type~bnsbase bnsbase type~bnslorene->type~bnsbase type~idbase idbase type~bnsbase->type~idbase timer timer type~idbase->timer construction_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables adm_mass angular_momentum angular_vel area_radius1 area_radius2 barycenter barycenter1_x barycenter2_x baryon_density bns_identifier bns_ptr center center1_x center2_x construction_timer distance distance_com energy_density energy_density_center1 energy_density_center2 ent_center1 ent_center2 eos1 eos1_loreneid eos2 eos2_loreneid g_xx g_xy g_xz g_yy g_yz g_zz gamma0_1 gamma0_2 gamma1_1 gamma1_2 gamma2_1 gamma2_2 gamma3_1 gamma3_2 gamma_1 gamma_2 k_xx k_xy k_xz k_yy k_yz k_zz kappa0_1 kappa0_2 kappa1_1 kappa1_2 kappa2_1 kappa2_2 kappa3_1 kappa3_2 kappa_1 kappa_2 lapse logP1_1 logP1_2 logRho0_1 logRho0_2 logRho1_1 logRho1_2 logRho2_1 logRho2_2 mOmega mass mass1 mass2 mass_grav mass_grav1 mass_grav2 nbar_center1 nbar_center2 npeos_1 npeos_2 pressure_center1 pressure_center2 radii radius1_x_comp radius1_x_opp radius1_y radius1_z radius2_x_comp radius2_x_opp radius2_y radius2_z rho_center1 rho_center2 shift_x shift_y shift_z specific_energy specific_energy_center1 specific_energy_center2 t_merger v_euler_x v_euler_y v_euler_z Constructor bnslorene Finalization Procedures destruct_bnslorene Type-Bound Procedures allocate_lorene_id_memory check_i_matter construct_binary deallocate_lorene_id_memory destruct_binary get_adm_mass get_angular_momentum get_angular_vel get_barycenter1_x get_barycenter2_x get_bns_identifier get_center1_x get_center2_x get_distance get_distance_com get_energy_density_center1 get_energy_density_center2 get_ent_center1 get_ent_center2 get_eos1 get_eos1_id get_eos1_loreneid get_eos2 get_eos2_id get_eos2_loreneid get_fa get_field get_fv get_gamma0_1 get_gamma0_2 get_gamma1_1 get_gamma1_2 get_gamma2_1 get_gamma2_2 get_gamma3_1 get_gamma3_2 get_gamma_1 get_gamma_2 get_grav_mass1 get_grav_mass2 get_kappa0_1 get_kappa0_2 get_kappa1_1 get_kappa1_2 get_kappa2_1 get_kappa2_2 get_kappa3_1 get_kappa3_2 get_kappa_1 get_kappa_2 get_logP1_1 get_logP1_2 get_logRho0_1 get_logRho0_2 get_logRho1_1 get_logRho1_2 get_logRho2_1 get_logRho2_2 get_mass1 get_mass2 get_n_matter get_nbar_center1 get_nbar_center2 get_npeos_1 get_npeos_2 get_one_lapse get_pressure_center1 get_pressure_center2 get_radius1_x_comp get_radius1_x_opp get_radius1_y get_radius1_z get_radius2_x_comp get_radius2_x_opp get_radius2_y get_radius2_z get_rho_center1 get_rho_center2 get_specific_energy_center1 get_specific_energy_center2 get_total_spatial_extent get_zero_shift import_id_int import_id_params import_spatial_metric integrate_baryon_mass_density print_id_params read_id_full read_id_hydro read_id_k read_id_mass_b read_id_particles read_id_spacetime read_mass_density return_barycenter return_center return_eos_name return_eos_parameters return_mass return_spatial_extent set_n_matter set_one_lapse set_zero_shift test_position Source Code bnslorene Components Type Visibility Attributes Name Initial double precision, public :: adm_mass ADM mass of the BNS [M_\\odot] double precision, public :: angular_momentum = 0.0D0 Angular momentum of the BNS system [G M_\\odot&#94;2/c] double precision, public :: angular_vel Angular velocity [{\\rm rad/s}] double precision, public :: area_radius1 Areal (or circumferential) radius of star 1 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public :: area_radius2 Areal (or circumferential) radius of star 2 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(2,3) :: barycenter Array containing the barycenters of the stars Todo add details double precision, public :: barycenter1_x Barycenter of star 1 [L_\\odot] double precision, public :: barycenter2_x Barycenter of star 2 [L_\\odot] double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] integer, private :: bns_identifier = 0 Identifier of the bnslorene object type(C_PTR), private :: bns_ptr C pointer to the \\texttt{LORENE}'s \\texttt{Bin_NS} object\nN.B. This variable is global. The pointer to the second \\texttt{LORENE} \\texttt{Bin_NS}\n     object will overwrite the first one, and so on.\n     This variable stores the pointer to the last defined \\texttt{LORENE} \\texttt{Bin_NS}\n     object. That's why it is not freed in the destructor of a bns object.\n     Presently, it has to be freed by the user at the end of the PROGRAM.\n     See the last part of the PROGRAM in setup_lorene_id.f90, for example. double precision, public, DIMENSION(2,3) :: center Array containing the centers of the stars Todo add details double precision, public :: center1_x Stellar center of star 1 (origin of the LORENE chart centered on star 1) [L_\\odot] double precision, public :: center2_x Stellar center of star 2 (origin of the LORENE chart centered on star 2) [L_\\odot] type(timer), public :: construction_timer Timer that times the construction of the appropriate object double precision, public :: distance Distance d between the points of maximum baryon density [{\\rm km}] double precision, public :: distance_com Distance between the centers of mass [L_\\odot(=1.47662503825040{\\rm km})] double precision, private, DIMENSION(:), ALLOCATABLE :: energy_density 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] double precision, public :: energy_density_center1 Central energy density for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: energy_density_center2 Central energy density for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center1 Central enthalpy for star 1 [c&#94;2] double precision, public :: ent_center2 Central enthalpy for star 2 [c&#94;2] character(len=:), public, ALLOCATABLE :: eos1 Name of the equation of state (EoS) of star 1 integer, private :: eos1_loreneid \\texttt{LORENE} identifiers for the EoS character(len=:), public, ALLOCATABLE :: eos2 Name of the equation of state (EoS) of star 2 integer, private :: eos2_loreneid \\texttt{LORENE} identifiers for the EoS double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx 1-D array storing the xx component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xy 1-D array storing the xy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xz 1-D array storing the xz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yy 1-D array storing the yy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yz 1-D array storing the yz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_zz 1-D array storing the zz component of the spatial metric [pure number] double precision, public :: gamma0_1 Piecewise polytrope: polytropic index \\gamma_0 for star 1 double precision, public :: gamma0_2 Piecewise polytrope: polytropic index \\gamma_0 for star 2 double precision, public :: gamma1_1 Piecewise polytrope: polytropic index \\gamma_1 for star 1 double precision, public :: gamma1_2 Piecewise polytrope: polytropic index \\gamma_1 for star 2 double precision, public :: gamma2_1 Piecewise polytrope: polytropic index \\gamma_2 for star 1 double precision, public :: gamma2_2 Piecewise polytrope: polytropic index \\gamma_2 for star 2 double precision, public :: gamma3_1 Piecewise polytrope: polytropic index \\gamma_3 for star 1 double precision, public :: gamma3_2 Piecewise polytrope: polytropic index \\gamma_3 for star 2 double precision, public :: gamma_1 Single polytrope: polytropic index for star 1 double precision, public :: gamma_2 Single polytrope: polytropic index for star 2 double precision, private, DIMENSION(:), ALLOCATABLE :: k_xx 1-D array storing the xx component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xy 1-D array storing the xy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xz 1-D array storing the xz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yy 1-D array storing the yy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yz 1-D array storing the yz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_zz 1-D array storing the zz component of the extrinsic curvature\n [c/MSun_geo] double precision, public :: kappa0_1 Piecewise polytrope: polytropic constant \\kappa_0 for star 1\n [pure number] double precision, public :: kappa0_2 Piecewise polytrope: polytropic constant \\kappa_0 for star 2\n [pure number] double precision, public :: kappa1_1 Piecewise polytrope: polytropic constant \\kappa_1 for star 1\n [pure number] double precision, public :: kappa1_2 Piecewise polytrope: polytropic constant \\kappa_1 for star 2\n [pure number] double precision, public :: kappa2_1 Piecewise polytrope: polytropic constant \\kappa_2 for star 1\n [pure number] double precision, public :: kappa2_2 Piecewise polytrope: polytropic constant \\kappa_2 for star 2\n [pure number] double precision, public :: kappa3_1 Piecewise polytrope: polytropic constant \\kappa_3 for star 1\n [pure number] double precision, public :: kappa3_2 Piecewise polytrope: polytropic constant \\kappa_3 for star 2\n [pure number] double precision, public :: kappa_1 Single polytrope: polytropic constant for star 1 [pure number] double precision, public :: kappa_2 Single polytrope: polytropic constant for star 2 [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: lapse 1-D array storing the lapse function double precision, public :: logP1_1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 1 double precision, public :: logP1_2 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 2 double precision, public :: logRho0_1 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho0_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho1_1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho1_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho2_1 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho2_2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: mOmega mOmega= ( angular_vel [{\\rm km&#94;{-1}}] ) \\times ( mass_grav1 [{\\rm km}] + mass_grav2 [{\\rm km}] ) [pure number] Constant used in K. Hotokezaka et al, Phys. Rev. D 87, 024001 (see Sec. IIB) to determine when\n the BNS is at approximately 3-4 quasicircular orbits from merger. For the\nEOS APR4 and ALF2, this requirement is approximately satisfied for\nmOmega =0.026 ; for the EOS H4 and MS1, for mOmega =0.025 . double precision, public, DIMENSION(2) :: mass Array containing the baryonic masses [M_\\odot] double precision, public :: mass1 Baryonic mass of star 1 [M_\\odot] double precision, public :: mass2 Baryonic mass of star 2 [M_\\odot] double precision, public, DIMENSION(2) :: mass_grav Array containing the gravitatil masses [M_\\odot] double precision, public :: mass_grav1 Gravitational mass of star 1 [M_\\odot] double precision, public :: mass_grav2 Gravitational mass of star 2 [M_\\odot] double precision, public :: nbar_center1 Central baryon number density for star 1 [L_\\odot&#94;{-3}] double precision, public :: nbar_center2 Central baryon number density for star 2 [L_\\odot&#94;{-3}] integer, public :: npeos_1 Piecewise polytrope: Number of polytropic pieces for star 1 integer, public :: npeos_2 Piecewise polytrope: Number of polytropic pieces for star 2 double precision, public :: pressure_center1 Central pressure for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: pressure_center2 Central pressure for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public, DIMENSION(2,6) :: radii Array containing the signed radii of the stars Todo add details double precision, public :: radius1_x_comp Radius of star 1, in the x direction, towards the companion [L_\\odot] double precision, public :: radius1_x_opp Radius of star 1, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius1_y Radius of star 1, in the y direction [L_\\odot] double precision, public :: radius1_z Radius of star 1, in the z direction [L_\\odot] double precision, public :: radius2_x_comp Radius of star 2, in the x direction, towards the companion [L_\\odot] double precision, public :: radius2_x_opp Radius of star 2, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius2_y Radius of star 2, in the y direction [L_\\odot] double precision, public :: radius2_z Radius of star 2, in the z direction [L_\\odot] double precision, public :: rho_center1 Central baryon mass density for star 1 [M_\\odot L_\\odot&#94;{-3}] double precision, public :: rho_center2 Central baryon mass density for star 2 [M_\\odot L_\\odot&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_x 1-D array storing the x component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_y 1-D array storing the y component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_z 1-D array storing the z component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: specific_energy 1-D array storing the specific internal energy [c&#94;2] double precision, public :: specific_energy_center1 Central specific energy for star 1 [c&#94;2] double precision, public :: specific_energy_center2 Central specific energy for star 2 [c&#94;2] double precision, public :: t_merger Estimated time of the merger [M_\\odot] t_\\mathrm{merger}=\\dfrac{5}{256}\n \\dfrac{d&#94;4}{M&#94;1_\\mathrm{g}M&#94;2_\\mathrm{g}(M&#94;1_\\mathrm{g}+M&#94;2_\\mathrm{g})} P. C. Peters, \"Gravitational Radiation and the Motion of Two Point\n Masses\", Phys. Rev. 136, B1224 (1964) double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_x 1-D array storing the x component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_y 1-D array storing the y component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_z 1-D array storing the z component of the fluid 3-velocity with respect to Constructor public interface bnslorene Interface of TYPE bnslorene public interface construct_bnslorene () Arguments None Finalization Procedures final :: destruct_bnslorene Finalizer (Destructor) of a [[bnslorene]] object public interface destruct_bnslorene () Arguments None Type-Bound Procedures procedure, public :: allocate_lorene_id_memory Allocates memory for the bnslorene member arrays interface public module module subroutine allocate_lorene_id_memory(THIS, d) Implementation → Allocates allocatable arrays member of a bnslorene object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. interface public module module subroutine check_i_matter(THIS, i_matter) Implementation → Checks that the given index i_matter is between 1 and n_matter , included. If not, it stops the execution of the\n program. Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked procedure, public :: construct_binary Constructs the \\texttt{LORENE} \\texttt{Bin_NS} object interface public module module subroutine construct_binary(THIS, resu_file) Implementation → Interface of the subroutine that constructs the \\texttt{LORENE} \\texttt{Bin_NS} object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID procedure, public :: deallocate_lorene_id_memory Deallocates memory for the bnslorene member arrays interface public module module subroutine deallocate_lorene_id_memory(THIS) Implementation → Deallocates allocatable arrays member of a bnslorene object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of procedure, public :: destruct_binary Destructs the \\texttt{LORENE} \\texttt{Bin_NS} object interface public module module subroutine destruct_binary(THIS) Implementation → Destructs a \\texttt{LORENE} \\texttt{Bin_NS} object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of procedure, public :: get_adm_mass Returns adm_mass interface public module module function get_adm_mass(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_angular_momentum Returns angular_momentum interface public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_angular_vel Returns angular_vel interface public module module function get_angular_vel(THIS) Implementation → Returns angular_vel Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_barycenter1_x Returns barycenter1_x interface public module module function get_barycenter1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_barycenter2_x Returns barycenter2_x interface public module module function get_barycenter2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_bns_identifier Returns bns_identifier interface public module module function get_bns_identifier(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_center1_x Returns center1_x interface public module module function get_center1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_center2_x Returns center2_x interface public module module function get_center2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_distance Returns distance interface public module module function get_distance(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_distance_com Returns distance_com interface public module module function get_distance_com(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_energy_density_center1 Returns energy_density_center1 interface public module module function get_energy_density_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_energy_density_center2 Returns energy_density_center2 interface public module module function get_energy_density_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_ent_center1 Returns ent_center1 interface public module module function get_ent_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_ent_center2 Returns ent_center2 interface public module module function get_ent_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_eos1 Returns eos1 interface public module module function get_eos1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE procedure, public :: get_eos1_id => get_eos1_loreneid Returns the \\texttt{LORENE} identifier for the EOS of star 1 interface public module module function get_eos1_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer procedure, public :: get_eos1_loreneid Returns eos1_loreneid interface public module module function get_eos1_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer procedure, public :: get_eos2 Returns eos2 interface public module module function get_eos2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE procedure, public :: get_eos2_id => get_eos2_loreneid Returns the \\texttt{LORENE} identifier for the EOS of star 2 interface public module module function get_eos2_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer procedure, public :: get_eos2_loreneid Returns eos2_loreneid interface public module module function get_eos2_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer procedure, public :: get_fa => get_field_array Access the bnslorene -member arrays interface public module module function get_field_array(THIS, field) result(field_array) Implementation → Returns the bnslorene member arrays named field Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Desired bnslorene member array generic, public :: get_field => get_fa , get_fv GENERIC PROCEDURE, overloded to access the bnslorene -member variables\n as arrays and as values public interface get_field_array () Arguments None public interface get_field_value () Arguments None procedure, public :: get_fv => get_field_value Access the components of the bnslorene -member arrays interface public module module function get_field_value(THIS, field, n) result(field_value) Implementation → Returns the component n of the bnslorene member arrays named field Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array integer, intent(in) :: n Component of the desired bnslorene member array Return Value double precision Component n of the desired bnslorene member array procedure, public :: get_gamma0_1 Returns gamma0_1 interface public module module function get_gamma0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma0_2 Returns gamma0_2 interface public module module function get_gamma0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma1_1 Returns gamma1_1 interface public module module function get_gamma1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma1_2 Returns gamma1_2 interface public module module function get_gamma1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma2_1 Returns gamma2_1 interface public module module function get_gamma2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma2_2 Returns gamma2_2 interface public module module function get_gamma2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma3_1 Returns gamma3_1 interface public module module function get_gamma3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma3_2 Returns gamma3_2 interface public module module function get_gamma3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma_1 Returns gamma_1 interface public module module function get_gamma_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma_2 Returns gamma_2 interface public module module function get_gamma_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grav_mass1 Returns mass_grav1 interface public module module function get_grav_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grav_mass2 Returns mass_grav2 interface public module module function get_grav_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa0_1 Returns kappa0_1 interface public module module function get_kappa0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa0_2 Returns kappa0_2 interface public module module function get_kappa0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa1_1 Returns kappa1_1 interface public module module function get_kappa1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa1_2 Returns kappa1_2 interface public module module function get_kappa1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa2_1 Returns kappa2_1 interface public module module function get_kappa2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa2_2 Returns kappa2_2 interface public module module function get_kappa2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa3_1 Returns kappa3_1 interface public module module function get_kappa3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa3_2 Returns kappa3_2 interface public module module function get_kappa3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa_1 Returns kappa_1 interface public module module function get_kappa_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa_2 Returns kappa_2 interface public module module function get_kappa_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logP1_1 Returns logP1_1 interface public module module function get_logP1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logP1_2 Returns logP1_2 interface public module module function get_logP1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho0_1 Returns logRho0_1 interface public module module function get_logRho0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho0_2 Returns logRho0_2 interface public module module function get_logRho0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho1_1 Returns logRho1_1 interface public module module function get_logRho1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho1_2 Returns logRho1_2 interface public module module function get_logRho1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho2_1 Returns logRho2_1 interface public module module function get_logRho2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho2_2 Returns logRho2_2 interface public module module function get_logRho2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_mass1 Returns mass1 interface public module module function get_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_mass2 Returns mass2 interface public module module function get_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system interface public module module function get_n_matter(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the procedure, public :: get_nbar_center1 Returns nbar_center1 interface public module module function get_nbar_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_nbar_center2 Returns nbar_center2 interface public module module function get_nbar_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_npeos_1 Returns npeos_1 interface public module module function get_npeos_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer procedure, public :: get_npeos_2 Returns npeos_2 interface public module module function get_npeos_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module function get_one_lapse(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: get_pressure_center1 Returns pressure_center1 interface public module module function get_pressure_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_pressure_center2 Returns pressure_center2 interface public module module function get_pressure_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_x_comp Returns radius1_x_comp interface public module module function get_radius1_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_x_opp Returns radius1_x_opp interface public module module function get_radius1_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_y Returns radius1_y interface public module module function get_radius1_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius1_z Returns radius1_z interface public module module function get_radius1_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_x_comp Returns radius2_x_comp interface public module module function get_radius2_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_x_opp Returns radius2_x_opp interface public module module function get_radius2_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_y Returns radius2_y interface public module module function get_radius2_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_radius2_z Returns radius2_y interface public module module function get_radius2_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_rho_center1 Returns rho_center1 interface public module module function get_rho_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_rho_center2 Returns rho_center2 interface public module module function get_rho_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_center1 Returns specific_energy_center1 interface public module module function get_specific_energy_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_center2 Returns specific_energy_center2 interface public module module function get_specific_energy_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} interface public module module function get_total_spatial_extent(THIS) result(box) Implementation → INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module function get_zero_shift(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: import_id_int Stores the ID in the bnslorene member arrays interface public module module subroutine import_id_int(THIS, n, x, y, z) Implementation → Stores the ID in the bnslorene member arrays Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z procedure, public :: import_id_params Imports the parameters of the BNS from \\texttt{LORENE} Integrates the \\texttt{LORENE} baryon mass density and computes the\n radial mass profile interface public module module subroutine import_id_params(THIS) Implementation → Imports the BNS parameters from \\texttt{LORENE} Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of procedure, public :: import_spatial_metric Returns the \\texttt{LORENE}'s conformally flat spatial ADM metric interface public module module function import_spatial_metric(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} conformally flat spatial metric component g_{xx}=g_{yy}=g_{zz} at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star interface public module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Implementation → INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order procedure, public :: print_id_params Prints the parameters of the BNS to the standard output interface public module module subroutine print_id_params(THIS) Implementation → Prints the BNS parameters to the standard output Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of procedure, public :: read_id_full => import_id_full interface public module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the ID in non bnslorene -member arrays with the same shape as the bnslorene member arrays Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure, public :: read_id_hydro => import_id_hydro interface public module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Implementation → Stores the hydro ID in the arrays needed to compute the constraints\n on the refined mesh Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler procedure, public :: read_id_k => import_id_k interface public module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Implementation → Stores the components of the extrinsic curvature in arrays Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz procedure, public :: read_id_mass_b => import_id_mass_b interface public module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Implementation → Stores the hydro ID in the arrays needed to compute the baryon mass Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure, public :: read_id_particles => import_id_particles interface public module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the hydro ID in the arrays needed to compute the SPH ID Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure, public :: read_id_spacetime => import_id_spacetime interface public module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Implementation → Stores the spacetime ID in multi-dimensional arrays needed to compute\n the BSSN variables and constraints Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek procedure, public :: read_mass_density => import_mass_density Returns the \\texttt{LORENE}'s mass density at the given point interface public module module function import_mass_density(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} baryon mass density at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) procedure, public :: return_barycenter => get_barycenter interface public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_center => get_center interface public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_eos_name => get_eos interface public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE procedure, public :: return_eos_parameters => get_eos_parameters interface public module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object procedure, public :: return_mass => get_mass interface public module module function get_mass(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision procedure, public :: return_spatial_extent => get_radii interface public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value interface public module module subroutine set_n_matter(THIS, value) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module subroutine set_one_lapse(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module subroutine set_zero_shift(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure, public :: test_position => is_hydro_negative Returns 1 if the energy density or the specific energy or the pressure\n are negative interface public module module function is_hydro_negative(THIS, x, y, z) result(res) Implementation → Returns 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Source Code TYPE , EXTENDS ( bnsbase ) :: bnslorene !! TYPE representing a binary system of neutron stars (bns) PRIVATE !> Identifier of the bnslorene object INTEGER :: bns_identifier = 0 !> |lorene| identifiers for the EoS INTEGER :: eos1_loreneid , eos2_loreneid ! !-- Spacetime fields ! !> 1-D array storing the lapse function DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: lapse !> 1-D array storing the x component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_x !> 1-D array storing the y component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_y !> 1-D array storing the z component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_z !> 1-D array storing the xx component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xx !> 1-D array storing the xy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xy !> 1-D array storing the xz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xz !> 1-D array storing the yy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yy !> 1-D array storing the yz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yz !> 1-D array storing the zz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_zz !& 1-D array storing the xx component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xx !& 1-D array storing the xy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xy !& 1-D array storing the xz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xz !& 1-D array storing the yy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yy !& 1-D array storing the yz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yz !& 1-D array storing the zz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_zz ! !-- Hydro fields ! !> 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: baryon_density !> 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: energy_density !> 1-D array storing the specific internal energy [c&#94;2] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: specific_energy !> 1-D array storing the x component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_x !> 1-D array storing the y component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_y !> 1-D array storing the z component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_z !& C pointer to the |lorene|'s |binns| object ! N.B. This variable is global. The pointer to the second |lorene| |binns| !      object will overwrite the first one, and so on. !      This variable stores the pointer to the last defined |lorene| |binns| !      object. That's why it is not freed in the destructor of a bns object. !      Presently, it has to be freed by the user at the end of the PROGRAM. !      See the last part of the PROGRAM in setup_lorene_id.f90, for example. TYPE ( C_PTR ) :: bns_ptr CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: construct_binary !! Constructs the |lorene| |binns| object PROCEDURE :: destruct_binary !! Destructs the |lorene| |binns| object PROCEDURE :: allocate_lorene_id_memory !! Allocates memory for the [[bnslorene]] member arrays PROCEDURE :: deallocate_lorene_id_memory !! Deallocates memory for the [[bnslorene]] member arrays PROCEDURE :: import_id_params !! Imports the parameters of the BNS from |lorene| !PROCEDURE:: integrate_field_on_star => integrate_baryon_mass_density !# Integrates the |lorene| baryon mass density and computes the !  radial mass profile PROCEDURE , PUBLIC :: print_id_params !! Prints the parameters of the BNS to the standard output PROCEDURE :: import_id_int !! Stores the ID in the [[bnslorene]] member arrays PROCEDURE :: read_id_full => import_id_full PROCEDURE :: read_id_spacetime => import_id_spacetime PROCEDURE :: read_id_particles => import_id_particles PROCEDURE :: read_id_hydro => import_id_hydro PROCEDURE :: read_id_mass_b => import_id_mass_b PROCEDURE :: read_id_k => import_id_k !-----------------! !--  FUNCTIONS  --! !-----------------! !> Returns the |lorene|'s mass density at the given point PROCEDURE :: read_mass_density => import_mass_density !> Returns the |lorene|'s conformally flat spatial ADM metric PROCEDURE :: import_spatial_metric !& Returns 1 if the energy density or the specific energy or the pressure !  are negative PROCEDURE :: test_position => is_hydro_negative !PROCEDURE, NOPASS:: derived_type_constructor => construct_bnslorene2 ! !-- Overloaded FUNCTION to access the fields as arrays and as values ! GENERIC , PUBLIC :: get_field => get_fa , get_fv !# GENERIC PROCEDURE, overloded to access the [[bnslorene]]-member variables !  as arrays and as values PROCEDURE :: get_fa => get_field_array !! Access the [[bnslorene]]-member arrays PROCEDURE :: get_fv => get_field_value !! Access the components of the [[bnslorene]]-member arrays ! !-- FUNCTIONS that access member variables ! PROCEDURE :: get_eos1_id => get_eos1_loreneid !! Returns the |lorene| identifier for the EOS of star 1 PROCEDURE :: get_eos2_id => get_eos2_loreneid !! Returns the |lorene| identifier for the EOS of star 2 PROCEDURE :: return_eos_parameters => get_eos_parameters PROCEDURE , PUBLIC :: get_eos1_loreneid !! Returns [[bnslorene:eos1_loreneid]] PROCEDURE , PUBLIC :: get_eos2_loreneid !! Returns [[bnslorene:eos2_loreneid]] PROCEDURE , PUBLIC :: get_bns_identifier !! Returns [[bnslorene:bns_identifier]] !PROCEDURE, PUBLIC:: get_bns_ptr FINAL :: destruct_bnslorene !! Finalizer (Destructor) of a [[bnslorene]] object END TYPE bnslorene","tags":"","loc":"type/bnslorene.html"},{"title":"diffstarbase – SPHINCS_LORENE ","text":"type, public, ABSTRACT, extends( idbase ) :: diffstarbase Base TYPE for DRS ID for \\texttt{SPHINCS_BSSN} (produced with \\texttt{LORENE}, or with\n \\texttt{FUKA}, etc.; or produced with the same tool, but read in different ways,\n for example by linking to the \\texttt{LORENE} library, or reading the ID from\n a lattice, etc.) Inherits type~~diffstarbase~~InheritsGraph type~diffstarbase diffstarbase type~idbase idbase type~diffstarbase->type~idbase timer timer type~idbase->timer construction_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~diffstarbase~~InheritedByGraph type~diffstarbase diffstarbase type~diffstarlorene diffstarlorene type~diffstarlorene->type~diffstarbase Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables angular_momentum area_radius barycenter center construction_timer energy_density_center ent_center eos f_isco gamma gamma0 gamma1 gamma2 gamma3 grv2 grv3 kappa kappa0 kappa1 kappa2 kappa3 logP1 logRho0 logRho1 logRho2 mass mass_grav nbar_center npeos omega_c pressure_center r_circ r_eq r_eq_3pi2 r_eq_pi r_eq_pi2 r_isco r_mean r_pole r_ratio radii redshift_eqb redshift_eqf redshift_pole rho_center specific_angular_momentum_isco specific_energy_center specific_energy_isco surface_area tsw Type-Bound Procedures check_i_matter get_angular_momentum get_area_radius get_energy_density_center get_ent_center get_eos_id get_f_isco get_gamma get_gamma0 get_gamma1 get_gamma2 get_gamma3 get_grv2 get_grv3 get_kappa get_kappa0 get_kappa1 get_kappa2 get_kappa3 get_logP1 get_logRho0 get_logRho1 get_logRho2 get_mass_grav get_n_matter get_nbar_center get_npeos get_omega_c get_one_lapse get_pressure_center get_r_circ get_r_eq get_r_eq_3pi2 get_r_eq_pi get_r_eq_pi2 get_r_isco get_r_mean get_r_pole get_r_ratio get_rho_center get_specific_angular_momentum_isco get_specific_energy_center get_specific_energy_isco get_surface_area get_total_spatial_extent get_tsw get_zero_shift integrate_baryon_mass_density read_id_full read_id_hydro read_id_k read_id_mass_b read_id_particles read_id_spacetime read_mass_density return_barycenter return_center return_eos_name return_eos_parameters return_mass return_spatial_extent set_n_matter set_one_lapse set_zero_shift test_position Source Code diffstarbase Components Type Visibility Attributes Name Initial double precision, public :: angular_momentum = 0.0D0 Angular momentum of the DRS [G M_\\odot&#94;2/c] double precision, public :: area_radius Areal (or circumferential) radius of DRS [Msun_geo]\n Note that these is the areal radius of the star in the binary system,\n which is different than that of an isolated star. The latter is used\n in the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(3) :: barycenter Array containing the barycenters of the stars Todo add details double precision, public, DIMENSION(3) :: center Array containing the centers of the stars Todo add details type(timer), public :: construction_timer Timer that times the construction of the appropriate object double precision, public :: energy_density_center Central energy density [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center Central enthalpy [c&#94;2] character(len=:), public, ALLOCATABLE :: eos Name of the equation of state (EoS) of star 1 double precision, public :: f_isco Orbital frequency of the Innermost Stable Circular Orbit (ISCO) double precision, public :: gamma Single polytrope: polytropic index double precision, public :: gamma0 Piecewise polytrope: polytropic index \\gamma_0 double precision, public :: gamma1 Piecewise polytrope: polytropic index \\gamma_1 double precision, public :: gamma2 Piecewise polytrope: polytropic index \\gamma_2 double precision, public :: gamma3 Piecewise polytrope: polytropic index \\gamma_3 double precision, public :: grv2 Error on the virial identity {\\rm GRV2} . See Section 3.5 in Gourgoulhon et al, Astron.Astrophys.349:851,1999 . double precision, public :: grv3 Error on the virial identity {\\rm GRV3} . See Section 3.5 in Gourgoulhon et al, Astron.Astrophys.349:851,1999 . The error is computed as the integral defined\n by Eq. (43) of Gourgoulhon and Bonazzola, Class. Quantum Grav. 11, 443 (1994) divided by the integral of the matter terms. double precision, public :: kappa Single polytrope: polytropic constant [pure number] double precision, public :: kappa0 Piecewise polytrope: polytropic constant \\kappa_0 [pure number] double precision, public :: kappa1 Piecewise polytrope: polytropic constant \\kappa_1 [pure number] double precision, public :: kappa2 Piecewise polytrope: polytropic constant \\kappa_2 [pure number] double precision, public :: kappa3 Piecewise polytrope: polytropic constant \\kappa_3 [pure number] double precision, public :: logP1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] double precision, public :: logRho0 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] double precision, public :: mass Baryonic mass of DRS [M_\\odot] double precision, public :: mass_grav Gravitational mass of DRS [M_\\odot] double precision, public :: nbar_center Central baryon number density [L_\\odot&#94;{-3}] integer, public :: npeos Piecewise polytrope: Number of polytropic pieces double precision, public :: omega_c Central angular velocity [{\\rm rad/s}] double precision, public :: pressure_center Central pressure [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: r_circ Circumferential radius double precision, public :: r_eq Equatorial radius at \\phi=0 double precision, public :: r_eq_3pi2 Equatorial radius at \\phi=\\dfrac{3\\pi}{2} double precision, public :: r_eq_pi Equatorial radius at \\phi=\\pi double precision, public :: r_eq_pi2 Equatorial radius at \\phi=\\dfrac{\\pi}{2} double precision, public :: r_isco Radius of the Innermost Stable Circular Orbit (ISCO) double precision, public :: r_mean Mean radius double precision, public :: r_pole Polar radius double precision, public :: r_ratio Ratio r_pole / r_eq double precision, public, DIMENSION(6) :: radii double precision, public :: redshift_eqb Backward redshift factor at equator double precision, public :: redshift_eqf Forward redshift factor at equator double precision, public :: redshift_pole Redshift factor at North pole double precision, public :: rho_center Central baryon mass density [M_\\odot L_\\odot&#94;{-3}] double precision, public :: specific_angular_momentum_isco Specific angular momentum of a test particle at the Innermost Stable\n Circular Orbit (ISCO) double precision, public :: specific_energy_center Central specific energy [c&#94;2] double precision, public :: specific_energy_isco Specific energy of a test particle at the Innermost Stable Circular\n Orbit (ISCO) double precision, public :: surface_area Surface area double precision, public :: tsw Ratio between the kinetic and gravitatial potential energy T/W . See Section 6 in Gourgoulhon et al, Astron.Astrophys.349:851,1999 Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. interface public module module subroutine check_i_matter(THIS, i_matter) Implementation → Checks that the given index i_matter is between 1 and n_matter , included. If not, it stops the execution of the\n program. Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked procedure, public :: get_angular_momentum Returns angular_momentum interface public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_area_radius Returns area_radius interface public module module function get_area_radius(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_energy_density_center Returns energy_density_center interface public module module function get_energy_density_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_ent_center Returns ent_center interface public module module function get_ent_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure( get_eos_id_int ), public, deferred :: get_eos_id Returns an integer that identifies the equation of state Integrates the baryon mass density over the starand computes the radial\n mass profile function get_eos_id_int(THIS) Prototype Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer procedure, public :: get_f_isco Returns f_isco interface public module module function get_f_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma Returns gamma interface public module module function get_gamma(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma0 Returns gamma0 interface public module module function get_gamma0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma1 Returns gamma1 interface public module module function get_gamma1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma2 Returns gamma2 interface public module module function get_gamma2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma3 Returns gamma3 interface public module module function get_gamma3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grv2 Returns grv2 interface public module module function get_grv2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grv3 Returns grv3 interface public module module function get_grv3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa Returns kappa interface public module module function get_kappa(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa0 Returns kappa0 interface public module module function get_kappa0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa1 Returns kappa1 interface public module module function get_kappa1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa2 Returns kappa2 interface public module module function get_kappa2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa3 Returns kappa3 interface public module module function get_kappa3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logP1 Returns logP1 interface public module module function get_logP1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho0 Returns logRho0 interface public module module function get_logRho0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho1 Returns logRho1 interface public module module function get_logRho1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho2 Returns logRho2 interface public module module function get_logRho2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_mass_grav Returns mass_grav interface public module module function get_mass_grav(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system interface public module module function get_n_matter(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the procedure, public :: get_nbar_center Returns nbar_center interface public module module function get_nbar_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_npeos Returns npeos interface public module module function get_npeos(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer procedure, public :: get_omega_c Returns omega_c Returns mass interface public module module function get_omega_c(THIS) Implementation → Returns omega_c Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module function get_one_lapse(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: get_pressure_center Returns pressure_center Returns eos interface public module module function get_pressure_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_circ Returns r_circ interface public module module function get_r_circ(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq Returns r_eq interface public module module function get_r_eq(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq_3pi2 Returns r_eq_3pi2 interface public module module function get_r_eq_3pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq_pi Returns r_eq_pi interface public module module function get_r_eq_pi(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq_pi2 Returns r_eq_pi2 interface public module module function get_r_eq_pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_isco Returns r_isco interface public module module function get_r_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_mean Returns r_mean interface public module module function get_r_mean(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_pole Returns r_pole interface public module module function get_r_pole(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_ratio Returns r_ratio interface public module module function get_r_ratio(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_rho_center Returns rho_center interface public module module function get_rho_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_angular_momentum_isco Returns specific_angular_momentum_isco interface public module module function get_specific_angular_momentum_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_center Returns specific_energy_center interface public module module function get_specific_energy_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_isco Returns specific_energy_isco interface public module module function get_specific_energy_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_surface_area Returns surface_area interface public module module function get_surface_area(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} interface public module module function get_total_spatial_extent(THIS) result(box) Implementation → INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. procedure, public :: get_tsw Returns tsw interface public module module function get_tsw(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module function get_zero_shift(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star interface public module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Implementation → INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order procedure( read_id_full_int ), public, deferred :: read_id_full Reads the full ID subroutine read_id_full_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Prototype INTERFACE or the SUBROUTINE reading the full ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure( read_id_hydro_int ), public, deferred :: read_id_hydro Reads the hydro ID needed to compute the constraints on the refined mesh subroutine read_id_hydro_int(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Prototype INTERFACE or the SUBROUTINE reading the the hydro ID needed to compute\n the constraints on the refined mesh Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler procedure( read_id_k_int ), public, deferred :: read_id_k Reads the components of the extrinsic curvature subroutine read_id_k_int(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Prototype INTERFACE or the SUBROUTINE reading the components of the extrinsic\n curvature Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz procedure( read_id_mass_b_int ), public, deferred :: read_id_mass_b Reads the hydro ID needed to compute the baryon mass subroutine read_id_mass_b_int(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Prototype INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n baryon mass Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure( read_id_particles_int ), public, deferred :: read_id_particles Reads the hydro ID needed to compute the SPH ID subroutine read_id_particles_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Prototype INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n SPH ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure( read_id_spacetime_int ), public, deferred :: read_id_spacetime Reads the spacetime ID needed to compute\n the BSSN variables and constraints subroutine read_id_spacetime_int(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Prototype INTERFACE or the SUBROUTINE reading the spacetime ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek procedure( read_double_at_pos ), public, deferred :: read_mass_density Returns the baryon mass density at the given point function read_double_at_pos(THIS, x, y, z) result(res) Prototype INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION at a given\n position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Real number at (x,y,z) procedure, public :: return_barycenter => get_barycenter interface public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_center => get_center interface public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_eos_name => get_eos interface public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE procedure( return_eos_parameters_int ), public, deferred :: return_eos_parameters Returns the identification number of the EoS of the matter objects. Todo Set up a convention for the identification number subroutine return_eos_parameters_int(THIS, i_matter, eos_params) Prototype INTERFACE for a PROCEDURE that returns an array containing the\n parametersf the EoS for the matter objects Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object procedure, public :: return_mass => get_mass interface public module module function get_mass(THIS, i_matter) Implementation → Returns mass Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision procedure, public :: return_spatial_extent => get_radii interface public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value interface public module module subroutine set_n_matter(THIS, value) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module subroutine set_one_lapse(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module subroutine set_zero_shift(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure( read_integer_at_pos ), public, deferred :: test_position Returns 1 if the position has physically acceptable properties,\n 0 otherwise function read_integer_at_pos(THIS, x, y, z) result(res) Prototype INTERFACE for a PROCEDURE that returns an INTEGER at a given position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer Integer at (x,y,z) Source Code TYPE , ABSTRACT , EXTENDS ( idbase ) :: diffstarbase !# Base TYPE for DRS ID for |sphincsbssn| (produced with |lorene|, or with !  |fuka|, etc.; or produced with the same tool, but read in different ways, !  for example by linking to the |lorene| library, or reading the ID from !  a lattice, etc.) !-----------------------------! !--  Parameters of the DRS  --! !-----------------------------! DOUBLE PRECISION :: omega_c !! Central angular velocity [{\\rm rad/s}] DOUBLE PRECISION :: mass !! Baryonic mass of DRS [M_\\odot] DOUBLE PRECISION :: mass_grav !! Gravitational mass of DRS [M_\\odot] DOUBLE PRECISION :: angular_momentum = 0.0D0 !! Angular momentum of the DRS [G M_\\odot&#94;2/c] DOUBLE PRECISION :: tsw !# Ratio between the kinetic and gravitatial potential energy T/W. ! !  See Section 6 in !  [Gourgoulhon et al, Astron.Astrophys.349:851,1999](https://arxiv.org/abs/astro-ph/9907225v1){:target=\"_blank\"} DOUBLE PRECISION :: grv2 !# Error on the virial identity {\\rm GRV2}. ! !  See Section 3.5 in !  [Gourgoulhon et al, Astron.Astrophys.349:851,1999](https://arxiv.org/abs/astro-ph/9907225v1){:target=\"_blank\"}. DOUBLE PRECISION :: grv3 !# Error on the virial identity {\\rm GRV3}. ! !  See Section 3.5 in !  [Gourgoulhon et al, Astron.Astrophys.349:851,1999](https://arxiv.org/abs/astro-ph/9907225v1){:target=\"_blank\"} . ! !  The error is computed as the integral defined !  by Eq. (43) of [Gourgoulhon and Bonazzola, Class. Quantum Grav. 11, 443 (1994)](https://iopscience.iop.org/article/10.1088/0264-9381/11/2/015?pageTitle=IOPscience){:target=\"_blank\"} !  divided by the integral of the matter terms. DOUBLE PRECISION , DIMENSION ( 3 ) :: center !# Array containing the centers of the stars !  @todo add details DOUBLE PRECISION , DIMENSION ( 3 ) :: barycenter !# Array containing the barycenters of the stars !  @todo add details DOUBLE PRECISION , DIMENSION ( 6 ) :: radii DOUBLE PRECISION :: r_circ !# Circumferential radius DOUBLE PRECISION :: r_mean !# Mean radius DOUBLE PRECISION :: r_eq !# Equatorial radius at \\phi=0 DOUBLE PRECISION :: r_eq_pi2 !# Equatorial radius at \\phi=\\dfrac{\\pi}{2} DOUBLE PRECISION :: r_eq_pi !# Equatorial radius at \\phi=\\pi DOUBLE PRECISION :: r_eq_3pi2 !# Equatorial radius at \\phi=\\dfrac{3\\pi}{2} DOUBLE PRECISION :: r_pole !# Polar radius DOUBLE PRECISION :: r_ratio !# Ratio [[diffstarbase:r_pole]]/[[diffstarbase:r_eq]] DOUBLE PRECISION :: r_isco !# Radius of the Innermost Stable Circular Orbit (ISCO) DOUBLE PRECISION :: f_isco !# Orbital frequency of the Innermost Stable Circular Orbit (ISCO) DOUBLE PRECISION :: specific_energy_isco !# Specific energy of a test particle at the Innermost Stable Circular !  Orbit (ISCO) DOUBLE PRECISION :: specific_angular_momentum_isco !# Specific angular momentum of a test particle at the Innermost Stable !  Circular Orbit (ISCO) DOUBLE PRECISION :: surface_area !# Surface area DOUBLE PRECISION :: area_radius !# Areal (or circumferential) radius of DRS [Msun_geo] !  Note that these is the areal radius of the star in the binary system, !  which is different than that of an isolated star. The latter is used !  in the mass-radius diagrams, together with the gravitatonal mass DOUBLE PRECISION :: ent_center !! Central enthalpy [c&#94;2] DOUBLE PRECISION :: nbar_center !! Central baryon number density [L_\\odot&#94;{-3}] DOUBLE PRECISION :: rho_center !! Central baryon mass density [M_\\odot L_\\odot&#94;{-3}] DOUBLE PRECISION :: energy_density_center !! Central energy density [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: specific_energy_center !! Central specific energy [c&#94;2] DOUBLE PRECISION :: pressure_center !! Central pressure [M_\\odot c&#94;2 L_\\odot&#94;{-3}] DOUBLE PRECISION :: redshift_eqf !! Forward redshift factor at equator DOUBLE PRECISION :: redshift_eqb !! Backward redshift factor at equator DOUBLE PRECISION :: redshift_pole !! Redshift factor at North pole CHARACTER ( LEN = : ), ALLOCATABLE :: eos !! Name of the equation of state (EoS) of star 1 ! !-- Parameters of single polytropic equations of state for the two NSs ! DOUBLE PRECISION :: gamma !! Single polytrope: polytropic index DOUBLE PRECISION :: kappa !! Single polytrope: polytropic constant [pure number] ! !-- Parameters of the piecewise polytropic equation of state for NS 1 ! INTEGER :: npeos !! Piecewise polytrope: Number of polytropic pieces DOUBLE PRECISION :: gamma0 !! Piecewise polytrope: polytropic index \\gamma_0 DOUBLE PRECISION :: gamma1 !! Piecewise polytrope: polytropic index \\gamma_1 DOUBLE PRECISION :: gamma2 !! Piecewise polytrope: polytropic index \\gamma_2 DOUBLE PRECISION :: gamma3 !! Piecewise polytrope: polytropic index \\gamma_3 DOUBLE PRECISION :: kappa0 !# Piecewise polytrope: polytropic constant \\kappa_0 !  [pure number] DOUBLE PRECISION :: kappa1 !# Piecewise polytrope: polytropic constant \\kappa_1 !  [pure number] DOUBLE PRECISION :: kappa2 !# Piecewise polytrope: polytropic constant \\kappa_2 !  [pure number] DOUBLE PRECISION :: kappa3 !# Piecewise polytrope: polytropic constant \\kappa_3 !  [pure number] DOUBLE PRECISION :: logP1 !# Piecewise polytrope: Base 10 exponent of the pressure at the first !  fiducial density (between \\gamma_0 and \\gamma_1) !  [{\\rm dyne/cm&#94;2}] DOUBLE PRECISION :: logRho0 !# Piecewise polytrope: Base 10 exponent of the first fiducial density !  (between \\gamma_0 and \\gamma_1) [{\\rm g/cm&#94;3}] DOUBLE PRECISION :: logRho1 !# Piecewise polytrope: Base 10 exponent of the second fiducial density !  (between \\gamma_1 and \\gamma_2) [{\\rm g/cm&#94;3}] DOUBLE PRECISION :: logRho2 !# Piecewise polytrope: Base 10 exponent of the third fiducial density !  (between \\gamma_2 and \\gamma_3) [{\\rm g/cm&#94;3}] CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE ( get_eos_id_int ), DEFERRED :: get_eos_id !! Returns an integer that identifies the equation of state !PROCEDURE:: integrate_field_on_star => integrate_baryon_mass_density !# Integrates the baryon mass density over the starand computes the radial !  mass profile !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE :: return_mass => get_mass PROCEDURE :: return_center => get_center PROCEDURE :: return_barycenter => get_barycenter PROCEDURE :: return_eos_name => get_eos PROCEDURE :: return_spatial_extent => get_radii PROCEDURE , PUBLIC :: get_omega_c !! Returns [[diffstarbase:omega_c]] !PROCEDURE, PUBLIC:: get_mass !! Returns [[diffstarbase:mass]] PROCEDURE , PUBLIC :: get_mass_grav !! Returns [[diffstarbase:mass_grav]] PROCEDURE , PUBLIC :: get_angular_momentum !! Returns [[diffstarbase:angular_momentum]] PROCEDURE , PUBLIC :: get_tsw !! Returns [[diffstarbase:tsw]] PROCEDURE , PUBLIC :: get_grv2 !! Returns [[diffstarbase:grv2]] PROCEDURE , PUBLIC :: get_grv3 !! Returns [[diffstarbase:grv3]] PROCEDURE , PUBLIC :: get_r_circ !! Returns [[diffstarbase:r_circ]] PROCEDURE , PUBLIC :: get_r_mean !! Returns [[diffstarbase:r_mean]] PROCEDURE , PUBLIC :: get_r_eq !! Returns [[diffstarbase:r_eq]] PROCEDURE , PUBLIC :: get_r_eq_pi2 !! Returns [[diffstarbase:r_eq_pi2]] PROCEDURE , PUBLIC :: get_r_eq_pi !! Returns [[diffstarbase:r_eq_pi]] PROCEDURE , PUBLIC :: get_r_eq_3pi2 !! Returns [[diffstarbase:r_eq_3pi2]] PROCEDURE , PUBLIC :: get_r_pole !! Returns [[diffstarbase:r_pole]] PROCEDURE , PUBLIC :: get_r_ratio !! Returns [[diffstarbase:r_ratio]] PROCEDURE , PUBLIC :: get_r_isco !! Returns [[diffstarbase:r_isco]] PROCEDURE , PUBLIC :: get_f_isco !! Returns [[diffstarbase:f_isco]] PROCEDURE , PUBLIC :: get_specific_energy_isco !! Returns [[diffstarbase:specific_energy_isco]] PROCEDURE , PUBLIC :: get_specific_angular_momentum_isco !! Returns [[diffstarbase:specific_angular_momentum_isco]] PROCEDURE , PUBLIC :: get_surface_area !! Returns [[diffstarbase:surface_area]] PROCEDURE , PUBLIC :: get_area_radius !! Returns [[diffstarbase:area_radius]] PROCEDURE , PUBLIC :: get_ent_center !! Returns [[diffstarbase:ent_center]] PROCEDURE , PUBLIC :: get_nbar_center !! Returns [[diffstarbase:nbar_center]] PROCEDURE , PUBLIC :: get_rho_center !! Returns [[diffstarbase:rho_center]] PROCEDURE , PUBLIC :: get_energy_density_center !! Returns [[diffstarbase:energy_density_center]] PROCEDURE , PUBLIC :: get_specific_energy_center !! Returns [[diffstarbase:specific_energy_center]] PROCEDURE , PUBLIC :: get_pressure_center !! Returns [[diffstarbase:pressure_center]] !PROCEDURE, PUBLIC:: get_eos !! Returns [[diffstarbase:eos]] ! !-- PROCEDURES to be used for single polytropic EOS ! PROCEDURE , PUBLIC :: get_gamma !! Returns [[diffstarbase:gamma]] PROCEDURE , PUBLIC :: get_kappa !! Returns [[diffstarbase:kappa]] ! !-- PROCEDURES to be used for piecewise polytropic EOS ! PROCEDURE , PUBLIC :: get_npeos !! Returns [[diffstarbase:npeos]] PROCEDURE , PUBLIC :: get_gamma0 !! Returns [[diffstarbase:gamma0]] PROCEDURE , PUBLIC :: get_gamma1 !! Returns [[diffstarbase:gamma1]] PROCEDURE , PUBLIC :: get_gamma2 !! Returns [[diffstarbase:gamma2]] PROCEDURE , PUBLIC :: get_gamma3 !! Returns [[diffstarbase:gamma3]] PROCEDURE , PUBLIC :: get_kappa0 !! Returns [[diffstarbase:kappa0]] PROCEDURE , PUBLIC :: get_kappa1 !! Returns [[diffstarbase:kappa1]] PROCEDURE , PUBLIC :: get_kappa2 !! Returns [[diffstarbase:kappa2]] PROCEDURE , PUBLIC :: get_kappa3 !! Returns [[diffstarbase:kappa3]] PROCEDURE , PUBLIC :: get_logP1 !! Returns [[diffstarbase:logP1]] PROCEDURE , PUBLIC :: get_logRho0 !! Returns [[diffstarbase:logRho0]] PROCEDURE , PUBLIC :: get_logRho1 !! Returns [[diffstarbase:logRho1]] PROCEDURE , PUBLIC :: get_logRho2 !! Returns [[diffstarbase:logRho2]] END TYPE diffstarbase","tags":"","loc":"type/diffstarbase.html"},{"title":"diffstarlorene – SPHINCS_LORENE ","text":"type, public, extends( diffstarbase ) :: diffstarlorene TYPE representing a differentially rotating star (DRS) Inherits type~~diffstarlorene~~InheritsGraph type~diffstarlorene diffstarlorene type~diffstarbase diffstarbase type~diffstarlorene->type~diffstarbase C_PTR C_PTR type~diffstarlorene->C_PTR diffstar_ptr type~idbase idbase type~diffstarbase->type~idbase timer timer type~idbase->timer construction_timer Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables angular_momentum area_radius barycenter baryon_density center construction_timer diffstar_identifier diffstar_ptr energy_density energy_density_center ent_center eos eos_loreneid f_isco g_xx g_xy g_xz g_yy g_yz g_zz gamma gamma0 gamma1 gamma2 gamma3 grv2 grv3 k_xx k_xy k_xz k_yy k_yz k_zz kappa kappa0 kappa1 kappa2 kappa3 lapse logP1 logRho0 logRho1 logRho2 mass mass_grav nbar_center npeos omega_c pressure_center r_circ r_eq r_eq_3pi2 r_eq_pi r_eq_pi2 r_isco r_mean r_pole r_ratio radii redshift_eqb redshift_eqf redshift_pole rho_center shift_x shift_y shift_z specific_angular_momentum_isco specific_energy specific_energy_center specific_energy_isco surface_area tsw v_euler_x v_euler_y v_euler_z Constructor diffstarlorene Finalization Procedures destruct_diffstarlorene Type-Bound Procedures allocate_diffstar_memory check_i_matter construct_drs deallocate_diffstar_memory destruct_drs get_angular_momentum get_area_radius get_diffstar_identifier get_energy_density_center get_ent_center get_eos_id get_eos_loreneid get_f_isco get_fa get_field get_fv get_gamma get_gamma0 get_gamma1 get_gamma2 get_gamma3 get_grv2 get_grv3 get_kappa get_kappa0 get_kappa1 get_kappa2 get_kappa3 get_logP1 get_logRho0 get_logRho1 get_logRho2 get_mass_grav get_n_matter get_nbar_center get_npeos get_omega_c get_one_lapse get_pressure_center get_r_circ get_r_eq get_r_eq_3pi2 get_r_eq_pi get_r_eq_pi2 get_r_isco get_r_mean get_r_pole get_r_ratio get_rho_center get_specific_angular_momentum_isco get_specific_energy_center get_specific_energy_isco get_surface_area get_total_spatial_extent get_tsw get_zero_shift import_diffstar_params import_id_int import_spatial_metric integrate_baryon_mass_density print_diffstar_params read_id_full read_id_hydro read_id_k read_id_mass_b read_id_particles read_id_spacetime read_mass_density return_barycenter return_center return_eos_name return_eos_parameters return_mass return_spatial_extent set_n_matter set_one_lapse set_zero_shift test_position Source Code diffstarlorene Components Type Visibility Attributes Name Initial double precision, public :: angular_momentum = 0.0D0 Angular momentum of the DRS [G M_\\odot&#94;2/c] double precision, public :: area_radius Areal (or circumferential) radius of DRS [Msun_geo]\n Note that these is the areal radius of the star in the binary system,\n which is different than that of an isolated star. The latter is used\n in the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(3) :: barycenter Array containing the barycenters of the stars Todo add details double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] double precision, public, DIMENSION(3) :: center Array containing the centers of the stars Todo add details type(timer), public :: construction_timer Timer that times the construction of the appropriate object integer, private :: diffstar_identifier = 0 Identifier of the diffstarlorene object type(C_PTR), private :: diffstar_ptr C pointer to the \\texttt{LORENE}'s Etdiffrot object\nN.B. This variable is global. The pointer to the second \\texttt{LORENE} Etdiffrot\n     object will overwrite the first one, and so on.\n     This variable stores the pointer to the last defined \\texttt{LORENE} Etdiffrot\n     object. That's why it is not freed in the destructor of a bns object.\n     Presently, it has to be freed by the user at the end of the PROGRAM.\n     See the last part of the PROGRAM in setup_diffstar.f90, for example. double precision, private, DIMENSION(:), ALLOCATABLE :: energy_density 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] double precision, public :: energy_density_center Central energy density [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center Central enthalpy [c&#94;2] character(len=:), public, ALLOCATABLE :: eos Name of the equation of state (EoS) of star 1 integer, private :: eos_loreneid \\texttt{LORENE} identifier for the EoS double precision, public :: f_isco Orbital frequency of the Innermost Stable Circular Orbit (ISCO) double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx 1-D array storing the xx component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xy 1-D array storing the xy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xz 1-D array storing the xz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yy 1-D array storing the yy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yz 1-D array storing the yz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_zz 1-D array storing the zz component of the spatial metric [pure number] double precision, public :: gamma Single polytrope: polytropic index double precision, public :: gamma0 Piecewise polytrope: polytropic index \\gamma_0 double precision, public :: gamma1 Piecewise polytrope: polytropic index \\gamma_1 double precision, public :: gamma2 Piecewise polytrope: polytropic index \\gamma_2 double precision, public :: gamma3 Piecewise polytrope: polytropic index \\gamma_3 double precision, public :: grv2 Error on the virial identity {\\rm GRV2} . See Section 3.5 in Gourgoulhon et al, Astron.Astrophys.349:851,1999 . double precision, public :: grv3 Error on the virial identity {\\rm GRV3} . See Section 3.5 in Gourgoulhon et al, Astron.Astrophys.349:851,1999 . The error is computed as the integral defined\n by Eq. (43) of Gourgoulhon and Bonazzola, Class. Quantum Grav. 11, 443 (1994) divided by the integral of the matter terms. double precision, private, DIMENSION(:), ALLOCATABLE :: k_xx 1-D array storing the xx component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xy 1-D array storing the xy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xz 1-D array storing the xz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yy 1-D array storing the yy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yz 1-D array storing the yz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_zz 1-D array storing the zz component of the extrinsic curvature\n [c/MSun_geo] double precision, public :: kappa Single polytrope: polytropic constant [pure number] double precision, public :: kappa0 Piecewise polytrope: polytropic constant \\kappa_0 [pure number] double precision, public :: kappa1 Piecewise polytrope: polytropic constant \\kappa_1 [pure number] double precision, public :: kappa2 Piecewise polytrope: polytropic constant \\kappa_2 [pure number] double precision, public :: kappa3 Piecewise polytrope: polytropic constant \\kappa_3 [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: lapse 1-D array storing the lapse function double precision, public :: logP1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] double precision, public :: logRho0 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] double precision, public :: mass Baryonic mass of DRS [M_\\odot] double precision, public :: mass_grav Gravitational mass of DRS [M_\\odot] double precision, public :: nbar_center Central baryon number density [L_\\odot&#94;{-3}] integer, public :: npeos Piecewise polytrope: Number of polytropic pieces double precision, public :: omega_c Central angular velocity [{\\rm rad/s}] double precision, public :: pressure_center Central pressure [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: r_circ Circumferential radius double precision, public :: r_eq Equatorial radius at \\phi=0 double precision, public :: r_eq_3pi2 Equatorial radius at \\phi=\\dfrac{3\\pi}{2} double precision, public :: r_eq_pi Equatorial radius at \\phi=\\pi double precision, public :: r_eq_pi2 Equatorial radius at \\phi=\\dfrac{\\pi}{2} double precision, public :: r_isco Radius of the Innermost Stable Circular Orbit (ISCO) double precision, public :: r_mean Mean radius double precision, public :: r_pole Polar radius double precision, public :: r_ratio Ratio r_pole / r_eq double precision, public, DIMENSION(6) :: radii double precision, public :: redshift_eqb Backward redshift factor at equator double precision, public :: redshift_eqf Forward redshift factor at equator double precision, public :: redshift_pole Redshift factor at North pole double precision, public :: rho_center Central baryon mass density [M_\\odot L_\\odot&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_x 1-D array storing the x component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_y 1-D array storing the y component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_z 1-D array storing the z component of the shift vector [c] double precision, public :: specific_angular_momentum_isco Specific angular momentum of a test particle at the Innermost Stable\n Circular Orbit (ISCO) double precision, private, DIMENSION(:), ALLOCATABLE :: specific_energy 1-D array storing the specific internal energy [c&#94;2] double precision, public :: specific_energy_center Central specific energy [c&#94;2] double precision, public :: specific_energy_isco Specific energy of a test particle at the Innermost Stable Circular\n Orbit (ISCO) double precision, public :: surface_area Surface area double precision, public :: tsw Ratio between the kinetic and gravitatial potential energy T/W . See Section 6 in Gourgoulhon et al, Astron.Astrophys.349:851,1999 double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_x 1-D array storing the x component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_y 1-D array storing the y component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_z 1-D array storing the z component of the fluid 3-velocity with respect to Constructor public interface diffstarlorene Interface of TYPE diffstarlorene public interface construct_diffstarlorene () Arguments None Finalization Procedures final :: destruct_diffstarlorene Finalizer (Destructor) of a [[diffstarlorene]] object public interface destruct_diffstarlorene () Arguments None Type-Bound Procedures procedure, public :: allocate_diffstar_memory Allocates memory for the diffstarlorene member arrays interface public module module subroutine allocate_diffstar_memory(THIS, d) Implementation → Allocates allocatable arrays member of a diffstarlorene object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. interface public module module subroutine check_i_matter(THIS, i_matter) Implementation → Checks that the given index i_matter is between 1 and n_matter , included. If not, it stops the execution of the\n program. Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked procedure, public :: construct_drs Constructs the \\texttt{LORENE} Etdiffrot object interface public module module subroutine construct_drs(THIS, resu_file) Implementation → Interface of the subroutine that constructs the \\texttt{LORENE} Etdiffrot object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID procedure, public :: deallocate_diffstar_memory Deallocates memory for the diffstarlorene member arrays interface public module module subroutine deallocate_diffstar_memory(THIS) Implementation → Deallocates allocatable arrays member of a diffstarlorene object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of procedure, public :: destruct_drs Destructs the \\texttt{LORENE} Etdiffrot object interface public module module subroutine destruct_drs(THIS) Implementation → Destructs a \\texttt{LORENE} Etdiffrot object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of procedure, public :: get_angular_momentum Returns angular_momentum interface public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_area_radius Returns area_radius interface public module module function get_area_radius(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_diffstar_identifier Returns diffstar_identifier ] interface public module module function get_diffstar_identifier(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_energy_density_center Returns energy_density_center interface public module module function get_energy_density_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_ent_center Returns ent_center interface public module module function get_ent_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_eos_id => get_eos_loreneid Returns the \\texttt{LORENE} identifier for the EOS interface public module module function get_eos_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value integer procedure, public :: get_eos_loreneid Returns eos_loreneid interface public module module function get_eos_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value integer procedure, public :: get_f_isco Returns f_isco interface public module module function get_f_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_fa => get_field_array Access the diffstarlorene -member arrays interface public module module function get_field_array(THIS, field) result(field_array) Implementation → Returns the diffstarlorene member arrays named field Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Desired diffstarlorene member array generic, public :: get_field => get_fa , get_fv GENERIC PROCEDURE, overloded to access the diffstarlorene -member\n variables as arrays and as values public interface get_field_array () Arguments None public interface get_field_value () Arguments None procedure, public :: get_fv => get_field_value Access the components of the diffstarlorene -member arrays interface public module module function get_field_value(THIS, field, n) result(field_value) Implementation → Returns the component n of the diffstarlorene member arrays named field Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array integer, intent(in) :: n Component of the desired diffstarlorene member array Return Value double precision Component n of the desired diffstarlorene member array procedure, public :: get_gamma Returns gamma interface public module module function get_gamma(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma0 Returns gamma0 interface public module module function get_gamma0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma1 Returns gamma1 interface public module module function get_gamma1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma2 Returns gamma2 interface public module module function get_gamma2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_gamma3 Returns gamma3 interface public module module function get_gamma3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grv2 Returns grv2 interface public module module function get_grv2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_grv3 Returns grv3 interface public module module function get_grv3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa Returns kappa interface public module module function get_kappa(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa0 Returns kappa0 interface public module module function get_kappa0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa1 Returns kappa1 interface public module module function get_kappa1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa2 Returns kappa2 interface public module module function get_kappa2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_kappa3 Returns kappa3 interface public module module function get_kappa3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logP1 Returns logP1 interface public module module function get_logP1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho0 Returns logRho0 interface public module module function get_logRho0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho1 Returns logRho1 interface public module module function get_logRho1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_logRho2 Returns logRho2 interface public module module function get_logRho2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_mass_grav Returns mass_grav interface public module module function get_mass_grav(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system interface public module module function get_n_matter(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the procedure, public :: get_nbar_center Returns nbar_center interface public module module function get_nbar_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_npeos Returns npeos interface public module module function get_npeos(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer procedure, public :: get_omega_c Returns omega_c Returns mass interface public module module function get_omega_c(THIS) Implementation → Returns omega_c Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module function get_one_lapse(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: get_pressure_center Returns pressure_center Returns eos interface public module module function get_pressure_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_circ Returns r_circ interface public module module function get_r_circ(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq Returns r_eq interface public module module function get_r_eq(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq_3pi2 Returns r_eq_3pi2 interface public module module function get_r_eq_3pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq_pi Returns r_eq_pi interface public module module function get_r_eq_pi(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_eq_pi2 Returns r_eq_pi2 interface public module module function get_r_eq_pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_isco Returns r_isco interface public module module function get_r_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_mean Returns r_mean interface public module module function get_r_mean(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_pole Returns r_pole interface public module module function get_r_pole(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_r_ratio Returns r_ratio interface public module module function get_r_ratio(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_rho_center Returns rho_center interface public module module function get_rho_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_angular_momentum_isco Returns specific_angular_momentum_isco interface public module module function get_specific_angular_momentum_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_center Returns specific_energy_center interface public module module function get_specific_energy_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_specific_energy_isco Returns specific_energy_isco interface public module module function get_specific_energy_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public :: get_surface_area Returns surface_area interface public module module function get_surface_area(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} interface public module module function get_total_spatial_extent(THIS) result(box) Implementation → INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. procedure, public :: get_tsw Returns tsw interface public module module function get_tsw(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module function get_zero_shift(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the procedure, public :: import_diffstar_params Imports the parameters of the DRS from \\texttt{LORENE} interface public module module subroutine import_diffstar_params(THIS) Implementation → Imports the DRS parameters from \\texttt{LORENE} Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of procedure, public :: import_id_int Stores the ID in the diffstarlorene member arrays interface public module module subroutine import_id_int(THIS, n, x, y, z) Implementation → Stores the ID in the diffstarlorene member arrays Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z procedure, public :: import_spatial_metric Returns the \\texttt{LORENE}'s conformally flat spatial ADM metric interface public module module function import_spatial_metric(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} conformally flat spatial metric component g_{xx}=g_{yy}=g_{zz} at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star interface public module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Implementation → INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order procedure, public :: print_diffstar_params Prints the parameters of the DRS to the standard output interface public module module subroutine print_diffstar_params(THIS) Implementation → Prints the DRS parameters to the standard output Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of procedure, public :: read_id_full => import_id_full interface public module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the ID in non diffstarlorene -member arrays with the same\n shape as the diffstarlorene member arrays Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure, public :: read_id_hydro => import_id_hydro interface public module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Implementation → Stores the hydro ID in the arrays needed to compute the constraints\n on the refined mesh Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler procedure, public :: read_id_k => import_id_k interface public module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Implementation → Stores the components of the extrinsic curvature in arrays Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz procedure, public :: read_id_mass_b => import_id_mass_b interface public module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Implementation → Stores the hydro ID in the arrays needed to compute the baryon mass Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure, public :: read_id_particles => import_id_particles interface public module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the hydro ID in the arrays needed to compute the SPH ID Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z procedure, public :: read_id_spacetime => import_id_spacetime interface public module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Implementation → Stores the spacetime ID in multi-dimensional arrays needed to compute\n the BSSN variables and constraints Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek procedure, public :: read_mass_density => import_mass_density Returns the \\texttt{LORENE}'s mass density at the given point interface public module module function import_mass_density(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} baryon mass density at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) procedure, public :: return_barycenter => get_barycenter interface public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_center => get_center interface public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) procedure, public :: return_eos_name => get_eos interface public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE procedure, public :: return_eos_parameters => get_eos_parameters interface public module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the DRS procedure, public :: return_mass => get_mass interface public module module function get_mass(THIS, i_matter) Implementation → Returns mass Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision procedure, public :: return_spatial_extent => get_radii interface public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value interface public module module subroutine set_n_matter(THIS, value) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used interface public module module subroutine set_one_lapse(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 interface public module module subroutine set_zero_shift(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to procedure, public :: test_position => is_hydro_negative Returns 1 if the energy density or the specific energy or the pressure\n are negative interface public module module function is_hydro_negative(THIS, x, y, z) result(res) Implementation → Returns 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Source Code TYPE , EXTENDS ( diffstarbase ) :: diffstarlorene !! TYPE representing a differentially rotating star (DRS) PRIVATE INTEGER :: diffstar_identifier = 0 !! Identifier of the diffstarlorene object INTEGER :: eos_loreneid !! |lorene| identifier for the EoS ! !-- Spacetime fields ! !> 1-D array storing the lapse function DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: lapse !> 1-D array storing the x component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_x !> 1-D array storing the y component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_y !> 1-D array storing the z component of the shift vector [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: shift_z !> 1-D array storing the xx component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xx !> 1-D array storing the xy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xy !> 1-D array storing the xz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_xz !> 1-D array storing the yy component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yy !> 1-D array storing the yz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_yz !> 1-D array storing the zz component of the spatial metric [pure number] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: g_zz !& 1-D array storing the xx component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xx !& 1-D array storing the xy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xy !& 1-D array storing the xz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_xz !& 1-D array storing the yy component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yy !& 1-D array storing the yz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_yz !& 1-D array storing the zz component of the extrinsic curvature !  [c/MSun_geo] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: k_zz ! !-- Hydro fields ! !> 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: baryon_density !> 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: energy_density !> 1-D array storing the specific internal energy [c&#94;2] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: specific_energy !> 1-D array storing the x component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_x !> 1-D array storing the y component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_y !> 1-D array storing the z component of the fluid 3-velocity with respect to !  the Eulerian observer [c] DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE :: v_euler_z !& C pointer to the |lorene|'s Etdiffrot object ! N.B. This variable is global. The pointer to the second |lorene| Etdiffrot !      object will overwrite the first one, and so on. !      This variable stores the pointer to the last defined |lorene| Etdiffrot !      object. That's why it is not freed in the destructor of a bns object. !      Presently, it has to be freed by the user at the end of the PROGRAM. !      See the last part of the PROGRAM in setup_diffstar.f90, for example. TYPE ( C_PTR ) :: diffstar_ptr CONTAINS !-------------------! !--  SUBROUTINES  --! !-------------------! PROCEDURE :: construct_drs !! Constructs the |lorene| Etdiffrot object PROCEDURE :: destruct_drs !! Destructs the |lorene| Etdiffrot object PROCEDURE :: allocate_diffstar_memory !! Allocates memory for the [[diffstarlorene]] member arrays PROCEDURE :: deallocate_diffstar_memory !! Deallocates memory for the [[diffstarlorene]] member arrays PROCEDURE :: import_diffstar_params !! Imports the parameters of the DRS from |lorene| PROCEDURE , PUBLIC :: print_diffstar_params !! Prints the parameters of the DRS to the standard output PROCEDURE :: import_id_int !! Stores the ID in the [[diffstarlorene]] member arrays PROCEDURE :: read_id_full => import_id_full PROCEDURE :: read_id_spacetime => import_id_spacetime PROCEDURE :: read_id_particles => import_id_particles PROCEDURE :: read_id_hydro => import_id_hydro PROCEDURE :: read_id_mass_b => import_id_mass_b PROCEDURE :: read_id_k => import_id_k !-----------------! !--  FUNCTIONS  --! !-----------------! PROCEDURE :: read_mass_density => import_mass_density !! Returns the |lorene|'s mass density at the given point PROCEDURE :: import_spatial_metric !! Returns the |lorene|'s conformally flat spatial ADM metric PROCEDURE :: test_position => is_hydro_negative !# Returns 1 if the energy density or the specific energy or the pressure !  are negative ! !-- Overloaded FUNCTION to access the fields as arrays and as values ! GENERIC , PUBLIC :: get_field => get_fa , get_fv !# GENERIC PROCEDURE, overloded to access the [[diffstarlorene]]-member !  variables as arrays and as values PROCEDURE :: get_fa => get_field_array !! Access the [[diffstarlorene]]-member arrays PROCEDURE :: get_fv => get_field_value !! Access the components of the [[diffstarlorene]]-member arrays ! !-- FUNCTIONS that access member variables ! PROCEDURE :: get_eos_id => get_eos_loreneid !! Returns the |lorene| identifier for the EOS PROCEDURE :: return_eos_parameters => get_eos_parameters PROCEDURE , PUBLIC :: get_eos_loreneid !! Returns [[diffstarlorene:eos_loreneid]] PROCEDURE , PUBLIC :: get_diffstar_identifier !! Returns [[diffstarlorene:diffstar_identifier]]] !PROCEDURE, PUBLIC:: get_diffstar_ptr FINAL :: destruct_diffstarlorene !! Finalizer (Destructor) of a [[diffstarlorene]] object END TYPE diffstarlorene","tags":"","loc":"type/diffstarlorene.html"},{"title":"compute_and_export_3p1_constraints_grid_interface – SPHINCS_LORENE","text":"abstract interface public subroutine compute_and_export_3p1_constraints_grid_interface(THIS, id, namefile, name_logfile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile","tags":"","loc":"interface/compute_and_export_3p1_constraints_grid_interface.html"},{"title":"compute_and_export_3p1_constraints_particles_interface – SPHINCS_LORENE","text":"abstract interface public subroutine compute_and_export_3p1_constraints_particles_interface(THIS, parts_obj, namefile, name_logfile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile","tags":"","loc":"interface/compute_and_export_3p1_constraints_particles_interface.html"},{"title":"compute_and_export_3p1_variables_interface – SPHINCS_LORENE","text":"abstract interface public subroutine compute_and_export_3p1_variables_interface(THIS, namefile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile","tags":"","loc":"interface/compute_and_export_3p1_variables_interface.html"},{"title":"deallocate_fields_interface – SPHINCS_LORENE","text":"abstract interface public subroutine deallocate_fields_interface(THIS) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS","tags":"","loc":"interface/deallocate_fields_interface.html"},{"title":"define_allocate_fields_interface – SPHINCS_LORENE","text":"abstract interface public subroutine define_allocate_fields_interface(THIS) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS","tags":"","loc":"interface/define_allocate_fields_interface.html"},{"title":"print_formatted_lorene_id_3p1_variables_interface – SPHINCS_LORENE","text":"abstract interface public subroutine print_formatted_lorene_id_3p1_variables_interface(THIS, namefile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile","tags":"","loc":"interface/print_formatted_lorene_id_3p1_variables_interface.html"},{"title":"integrate_field_int – SPHINCS_LORENE","text":"abstract interface public subroutine integrate_field_int(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order Description INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star.","tags":"","loc":"interface/integrate_field_int.html"},{"title":"read_double_at_pos – SPHINCS_LORENE","text":"abstract interface public function read_double_at_pos(THIS, x, y, z) result(res) Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Real number at (x,y,z) Description INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION at a given\n position","tags":"","loc":"interface/read_double_at_pos.html"},{"title":"read_id_full_int – SPHINCS_LORENE","text":"abstract interface public subroutine read_id_full_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Description INTERFACE or the SUBROUTINE reading the full ID","tags":"","loc":"interface/read_id_full_int.html"},{"title":"read_id_hydro_int – SPHINCS_LORENE","text":"abstract interface public subroutine read_id_hydro_int(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler Description INTERFACE or the SUBROUTINE reading the the hydro ID needed to compute\n the constraints on the refined mesh","tags":"","loc":"interface/read_id_hydro_int.html"},{"title":"read_id_k_int – SPHINCS_LORENE","text":"abstract interface public subroutine read_id_k_int(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz Description INTERFACE or the SUBROUTINE reading the components of the extrinsic\n curvature","tags":"","loc":"interface/read_id_k_int.html"},{"title":"read_id_mass_b_int – SPHINCS_LORENE","text":"abstract interface public subroutine read_id_mass_b_int(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler Description INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n baryon mass","tags":"","loc":"interface/read_id_mass_b_int.html"},{"title":"read_id_particles_int – SPHINCS_LORENE","text":"abstract interface public subroutine read_id_particles_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Description INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n SPH ID","tags":"","loc":"interface/read_id_particles_int.html"},{"title":"read_id_spacetime_int – SPHINCS_LORENE","text":"abstract interface public subroutine read_id_spacetime_int(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek Description INTERFACE or the SUBROUTINE reading the spacetime ID","tags":"","loc":"interface/read_id_spacetime_int.html"},{"title":"read_integer_at_pos – SPHINCS_LORENE","text":"abstract interface public function read_integer_at_pos(THIS, x, y, z) result(res) Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer Integer at (x,y,z) Description INTERFACE for a PROCEDURE that returns an INTEGER at a given position","tags":"","loc":"interface/read_integer_at_pos.html"},{"title":"return_double_parameter – SPHINCS_LORENE","text":"abstract interface public function return_double_parameter(THIS, i_matter) result(res) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision Real number. Parameter of the i_matter -th matter object Description INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION","tags":"","loc":"interface/return_double_parameter.html"},{"title":"return_eos_parameters_int – SPHINCS_LORENE","text":"abstract interface public subroutine return_eos_parameters_int(THIS, i_matter, eos_params) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object Description INTERFACE for a PROCEDURE that returns an array containing the\n parametersf the EoS for the matter objects","tags":"","loc":"interface/return_eos_parameters_int.html"},{"title":"return_integer_parameter – SPHINCS_LORENE","text":"abstract interface public function return_integer_parameter(THIS, i_matter) result(res) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value integer Real number. Parameter of the i_matter -th matter object Description INTERFACE for a PROCEDURE that returns an INTEGER","tags":"","loc":"interface/return_integer_parameter.html"},{"title":"return_position – SPHINCS_LORENE","text":"abstract interface public function return_position(THIS, i_matter) result(res) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Centers of the matter objects. The first index runs over the matter\n objects, the second index over (x,y,z) . Description INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION","tags":"","loc":"interface/return_position.html"},{"title":"return_spatial_extent_int – SPHINCS_LORENE","text":"abstract interface public function return_spatial_extent_int(THIS, i_matter) result(box) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. Description INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  matter objects, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system.","tags":"","loc":"interface/return_spatial_extent_int.html"},{"title":"return_string_parameter – SPHINCS_LORENE","text":"abstract interface public function return_string_parameter(THIS, i_matter) result(string) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE Description INTERFACE for a PROCEDURE that returns a CHARACTER( LEN= : )","tags":"","loc":"interface/return_string_parameter.html"},{"title":"return_total_spatial_extent_int – SPHINCS_LORENE","text":"abstract interface public function return_total_spatial_extent_int(THIS) result(box) Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. Description INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system.","tags":"","loc":"interface/return_total_spatial_extent_int.html"},{"title":"get_eos_id_int – SPHINCS_LORENE","text":"abstract interface public function get_eos_id_int(THIS) Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_eos_id_int.html"},{"title":"get_eos_id_int – SPHINCS_LORENE","text":"abstract interface public function get_eos_id_int(THIS) Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_eos_id_int~2.html"},{"title":"cauchy_convergence_test_known – SPHINCS_LORENE","text":"subroutine cauchy_convergence_test_known(formul_dx, formul_dx2, use_constraints, ref_lev) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: formul_dx class( formul_3p1 ), intent(inout) :: formul_dx2 integer, intent(in) :: use_constraints integer, intent(in) :: ref_lev Called by proc~~cauchy_convergence_test_known~~CalledByGraph proc~cauchy_convergence_test_known cauchy_convergence_test_known program~convergence_test convergence_test program~convergence_test->proc~cauchy_convergence_test_known Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables abs_grid convergence_factor exist grid_dx ix iy iz min_abs_y min_abs_z min_ix_y min_ix_z min_iy_y min_iy_z min_iz_y min_iz_z name_cauchy_ct name_cauchy_parts_ct nx ny nz point_dx2 tiny_real unit_cauchy_ct unit_cauchy_parts_ct Source Code cauchy_convergence_test_known Variables Type Visibility Attributes Name Initial double precision, public, DIMENSION( :, :, :, : ), ALLOCATABLE :: abs_grid double precision, public, DIMENSION(:,:,:), ALLOCATABLE :: convergence_factor logical, public :: exist double precision, public, DIMENSION(:,:,:,:), ALLOCATABLE :: grid_dx integer, public :: ix integer, public :: iy integer, public :: iz double precision, public :: min_abs_y double precision, public :: min_abs_z integer, public :: min_ix_y integer, public :: min_ix_z integer, public :: min_iy_y integer, public :: min_iy_z integer, public :: min_iz_y integer, public :: min_iz_z character(len=:), public, ALLOCATABLE :: name_cauchy_ct character(len=:), public, ALLOCATABLE :: name_cauchy_parts_ct integer, public :: nx integer, public :: ny integer, public :: nz double precision, public, DIMENSION(3) :: point_dx2 double precision, public, parameter :: tiny_real = 1D-30 integer, public :: unit_cauchy_ct integer, public :: unit_cauchy_parts_ct Source Code SUBROUTINE cauchy_convergence_test_known ( formul_dx , formul_dx2 , & use_constraints , ref_lev ) IMPLICIT NONE CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: formul_dx , formul_dx2 INTEGER , INTENT ( IN ) :: use_constraints , ref_lev INTEGER :: ix , iy , iz , nx , ny , nz , unit_cauchy_ct , unit_cauchy_parts_ct , & min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid DOUBLE PRECISION , PARAMETER :: tiny_real = 1 D - 30 DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: grid_dx DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx2 DOUBLE PRECISION , DIMENSION (:,:,:), ALLOCATABLE :: convergence_factor CHARACTER ( LEN = : ), ALLOCATABLE :: name_cauchy_ct , name_cauchy_parts_ct LOGICAL :: exist nx = formul_dx % get_ngrid_x ( ref_lev ) ny = formul_dx % get_ngrid_y ( ref_lev ) nz = formul_dx % get_ngrid_z ( ref_lev ) nx = FLOOR ( DBLE ( nx - 1 ) / denominator_ratio_dx ) + 1 ny = FLOOR ( DBLE ( ny - 1 ) / denominator_ratio_dx ) + 1 nz = FLOOR ( DBLE ( nz - 1 ) / denominator_ratio_dx ) + 1 ALLOCATE ( grid_dx ( 3 , nx , ny , nz ) ) ALLOCATE ( abs_grid ( 3 , nx , ny , nz ) ) ALLOCATE ( convergence_factor ( nx , ny , nz ) ) PRINT * , \"** Computing convergence factor...\" choose_constraints : SELECT CASE ( use_constraints ) CASE ( 1 ) shared_grid_loops1 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( formul_dx % get_HC ( 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ))& / ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) & + tiny_real ) & ) + tiny_real ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops1 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_ct = 3109 name_cauchy_ct = \"cauchy_convergence_test_known.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_ct) ) WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing he arrays in \" , & TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_ct ) PRINT * CASE ( 2 ) shared_grid_loops2 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( ABS ( & formul_dx % get_HC_parts ( 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev )& / ( formul_dx2 % get_HC_parts ( 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) & + tiny_real ) & ) + tiny_real ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops2 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_parts_ct = 3111 name_cauchy_parts_ct = \"cauchy_convergence_test_known_parts.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_parts_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_parts_ct) ) WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing e arrays in \" , & TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_parts_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_parts_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_parts_ct ) PRINT * CASE DEFAULT PRINT * , \"** There is no well defined algorithm \" & // \"corresponding to the number\" , use_constraints PRINT * , \" * Please set use_constraints to 1 or 2.\" STOP END SELECT choose_constraints DEALLOCATE ( grid_dx ) END SUBROUTINE cauchy_convergence_test_known","tags":"","loc":"proc/cauchy_convergence_test_known.html"},{"title":"cauchy_convergence_test_unknown – SPHINCS_LORENE","text":"subroutine cauchy_convergence_test_unknown(formul_dx, formul_dx2, formul_dx4, use_constraints, ref_lev) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: formul_dx class( formul_3p1 ), intent(inout) :: formul_dx2 class( formul_3p1 ), intent(inout) :: formul_dx4 integer, intent(in) :: use_constraints integer, intent(in) :: ref_lev Called by proc~~cauchy_convergence_test_unknown~~CalledByGraph proc~cauchy_convergence_test_unknown cauchy_convergence_test_unknown program~convergence_test convergence_test program~convergence_test->proc~cauchy_convergence_test_unknown Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables abs_grid convergence_factor exist grid_dx ix iy iz min_abs_y min_abs_z min_ix_y min_ix_z min_iy_y min_iy_z min_iz_y min_iz_z name_cauchy_ct name_cauchy_parts_ct nx ny nz point_dx2 point_dx4 tiny_real unit_cauchy_ct unit_cauchy_parts_ct Source Code cauchy_convergence_test_unknown Variables Type Visibility Attributes Name Initial double precision, public, DIMENSION( :, :, :, : ), ALLOCATABLE :: abs_grid double precision, public, DIMENSION(:,:,:), ALLOCATABLE :: convergence_factor logical, public :: exist double precision, public, DIMENSION(:,:,:,:), ALLOCATABLE :: grid_dx integer, public :: ix integer, public :: iy integer, public :: iz double precision, public :: min_abs_y double precision, public :: min_abs_z integer, public :: min_ix_y integer, public :: min_ix_z integer, public :: min_iy_y integer, public :: min_iy_z integer, public :: min_iz_y integer, public :: min_iz_z character(len=:), public, ALLOCATABLE :: name_cauchy_ct character(len=:), public, ALLOCATABLE :: name_cauchy_parts_ct integer, public :: nx integer, public :: ny integer, public :: nz double precision, public, DIMENSION(3) :: point_dx2 double precision, public, DIMENSION(3) :: point_dx4 double precision, public, parameter :: tiny_real = 1D-30 integer, public :: unit_cauchy_ct integer, public :: unit_cauchy_parts_ct Source Code SUBROUTINE cauchy_convergence_test_unknown ( formul_dx , formul_dx2 , & formul_dx4 , use_constraints , & ref_lev ) IMPLICIT NONE CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: formul_dx , formul_dx2 , formul_dx4 INTEGER , INTENT ( IN ) :: use_constraints , ref_lev INTEGER :: ix , iy , iz , nx , ny , nz , unit_cauchy_ct , unit_cauchy_parts_ct , & min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid DOUBLE PRECISION , PARAMETER :: tiny_real = 1 D - 30 DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: grid_dx DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx2 DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx4 DOUBLE PRECISION , DIMENSION (:,:,:), ALLOCATABLE :: convergence_factor CHARACTER ( LEN = : ), ALLOCATABLE :: name_cauchy_ct , name_cauchy_parts_ct LOGICAL :: exist nx = formul_dx % get_ngrid_x ( ref_lev ) ny = formul_dx % get_ngrid_y ( ref_lev ) nz = formul_dx % get_ngrid_z ( ref_lev ) nx = FLOOR ( DBLE ( nx - 1 ) / denominator_ratio_dx ** 2 ) + 1 ny = FLOOR ( DBLE ( ny - 1 ) / denominator_ratio_dx ** 2 ) + 1 nz = FLOOR ( DBLE ( nz - 1 ) / denominator_ratio_dx ** 2 ) + 1 ALLOCATE ( grid_dx ( 3 , nx , ny , nz ) ) ALLOCATE ( abs_grid ( 3 , nx , ny , nz ) ) ALLOCATE ( convergence_factor ( nx , ny , nz ) ) PRINT * , \"** Computing convergence factor...\" IF ( debug ) THEN PRINT * , \"formul_dx%  get_ngrid_x=\" , formul_dx % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx%  get_ngrid_y=\" , formul_dx % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx%  get_ngrid_z=\" , formul_dx % get_ngrid_z ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_x=\" , formul_dx2 % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_y=\" , formul_dx2 % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_z=\" , formul_dx2 % get_ngrid_z ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_x=\" , formul_dx4 % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_y=\" , formul_dx4 % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_z=\" , formul_dx4 % get_ngrid_z ( ref_lev ) PRINT * PRINT * , \"formul_dx%  get_dx=\" , formul_dx % get_dx ( ref_lev ) PRINT * , \"formul_dx2% get_dy=\" , formul_dx2 % get_dx ( ref_lev ) PRINT * , \"formul_dx4% get_dz=\" , formul_dx4 % get_dx ( ref_lev ) PRINT * !STOP ENDIF choose_constraints : SELECT CASE ( use_constraints ) CASE ( 1 ) shared_grid_loops3 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 ! grid_dx( :, 1 + ix, 1 + iy, 1 + iz ) = & !            formul_dx%  get_grid_point(  & !                             1 + ix,   1 + iy,   1 + iz   ) ! point_dx2= formul_dx2% get_grid_point( & !                             1 + 2*ix, 1 + 2*iy, 1 + 2*iz ) ! point_dx4= formul_dx4% get_grid_point( & !                             1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) ! ! IF( grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(1) & !.OR. grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(1) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(2) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(2) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(3) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(3) & grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ) point_dx4 = formul_dx4 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ), & point_dx4 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ), & point_dx4 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ), & point_dx4 ( 3 ) PRINT * STOP ENDIF !convergence_factor( 1 + ix, 1 + iy, 1 + iz )= & ! LOG( & ! ABS( & ! ( ABS(formul_dx%  get_HC( 1 + ix,   1 + iy,   1 + iz )) & ! - ABS(formul_dx2% get_HC( 1 + 2*ix, 1 + 2*iy, 1 + 2*iz )))& !/( ABS(formul_dx2% get_HC( 1 + 2*ix, 1 + 2*iy, 1 + 2*iz )) & ! - ABS(formul_dx4% get_HC( 1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) )& ! + 0*tiny_real ) & ! ) & ! )/ln2!/LOG(2.0) convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( ABS ( formul_dx % get_HC ( 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev )) & - ABS ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ))) & / ( ABS ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )) & - ABS ( formul_dx4 % get_HC ( 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) ) & + tiny_real ) & ) + tiny_real & ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops3 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_ct = 3108 name_cauchy_ct = \"cauchy_convergence_test_unknown.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_ct) ) WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_ct ) PRINT * CASE ( 2 ) shared_grid_loops4 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 ! grid_dx( :, 1 + ix, 1 + iy, 1 + iz ) = & !            formul_dx%  get_grid_point(  & !                             1 + ix,   1 + iy,   1 + iz   ) ! point_dx2= formul_dx2% get_grid_point( & !                             1 + 2*ix, 1 + 2*iy, 1 + 2*iz ) ! point_dx4= formul_dx4% get_grid_point( & !                             1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) ! ! IF( grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(1) & !.OR. grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(1) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(2) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(2) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(3) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(3) & grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ) point_dx4 = formul_dx4 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ), & point_dx4 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ), & point_dx4 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ), & point_dx4 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( ABS ( formul_dx % get_HC_parts ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev )) & - ABS ( formul_dx2 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )))& / ( ABS ( formul_dx2 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )) & - ABS ( formul_dx4 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) )& + tiny_real ) & ) + tiny_real & ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops4 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_parts_ct = 3110 name_cauchy_parts_ct = \"cauchy_convergence_test_unknown_parts.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_parts_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_parts_ct) ) WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_parts_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_parts_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_parts_ct ) PRINT * CASE DEFAULT PRINT * , \"** There is no well defined algorithm \" & // \"corresponding to the number\" , use_constraints PRINT * , \" * Please set use_constraints to 1 or 2.\" STOP END SELECT choose_constraints DEALLOCATE ( grid_dx ) END SUBROUTINE cauchy_convergence_test_unknown","tags":"","loc":"proc/cauchy_convergence_test_unknown.html"},{"title":"read_bns_id_parameters – SPHINCS_LORENE","text":"subroutine read_bns_id_parameters() Arguments None Called by proc~~read_bns_id_parameters~~CalledByGraph proc~read_bns_id_parameters read_bns_id_parameters program~convergence_test convergence_test program~convergence_test->proc~read_bns_id_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables lorene_bns_id_parameters msg stat unit_parameters Source Code read_bns_id_parameters Variables Type Visibility Attributes Name Initial character(len=:), public, ALLOCATABLE :: lorene_bns_id_parameters character(len=:), public, ALLOCATABLE :: msg integer, public :: stat integer, public, parameter :: unit_parameters = 17 Source Code SUBROUTINE read_bns_id_parameters () IMPLICIT NONE INTEGER :: stat INTEGER , PARAMETER :: unit_parameters = 17 CHARACTER ( LEN = : ), ALLOCATABLE :: lorene_bns_id_parameters CHARACTER ( LEN = : ), ALLOCATABLE :: msg lorene_bns_id_parameters = 'sphincs_lorene_bns_parameters.par' INQUIRE ( FILE = lorene_bns_id_parameters , EXIST = file_exists ) IF ( file_exists ) THEN OPEN ( UNIT = unit_parameters , FILE = lorene_bns_id_parameters , & STATUS = 'OLD' ) ELSE PRINT * PRINT * , '** ERROR: ' , lorene_bns_id_parameters , \" file not found!\" PRINT * STOP ENDIF READ ( UNIT = unit_parameters , NML = bns_parameters , IOSTAT = stat , & IOMSG = msg ) IF ( stat /= 0 ) THEN PRINT * , \"** ERROR: Error in reading \" , lorene_bns_id_parameters ,& \". The IOSTAT variable is \" , stat , & \"The error message is\" , msg STOP ENDIF CLOSE ( UNIT = unit_parameters ) DO itr = 1 , max_length , 1 IF ( TRIM ( filenames ( itr )). NE . \"0\" ) THEN cnt = cnt + 1 ENDIF ENDDO IF ( cnt . NE . n_bns ) THEN PRINT * , \"** ERROR! The number of file names is\" , cnt , & \"and n_bns=\" , n_bns , \". The two should be the same.\" PRINT * STOP ENDIF !DO itr= 1, n_bns, 1 !  DO itr2= 1, max_n_parts, 1 !    IF( placer( itr, itr2 ) == test_int )THEN !      PRINT * !      PRINT *, \"** ERROR! The array placer does not have \", & !               \"enough components to specify all the desired \", & !               \"particle distributions. Specify the \", & !               \"components in file lorene_bns_id_particles.par\" !      PRINT * !      STOP !    ENDIF !  ENDDO !ENDDO END SUBROUTINE read_bns_id_parameters","tags":"","loc":"proc/read_bns_id_parameters.html"},{"title":"read_bns_id_parameters – SPHINCS_LORENE","text":"subroutine read_bns_id_parameters() Arguments None Called by proc~~read_bns_id_parameters~2~~CalledByGraph proc~read_bns_id_parameters~2 read_bns_id_parameters program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->proc~read_bns_id_parameters~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables lorene_bns_id_parameters msg stat Variables Type Visibility Attributes Name Initial character(len=:), public, ALLOCATABLE :: lorene_bns_id_parameters character(len=100), public :: msg integer, public :: stat","tags":"","loc":"proc/read_bns_id_parameters~2.html"},{"title":"compute_g4 – SPHINCS_LORENE","text":"public subroutine compute_g4(ix, iy, iz, lapse, shift_u, g_phys3_ll, g4) Uses tensor proc~~compute_g4~~UsesGraph proc~compute_g4 compute_g4 tensor tensor proc~compute_g4->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: ix integer :: iy integer :: iz double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift_u double precision, intent(inout), DIMENSION(:,:,:,:) :: g_phys3_ll double precision, intent(inout), DIMENSION(:,:,:,:) :: g4 Called by proc~~compute_g4~~CalledByGraph proc~compute_g4 compute_g4 proc~import_id_spacetime~2 import_id_spacetime proc~import_id_spacetime~2->proc~compute_g4 proc~import_id_spacetime import_id_spacetime proc~import_id_spacetime->proc~compute_g4 proc~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid proc~compute_and_export_bssn_constraints_grid->proc~compute_g4 interface~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid interface~compute_and_export_bssn_constraints_grid->proc~compute_and_export_bssn_constraints_grid interface~import_id_spacetime import_id_spacetime interface~import_id_spacetime->proc~import_id_spacetime interface~import_id_spacetime~2 import_id_spacetime interface~import_id_spacetime~2->proc~import_id_spacetime~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code compute_g4 Source Code SUBROUTINE compute_g4 ( ix , iy , iz , lapse , shift_u , g_phys3_ll , g4 ) !************************************************ !                                               * ! Computes the spacetime metric from lapse,     * ! shift and spatial metric !                                               * ! FT 27.11.2020                                 * !                                               * !************************************************ USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , & ixz , iyy , iyz , izz , jxx , jxy , jxz , & jyy , jyz , jzz , jx , jy , jz , n_sym3x3 , n_sym4x4 IMPLICIT NONE INTEGER :: ix , iy , iz DOUBLE PRECISION , DIMENSION (:,:,:), INTENT ( IN OUT ) :: & lapse DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: & shift_u DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: & g_phys3_ll DOUBLE PRECISION , DIMENSION (:,:,:,:), INTENT ( IN OUT ) :: g4 g4 ( ix , iy , iz , itt ) = - lapse ( ix , iy , iz ) * lapse ( ix , iy , iz ) & + g_phys3_ll ( ix , iy , iz , jxx ) & * shift_u ( ix , iy , iz , jx ) & * shift_u ( ix , iy , iz , jx ) & + 2.0D0 * g_phys3_ll ( ix , iy , iz , jxy ) & * shift_u ( ix , iy , iz , jx ) & * shift_u ( ix , iy , iz , jy ) & + 2.0D0 * g_phys3_ll ( ix , iy , iz , jxz ) & * shift_u ( ix , iy , iz , jx ) & * shift_u ( ix , iy , iz , jz ) & + g_phys3_ll ( ix , iy , iz , jyy ) & * shift_u ( ix , iy , iz , jy ) & * shift_u ( ix , iy , iz , jy ) & + 2.0D0 * g_phys3_ll ( ix , iy , iz , jyz ) & * shift_u ( ix , iy , iz , jy ) & * shift_u ( ix , iy , iz , jz ) & + g_phys3_ll ( ix , iy , iz , jzz ) & * shift_u ( ix , iy , iz , jz ) & * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , itx ) = g_phys3_ll ( ix , iy , iz , jxx ) * shift_u ( ix , iy , iz , jx ) & + g_phys3_ll ( ix , iy , iz , jxy ) * shift_u ( ix , iy , iz , jy ) & + g_phys3_ll ( ix , iy , iz , jxz ) * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , ity ) = g_phys3_ll ( ix , iy , iz , jxy ) * shift_u ( ix , iy , iz , jx ) & + g_phys3_ll ( ix , iy , iz , jyy ) * shift_u ( ix , iy , iz , jy ) & + g_phys3_ll ( ix , iy , iz , jyz ) * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , itz ) = g_phys3_ll ( ix , iy , iz , jxz ) * shift_u ( ix , iy , iz , jx ) & + g_phys3_ll ( ix , iy , iz , jyz ) * shift_u ( ix , iy , iz , jy ) & + g_phys3_ll ( ix , iy , iz , jzz ) * shift_u ( ix , iy , iz , jz ) g4 ( ix , iy , iz , ixx ) = g_phys3_ll ( ix , iy , iz , jxx ) g4 ( ix , iy , iz , ixy ) = g_phys3_ll ( ix , iy , iz , jxy ) g4 ( ix , iy , iz , ixz ) = g_phys3_ll ( ix , iy , iz , jxz ) g4 ( ix , iy , iz , iyy ) = g_phys3_ll ( ix , iy , iz , jyy ) g4 ( ix , iy , iz , iyz ) = g_phys3_ll ( ix , iy , iz , jyz ) g4 ( ix , iy , iz , izz ) = g_phys3_ll ( ix , iy , iz , jzz ) END SUBROUTINE compute_g4","tags":"","loc":"proc/compute_g4.html"},{"title":"determinant_sym3x3_grid – SPHINCS_LORENE","text":"public subroutine determinant_sym3x3_grid(i, j, k, A, det) Uses tensor proc~~determinant_sym3x3_grid~~UsesGraph proc~determinant_sym3x3_grid determinant_sym3x3_grid tensor tensor proc~determinant_sym3x3_grid->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: i integer :: j integer :: k double precision, intent(in) :: A (:,:,:,:) double precision, intent(out) :: det Called by proc~~determinant_sym3x3_grid~~CalledByGraph proc~determinant_sym3x3_grid determinant_sym3x3_grid proc~setup_standard3p1_variables setup_standard3p1_variables proc~setup_standard3p1_variables->proc~determinant_sym3x3_grid interface~setup_standard3p1_variables setup_standard3p1_variables interface~setup_standard3p1_variables->proc~setup_standard3p1_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables components Source Code determinant_sym3x3_grid Variables Type Visibility Attributes Name Initial integer, public, DIMENSION(4) :: components Source Code SUBROUTINE determinant_sym3x3_grid ( i , j , k , A , det ) !***************************************************************** !                                                                * ! Compute the determinant of a 3x3 symmetric matrix field at a   * ! given grid point                                               * !                                                                * ! FT 26.03.2021                                                  * !                                                                * !***************************************************************** USE tensor , ONLY : jxx , jxy , jxz , jyy , jyz , jzz , n_sym3x3 IMPLICIT NONE INTEGER :: i , j , k INTEGER , DIMENSION ( 4 ) :: components DOUBLE PRECISION , INTENT ( IN ) :: A (:,:,:,:) DOUBLE PRECISION , INTENT ( OUT ) :: det components = SHAPE ( A ) IF ( components ( 4 ) /= n_sym3x3 ) THEN PRINT * , \"** ERROR in determinant_sym3x3_grid in MODULE utility.\" , & \" This subroutine needs a symmetric matrix with 6 components,\" ,& \" and a \" , components , \"component matrix was given instead.\" STOP ENDIF det = A ( i , j , k , jxx ) * A ( i , j , k , jyy ) * A ( i , j , k , jzz ) & + A ( i , j , k , jxy ) * A ( i , j , k , jyz ) * A ( i , j , k , jxz ) & + A ( i , j , k , jxz ) * A ( i , j , k , jxy ) * A ( i , j , k , jyz ) & - A ( i , j , k , jxy ) * A ( i , j , k , jxy ) * A ( i , j , k , jzz ) & - A ( i , j , k , jxz ) * A ( i , j , k , jyy ) * A ( i , j , k , jxz ) & - A ( i , j , k , jxx ) * A ( i , j , k , jyz ) * A ( i , j , k , jyz ) END SUBROUTINE determinant_sym3x3_grid","tags":"","loc":"proc/determinant_sym3x3_grid.html"},{"title":"determinant_sym4x4_grid – SPHINCS_LORENE","text":"public subroutine determinant_sym4x4_grid(ix, iy, iz, A, det) Uses tensor proc~~determinant_sym4x4_grid~~UsesGraph proc~determinant_sym4x4_grid determinant_sym4x4_grid tensor tensor proc~determinant_sym4x4_grid->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer :: ix integer :: iy integer :: iz double precision, intent(in) :: A (:,:,:,:) double precision, intent(out) :: det Called by proc~~determinant_sym4x4_grid~~CalledByGraph proc~determinant_sym4x4_grid determinant_sym4x4_grid proc~import_id_spacetime~2 import_id_spacetime proc~import_id_spacetime~2->proc~determinant_sym4x4_grid proc~import_id_spacetime import_id_spacetime proc~import_id_spacetime->proc~determinant_sym4x4_grid proc~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid proc~compute_and_export_bssn_constraints_grid->proc~determinant_sym4x4_grid interface~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid interface~compute_and_export_bssn_constraints_grid->proc~compute_and_export_bssn_constraints_grid interface~import_id_spacetime import_id_spacetime interface~import_id_spacetime->proc~import_id_spacetime interface~import_id_spacetime~2 import_id_spacetime interface~import_id_spacetime~2->proc~import_id_spacetime~2 var panprocdeterminant_sym4x4_gridCalledByGraph = svgPanZoom('#procdeterminant_sym4x4_gridCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables components Source Code determinant_sym4x4_grid Variables Type Visibility Attributes Name Initial integer, public, DIMENSION(4) :: components Source Code SUBROUTINE determinant_sym4x4_grid ( ix , iy , iz , A , det ) !***************************************************************** !                                                                * ! Compute the determinant of a 4x4 symmetric matrix field at a   * ! given grid point                                               * !                                                                * !***************************************************************** USE tensor , ONLY : itt , itx , ity , itz , ixx , ixy , ixz , iyy , iyz , izz , n_sym4x4 IMPLICIT NONE INTEGER :: ix , iy , iz INTEGER , DIMENSION ( 4 ) :: components DOUBLE PRECISION , INTENT ( IN ) :: A (:,:,:,:) DOUBLE PRECISION , INTENT ( OUT ) :: det components = SHAPE ( A ) IF ( components ( 4 ) /= n_sym4x4 ) THEN PRINT * , \"** ERROR in determinant_sym4x4_grid in MODULE utility.\" , & \" This subroutine needs a symmetric matrix with 10 components,\" ,& \" and a \" , components , \"component matrix was given instead.\" STOP ENDIF det = A ( ix , iy , iz , itt ) * ( A ( ix , iy , iz , ixx ) * ( A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , izz ) & - A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , iyz )) & + A ( ix , iy , iz , ixy ) * ( A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , ixz ) & - A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , izz )) & + A ( ix , iy , iz , ixz ) * ( A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , iyz ) & - A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , ixz ))) & - A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , izz ) & - A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , iyz )) & + A ( ix , iy , iz , ixy ) * ( A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , itz ) & - A ( ix , iy , iz , ity ) * A ( ix , iy , iz , izz )) & + A ( ix , iy , iz , ixz ) * ( A ( ix , iy , iz , ity ) * A ( ix , iy , iz , iyz ) & - A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , itz ))) & + A ( ix , iy , iz , ity ) * ( A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , izz ) & - A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , ixz )) & + A ( ix , iy , iz , ixx ) * ( A ( ix , iy , iz , iyz ) * A ( ix , iy , iz , itz ) & - A ( ix , iy , iz , ity ) * A ( ix , iy , iz , izz )) & + A ( ix , iy , iz , ixz ) * ( A ( ix , iy , iz , ity ) * A ( ix , iy , iz , ixz ) & - A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , itz ))) & - A ( ix , iy , iz , itz ) * ( A ( ix , iy , iz , itx ) * ( A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , iyz ) & - A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , ixz )) & + A ( ix , iy , iz , ixx ) * ( A ( ix , iy , iz , iyy ) * A ( ix , iy , iz , itz ) & - A ( ix , iy , iz , ity ) * A ( ix , iy , iz , iyz )) & + A ( ix , iy , iz , ixy ) * ( A ( ix , iy , iz , ity ) * A ( ix , iy , iz , ixz ) & - A ( ix , iy , iz , ixy ) * A ( ix , iy , iz , itz ))) END SUBROUTINE determinant_sym4x4_grid","tags":"","loc":"proc/determinant_sym4x4_grid.html"},{"title":"test_status – SPHINCS_LORENE","text":"public subroutine test_status(io_stat, io_msg, opt_msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: io_stat character(len=100), intent(in) :: io_msg character(len=*), intent(in), optional :: opt_msg Contents Source Code test_status Source Code SUBROUTINE test_status ( io_stat , io_msg , opt_msg ) !************************************************ !                                               * ! Test if a status variable is 0 or not         * !                                               * ! FT 17.09.2020                                 * !                                               * !************************************************ IMPLICIT NONE INTEGER , INTENT ( IN ) :: io_stat CHARACTER ( LEN = 100 ), INTENT ( IN ) :: io_msg CHARACTER ( LEN = * ), INTENT ( IN ), OPTIONAL :: opt_msg IF ( io_stat > 0 ) THEN PRINT * PRINT * , \"***** ERROR! IOSTAT > 0. \" , & \"The error message is: \" , io_msg IF ( PRESENT ( opt_msg ) ) THEN PRINT * , opt_msg ENDIF PRINT * STOP ENDIF END SUBROUTINE test_status","tags":"","loc":"proc/test_status.html"},{"title":"abs_values_in – SPHINCS_LORENE","text":"interface Calls interface~~abs_values_in~~CallsGraph interface~abs_values_in abs_values_in proc~abs_values_in abs_values_in interface~abs_values_in->proc~abs_values_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine abs_values_in(THIS, lower_bound, upper_bound, constraint, l, export, unit_analysis, cnt) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS double precision :: lower_bound double precision :: upper_bound double precision, intent(in), DIMENSION(:,:,:) :: constraint integer, intent(in) :: l logical, intent(in) :: export integer, intent(in) :: unit_analysis integer, intent(out) :: cnt","tags":"","loc":"interface/abs_values_in.html"},{"title":"analyze_constraint – SPHINCS_LORENE","text":"interface Calls interface~~analyze_constraint~~CallsGraph interface~analyze_constraint analyze_constraint proc~analyze_constraint analyze_constraint interface~analyze_constraint->proc~analyze_constraint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine analyze_constraint(THIS, l, constraint, name_constraint, unit_logfile, name_analysis, l2_norm, loo_norm) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l double precision, intent(in), DIMENSION(:,:,:) :: constraint character(len=*), intent(in) :: name_constraint integer, intent(in) :: unit_logfile character(len=*), intent(in) :: name_analysis double precision, intent(out) :: l2_norm double precision, intent(out) :: loo_norm","tags":"","loc":"interface/analyze_constraint.html"},{"title":"deallocate_standard3p1_variables – SPHINCS_LORENE","text":"interface Calls interface~~deallocate_standard3p1_variables~~CallsGraph interface~deallocate_standard3p1_variables deallocate_standard3p1_variables proc~deallocate_standard3p1_variables deallocate_standard3p1_variables interface~deallocate_standard3p1_variables->proc~deallocate_standard3p1_variables deallocate_grid_function deallocate_grid_function proc~deallocate_standard3p1_variables->deallocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine deallocate_standard3p1_variables(f3p1) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1","tags":"","loc":"interface/deallocate_standard3p1_variables.html"},{"title":"get_HC – SPHINCS_LORENE","text":"interface Calls interface~~get_hc~~CallsGraph interface~get_hc get_HC proc~get_hc get_HC interface~get_hc->proc~get_hc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_HC(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision","tags":"","loc":"interface/get_hc.html"},{"title":"get_HC_parts – SPHINCS_LORENE","text":"interface Calls interface~~get_hc_parts~~CallsGraph interface~get_hc_parts get_HC_parts proc~get_hc_parts get_HC_parts interface~get_hc_parts->proc~get_hc_parts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_HC_parts(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision","tags":"","loc":"interface/get_hc_parts.html"},{"title":"get_MC – SPHINCS_LORENE","text":"interface Calls interface~~get_mc~~CallsGraph interface~get_mc get_MC proc~get_mc get_MC interface~get_mc->proc~get_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_MC(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3)","tags":"","loc":"interface/get_mc.html"},{"title":"get_MC_parts – SPHINCS_LORENE","text":"interface Calls interface~~get_mc_parts~~CallsGraph interface~get_mc_parts get_MC_parts proc~get_mc_parts get_MC_parts interface~get_mc_parts->proc~get_mc_parts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_MC_parts(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3)","tags":"","loc":"interface/get_mc_parts.html"},{"title":"get_dx – SPHINCS_LORENE","text":"interface Calls interface~~get_dx~~CallsGraph interface~get_dx get_dx proc~get_dx get_dx interface~get_dx->proc~get_dx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_dx(THIS, l) result(dx) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision","tags":"","loc":"interface/get_dx.html"},{"title":"get_dy – SPHINCS_LORENE","text":"interface Calls interface~~get_dy~~CallsGraph interface~get_dy get_dy proc~get_dy get_dy interface~get_dy->proc~get_dy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_dy(THIS, l) result(dy) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision","tags":"","loc":"interface/get_dy.html"},{"title":"get_dz – SPHINCS_LORENE","text":"interface Calls interface~~get_dz~~CallsGraph interface~get_dz get_dz proc~get_dz get_dz interface~get_dz->proc~get_dz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_dz(THIS, l) result(dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision","tags":"","loc":"interface/get_dz.html"},{"title":"get_grid_point – SPHINCS_LORENE","text":"interface Calls interface~~get_grid_point~~CallsGraph interface~get_grid_point get_grid_point proc~get_grid_point get_grid_point interface~get_grid_point->proc~get_grid_point Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_grid_point(THIS, i, j, k, l) result(grid_point) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3)","tags":"","loc":"interface/get_grid_point.html"},{"title":"get_levels – SPHINCS_LORENE","text":"interface Calls interface~~get_levels~~CallsGraph interface~get_levels get_levels proc~get_levels get_levels interface~get_levels->proc~get_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_levels(THIS, l) result(levels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value type(level),\n  DIMENSION(:),ALLOCATABLE","tags":"","loc":"interface/get_levels.html"},{"title":"get_ngrid_x – SPHINCS_LORENE","text":"interface Calls interface~~get_ngrid_x~~CallsGraph interface~get_ngrid_x get_ngrid_x proc~get_ngrid_x get_ngrid_x interface~get_ngrid_x->proc~get_ngrid_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_ngrid_x(THIS, l) result(ngrid_x) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer","tags":"","loc":"interface/get_ngrid_x.html"},{"title":"get_ngrid_y – SPHINCS_LORENE","text":"interface Calls interface~~get_ngrid_y~~CallsGraph interface~get_ngrid_y get_ngrid_y proc~get_ngrid_y get_ngrid_y interface~get_ngrid_y->proc~get_ngrid_y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_ngrid_y(THIS, l) result(ngrid_y) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer","tags":"","loc":"interface/get_ngrid_y.html"},{"title":"get_ngrid_z – SPHINCS_LORENE","text":"interface Calls interface~~get_ngrid_z~~CallsGraph interface~get_ngrid_z get_ngrid_z proc~get_ngrid_z get_ngrid_z interface~get_ngrid_z->proc~get_ngrid_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_ngrid_z(THIS, l) result(ngrid_z) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer","tags":"","loc":"interface/get_ngrid_z.html"},{"title":"get_nlevels – SPHINCS_LORENE","text":"interface Calls interface~~get_nlevels~~CallsGraph interface~get_nlevels get_nlevels proc~get_nlevels get_nlevels interface~get_nlevels->proc~get_nlevels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nlevels(THIS) result(nlevels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS Return Value double precision","tags":"","loc":"interface/get_nlevels.html"},{"title":"get_xR – SPHINCS_LORENE","text":"interface Calls interface~~get_xr~~CallsGraph interface~get_xr get_xR proc~get_xr get_xR interface~get_xr->proc~get_xr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_xR(THIS, l) result(xR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer","tags":"","loc":"interface/get_xr.html"},{"title":"get_yR – SPHINCS_LORENE","text":"interface Calls interface~~get_yr~~CallsGraph interface~get_yr get_yR proc~get_yr get_yR interface~get_yr->proc~get_yr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_yR(THIS, l) result(yR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer","tags":"","loc":"interface/get_yr.html"},{"title":"get_zR – SPHINCS_LORENE","text":"interface Calls interface~~get_zr~~CallsGraph interface~get_zr get_zR proc~get_zr get_zR interface~get_zr->proc~get_zr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_zR(THIS, l) result(zR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer","tags":"","loc":"interface/get_zr.html"},{"title":"setup_standard3p1_variables – SPHINCS_LORENE","text":"interface Calls interface~~setup_standard3p1_variables~~CallsGraph interface~setup_standard3p1_variables setup_standard3p1_variables proc~setup_standard3p1_variables setup_standard3p1_variables interface~setup_standard3p1_variables->proc~setup_standard3p1_variables allocate_grid_function allocate_grid_function proc~setup_standard3p1_variables->allocate_grid_function deallocate_grid_function deallocate_grid_function proc~setup_standard3p1_variables->deallocate_grid_function levels levels proc~setup_standard3p1_variables->levels timer timer proc~setup_standard3p1_variables->timer initialize_grid initialize_grid proc~setup_standard3p1_variables->initialize_grid proc~determinant_sym3x3_grid determinant_sym3x3_grid proc~setup_standard3p1_variables->proc~determinant_sym3x3_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine setup_standard3p1_variables(f3p1, id, dx, dy, dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz","tags":"","loc":"interface/setup_standard3p1_variables.html"},{"title":"allocate_bssn_fields – SPHINCS_LORENE","text":"interface Calls interface~~allocate_bssn_fields~~CallsGraph interface~allocate_bssn_fields allocate_bssn_fields proc~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields->proc~allocate_bssn_fields allocate_grid_function allocate_grid_function proc~allocate_bssn_fields->allocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~allocate_bssn_fields~~CalledByGraph interface~allocate_bssn_fields allocate_bssn_fields proc~construct_bssn_id construct_bssn_id proc~construct_bssn_id->interface~allocate_bssn_fields interface~construct_bssn_id construct_bssn_id interface~construct_bssn_id->proc~construct_bssn_id interface~bssn_id bssn_id interface~bssn_id->interface~construct_bssn_id program~convergence_test convergence_test program~convergence_test->interface~bssn_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~bssn_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine allocate_bssn_fields(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS","tags":"","loc":"interface/allocate_bssn_fields.html"},{"title":"bssn_id – SPHINCS_LORENE","text":"public interface bssn_id Calls interface~~bssn_id~~CallsGraph interface~bssn_id bssn_id interface~construct_bssn_id construct_bssn_id interface~bssn_id->interface~construct_bssn_id proc~construct_bssn_id construct_bssn_id interface~construct_bssn_id->proc~construct_bssn_id initialize_bssn initialize_bssn proc~construct_bssn_id->initialize_bssn interface~allocate_bssn_fields allocate_bssn_fields proc~construct_bssn_id->interface~allocate_bssn_fields timer timer proc~construct_bssn_id->timer deallocate_bssn deallocate_bssn proc~construct_bssn_id->deallocate_bssn proc~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields->proc~allocate_bssn_fields allocate_grid_function allocate_grid_function proc~allocate_bssn_fields->allocate_grid_function var paninterfacebssn_idCallsGraph = svgPanZoom('#interfacebssn_idCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~bssn_id~~CalledByGraph interface~bssn_id bssn_id program~convergence_test convergence_test program~convergence_test->interface~bssn_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~bssn_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures construct_bssn_id Module Procedures public interface construct_bssn_id () Arguments None","tags":"","loc":"interface/bssn_id.html"},{"title":"compute_and_export_bssn_constraints_grid – SPHINCS_LORENE","text":"interface Calls interface~~compute_and_export_bssn_constraints_grid~~CallsGraph interface~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid proc~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid interface~compute_and_export_bssn_constraints_grid->proc~compute_and_export_bssn_constraints_grid g_bssn3_ll g_bssn3_ll proc~compute_and_export_bssn_constraints_grid->g_bssn3_ll a_bssn3_ll a_bssn3_ll proc~compute_and_export_bssn_constraints_grid->a_bssn3_ll allocate_grid_function allocate_grid_function proc~compute_and_export_bssn_constraints_grid->allocate_grid_function g_phys3_ll g_phys3_ll proc~compute_and_export_bssn_constraints_grid->g_phys3_ll proc~compute_g4 compute_g4 proc~compute_and_export_bssn_constraints_grid->proc~compute_g4 proc~determinant_sym4x4_grid determinant_sym4x4_grid proc~compute_and_export_bssn_constraints_grid->proc~determinant_sym4x4_grid gc gc proc~compute_and_export_bssn_constraints_grid->gc lapse lapse proc~compute_and_export_bssn_constraints_grid->lapse levels levels proc~compute_and_export_bssn_constraints_grid->levels shift_u shift_u proc~compute_and_export_bssn_constraints_grid->shift_u bssn_constraints_interior bssn_constraints_interior proc~compute_and_export_bssn_constraints_grid->bssn_constraints_interior mc mc proc~compute_and_export_bssn_constraints_grid->mc trk trk proc~compute_and_export_bssn_constraints_grid->trk gamma_u gamma_u proc~compute_and_export_bssn_constraints_grid->gamma_u invert_4x4_matrix invert_4x4_matrix proc~compute_and_export_bssn_constraints_grid->invert_4x4_matrix hc hc proc~compute_and_export_bssn_constraints_grid->hc phi phi proc~compute_and_export_bssn_constraints_grid->phi k_phys3_ll k_phys3_ll proc~compute_and_export_bssn_constraints_grid->k_phys3_ll var paninterfacecompute_and_export_bssn_constraints_gridCallsGraph = svgPanZoom('#interfacecompute_and_export_bssn_constraints_gridCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine compute_and_export_bssn_constraints_grid(THIS, id, namefile, name_logfile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile","tags":"","loc":"interface/compute_and_export_bssn_constraints_grid.html"},{"title":"compute_and_export_bssn_constraints_particles – SPHINCS_LORENE","text":"interface Calls interface~~compute_and_export_bssn_constraints_particles~~CallsGraph interface~compute_and_export_bssn_constraints_particles compute_and_export_bssn_constraints_particles proc~compute_and_export_bssn_constraints_particles compute_and_export_bssn_constraints_particles interface~compute_and_export_bssn_constraints_particles->proc~compute_and_export_bssn_constraints_particles iorig iorig proc~compute_and_export_bssn_constraints_particles->iorig allocate_metric_on_particles allocate_metric_on_particles proc~compute_and_export_bssn_constraints_particles->allocate_metric_on_particles deallocate_metric_on_particles deallocate_metric_on_particles proc~compute_and_export_bssn_constraints_particles->deallocate_metric_on_particles allocate_rcb_tree_memory_3d allocate_rcb_tree_memory_3d proc~compute_and_export_bssn_constraints_particles->allocate_rcb_tree_memory_3d levels levels proc~compute_and_export_bssn_constraints_particles->levels deallocate_adm deallocate_adm proc~compute_and_export_bssn_constraints_particles->deallocate_adm deallocate_pp_g deallocate_pp_g proc~compute_and_export_bssn_constraints_particles->deallocate_pp_g read_options read_options proc~compute_and_export_bssn_constraints_particles->read_options allocate_ztmp allocate_ztmp proc~compute_and_export_bssn_constraints_particles->allocate_ztmp allocate_gradient allocate_gradient proc~compute_and_export_bssn_constraints_particles->allocate_gradient lapse lapse proc~compute_and_export_bssn_constraints_particles->lapse get_metric_on_particles get_metric_on_particles proc~compute_and_export_bssn_constraints_particles->get_metric_on_particles set_units set_units proc~compute_and_export_bssn_constraints_particles->set_units shift_u shift_u proc~compute_and_export_bssn_constraints_particles->shift_u deallocate_bssn deallocate_bssn proc~compute_and_export_bssn_constraints_particles->deallocate_bssn deallocate_rcb_tree_memory_3d deallocate_rcb_tree_memory_3d proc~compute_and_export_bssn_constraints_particles->deallocate_rcb_tree_memory_3d a_bssn3_ll a_bssn3_ll proc~compute_and_export_bssn_constraints_particles->a_bssn3_ll allocate_gravityacceleration allocate_gravityacceleration proc~compute_and_export_bssn_constraints_particles->allocate_gravityacceleration allocate_grid_function allocate_grid_function proc~compute_and_export_bssn_constraints_particles->allocate_grid_function allocate_bssn allocate_bssn proc~compute_and_export_bssn_constraints_particles->allocate_bssn deallocate_grid_function deallocate_grid_function proc~compute_and_export_bssn_constraints_particles->deallocate_grid_function hc_parts hc_parts proc~compute_and_export_bssn_constraints_particles->hc_parts alive alive proc~compute_and_export_bssn_constraints_particles->alive allocate_sph_memory allocate_sph_memory proc~compute_and_export_bssn_constraints_particles->allocate_sph_memory allocate_adm allocate_adm proc~compute_and_export_bssn_constraints_particles->allocate_adm deallocate_hash_memory deallocate_hash_memory proc~compute_and_export_bssn_constraints_particles->deallocate_hash_memory map_2_grid_hash map_2_grid_hash proc~compute_and_export_bssn_constraints_particles->map_2_grid_hash deallocate_all_lists deallocate_all_lists proc~compute_and_export_bssn_constraints_particles->deallocate_all_lists phi phi proc~compute_and_export_bssn_constraints_particles->phi g_bssn3_ll g_bssn3_ll proc~compute_and_export_bssn_constraints_particles->g_bssn3_ll exact_nei_tree_update exact_nei_tree_update proc~compute_and_export_bssn_constraints_particles->exact_nei_tree_update deallocate_gradient deallocate_gradient proc~compute_and_export_bssn_constraints_particles->deallocate_gradient gc_parts gc_parts proc~compute_and_export_bssn_constraints_particles->gc_parts deallocate_flag_nei_cell deallocate_flag_nei_cell proc~compute_and_export_bssn_constraints_particles->deallocate_flag_nei_cell allocate_tmunu allocate_tmunu proc~compute_and_export_bssn_constraints_particles->allocate_tmunu deallocate_tmunu deallocate_tmunu proc~compute_and_export_bssn_constraints_particles->deallocate_tmunu deallocate_sph_memory deallocate_sph_memory proc~compute_and_export_bssn_constraints_particles->deallocate_sph_memory mc_parts mc_parts proc~compute_and_export_bssn_constraints_particles->mc_parts bssn_constraints_interior bssn_constraints_interior proc~compute_and_export_bssn_constraints_particles->bssn_constraints_interior deallocate_ztmp deallocate_ztmp proc~compute_and_export_bssn_constraints_particles->deallocate_ztmp trk trk proc~compute_and_export_bssn_constraints_particles->trk gamma_u gamma_u proc~compute_and_export_bssn_constraints_particles->gamma_u deallocate_gravityacceleration deallocate_gravityacceleration proc~compute_and_export_bssn_constraints_particles->deallocate_gravityacceleration k_phys3_ll k_phys3_ll proc~compute_and_export_bssn_constraints_particles->k_phys3_ll var paninterfacecompute_and_export_bssn_constraints_particlesCallsGraph = svgPanZoom('#interfacecompute_and_export_bssn_constraints_particlesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine compute_and_export_bssn_constraints_particles(THIS, parts_obj, namefile, name_logfile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile","tags":"","loc":"interface/compute_and_export_bssn_constraints_particles.html"},{"title":"compute_and_export_bssn_variables – SPHINCS_LORENE","text":"interface Calls interface~~compute_and_export_bssn_variables~~CallsGraph interface~compute_and_export_bssn_variables compute_and_export_bssn_variables proc~compute_and_export_bssn_variables compute_and_export_bssn_variables interface~compute_and_export_bssn_variables->proc~compute_and_export_bssn_variables allocate_gravityacceleration allocate_gravityacceleration proc~compute_and_export_bssn_variables->allocate_gravityacceleration adm_to_bssn adm_to_bssn proc~compute_and_export_bssn_variables->adm_to_bssn allocate_grid_function allocate_grid_function proc~compute_and_export_bssn_variables->allocate_grid_function allocate_bssn allocate_bssn proc~compute_and_export_bssn_variables->allocate_bssn deallocate_grid_function deallocate_grid_function proc~compute_and_export_bssn_variables->deallocate_grid_function deallocate_tmunu deallocate_tmunu proc~compute_and_export_bssn_variables->deallocate_tmunu allocate_tmunu allocate_tmunu proc~compute_and_export_bssn_variables->allocate_tmunu allocate_ztmp allocate_ztmp proc~compute_and_export_bssn_variables->allocate_ztmp levels levels proc~compute_and_export_bssn_variables->levels allocate_adm allocate_adm proc~compute_and_export_bssn_variables->allocate_adm deallocate_adm deallocate_adm proc~compute_and_export_bssn_variables->deallocate_adm deallocate_ztmp deallocate_ztmp proc~compute_and_export_bssn_variables->deallocate_ztmp write_bssn_dump write_bssn_dump proc~compute_and_export_bssn_variables->write_bssn_dump deallocate_gravityacceleration deallocate_gravityacceleration proc~compute_and_export_bssn_variables->deallocate_gravityacceleration deallocate_bssn deallocate_bssn proc~compute_and_export_bssn_variables->deallocate_bssn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine compute_and_export_bssn_variables(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile","tags":"","loc":"interface/compute_and_export_bssn_variables.html"},{"title":"construct_bssn_id – SPHINCS_LORENE","text":"interface Calls interface~~construct_bssn_id~~CallsGraph interface~construct_bssn_id construct_bssn_id proc~construct_bssn_id construct_bssn_id interface~construct_bssn_id->proc~construct_bssn_id initialize_bssn initialize_bssn proc~construct_bssn_id->initialize_bssn interface~allocate_bssn_fields allocate_bssn_fields proc~construct_bssn_id->interface~allocate_bssn_fields timer timer proc~construct_bssn_id->timer deallocate_bssn deallocate_bssn proc~construct_bssn_id->deallocate_bssn proc~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields->proc~allocate_bssn_fields allocate_grid_function allocate_grid_function proc~allocate_bssn_fields->allocate_grid_function var paninterfaceconstruct_bssn_idCallsGraph = svgPanZoom('#interfaceconstruct_bssn_idCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~construct_bssn_id~~CalledByGraph interface~construct_bssn_id construct_bssn_id interface~bssn_id bssn_id interface~bssn_id->interface~construct_bssn_id program~convergence_test convergence_test program~convergence_test->interface~bssn_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~bssn_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function construct_bssn_id(id, dx, dy, dz) result(bssnid) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Return Value type( bssn_id ) Description Constructs the bssn_id object from the number of grid points\n along each axis","tags":"","loc":"interface/construct_bssn_id.html"},{"title":"deallocate_bssn_fields – SPHINCS_LORENE","text":"interface Calls interface~~deallocate_bssn_fields~~CallsGraph interface~deallocate_bssn_fields deallocate_bssn_fields proc~deallocate_bssn_fields deallocate_bssn_fields interface~deallocate_bssn_fields->proc~deallocate_bssn_fields deallocate_grid_function deallocate_grid_function proc~deallocate_bssn_fields->deallocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~deallocate_bssn_fields~~CalledByGraph interface~deallocate_bssn_fields deallocate_bssn_fields proc~destruct_bssn_id destruct_bssn_id proc~destruct_bssn_id->interface~deallocate_bssn_fields interface~destruct_bssn_id destruct_bssn_id interface~destruct_bssn_id->proc~destruct_bssn_id proc~destructor destructor proc~destructor->interface~destruct_bssn_id interface~destructor destructor interface~destructor->proc~destructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine deallocate_bssn_fields(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS","tags":"","loc":"interface/deallocate_bssn_fields.html"},{"title":"destruct_bssn_id – SPHINCS_LORENE","text":"interface Calls interface~~destruct_bssn_id~~CallsGraph interface~destruct_bssn_id destruct_bssn_id proc~destruct_bssn_id destruct_bssn_id interface~destruct_bssn_id->proc~destruct_bssn_id interface~deallocate_bssn_fields deallocate_bssn_fields proc~destruct_bssn_id->interface~deallocate_bssn_fields proc~deallocate_bssn_fields deallocate_bssn_fields interface~deallocate_bssn_fields->proc~deallocate_bssn_fields deallocate_grid_function deallocate_grid_function proc~deallocate_bssn_fields->deallocate_grid_function var paninterfacedestruct_bssn_idCallsGraph = svgPanZoom('#interfacedestruct_bssn_idCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~destruct_bssn_id~~CalledByGraph interface~destruct_bssn_id destruct_bssn_id proc~destructor destructor proc~destructor->interface~destruct_bssn_id interface~destructor destructor interface~destructor->proc~destructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine destruct_bssn_id(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS","tags":"","loc":"interface/destruct_bssn_id.html"},{"title":"destructor – SPHINCS_LORENE","text":"interface Calls interface~~destructor~~CallsGraph interface~destructor destructor proc~destructor destructor interface~destructor->proc~destructor interface~destruct_bssn_id destruct_bssn_id proc~destructor->interface~destruct_bssn_id deallocate_standard3p1_variables deallocate_standard3p1_variables proc~destructor->deallocate_standard3p1_variables proc~destruct_bssn_id destruct_bssn_id interface~destruct_bssn_id->proc~destruct_bssn_id interface~deallocate_bssn_fields deallocate_bssn_fields proc~destruct_bssn_id->interface~deallocate_bssn_fields proc~deallocate_bssn_fields deallocate_bssn_fields interface~deallocate_bssn_fields->proc~deallocate_bssn_fields deallocate_grid_function deallocate_grid_function proc~deallocate_bssn_fields->deallocate_grid_function var paninterfacedestructorCallsGraph = svgPanZoom('#interfacedestructorCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine destructor(THIS) Implementation → Arguments Type Intent Optional Attributes Name type( bssn_id ), intent(inout) :: THIS","tags":"","loc":"interface/destructor.html"},{"title":"print_formatted_lorene_id_bssn_variables – SPHINCS_LORENE","text":"interface Calls interface~~print_formatted_lorene_id_bssn_variables~~CallsGraph interface~print_formatted_lorene_id_bssn_variables print_formatted_lorene_id_bssn_variables proc~print_formatted_lorene_id_bssn_variables print_formatted_lorene_id_bssn_variables interface~print_formatted_lorene_id_bssn_variables->proc~print_formatted_lorene_id_bssn_variables a_bssn3_ll a_bssn3_ll proc~print_formatted_lorene_id_bssn_variables->a_bssn3_ll gamma_u gamma_u proc~print_formatted_lorene_id_bssn_variables->gamma_u trk trk proc~print_formatted_lorene_id_bssn_variables->trk lapse lapse proc~print_formatted_lorene_id_bssn_variables->lapse phi phi proc~print_formatted_lorene_id_bssn_variables->phi shift_u shift_u proc~print_formatted_lorene_id_bssn_variables->shift_u g_bssn3_ll g_bssn3_ll proc~print_formatted_lorene_id_bssn_variables->g_bssn3_ll Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine print_formatted_lorene_id_bssn_variables(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile","tags":"","loc":"interface/print_formatted_lorene_id_bssn_variables.html"},{"title":"read_bssn_dump_print_formatted – SPHINCS_LORENE","text":"interface Calls interface~~read_bssn_dump_print_formatted~~CallsGraph interface~read_bssn_dump_print_formatted read_bssn_dump_print_formatted proc~read_bssn_dump_print_formatted read_bssn_dump_print_formatted interface~read_bssn_dump_print_formatted->proc~read_bssn_dump_print_formatted a_bssn3_ll a_bssn3_ll proc~read_bssn_dump_print_formatted->a_bssn3_ll allocate_bssn allocate_bssn proc~read_bssn_dump_print_formatted->allocate_bssn read_bssn_dump read_bssn_dump proc~read_bssn_dump_print_formatted->read_bssn_dump lapse lapse proc~read_bssn_dump_print_formatted->lapse allocate_adm allocate_adm proc~read_bssn_dump_print_formatted->allocate_adm shift_u shift_u proc~read_bssn_dump_print_formatted->shift_u deallocate_adm deallocate_adm proc~read_bssn_dump_print_formatted->deallocate_adm trk trk proc~read_bssn_dump_print_formatted->trk gamma_u gamma_u proc~read_bssn_dump_print_formatted->gamma_u phi phi proc~read_bssn_dump_print_formatted->phi g_bssn3_ll g_bssn3_ll proc~read_bssn_dump_print_formatted->g_bssn3_ll deallocate_bssn deallocate_bssn proc~read_bssn_dump_print_formatted->deallocate_bssn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine read_bssn_dump_print_formatted(THIS, namefile_bin, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile_bin character(len=*), intent(inout), optional :: namefile","tags":"","loc":"interface/read_bssn_dump_print_formatted.html"},{"title":"number_surfaces – SPHINCS_LORENE","text":"function number_surfaces(m_p, center, radius, get_dens) result(n_shells_tmp) Uses constants proc~~number_surfaces~~UsesGraph proc~number_surfaces number_surfaces constants constants proc~number_surfaces->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the number of spherical surfaces\n  by integrating the linear particle density\n  along the larger equatorial radius FT 22.07.2021 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: m_p double precision, intent(in) :: center double precision, intent(in) :: radius function get_dens(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Return Value double precision Called by proc~~number_surfaces~~CalledByGraph proc~number_surfaces number_surfaces proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~number_surfaces interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables r Source Code number_surfaces Variables Type Visibility Attributes Name Initial integer, private :: r Source Code FUNCTION number_surfaces ( m_p , center , radius , get_dens ) & RESULT ( n_shells_tmp ) !************************************************ ! !# Compute the number of spherical surfaces !  by integrating the linear particle density !  along the larger equatorial radius ! !  FT 22.07.2021 ! !************************************************ USE constants , ONLY : third IMPLICIT NONE DOUBLE PRECISION , INTENT ( IN ) :: m_p , center , radius INTERFACE FUNCTION get_dens ( x , y , z ) RESULT ( density ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION :: density !> Baryon mass density at (x,y,z) END FUNCTION get_dens END INTERFACE DOUBLE PRECISION :: n_shells_tmp INTEGER :: r !  DOUBLE PRECISION, DIMENSION(:,:), ALLOCATABLE:: particle_profile ! !  IF(.NOT.ALLOCATED( particle_profile ))THEN !    ALLOCATE( particle_profile( 2, 500 ), STAT= ios, & !              ERRMSG= err_msg ) !    IF( ios > 0 )THEN !       PRINT *, \"...allocation error for array particle_profile in\" & !                // \"FUNCTION number_surfaces. \", & !                \"The error message is\", err_msg !       STOP !    ENDIF !  ENDIF n_shells_tmp = 0.0D0 !  particle_profile= 0.0D0 DO r = 1 , 500 , 1 n_shells_tmp = n_shells_tmp + & radius / 500 * ( ( get_dens ( & center + r * radius / 500 , 0.0D0 , 0.0D0 ) & ) / m_p ) ** third !particle_profile( 1, r )= r*radius/500 !particle_profile( 2, r )= n_shells_tmp ENDDO n_shells_tmp = NINT ( n_shells_tmp ) END FUNCTION number_surfaces","tags":"","loc":"proc/number_surfaces.html"},{"title":"particle_volume – SPHINCS_LORENE","text":"function particle_volume(rad, col, dr_shells, dth_shells, dphi_shells, th, colatitudes, npart_equator) result(pvol) Uses constants proc~~particle_volume~~UsesGraph proc~particle_volume particle_volume constants constants proc~particle_volume->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the geometrical particle volume\n  not the proper particle volume. FT 23.07.2021 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: rad double precision, intent(in) :: col double precision, intent(in) :: dr_shells double precision, intent(inout) :: dth_shells double precision, intent(in) :: dphi_shells integer, intent(in) :: th double precision, intent(in), DIMENSION(:) :: colatitudes integer, intent(in) :: npart_equator Return Value double precision Called by proc~~particle_volume~~CalledByGraph proc~particle_volume particle_volume proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~particle_volume interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code particle_volume Source Code FUNCTION particle_volume ( rad , col , dr_shells , dth_shells , dphi_shells , th , & colatitudes , npart_equator ) RESULT ( pvol ) !******************************************* ! !# Compute the geometrical particle volume !  not the proper particle volume. ! !  FT 23.07.2021 ! !******************************************* USE constants , ONLY : pi IMPLICIT NONE INTEGER , INTENT ( IN ) :: th , npart_equator DOUBLE PRECISION , INTENT ( IN ) :: rad , col , dr_shells , dphi_shells DOUBLE PRECISION , INTENT ( IN OUT ) :: dth_shells DOUBLE PRECISION , DIMENSION (:), INTENT ( IN ) :: colatitudes DOUBLE PRECISION :: pvol IF ( th == 1 ) THEN !dth_shells= pi - ( col + colatitude_pos(r)% colatitudes(th+1) )/2.0D0 IF ( npart_equator == 4 ) THEN dth_shells = pi ELSE dth_shells = 2.0D0 * ABS ( col - & ( col + colatitudes ( th + 1 ) ) / 2.0D0 ) ENDIF ELSEIF ( th == npart_equator / 4 ) THEN !dth_shells= ( colatitude_pos(r)% colatitudes(th-1) + col - pi )/2.0D0 dth_shells = 2.0D0 * ABS ( ( colatitudes ( th - 1 ) & + col ) / 2.0D0 - col ) ELSE dth_shells = ABS ( & ( colatitudes ( th + 1 ) + col ) / 2.0D0 & - ( col + colatitudes ( th - 1 ) ) / 2.0D0 ) ENDIF pvol = rad ** 2.0D0 * SIN ( col ) * dr_shells * dth_shells * dphi_shells ! & END FUNCTION particle_volume","tags":"","loc":"proc/particle_volume.html"},{"title":"assign_surfaces_mass – SPHINCS_LORENE","text":"subroutine assign_surfaces_mass(shell_masses, shell_radii, radius, dr, n_shells, mass_profile_idx, mass_profile, mass_star) Uses constants proc~~assign_surfaces_mass~~UsesGraph proc~assign_surfaces_mass assign_surfaces_mass constants constants proc~assign_surfaces_mass->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Assign a mass to each spherical surface,\n  based on the radial mass profile of the star\n  (computed along the larger equatorial radius) FT 23.07.2021 Arguments Type Intent Optional Attributes Name double precision, intent(inout), DIMENSION( n_shells ) :: shell_masses double precision, intent(in), DIMENSION( n_shells ) :: shell_radii double precision, intent(in) :: radius double precision, intent(in) :: dr integer, intent(in) :: n_shells integer, intent(in), DIMENSION( : ) :: mass_profile_idx double precision, intent(in), DIMENSION( :, : ) :: mass_profile double precision, intent(in) :: mass_star Called by proc~~assign_surfaces_mass~~CalledByGraph proc~assign_surfaces_mass assign_surfaces_mass proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~assign_surfaces_mass interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables itr2 shell_index Source Code assign_surfaces_mass Variables Type Visibility Attributes Name Initial integer, private :: itr2 integer, private :: shell_index Source Code SUBROUTINE assign_surfaces_mass ( shell_masses , shell_radii , radius , dr , & n_shells , mass_profile_idx , mass_profile , & mass_star ) !************************************************* ! !# Assign a mass to each spherical surface, !  based on the radial mass profile of the star !  (computed along the larger equatorial radius) ! !  FT 23.07.2021 ! !************************************************* USE constants , ONLY : third IMPLICIT NONE INTEGER , INTENT ( IN ) :: n_shells DOUBLE PRECISION , INTENT ( IN ) :: radius , dr , mass_star INTEGER , DIMENSION ( : ), INTENT ( IN ) :: mass_profile_idx DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN ) :: shell_radii DOUBLE PRECISION , DIMENSION ( :, : ), INTENT ( IN ) :: mass_profile DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN OUT ) :: shell_masses INTEGER shell_index , itr2 shell_index = 1 itr2 = 1 shell_masses = 0.0D0 assign_masses_to_surfaces : DO itr = 1 , NINT ( radius / dr ), 1 IF ( shell_index == n_shells ) THEN shell_masses ( shell_index ) = SUM ( mass_profile ( 2 , & mass_profile_idx ( itr2 ): mass_profile_idx ( NINT ( radius / dr ) - 1 ) ), DIM = 1 ) EXIT ENDIF IF ( mass_profile ( 1 , mass_profile_idx ( itr ) ) & >= shell_radii ( shell_index ) & !+ radius/DBLE(2*n_shells) ) THEN shell_masses ( shell_index ) = SUM ( mass_profile ( 2 , & mass_profile_idx ( itr2 ): mass_profile_idx ( itr ) ), DIM = 1 ) itr2 = itr + 1 shell_index = shell_index + 1 ENDIF ENDDO assign_masses_to_surfaces ! Safety check IF ( ABS ( SUM ( shell_masses , DIM = 1 ) - mass_star ) / mass_star > 5.0D-3 ) THEN PRINT * , \" ** The masses of the shells do not add up to the \" , & \"mass of the star. Stopping...\" PRINT * , \" * SUM( shell_masses )= \" , SUM ( shell_masses , DIM = 1 ) PRINT * , \" * Baryon mass of the star= \" , mass_star PRINT * , \" * Array shell_masses=\" , shell_masses PRINT * STOP ENDIF END SUBROUTINE assign_surfaces_mass","tags":"","loc":"proc/assign_surfaces_mass.html"},{"title":"compute_colatitudes_uniformly_in – SPHINCS_LORENE","text":"subroutine compute_colatitudes_uniformly_in(alpha, beta, colatitudes) Uses constants proc~~compute_colatitudes_uniformly_in~~UsesGraph proc~compute_colatitudes_uniformly_in compute_colatitudes_uniformly_in constants constants proc~compute_colatitudes_uniformly_in->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the colatitudes according to a\n  uniform distribution over a spherical\n  surface, between alpha and beta, with\n  pi/2 < alpha < beta < pi.\n  The values are stored in the array colatitudes\n  See https://mathworld.wolfram.com/SpherePointPicking.html FT 6.10.2021 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: alpha double precision, intent(in) :: beta double precision, intent(inout), DIMENSION(:) :: colatitudes Called by proc~~compute_colatitudes_uniformly_in~~CalledByGraph proc~compute_colatitudes_uniformly_in compute_colatitudes_uniformly_in proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~compute_colatitudes_uniformly_in interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i n size_col Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: n integer, private :: size_col","tags":"","loc":"proc/compute_colatitudes_uniformly_in.html"},{"title":"place_surfaces – SPHINCS_LORENE","text":"subroutine place_surfaces(central_dens, center, radius, m_p, n_shells, shell_radii, last_r, get_dens) Uses constants proc~~place_surfaces~~UsesGraph proc~place_surfaces place_surfaces constants constants proc~place_surfaces->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Place the spherical surface, according to\n  the baryon mass density of the star\n  along the larger equatorial radius FT 23.07.2021 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: central_dens double precision, intent(in) :: center double precision, intent(in) :: radius double precision, intent(in) :: m_p integer, intent(in) :: n_shells double precision, intent(inout), DIMENSION( n_shells ) :: shell_radii double precision, intent(in) :: last_r function get_dens(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Called by proc~~place_surfaces~~CalledByGraph proc~place_surfaces place_surfaces proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~place_surfaces interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables rho_tmp Source Code place_surfaces Variables Type Visibility Attributes Name Initial double precision, private :: rho_tmp Source Code SUBROUTINE place_surfaces ( central_dens , center , radius , m_p , n_shells , & shell_radii , last_r , get_dens ) !************************************************ ! !# Place the spherical surface, according to !  the baryon mass density of the star !  along the larger equatorial radius ! !  FT 23.07.2021 ! !************************************************ USE constants , ONLY : third IMPLICIT NONE INTEGER , INTENT ( IN ) :: n_shells DOUBLE PRECISION , INTENT ( IN ) :: central_dens , center , radius , m_p , last_r DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN OUT ) :: shell_radii INTERFACE FUNCTION get_dens ( x , y , z ) RESULT ( density ) !! Returns the baryon mass density at the desired point DOUBLE PRECISION , INTENT ( IN ) :: x !! x coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: y !! y coordinate of the desired point DOUBLE PRECISION , INTENT ( IN ) :: z !! z coordinate of the desired point DOUBLE PRECISION :: density !> Baryon mass density at (x,y,z) END FUNCTION get_dens END INTERFACE DOUBLE PRECISION :: rho_tmp !central_density= bns_obj% get_rho_center1() shell_radii = 0.0D0 shell_radii ( 1 ) = ( central_dens / m_p ) ** ( - third ) DO itr = 2 , n_shells , 1 rho_tmp = get_dens ( center + shell_radii ( itr - 1 ), & 0.0D0 , 0.0D0 ) IF ( rho_tmp == 0 ) THEN shell_radii = shell_radii * itr / n_shells ENDIF shell_radii ( itr ) = shell_radii ( itr - 1 ) + ( rho_tmp / m_p ) ** ( - third ) ENDDO shell_radii = shell_radii * ( radius * last_r / shell_radii ( n_shells )) END SUBROUTINE place_surfaces","tags":"","loc":"proc/place_surfaces.html"},{"title":"print_mass_profile_surface_radii – SPHINCS_LORENE","text":"subroutine print_mass_profile_surface_radii(mass_profile, mass_profile_idx, shell_radii, radius, dr, n_shells, filename_mass_profile, filename_shells_radii) Uses constants proc~~print_mass_profile_surface_radii~~UsesGraph proc~print_mass_profile_surface_radii print_mass_profile_surface_radii constants constants proc~print_mass_profile_surface_radii->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Print star's radial mass profile and radii of\n  spherical surfaces to different ASCII files FT 23.07.2021 Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION( :, : ) :: mass_profile integer, intent(in), DIMENSION( : ) :: mass_profile_idx double precision, intent(in), DIMENSION( n_shells ) :: shell_radii double precision, intent(in) :: radius double precision, intent(in) :: dr integer, intent(in) :: n_shells character(len=*), intent(in) :: filename_mass_profile character(len=*), intent(in) :: filename_shells_radii Called by proc~~print_mass_profile_surface_radii~~CalledByGraph proc~print_mass_profile_surface_radii print_mass_profile_surface_radii proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~print_mass_profile_surface_radii interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables exist Source Code print_mass_profile_surface_radii Variables Type Visibility Attributes Name Initial logical, private :: exist Source Code SUBROUTINE print_mass_profile_surface_radii ( mass_profile , mass_profile_idx , & shell_radii , radius , dr , & n_shells , & filename_mass_profile , & filename_shells_radii ) !************************************************* ! !# Print star's radial mass profile and radii of !  spherical surfaces to different ASCII files ! !  FT 23.07.2021 ! !************************************************* USE constants , ONLY : third IMPLICIT NONE INTEGER , INTENT ( IN ) :: n_shells DOUBLE PRECISION , INTENT ( IN ) :: radius , dr INTEGER , DIMENSION ( : ), INTENT ( IN ) :: mass_profile_idx DOUBLE PRECISION , DIMENSION ( n_shells ), INTENT ( IN ) :: shell_radii DOUBLE PRECISION , DIMENSION ( :, : ), INTENT ( IN ) :: mass_profile CHARACTER ( LEN = * ), INTENT ( IN ) :: filename_mass_profile , & filename_shells_radii LOGICAL :: exist PRINT * , \" * Print mass profile to file...\" PRINT * INQUIRE ( FILE = TRIM ( filename_mass_profile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( filename_mass_profile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( filename_mass_profile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( filename_mass_profile ), & \". The error message is\" , err_msg STOP ENDIF write_data_loop : DO itr = 1 , NINT ( radius / dr ) - 1 , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & mass_profile ( 1 , mass_profile_idx ( itr ) ), & mass_profile ( 2 , mass_profile_idx ( itr ) ), & mass_profile ( 3 , mass_profile_idx ( itr ) ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" & // TRIM ( filename_mass_profile ), \". The error message is\" , & err_msg STOP ENDIF ENDDO write_data_loop CLOSE ( UNIT = 2 ) PRINT * , \" * Print surfaces' radii to file...\" PRINT * INQUIRE ( FILE = TRIM ( filename_shells_radii ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( filename_shells_radii ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( filename_shells_radii ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( filename_shells_radii ), & \". The error message is\" , err_msg STOP ENDIF DO itr = 1 , n_shells , 1 WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & shell_radii ( itr ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" & // TRIM ( filename_shells_radii ), \". The error message is\" , & err_msg STOP ENDIF ENDDO CLOSE ( UNIT = 2 ) END SUBROUTINE print_mass_profile_surface_radii","tags":"","loc":"proc/print_mass_profile_surface_radii.html"},{"title":"reallocate_array_1d – SPHINCS_LORENE","text":"subroutine reallocate_array_1d(array, new_dim) Reallocate a 1-dimensional array FT 22.07.2021 Arguments Type Intent Optional Attributes Name double precision, intent(inout), DIMENSION(:), ALLOCATABLE :: array integer, intent(in) :: new_dim Called by proc~~reallocate_array_1d~~CalledByGraph proc~reallocate_array_1d reallocate_array_1d proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~reallocate_array_1d interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code reallocate_array_1d Source Code SUBROUTINE reallocate_array_1d ( array , new_dim ) !************************************ ! !# Reallocate a 1-dimensional array ! !  FT 22.07.2021 ! !************************************ IMPLICIT NONE DOUBLE PRECISION , DIMENSION (:), ALLOCATABLE , INTENT ( IN OUT ) :: array INTEGER , INTENT ( IN ) :: new_dim DEALLOCATE ( array , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF ALLOCATE ( array ( new_dim ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF END SUBROUTINE reallocate_array_1d","tags":"","loc":"proc/reallocate_array_1d.html"},{"title":"reallocate_array_2d – SPHINCS_LORENE","text":"subroutine reallocate_array_2d(array, new_dim, new_dim2) Reallocate a 2-dimensional array FT 22.07.2021 Arguments Type Intent Optional Attributes Name double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: array integer, intent(in) :: new_dim integer, intent(in) :: new_dim2 Called by proc~~reallocate_array_2d~~CalledByGraph proc~reallocate_array_2d reallocate_array_2d proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces->proc~reallocate_array_2d interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Source Code reallocate_array_2d Source Code SUBROUTINE reallocate_array_2d ( array , new_dim , new_dim2 ) !************************************ ! !# Reallocate a 2-dimensional array ! !  FT 22.07.2021 ! !************************************ IMPLICIT NONE DOUBLE PRECISION , DIMENSION (:,:), ALLOCATABLE , INTENT ( IN OUT ) :: array INTEGER , INTENT ( IN ) :: new_dim , new_dim2 DEALLOCATE ( array , STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...deallocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF ALLOCATE ( array ( new_dim , new_dim2 ), STAT = ios , ERRMSG = err_msg ) IF ( ios > 0 ) THEN PRINT * , \"...allocation error in SUBROUTINE\" & // \"reallocate_tmp_variable. \" , & \"The error message is\" , err_msg , \", and IOSTAT= \" , ios STOP ENDIF END SUBROUTINE reallocate_array_2d","tags":"","loc":"proc/reallocate_array_2d.html"},{"title":"check_particle_position – SPHINCS_LORENE","text":"public function check_particle_position(npart, pos, pos_a) result(cnt) Return the number of times that pos_a appears\n  in the array pos FT 13.10.2021 Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart double precision, intent(in), DIMENSION(3,npart) :: pos double precision, intent(in), DIMENSION(3) :: pos_a Return Value integer Contents Variables cnts itr itr2 size_x x_number x_number_filt x_sort Source Code check_particle_position Variables Type Visibility Attributes Name Initial integer, public, DIMENSION(npart) :: cnts integer, public :: itr integer, public :: itr2 integer, public :: size_x integer, public, DIMENSION(npart) :: x_number integer, public, DIMENSION(:), ALLOCATABLE :: x_number_filt integer, public, DIMENSION(npart) :: x_sort Source Code FUNCTION check_particle_position ( npart , pos , pos_a ) RESULT ( cnt ) !***************************************************** ! !# Return the number of times that pos_a appears !  in the array pos ! !  FT 13.10.2021 ! !***************************************************** !USE NR,             ONLY: indexx IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart DOUBLE PRECISION , DIMENSION ( 3 , npart ), INTENT ( IN ) :: pos DOUBLE PRECISION , DIMENSION ( 3 ), INTENT ( IN ) :: pos_a INTEGER :: cnt INTEGER :: itr , itr2 , size_x !, cnt INTEGER , DIMENSION ( npart ) :: x_sort , cnts INTEGER , DIMENSION ( npart ) :: x_number INTEGER , DIMENSION (:), ALLOCATABLE :: x_number_filt ! Sort x coordinates of the particles !CALL indexx( npart, pos( 1, : ), x_sort ) x_number = 0 itr2 = 0 ! Find the number of times that the x coordinate of pos_a appears in pos !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, pos_a, x_sort, x_number, npart ) & !$OMP             PRIVATE( itr ) DO itr = 1 , npart , 1 IF ( pos ( 1 , itr ) == pos_a ( 1 ) ) THEN !itr2= itr2 + 1 x_number ( itr ) = itr !ELSEIF( pos( 1, x_sort(itr) ) > pos_a( 1 ) )THEN ! !  EXIT ENDIF ENDDO !$OMP END PARALLEL DO x_number_filt = PACK ( x_number , x_number /= 0 ) size_x = SIZE ( x_number_filt ) cnts = 0 !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, pos_a, x_sort, x_number_filt, size_x, cnts )& !$OMP             PRIVATE( itr ) DO itr = 1 , size_x , 1 ! If they have the same y IF ( pos ( 2 , x_number_filt ( itr ) ) == pos_a ( 2 ) ) THEN ! If they have the same z IF ( pos ( 3 , x_number_filt ( itr ) ) == pos_a ( 3 ) ) THEN cnts ( itr ) = cnts ( itr ) + 1 ENDIF ENDIF ENDDO !$OMP END PARALLEL DO cnt = SUM ( cnts ) END FUNCTION check_particle_position","tags":"","loc":"proc/check_particle_position.html"},{"title":"check_particle_positions – SPHINCS_LORENE","text":"public subroutine check_particle_positions(npart, pos, debug) Uses NR proc~~check_particle_positions~~UsesGraph proc~check_particle_positions check_particle_positions NR NR proc~check_particle_positions->NR Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Check that the particles are not at the same\n  positions FT 1.9.2021 Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart double precision, intent(in), DIMENSION(3,npart) :: pos logical, intent(in), optional :: debug Calls proc~~check_particle_positions~~CallsGraph proc~check_particle_positions check_particle_positions indexx indexx proc~check_particle_positions->indexx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~check_particle_positions~~CalledByGraph proc~check_particle_positions check_particle_positions proc~construct_particles construct_particles proc~construct_particles->proc~check_particle_positions proc~perform_apm perform_apm proc~perform_apm->proc~check_particle_positions interface~perform_apm perform_apm interface~perform_apm->proc~perform_apm interface~construct_particles construct_particles interface~construct_particles->proc~construct_particles interface~particles particles interface~particles->interface~construct_particles program~convergence_test convergence_test program~convergence_test->interface~particles program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~particles var panproccheck_particle_positionsCalledByGraph = svgPanZoom('#proccheck_particle_positionsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables itr itr2 x_idx x_number x_sort Source Code check_particle_positions Variables Type Visibility Attributes Name Initial integer, public :: itr integer, public :: itr2 integer, public :: x_idx integer, public, DIMENSION(:), ALLOCATABLE :: x_number integer, public, DIMENSION(npart) :: x_sort Source Code SUBROUTINE check_particle_positions ( npart , pos , debug ) !************************************************* ! !# Check that the particles are not at the same !  positions ! !  FT 1.9.2021 ! !************************************************* USE NR , ONLY : indexx IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart LOGICAL , INTENT ( IN ), OPTIONAL :: debug DOUBLE PRECISION , DIMENSION ( 3 , npart ), INTENT ( IN ) :: pos INTEGER :: itr , itr2 , x_idx INTEGER , DIMENSION ( npart ) :: x_sort INTEGER , DIMENSION (:), ALLOCATABLE :: x_number PRINT * , \"** Checking that there are not multiple particles\" , & \" at the same position...\" PRINT * ALLOCATE ( x_number ( npart ) ) ! Sort x coordinates of the particles CALL indexx ( npart , pos ( 1 , : ), x_sort ) x_number = 1 itr2 = 1 ! Find the number of times each x appears DO itr = 1 , npart - 1 , 1 IF ( pos ( 1 , x_sort ( itr ) ) == & pos ( 1 , x_sort ( itr + 1 ) ) ) THEN x_number ( itr2 ) = x_number ( itr2 ) + 1 ELSE itr2 = itr2 + 1 ENDIF ENDDO x_number = x_number ( 1 : itr2 ) IF ( SUM ( x_number ) /= npart ) THEN PRINT * , \"** ERROR! The sum of the numbers of particles with the same\" , & \" x is not equal to the particle number.\" PRINT * , \" * SUM( x_number )=\" , SUM ( x_number ), \", \" , & \"npart=\" , npart PRINT * , \" * Stopping...\" PRINT * STOP ENDIF IF ( PRESENT ( debug ) . AND . debug . EQV . . TRUE . ) THEN !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, x_sort, x_number ) & !$OMP             PRIVATE( itr, itr2, x_idx ) DO itr = 1 , SIZE ( x_number ), 1 IF ( itr == 1 ) THEN x_idx = 1 ELSE x_idx = SUM ( x_number ( 1 : itr - 1 )) + 1 ENDIF DO itr2 = x_idx , x_idx + x_number ( itr ) - 2 , 1 ! If they do not have the same x IF ( pos ( 1 , x_sort ( itr2 ) ) /= & pos ( 1 , x_sort ( itr2 + 1 ) ) ) THEN PRINT * , \"** ERROR! \" , \"The two particles \" , x_sort ( itr2 ), & \" and\" , x_sort ( itr2 + 1 ), & \" do not have the same x, but should!\" PRINT * , pos ( :, x_sort ( itr2 ) ) PRINT * , pos ( :, x_sort ( itr2 + 1 ) ) PRINT * , \" * Stopping...\" PRINT * STOP ENDIF ENDDO ENDDO !$OMP END PARALLEL DO ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, x_sort, x_number ) & !$OMP             PRIVATE( itr, itr2, x_idx ) DO itr = 1 , SIZE ( x_number ), 1 IF ( itr == 1 ) THEN x_idx = 1 ELSE x_idx = SUM ( x_number ( 1 : itr - 1 )) + 1 ENDIF DO itr2 = x_idx , x_idx + x_number ( itr ) - 2 , 1 ! If they have the same y IF ( pos ( 2 , x_sort ( itr2 ) ) == & pos ( 2 , x_sort ( itr2 + 1 ) ) ) THEN ! If they have the same z IF ( pos ( 3 , x_sort ( itr2 ) ) == & pos ( 3 , x_sort ( itr2 + 1 ) ) ) THEN ! They are the same PRINT * , \"** ERROR! \" , \"The two particles \" , x_sort ( itr2 ), & \" and\" , x_sort ( itr2 + 1 ), \" have the same coordinates!\" PRINT * , pos ( :, x_sort ( itr2 ) ) PRINT * , pos ( :, x_sort ( itr2 + 1 ) ) PRINT * , \" * Stopping...\" PRINT * STOP ENDIF ENDIF ENDDO ENDDO !$OMP END PARALLEL DO DEALLOCATE ( x_number ) END SUBROUTINE check_particle_positions","tags":"","loc":"proc/check_particle_positions.html"},{"title":"allocate_lorene_id_parts_memory – SPHINCS_LORENE","text":"interface Calls interface~~allocate_lorene_id_parts_memory~~CallsGraph interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory proc~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory->proc~allocate_lorene_id_parts_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~allocate_lorene_id_parts_memory~~CalledByGraph interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory proc~construct_particles construct_particles proc~construct_particles->interface~allocate_lorene_id_parts_memory interface~construct_particles construct_particles interface~construct_particles->proc~construct_particles interface~particles particles interface~particles->interface~construct_particles program~convergence_test convergence_test program~convergence_test->interface~particles program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~particles var paninterfaceallocate_lorene_id_parts_memoryCalledByGraph = svgPanZoom('#interfaceallocate_lorene_id_parts_memoryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine allocate_lorene_id_parts_memory(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Description Allocates allocatable arrays member of a particles object","tags":"","loc":"interface/allocate_lorene_id_parts_memory.html"},{"title":"analyze_hydro – SPHINCS_LORENE","text":"interface Calls interface~~analyze_hydro~~CallsGraph interface~analyze_hydro analyze_hydro proc~analyze_hydro analyze_hydro interface~analyze_hydro->proc~analyze_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine analyze_hydro(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the particle positions at which\n some of the hydro fields are negative or zero are printed to Description Scans the hydro fields taken from \\texttt{\\texttt{LORENE}} to look\n for negative or zero values","tags":"","loc":"interface/analyze_hydro.html"},{"title":"compute_Ye – SPHINCS_LORENE","text":"interface Calls interface~~compute_ye~~CallsGraph interface~compute_ye compute_Ye proc~compute_ye compute_Ye interface~compute_ye->proc~compute_ye Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine compute_Ye(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Description Interpolates linearly the electron fraction Y_e at the particle\n densities; that is, assigns Y_e at the particle positions","tags":"","loc":"interface/compute_ye.html"},{"title":"compute_and_export_SPH_variables – SPHINCS_LORENE","text":"interface Calls interface~~compute_and_export_sph_variables~~CallsGraph interface~compute_and_export_sph_variables compute_and_export_SPH_variables proc~compute_and_export_sph_variables compute_and_export_SPH_variables interface~compute_and_export_sph_variables->proc~compute_and_export_sph_variables vel_u vel_u proc~compute_and_export_sph_variables->vel_u iorig iorig proc~compute_and_export_sph_variables->iorig nu nu proc~compute_and_export_sph_variables->nu allocate_metric_on_particles allocate_metric_on_particles proc~compute_and_export_sph_variables->allocate_metric_on_particles gen_pwp_eos_all gen_pwp_eos_all proc~compute_and_export_sph_variables->gen_pwp_eos_all deallocate_metric_on_particles deallocate_metric_on_particles proc~compute_and_export_sph_variables->deallocate_metric_on_particles allocate_rcb_tree_memory_3d allocate_rcb_tree_memory_3d proc~compute_and_export_sph_variables->allocate_rcb_tree_memory_3d pos_u pos_u proc~compute_and_export_sph_variables->pos_u sq_det_g4 sq_det_g4 proc~compute_and_export_sph_variables->sq_det_g4 nlrf nlrf proc~compute_and_export_sph_variables->nlrf read_options read_options proc~compute_and_export_sph_variables->read_options select_eos_parameters select_eos_parameters proc~compute_and_export_sph_variables->select_eos_parameters pr pr proc~compute_and_export_sph_variables->pr density density proc~compute_and_export_sph_variables->density av av proc~compute_and_export_sph_variables->av u u proc~compute_and_export_sph_variables->u assign_h assign_h proc~compute_and_export_sph_variables->assign_h allocate_gradient allocate_gradient proc~compute_and_export_sph_variables->allocate_gradient set_units set_units proc~compute_and_export_sph_variables->set_units deallocate_rcb_tree_memory_3d deallocate_rcb_tree_memory_3d proc~compute_and_export_sph_variables->deallocate_rcb_tree_memory_3d write_sphincs_dump write_sphincs_dump proc~compute_and_export_sph_variables->write_sphincs_dump get_u_pwp get_u_pwp proc~compute_and_export_sph_variables->get_u_pwp ncand ncand proc~compute_and_export_sph_variables->ncand allocate_sph_memory allocate_sph_memory proc~compute_and_export_sph_variables->allocate_sph_memory divv divv proc~compute_and_export_sph_variables->divv shorten_eos_name shorten_eos_name proc~compute_and_export_sph_variables->shorten_eos_name determinant_4x4_matrix determinant_4x4_matrix proc~compute_and_export_sph_variables->determinant_4x4_matrix temp temp proc~compute_and_export_sph_variables->temp theta theta proc~compute_and_export_sph_variables->theta deallocate_gradient deallocate_gradient proc~compute_and_export_sph_variables->deallocate_gradient h h proc~compute_and_export_sph_variables->h deallocate_sph_memory deallocate_sph_memory proc~compute_and_export_sph_variables->deallocate_sph_memory density_loop density_loop proc~compute_and_export_sph_variables->density_loop exact_nei_tree_update exact_nei_tree_update proc~compute_and_export_sph_variables->exact_nei_tree_update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine compute_and_export_SPH_variables(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the SPH ID is printed to Description Computes the SPH variables at the particle positions, and optionally\n prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} and \\texttt{splash} , and to a formatted file to be read by \\texttt{gnuplot} , by calling print_formatted_lorene_id_particles","tags":"","loc":"interface/compute_and_export_sph_variables.html"},{"title":"construct_particles – SPHINCS_LORENE","text":"interface Calls interface~~construct_particles~~CallsGraph interface~construct_particles construct_particles proc~construct_particles construct_particles interface~construct_particles->proc~construct_particles proc~check_particle_positions check_particle_positions proc~construct_particles->proc~check_particle_positions timer timer proc~construct_particles->timer read_options read_options proc~construct_particles->read_options set_units set_units proc~construct_particles->set_units ktable ktable proc~construct_particles->ktable alive alive proc~construct_particles->alive interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory proc~construct_particles->interface~allocate_lorene_id_parts_memory indexx indexx proc~check_particle_positions->indexx proc~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory->proc~allocate_lorene_id_parts_memory var paninterfaceconstruct_particlesCallsGraph = svgPanZoom('#interfaceconstruct_particlesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~construct_particles~~CalledByGraph interface~construct_particles construct_particles interface~particles particles interface~particles->interface~construct_particles program~convergence_test convergence_test program~convergence_test->interface~particles program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function construct_particles(id, dist) result(parts) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id idbase object representing the BNS for which we want to place\n particles integer, intent(in) :: dist Identifier of the desired particle distribution: 0: Read particle positions (and optionally the baryon number per\n    particle \\nu ) from a formatted file 1: Place particles on a single lattice that surrounds both stars 2: Place particles on two lattices, each one surrounding a star 3: Place particles on spherical surfaces inside the stars Warning Method 1 is almost deprecated, since method 2 is effectively\n          an improvement of method 1 Return Value type( particles ) Constructed particles object Description Constructs a particles object","tags":"","loc":"interface/construct_particles.html"},{"title":"deallocate_lorene_id_parts_memory – SPHINCS_LORENE","text":"interface Calls interface~~deallocate_lorene_id_parts_memory~~CallsGraph interface~deallocate_lorene_id_parts_memory deallocate_lorene_id_parts_memory proc~deallocate_lorene_id_parts_memory deallocate_lorene_id_parts_memory interface~deallocate_lorene_id_parts_memory->proc~deallocate_lorene_id_parts_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine deallocate_lorene_id_parts_memory(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Description Deallocates allocatable arrays member of a particles object","tags":"","loc":"interface/deallocate_lorene_id_parts_memory.html"},{"title":"destruct_particles – SPHINCS_LORENE","text":"interface Calls interface~~destruct_particles~~CallsGraph interface~destruct_particles destruct_particles proc~destruct_particles destruct_particles interface~destruct_particles->proc~destruct_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine destruct_particles(THIS) Implementation → Arguments Type Intent Optional Attributes Name type( particles ), intent(inout) :: THIS Finalizer (Destructor) of particles object particles object which this PROCEDURE is a member of","tags":"","loc":"interface/destruct_particles.html"},{"title":"get_h – SPHINCS_LORENE","text":"interface Calls interface~~get_h~~CallsGraph interface~get_h get_h proc~get_h get_h interface~get_h->proc~get_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_h(THIS) result(h) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE h Description Returns h","tags":"","loc":"interface/get_h.html"},{"title":"get_nlrf – SPHINCS_LORENE","text":"interface Calls interface~~get_nlrf~~CallsGraph interface~get_nlrf get_nlrf proc~get_nlrf get_nlrf interface~get_nlrf->proc~get_nlrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nlrf(THIS) result(nlrf) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE nlrf Description Returns nlrf","tags":"","loc":"interface/get_nlrf.html"},{"title":"get_npart – SPHINCS_LORENE","text":"interface Calls interface~~get_npart~~CallsGraph interface~get_npart get_npart proc~get_npart get_npart interface~get_npart->proc~get_npart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_npart(THIS) result(n_part) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer npart Description Returns npart","tags":"","loc":"interface/get_npart.html"},{"title":"get_npart1 – SPHINCS_LORENE","text":"interface Calls interface~~get_npart1~~CallsGraph interface~get_npart1 get_npart1 proc~get_npart1 get_npart1 interface~get_npart1->proc~get_npart1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_npart1(THIS) result(n_part) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles Description Returns particles","tags":"","loc":"interface/get_npart1.html"},{"title":"get_npart2 – SPHINCS_LORENE","text":"interface Calls interface~~get_npart2~~CallsGraph interface~get_npart2 get_npart2 proc~get_npart2 get_npart2 interface~get_npart2->proc~get_npart2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_npart2(THIS) result(n_part) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles Description Returns particles","tags":"","loc":"interface/get_npart2.html"},{"title":"get_nu – SPHINCS_LORENE","text":"interface Calls interface~~get_nu~~CallsGraph interface~get_nu get_nu proc~get_nu get_nu interface~get_nu->proc~get_nu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nu(THIS) result(nu) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE nu Description Returns nu","tags":"","loc":"interface/get_nu.html"},{"title":"get_nuratio – SPHINCS_LORENE","text":"interface Calls interface~~get_nuratio~~CallsGraph interface~get_nuratio get_nuratio proc~get_nuratio get_nuratio interface~get_nuratio->proc~get_nuratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nuratio(THIS) result(nuratio) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision nuratio Description Returns nuratio","tags":"","loc":"interface/get_nuratio.html"},{"title":"get_nuratio1 – SPHINCS_LORENE","text":"interface Calls interface~~get_nuratio1~~CallsGraph interface~get_nuratio1 get_nuratio1 proc~get_nuratio1 get_nuratio1 interface~get_nuratio1->proc~get_nuratio1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nuratio1(THIS) result(nuratio1) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles Description Returns particles","tags":"","loc":"interface/get_nuratio1.html"},{"title":"get_nuratio2 – SPHINCS_LORENE","text":"interface Calls interface~~get_nuratio2~~CallsGraph interface~get_nuratio2 get_nuratio2 proc~get_nuratio2 get_nuratio2 interface~get_nuratio2->proc~get_nuratio2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nuratio2(THIS) result(nuratio2) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles Description Returns particles","tags":"","loc":"interface/get_nuratio2.html"},{"title":"get_pos – SPHINCS_LORENE","text":"interface Calls interface~~get_pos~~CallsGraph interface~get_pos get_pos proc~get_pos get_pos interface~get_pos->proc~get_pos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_pos(THIS) result(pos_u) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:),ALLOCATABLE pos Description Returns pos","tags":"","loc":"interface/get_pos.html"},{"title":"get_pressure – SPHINCS_LORENE","text":"interface Calls interface~~get_pressure~~CallsGraph interface~get_pressure get_pressure proc~get_pressure get_pressure interface~get_pressure->proc~get_pressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_pressure(THIS) result(pressure) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE pressure_parts Description Returns pressure_parts","tags":"","loc":"interface/get_pressure.html"},{"title":"get_pressure_cu – SPHINCS_LORENE","text":"interface Calls interface~~get_pressure_cu~~CallsGraph interface~get_pressure_cu get_pressure_cu proc~get_pressure_cu get_pressure_cu interface~get_pressure_cu->proc~get_pressure_cu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_pressure_cu(THIS) result(pressure_cu) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE pressure_parts_cu Description Returns pressure_parts_cu","tags":"","loc":"interface/get_pressure_cu.html"},{"title":"get_theta – SPHINCS_LORENE","text":"interface Calls interface~~get_theta~~CallsGraph interface~get_theta get_theta proc~get_theta get_theta interface~get_theta->proc~get_theta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_theta(THIS) result(theta) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE Theta Description Returns Theta","tags":"","loc":"interface/get_theta.html"},{"title":"get_u – SPHINCS_LORENE","text":"interface Calls interface~~get_u~~CallsGraph interface~get_u get_u proc~get_u get_u interface~get_u->proc~get_u Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_u(THIS) result(u) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE specific_energy_parts Description Returns specific_energy_parts","tags":"","loc":"interface/get_u.html"},{"title":"get_vel – SPHINCS_LORENE","text":"interface Calls interface~~get_vel~~CallsGraph interface~get_vel get_vel proc~get_vel get_vel interface~get_vel->proc~get_vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_vel(THIS) result(vel) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:),ALLOCATABLE v Description Returns v","tags":"","loc":"interface/get_vel.html"},{"title":"is_empty – SPHINCS_LORENE","text":"interface Calls interface~~is_empty~~CallsGraph interface~is_empty is_empty proc~is_empty is_empty interface~is_empty->proc~is_empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function is_empty(THIS) result(answer) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(in) :: THIS particles object which this PROCEDURE is a member of Return Value logical .TRUE if the particles object is empty, .FALSE otherwise Description Returns .TRUE if the particles object is empty, .FALSE otherwise Warning experimental, not actively used in the code yet","tags":"","loc":"interface/is_empty.html"},{"title":"particles – SPHINCS_LORENE","text":"public interface particles Interface of TYPE particles Calls interface~~particles~~CallsGraph interface~particles particles interface~construct_particles construct_particles interface~particles->interface~construct_particles proc~construct_particles construct_particles interface~construct_particles->proc~construct_particles proc~check_particle_positions check_particle_positions proc~construct_particles->proc~check_particle_positions timer timer proc~construct_particles->timer read_options read_options proc~construct_particles->read_options set_units set_units proc~construct_particles->set_units ktable ktable proc~construct_particles->ktable alive alive proc~construct_particles->alive interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory proc~construct_particles->interface~allocate_lorene_id_parts_memory indexx indexx proc~check_particle_positions->indexx proc~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory->proc~allocate_lorene_id_parts_memory var paninterfaceparticlesCallsGraph = svgPanZoom('#interfaceparticlesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~particles~~CalledByGraph interface~particles particles program~convergence_test convergence_test program~convergence_test->interface~particles program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures construct_particles Module Procedures public interface construct_particles () Arguments None","tags":"","loc":"interface/particles.html"},{"title":"perform_apm – SPHINCS_LORENE","text":"interface Calls interface~~perform_apm~~CallsGraph interface~perform_apm perform_apm proc~perform_apm perform_apm interface~perform_apm->proc~perform_apm nu nu proc~perform_apm->nu iorig iorig proc~perform_apm->iorig allocate_metric_on_particles allocate_metric_on_particles proc~perform_apm->allocate_metric_on_particles deallocate_metric_on_particles deallocate_metric_on_particles proc~perform_apm->deallocate_metric_on_particles allocate_rcb_tree_memory_3d allocate_rcb_tree_memory_3d proc~perform_apm->allocate_rcb_tree_memory_3d com com proc~perform_apm->com none~validate_position_final validate_position_final proc~perform_apm->none~validate_position_final proc~check_particle_positions check_particle_positions proc~perform_apm->proc~check_particle_positions density density proc~perform_apm->density assign_h assign_h proc~perform_apm->assign_h allocate_gradient allocate_gradient proc~perform_apm->allocate_gradient proc~correct_center_of_mass correct_center_of_mass proc~perform_apm->proc~correct_center_of_mass proc~impose_equatorial_plane_symmetry impose_equatorial_plane_symmetry proc~perform_apm->proc~impose_equatorial_plane_symmetry deallocate_rcb_tree_memory_3d deallocate_rcb_tree_memory_3d proc~perform_apm->deallocate_rcb_tree_memory_3d ncand ncand proc~perform_apm->ncand allocate_sph_memory allocate_sph_memory proc~perform_apm->allocate_sph_memory position_correction position_correction proc~perform_apm->position_correction deallocate_gradient deallocate_gradient proc~perform_apm->deallocate_gradient h h proc~perform_apm->h deallocate_sph_memory deallocate_sph_memory proc~perform_apm->deallocate_sph_memory density_loop density_loop proc~perform_apm->density_loop exact_nei_tree_update exact_nei_tree_update proc~perform_apm->exact_nei_tree_update validate_position validate_position none~validate_position_final->validate_position indexx indexx proc~check_particle_positions->indexx proc~correct_center_of_mass->com proc~impose_equatorial_plane_symmetry->com Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine perform_apm(get_density, get_nstar_p, pos_input, pvol, h_output, nu_output, center, com_star, mass, radx_comp, radx_opp, rady, radz, apm_max_it, max_inc, mass_it, correct_nu, nuratio_thres, nuratio_des, nx_gh, ny_gh, nz_gh, namefile_pos_id, namefile_pos, namefile_results, validate_position) Implementation → Arguments Type Intent Optional Attributes Name function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine get_nstar_p(npart_real, x, y, z, nstar_p) Computes the proper baryon number density at the particle positions Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real Number of real particles (i.e., no ghost particles included here) double precision, intent(in) :: x (npart_real) Array of x coordinates double precision, intent(in) :: y (npart_real) Array of y coordinates double precision, intent(in) :: z (npart_real) Array of z coordinates double precision, intent(out) :: nstar_p (npart_real) Array to store the computed proper baryon number density double precision, intent(inout), DIMENSION(:,:) :: pos_input Initial particle positions double precision, intent(inout), DIMENSION(:) :: pvol Initial particle volume double precision, intent(out), DIMENSION(:) :: h_output Array to store the smoothing lengths computed at the end of the\n APM iteration double precision, intent(out), DIMENSION(:) :: nu_output Array to store the baryon number per particle computed at the end of\n the APM iteration double precision, intent(in) :: center Center of the star (point of highest density), computed by \\texttt{LORENE} double precision, intent(in) :: com_star Center of mass of the star, computed by \\texttt{LORENE} double precision, intent(in) :: mass Mass of the star double precision, intent(in) :: radx_comp Radius of the star in the x direction, towards the companion double precision, intent(in) :: radx_opp Radius of the star in the x direction, opposite to companion double precision, intent(in) :: rady Radius of the star in the y direction double precision, intent(in) :: radz Radius of the star in the z direction integer, intent(in) :: apm_max_it Maximum number of APM iterations, irrespective of the EXIT condition integer, intent(in) :: max_inc Sets the EXIT condition: If the average over all the\n particles of the relative error in the density estimate\n grows max_inc times, exit the iteration. logical, intent(in) :: mass_it If .TRUE. performs a second iteration after the APM one, without moving\n the particles, changing their mass in order to better match\n the star density. The mass ratio grows very fast in all the tried\n experiments, hence the suggested value is .FALSE. logical, intent(in) :: correct_nu If .TRUE., the baryon number per particle nu is corrected\n to include the total baryonic masses of the\n stars. double precision, intent(in) :: nuratio_thres Maximum mass ratio (equivalently baryon number ratio)\n to be used in the one-time-only final correction\n of the particle masses to match the star density even\n better (without moving the particles) double precision, intent(in) :: nuratio_des Sets the EXIT condition: If the baryon number ratio\n is within 2.5% of nuratio_des, exit the iteration\n Set nuratio_des to 0 to deactivate and exit the APM\n iteration using max_inc integer, intent(in) :: nx_gh Number of lattice points in the x direction for ghosts integer, intent(in) :: ny_gh Number of lattice points in the y direction for ghosts integer, intent(in) :: nz_gh Number of lattice points in the z direction for ghosts character(len=*), intent(inout), optional :: namefile_pos_id Name for the formatted file where the initial particle positions character(len=*), intent(inout), optional :: namefile_pos Name for the formatted file where the particle positions character(len=*), intent(inout), optional :: namefile_results Name for the formatted file where various quantities related procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise Description Performs the Artificial Pressure Method (APM) on one star's particles","tags":"","loc":"interface/perform_apm.html"},{"title":"place_particles_lattice – SPHINCS_LORENE","text":"interface Calls interface~~place_particles_lattice~~CallsGraph interface~place_particles_lattice place_particles_lattice proc~place_particles_lattice place_particles_lattice interface~place_particles_lattice->proc~place_particles_lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine place_particles_lattice(THIS, central_density, xmin, xmax, ymin, ymax, zmin, zmax, npart_des, npart_out, stretch, thres, pos, pvol, get_density, validate_position) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: central_density Maximum baryon mass density of the system double precision, intent(in) :: xmin Left x boundary of the lattice double precision, intent(in) :: xmax Right x boundary of the lattice double precision, intent(in) :: ymin Left y boundary of the lattice double precision, intent(in) :: ymax Right y boundary of the lattice double precision, intent(in) :: zmin Left z boundary of the lattice double precision, intent(in) :: zmax Right z boundary of the lattice integer, intent(in) :: npart_des Desired particle number integer, intent(out) :: npart_out Real, output particle number double precision, intent(in) :: stretch Stretching factor fo the lattice. xmin to zmax are multiplied by it double precision, intent(in) :: thres (~rho_max)/thres is the minimum mass density considered\nwhen placing particles. Used only when redistribute_nu is\n.FALSE. . When redistribute_nu is .TRUE. thres= 100*nu_ratio double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes\nArray storing the final particle volumes function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise Description Places particles on a lattice containing a physical object","tags":"","loc":"interface/place_particles_lattice.html"},{"title":"place_particles_spherical_surfaces – SPHINCS_LORENE","text":"interface Calls interface~~place_particles_spherical_surfaces~~CallsGraph interface~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces proc~place_surfaces place_surfaces proc~place_particles_spherical_surfaces->proc~place_surfaces proc~print_mass_profile_surface_radii print_mass_profile_surface_radii proc~place_particles_spherical_surfaces->proc~print_mass_profile_surface_radii proc~particle_volume particle_volume proc~place_particles_spherical_surfaces->proc~particle_volume proc~reallocate_array_1d reallocate_array_1d proc~place_particles_spherical_surfaces->proc~reallocate_array_1d proc~compute_colatitudes_uniformly_in compute_colatitudes_uniformly_in proc~place_particles_spherical_surfaces->proc~compute_colatitudes_uniformly_in proc~number_surfaces number_surfaces proc~place_particles_spherical_surfaces->proc~number_surfaces proc~reallocate_array_2d reallocate_array_2d proc~place_particles_spherical_surfaces->proc~reallocate_array_2d proc~assign_surfaces_mass assign_surfaces_mass proc~place_particles_spherical_surfaces->proc~assign_surfaces_mass none~validate_position_final~2 validate_position_final proc~place_particles_spherical_surfaces->none~validate_position_final~2 validate_position validate_position none~validate_position_final~2->validate_position var paninterfaceplace_particles_spherical_surfacesCallsGraph = svgPanZoom('#interfaceplace_particles_spherical_surfacesCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine place_particles_spherical_surfaces(THIS, mass_star, radius, center, central_density, npart_approx, npart_out, pos, pvol, pmass, last_r, upper_bound, lower_bound, upper_factor, lower_factor, max_steps, filename_mass_profile, filename_shells_radii, filename_shells_pos, get_density, integrate_density, get_id, validate_position) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: mass_star Baryonic mass of the star double precision, intent(in) :: radius Radius of the star in the x direction towards the companion double precision, intent(in) :: center (x|) coordinate of the center of the star, i.e.,\n of the point with highest density double precision, intent(in) :: central_density Central density of the star, i.e., highest density integer, intent(in) :: npart_approx idbase object needed to access the BNS data Todo Remove the idbase argument as done in SUBROUTINE perform_apm\nCLASS(idbase),       INTENT( IN OUT ):: id\n Approximate particle number on the star integer, intent(out) :: npart_out Final number of particles on the star double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos Array string the final positions double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pmass Array storing the final particle masses double precision, intent(in) :: last_r Radius of the last spherical surface double precision, intent(inout) :: upper_bound Desired upper bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(inout) :: lower_bound Desired lower bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(in) :: upper_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. upper_factor >= 1, usually an increase of 1% works double precision, intent(in) :: lower_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. lower_factor <= 1, usually a decrease of 1% works integer, intent(in) :: max_steps If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. max_steps >= 10. 100 is a nice value character(len=*), intent(inout), optional :: filename_mass_profile Name of the file to store the radial mass profile character(len=*), intent(inout), optional :: filename_shells_radii Name of the file to store the surface radii Todo change name of variable to filename_surfaces_radii character(len=*), intent(inout), optional :: filename_shells_pos Name of the file to store the final particle positions Todo change name of variable to filename_surfaces_pos function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine integrate_density(center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order subroutine get_id(x, y, z, g_xx, baryon_density, gamma_euler) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise Description Places particles on spherical surfaces on one star","tags":"","loc":"interface/place_particles_spherical_surfaces.html"},{"title":"print_formatted_lorene_id_particles – SPHINCS_LORENE","text":"interface Calls interface~~print_formatted_lorene_id_particles~~CallsGraph interface~print_formatted_lorene_id_particles print_formatted_lorene_id_particles proc~print_formatted_lorene_id_particles print_formatted_lorene_id_particles interface~print_formatted_lorene_id_particles->proc~print_formatted_lorene_id_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine print_formatted_lorene_id_particles(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted output file Description Prints the SPH ID to a formatted file","tags":"","loc":"interface/print_formatted_lorene_id_particles.html"},{"title":"read_compose_composition – SPHINCS_LORENE","text":"interface Calls interface~~read_compose_composition~~CallsGraph interface~read_compose_composition read_compose_composition proc~read_compose_composition read_compose_composition interface~read_compose_composition->proc~read_compose_composition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine read_compose_composition(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile To read the file great_eos.beta in directory compose_path/GREAT_EoS,\n namefile=\"GREAT_EoS/great_eos\" Description Reads the Y_e(n_b) table in the CompOSE file with extension .beta","tags":"","loc":"interface/read_compose_composition.html"},{"title":"read_sphincs_dump_print_formatted – SPHINCS_LORENE","text":"interface Calls interface~~read_sphincs_dump_print_formatted~~CallsGraph interface~read_sphincs_dump_print_formatted read_sphincs_dump_print_formatted proc~read_sphincs_dump_print_formatted read_sphincs_dump_print_formatted interface~read_sphincs_dump_print_formatted->proc~read_sphincs_dump_print_formatted vel_u vel_u proc~read_sphincs_dump_print_formatted->vel_u nu nu proc~read_sphincs_dump_print_formatted->nu pr pr proc~read_sphincs_dump_print_formatted->pr allocate_metric_on_particles allocate_metric_on_particles proc~read_sphincs_dump_print_formatted->allocate_metric_on_particles temp temp proc~read_sphincs_dump_print_formatted->temp theta theta proc~read_sphincs_dump_print_formatted->theta ye ye proc~read_sphincs_dump_print_formatted->ye deallocate_metric_on_particles deallocate_metric_on_particles proc~read_sphincs_dump_print_formatted->deallocate_metric_on_particles h h proc~read_sphincs_dump_print_formatted->h u u proc~read_sphincs_dump_print_formatted->u av av proc~read_sphincs_dump_print_formatted->av allocate_sph_memory allocate_sph_memory proc~read_sphincs_dump_print_formatted->allocate_sph_memory deallocate_sph_memory deallocate_sph_memory proc~read_sphincs_dump_print_formatted->deallocate_sph_memory pos_u pos_u proc~read_sphincs_dump_print_formatted->pos_u nlrf nlrf proc~read_sphincs_dump_print_formatted->nlrf set_units set_units proc~read_sphincs_dump_print_formatted->set_units divv divv proc~read_sphincs_dump_print_formatted->divv read_sphincs_dump read_sphincs_dump proc~read_sphincs_dump_print_formatted->read_sphincs_dump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine read_sphincs_dump_print_formatted(THIS, namefile_bin, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile_bin Name of the binary file to be read character(len=*), intent(inout), optional :: namefile Name of the formatted file to be printed Description Reads the binary ID file printed by compute_and_export_SPH_variables and prints the data stored in it to a formatted file","tags":"","loc":"interface/read_sphincs_dump_print_formatted.html"},{"title":"correct_center_of_mass – SPHINCS_LORENE","text":"subroutine correct_center_of_mass(npart_real, pos, nu, get_density, validate_pos, com_star, verbose) Uses analyze proc~~correct_center_of_mass~~UsesGraph proc~correct_center_of_mass correct_center_of_mass analyze analyze proc~correct_center_of_mass->analyze Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Translate the particles so that their center of mass\n  coincides with the center of mass of the star, given by\n  LORENE FT 1.09.2021 Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real double precision, intent(inout), DIMENSION(3,npart_real) :: pos double precision, intent(inout), DIMENSION(npart_real) :: nu function get_density(x, y, z) result(density) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z Return Value double precision function validate_pos(x, y, z) result(answer) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z Return Value integer double precision, intent(in) :: com_star logical, intent(in), optional :: verbose Calls proc~~correct_center_of_mass~~CallsGraph proc~correct_center_of_mass correct_center_of_mass com com proc~correct_center_of_mass->com Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~correct_center_of_mass~~CalledByGraph proc~correct_center_of_mass correct_center_of_mass proc~perform_apm perform_apm proc~perform_apm->proc~correct_center_of_mass interface~perform_apm perform_apm interface~perform_apm->proc~perform_apm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a com_d com_x com_y com_z pos_corr_tmp Source Code correct_center_of_mass Variables Type Visibility Attributes Name Initial integer, private :: a double precision, private :: com_d double precision, private :: com_x double precision, private :: com_y double precision, private :: com_z double precision, private, DIMENSION(3) :: pos_corr_tmp Source Code SUBROUTINE correct_center_of_mass ( npart_real , pos , nu , get_density , & validate_pos , com_star , verbose ) !*********************************************************** ! !# Translate the particles so that their center of mass !  coincides with the center of mass of the star, given by !  LORENE ! !  FT 1.09.2021 ! !*********************************************************** USE analyze , ONLY : COM IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart_real DOUBLE PRECISION , INTENT ( IN ) :: com_star LOGICAL , INTENT ( IN ), OPTIONAL :: verbose !TYPE(bns), INTENT(IN):: binary INTERFACE FUNCTION get_density ( x , y , z ) RESULT ( density ) DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z DOUBLE PRECISION :: density END FUNCTION END INTERFACE INTERFACE FUNCTION validate_pos ( x , y , z ) RESULT ( answer ) DOUBLE PRECISION , INTENT ( IN ) :: x DOUBLE PRECISION , INTENT ( IN ) :: y DOUBLE PRECISION , INTENT ( IN ) :: z INTEGER :: answer END FUNCTION END INTERFACE DOUBLE PRECISION , DIMENSION ( 3 , npart_real ), INTENT ( INOUT ) :: pos DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( INOUT ) :: nu INTEGER :: a DOUBLE PRECISION :: com_x , com_y , com_z , com_d DOUBLE PRECISION , DIMENSION ( 3 ) :: pos_corr_tmp CALL COM ( npart_real , pos , nu , & ! input com_x , com_y , com_z , com_d ) ! output IF ( PRESENT ( verbose ) . AND . verbose . EQV . . TRUE . ) THEN PRINT * , \"** Before center of mass correction:\" PRINT * , \" * x coordinate of the center of mass of the star, \" , & \"from LORENE: com_star= \" , com_star , \"Msun_geo\" PRINT * , \" * x coordinate of the center of mass of the particle \" , & \"distribution: com_x= \" , com_x , \"Msun_geo\" PRINT * , \" * y coordinate of the center of mass of the particle \" , & \"distribution: com_y= \" , com_y , \"Msun_geo\" PRINT * , \" * z coordinate of the center of mass of the particle \" , & \"distribution: com_z= \" , com_z , \"Msun_geo\" PRINT * , \" * Distance of the center of mass of the particle \" , & \"distribution from the  origin: com_d= \" , com_d PRINT * , \" * |com_x-com_star/com_star|=\" , & ABS ( com_x - com_star ) / ABS ( com_star + 1 ) PRINT * ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, com_star, & !$OMP                     com_x, com_y, com_z, npart_real ) & !$OMP             PRIVATE( pos_corr_tmp, a ) DO a = 1 , npart_real , 1 pos_corr_tmp ( 1 ) = pos ( 1 , a ) - ( com_x - com_star ) pos_corr_tmp ( 2 ) = pos ( 2 , a ) - com_y pos_corr_tmp ( 3 ) = pos ( 3 , a ) - com_z IF ( get_density ( & pos_corr_tmp ( 1 ), pos_corr_tmp ( 2 ), pos_corr_tmp ( 3 ) ) > 0.0D0 & . AND . & !binary% is_hydro_negative( & validate_pos ( & pos_corr_tmp ( 1 ), pos_corr_tmp ( 2 ), pos_corr_tmp ( 3 ) ) == 0 & ) THEN pos (:, a ) = pos_corr_tmp ENDIF ENDDO !$OMP END PARALLEL DO CALL COM ( npart_real , pos , nu , & ! input com_x , com_y , com_z , com_d ) ! output IF ( PRESENT ( verbose ) . AND . verbose . EQV . . TRUE . ) THEN PRINT * , \"** After center of mass correction:\" PRINT * , \" * x coordinate of the center of mass of the star, \" , & \"from LORENE: com_star= \" , com_star , \"Msun_geo\" PRINT * , \" * x coordinate of the center of mass of the particle \" , & \"distribution: com_x= \" , com_x , \"Msun_geo\" PRINT * , \" * y coordinate of the center of mass of the particle \" , & \"distribution: com_y= \" , com_y , \"Msun_geo\" PRINT * , \" * z coordinate of the center of mass of the particle \" , & \"distribution: com_z= \" , com_z , \"Msun_geo\" PRINT * , \" * Distance of the center of mass of the particle \" , & \"distribution from the  origin: com_d= \" , com_d PRINT * , \" * |com_x-com_star/com_star|=\" , & ABS ( com_x - com_star ) / ABS ( com_star + 1 ) PRINT * ENDIF END SUBROUTINE correct_center_of_mass","tags":"","loc":"proc/correct_center_of_mass.html"},{"title":"get_neighbours_bf – SPHINCS_LORENE","text":"subroutine get_neighbours_bf(ipart, npart, pos, h, dimensions, nnei, neilist) just for test purposes: get neighbours of particle ipart in\n  a \"brute force\" way; ipart is ALSO on the neighbour list;\n  SKR 8.2.2010 Removed ipart from its own neighbors' list\n  FT 04.06.2021 Arguments Type Intent Optional Attributes Name integer, intent(in) :: ipart integer, intent(in) :: npart double precision, intent(in) :: pos (dimensions,npart) double precision, intent(in) :: h (npart) integer, intent(in) :: dimensions integer, intent(out) :: nnei integer, intent(out) :: neilist (npart) Contents Variables a d2 diff r_int2 Source Code get_neighbours_bf Variables Type Visibility Attributes Name Initial integer, private :: a double precision, private :: d2 double precision, private :: diff (dimensions) double precision, private :: r_int2 Source Code SUBROUTINE get_neighbours_bf ( ipart , npart , pos , h , dimensions , nnei , neilist ) !************************************************************** ! !# just for test purposes: get neighbours of particle ipart in !  a \"brute force\" way; ipart is ALSO on the neighbour list; !  SKR 8.2.2010 ! !  Removed ipart from its own neighbors' list !  FT 04.06.2021 ! !************************************************************** IMPLICIT NONE INTEGER , INTENT ( IN ) :: ipart , npart , dimensions DOUBLE PRECISION , INTENT ( IN ) :: pos ( dimensions , npart ), h ( npart ) INTEGER , INTENT ( OUT ) :: nnei , neilist ( npart ) INTEGER a DOUBLE PRECISION diff ( dimensions ), d2 , r_int2 ! square of interaction radius r_int2 = ( 2.0D0 * h ( ipart )) ** 2 nnei = 0 !$OMP PARALLEL DO SHARED(pos,dimensions,ipart,npart,r_int2,nnei,neilist)& !$OMP             PRIVATE(a,diff,d2) DO a = 1 , npart , 1 IF ( a /= ipart ) THEN diff = pos ( 1 : dimensions , a ) - pos ( 1 : dimensions , ipart ) d2 = DOT_PRODUCT ( diff , diff ) ! neighbour? IF ( d2 < r_int2 ) THEN nnei = nnei + 1 neilist ( nnei ) = a ENDIF ENDIF ENDDO !$OMP END PARALLEL DO END SUBROUTINE get_neighbours_bf","tags":"","loc":"proc/get_neighbours_bf.html"},{"title":"impose_equatorial_plane_symmetry – SPHINCS_LORENE","text":"subroutine impose_equatorial_plane_symmetry(npart_real, pos, nu, com_star, verbose) Uses analyze proc~~impose_equatorial_plane_symmetry~~UsesGraph proc~impose_equatorial_plane_symmetry impose_equatorial_plane_symmetry analyze analyze proc~impose_equatorial_plane_symmetry->analyze Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Mirror the particle with z>0 with respect to the xy plane,\n  to impose the equatorial-plane symmetry FT 1.09.2021 Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real double precision, intent(inout), DIMENSION(3,npart_real) :: pos double precision, intent(inout), DIMENSION(npart_real) :: nu double precision, intent(in), optional :: com_star logical, intent(in), optional :: verbose Calls proc~~impose_equatorial_plane_symmetry~~CallsGraph proc~impose_equatorial_plane_symmetry impose_equatorial_plane_symmetry com com proc~impose_equatorial_plane_symmetry->com Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~impose_equatorial_plane_symmetry~~CalledByGraph proc~impose_equatorial_plane_symmetry impose_equatorial_plane_symmetry proc~perform_apm perform_apm proc~perform_apm->proc~impose_equatorial_plane_symmetry interface~perform_apm perform_apm interface~perform_apm->proc~perform_apm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a com_d com_x com_y com_z itr npart_real_half nu_tmp pos_tmp Source Code impose_equatorial_plane_symmetry Variables Type Visibility Attributes Name Initial integer, private :: a double precision, private :: com_d double precision, private :: com_x double precision, private :: com_y double precision, private :: com_z integer, private :: itr integer, private :: npart_real_half double precision, private, DIMENSION(npart_real) :: nu_tmp double precision, private, DIMENSION(3,npart_real) :: pos_tmp Source Code SUBROUTINE impose_equatorial_plane_symmetry ( npart_real , pos , nu , com_star , & verbose ) !************************************************************* ! !# Mirror the particle with z>0 with respect to the xy plane, !  to impose the equatorial-plane symmetry ! !  FT 1.09.2021 ! !************************************************************* USE analyze , ONLY : COM IMPLICIT NONE INTEGER , INTENT ( IN ) :: npart_real DOUBLE PRECISION , INTENT ( IN ), OPTIONAL :: com_star LOGICAL , INTENT ( IN ), OPTIONAL :: verbose DOUBLE PRECISION , DIMENSION ( 3 , npart_real ), INTENT ( INOUT ) :: pos DOUBLE PRECISION , DIMENSION ( npart_real ), INTENT ( INOUT ) :: nu INTEGER :: a , itr , npart_real_half DOUBLE PRECISION :: com_x , com_y , com_z , com_d DOUBLE PRECISION , DIMENSION ( 3 , npart_real ) :: pos_tmp DOUBLE PRECISION , DIMENSION ( npart_real ) :: nu_tmp pos_tmp = pos nu_tmp = nu itr = 0 DO a = 1 , npart_real , 1 IF ( pos_tmp ( 3 , a ) > 0.0D0 & . AND . & itr < npart_real / 2 ) THEN itr = itr + 1 pos ( 1 , itr ) = pos_tmp ( 1 , a ) pos ( 2 , itr ) = pos_tmp ( 2 , a ) pos ( 3 , itr ) = pos_tmp ( 3 , a ) nu ( itr ) = nu_tmp ( a ) ENDIF ENDDO npart_real_half = itr ! If some of the particles crossed the xy plane top-down in the ! last step, replace them with their previous position ! above the xy plane !   IF( npart_real_half < npart_real/2 )THEN ! !     npart_missing= npart_real/2 - npart_real_half ! !     DO a= npart_real_half + 1, npart_real/2, 1 ! !       pos( :, a )= all_pos_tmp2( :, a ) ! !     ENDDO ! !   ENDIF !$OMP PARALLEL DO DEFAULT( NONE ) & !$OMP             SHARED( pos, npart_real_half, nu ) & !$OMP             PRIVATE( a ) DO a = 1 , npart_real_half , 1 pos ( 1 , npart_real_half + a ) = pos ( 1 , a ) pos ( 2 , npart_real_half + a ) = pos ( 2 , a ) pos ( 3 , npart_real_half + a ) = - pos ( 3 , a ) nu ( npart_real_half + a ) = nu ( a ) ENDDO !$OMP END PARALLEL DO IF ( PRESENT ( verbose ) . AND . verbose . EQV . . TRUE . ) THEN CALL COM ( npart_real , pos , nu , & ! input com_x , com_y , com_z , com_d ) ! output PRINT * , \"** After mirroring particles:\" IF ( PRESENT ( com_star ) ) PRINT * , & \" * x coordinate of the center of mass of the star, \" , & \"from LORENE: com_star= \" , com_star , \"Msun_geo\" PRINT * , \" * x coordinate of the center of mass of the particle \" , & \"distribution: com_x= \" , com_x , \"Msun_geo\" PRINT * , \" * y coordinate of the center of mass of the particle \" , & \"distribution: com_y= \" , com_y , \"Msun_geo\" PRINT * , \" * z coordinate of the center of mass of the particle \" , & \"distribution: com_z= \" , com_z , \"Msun_geo\" PRINT * , \" * Distance of the center of mass of the particle \" , & \"distribution from the  origin: com_d= \" , com_d IF ( PRESENT ( com_star ) ) PRINT * , \" * |com_x-com_star/com_star|=\" , & ABS ( com_x - com_star ) / ABS ( com_star + 1 ) PRINT * ENDIF END SUBROUTINE impose_equatorial_plane_symmetry","tags":"","loc":"proc/impose_equatorial_plane_symmetry.html"},{"title":"check_i_matter – SPHINCS_LORENE","text":"interface Calls interface~~check_i_matter~~CallsGraph interface~check_i_matter check_i_matter proc~check_i_matter check_i_matter interface~check_i_matter->proc~check_i_matter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine check_i_matter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked Description Checks that the given index i_matter is between 1 and n_matter , included. If not, it stops the execution of the\n program.","tags":"","loc":"interface/check_i_matter.html"},{"title":"get_n_matter – SPHINCS_LORENE","text":"interface Calls interface~~get_n_matter~~CallsGraph interface~get_n_matter get_n_matter proc~get_n_matter get_n_matter interface~get_n_matter->proc~get_n_matter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_n_matter(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the Description Returns n_matter , the number of matter objects in the\n physical system","tags":"","loc":"interface/get_n_matter.html"},{"title":"get_one_lapse – SPHINCS_LORENE","text":"interface Calls interface~~get_one_lapse~~CallsGraph interface~get_one_lapse get_one_lapse proc~get_one_lapse get_one_lapse interface~get_one_lapse->proc~get_one_lapse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_one_lapse(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the Description Returns n_matter , the number of matter objects in the\n physical system","tags":"","loc":"interface/get_one_lapse.html"},{"title":"get_total_spatial_extent – SPHINCS_LORENE","text":"interface Calls interface~~get_total_spatial_extent~~CallsGraph interface~get_total_spatial_extent get_total_spatial_extent proc~get_total_spatial_extent get_total_spatial_extent interface~get_total_spatial_extent->proc~get_total_spatial_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_total_spatial_extent(THIS) result(box) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. Description INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system.","tags":"","loc":"interface/get_total_spatial_extent.html"},{"title":"get_zero_shift – SPHINCS_LORENE","text":"interface Calls interface~~get_zero_shift~~CallsGraph interface~get_zero_shift get_zero_shift proc~get_zero_shift get_zero_shift interface~get_zero_shift->proc~get_zero_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_zero_shift(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the Description Returns n_matter , the number of matter objects in the\n physical system","tags":"","loc":"interface/get_zero_shift.html"},{"title":"integrate_baryon_mass_density – SPHINCS_LORENE","text":"interface Calls interface~~integrate_baryon_mass_density~~CallsGraph interface~integrate_baryon_mass_density integrate_baryon_mass_density proc~integrate_baryon_mass_density integrate_baryon_mass_density interface~integrate_baryon_mass_density->proc~integrate_baryon_mass_density indexx indexx proc~integrate_baryon_mass_density->indexx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order Description INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star.","tags":"","loc":"interface/integrate_baryon_mass_density.html"},{"title":"set_n_matter – SPHINCS_LORENE","text":"interface Calls interface~~set_n_matter~~CallsGraph interface~set_n_matter set_n_matter proc~set_n_matter set_n_matter interface~set_n_matter->proc~set_n_matter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine set_n_matter(THIS, value) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to Description Sets n_matter , the number of matter objects in the\n physical system, to the given value","tags":"","loc":"interface/set_n_matter.html"},{"title":"set_one_lapse – SPHINCS_LORENE","text":"interface Calls interface~~set_one_lapse~~CallsGraph interface~set_one_lapse set_one_lapse proc~set_one_lapse set_one_lapse interface~set_one_lapse->proc~set_one_lapse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine set_one_lapse(THIS, logic) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to Description Sets n_matter , the number of matter objects in the\n physical system, to the given value","tags":"","loc":"interface/set_one_lapse.html"},{"title":"set_zero_shift – SPHINCS_LORENE","text":"interface Calls interface~~set_zero_shift~~CallsGraph interface~set_zero_shift set_zero_shift proc~set_zero_shift set_zero_shift interface~set_zero_shift->proc~set_zero_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine set_zero_shift(THIS, logic) Implementation → Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to Description Sets n_matter , the number of matter objects in the\n physical system, to the given value","tags":"","loc":"interface/set_zero_shift.html"},{"title":"get_adm_mass – SPHINCS_LORENE","text":"interface Calls interface~~get_adm_mass~~CallsGraph interface~get_adm_mass get_adm_mass proc~get_adm_mass get_adm_mass interface~get_adm_mass->proc~get_adm_mass Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_adm_mass(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_adm_mass.html"},{"title":"get_angular_momentum – SPHINCS_LORENE","text":"interface Calls interface~~get_angular_momentum~~CallsGraph interface~get_angular_momentum get_angular_momentum proc~get_angular_momentum get_angular_momentum interface~get_angular_momentum->proc~get_angular_momentum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_angular_momentum.html"},{"title":"get_angular_vel – SPHINCS_LORENE","text":"interface Calls interface~~get_angular_vel~~CallsGraph interface~get_angular_vel get_angular_vel proc~get_angular_vel get_angular_vel interface~get_angular_vel->proc~get_angular_vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_angular_vel(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Description Returns angular_vel","tags":"","loc":"interface/get_angular_vel.html"},{"title":"get_barycenter – SPHINCS_LORENE","text":"interface Calls interface~~get_barycenter~~CallsGraph interface~get_barycenter get_barycenter proc~get_barycenter get_barycenter interface~get_barycenter->proc~get_barycenter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3)","tags":"","loc":"interface/get_barycenter.html"},{"title":"get_barycenter1_x – SPHINCS_LORENE","text":"interface Calls interface~~get_barycenter1_x~~CallsGraph interface~get_barycenter1_x get_barycenter1_x proc~get_barycenter1_x get_barycenter1_x interface~get_barycenter1_x->proc~get_barycenter1_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_barycenter1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_barycenter1_x.html"},{"title":"get_barycenter2_x – SPHINCS_LORENE","text":"interface Calls interface~~get_barycenter2_x~~CallsGraph interface~get_barycenter2_x get_barycenter2_x proc~get_barycenter2_x get_barycenter2_x interface~get_barycenter2_x->proc~get_barycenter2_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_barycenter2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_barycenter2_x.html"},{"title":"get_center – SPHINCS_LORENE","text":"interface Calls interface~~get_center~~CallsGraph interface~get_center get_center proc~get_center get_center interface~get_center->proc~get_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3)","tags":"","loc":"interface/get_center.html"},{"title":"get_center1_x – SPHINCS_LORENE","text":"interface Calls interface~~get_center1_x~~CallsGraph interface~get_center1_x get_center1_x proc~get_center1_x get_center1_x interface~get_center1_x->proc~get_center1_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_center1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_center1_x.html"},{"title":"get_center2_x – SPHINCS_LORENE","text":"interface Calls interface~~get_center2_x~~CallsGraph interface~get_center2_x get_center2_x proc~get_center2_x get_center2_x interface~get_center2_x->proc~get_center2_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_center2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_center2_x.html"},{"title":"get_distance – SPHINCS_LORENE","text":"interface Calls interface~~get_distance~~CallsGraph interface~get_distance get_distance proc~get_distance get_distance interface~get_distance->proc~get_distance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_distance(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_distance.html"},{"title":"get_distance_com – SPHINCS_LORENE","text":"interface Calls interface~~get_distance_com~~CallsGraph interface~get_distance_com get_distance_com proc~get_distance_com get_distance_com interface~get_distance_com->proc~get_distance_com Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_distance_com(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_distance_com.html"},{"title":"get_energy_density_center1 – SPHINCS_LORENE","text":"interface Calls interface~~get_energy_density_center1~~CallsGraph interface~get_energy_density_center1 get_energy_density_center1 proc~get_energy_density_center1 get_energy_density_center1 interface~get_energy_density_center1->proc~get_energy_density_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_energy_density_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_energy_density_center1.html"},{"title":"get_energy_density_center2 – SPHINCS_LORENE","text":"interface Calls interface~~get_energy_density_center2~~CallsGraph interface~get_energy_density_center2 get_energy_density_center2 proc~get_energy_density_center2 get_energy_density_center2 interface~get_energy_density_center2->proc~get_energy_density_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_energy_density_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_energy_density_center2.html"},{"title":"get_ent_center1 – SPHINCS_LORENE","text":"interface Calls interface~~get_ent_center1~~CallsGraph interface~get_ent_center1 get_ent_center1 proc~get_ent_center1 get_ent_center1 interface~get_ent_center1->proc~get_ent_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_ent_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_ent_center1.html"},{"title":"get_ent_center2 – SPHINCS_LORENE","text":"interface Calls interface~~get_ent_center2~~CallsGraph interface~get_ent_center2 get_ent_center2 proc~get_ent_center2 get_ent_center2 interface~get_ent_center2->proc~get_ent_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_ent_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_ent_center2.html"},{"title":"get_eos – SPHINCS_LORENE","text":"interface Calls interface~~get_eos~~CallsGraph interface~get_eos get_eos proc~get_eos get_eos interface~get_eos->proc~get_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE","tags":"","loc":"interface/get_eos.html"},{"title":"get_eos1 – SPHINCS_LORENE","text":"interface Calls interface~~get_eos1~~CallsGraph interface~get_eos1 get_eos1 proc~get_eos1 get_eos1 interface~get_eos1->proc~get_eos1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_eos1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE","tags":"","loc":"interface/get_eos1.html"},{"title":"get_eos2 – SPHINCS_LORENE","text":"interface Calls interface~~get_eos2~~CallsGraph interface~get_eos2 get_eos2 proc~get_eos2 get_eos2 interface~get_eos2->proc~get_eos2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_eos2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE","tags":"","loc":"interface/get_eos2.html"},{"title":"get_gamma0_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma0_1~~CallsGraph interface~get_gamma0_1 get_gamma0_1 proc~get_gamma0_1 get_gamma0_1 interface~get_gamma0_1->proc~get_gamma0_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma0_1.html"},{"title":"get_gamma0_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma0_2~~CallsGraph interface~get_gamma0_2 get_gamma0_2 proc~get_gamma0_2 get_gamma0_2 interface~get_gamma0_2->proc~get_gamma0_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma0_2.html"},{"title":"get_gamma1_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma1_1~~CallsGraph interface~get_gamma1_1 get_gamma1_1 proc~get_gamma1_1 get_gamma1_1 interface~get_gamma1_1->proc~get_gamma1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma1_1.html"},{"title":"get_gamma1_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma1_2~~CallsGraph interface~get_gamma1_2 get_gamma1_2 proc~get_gamma1_2 get_gamma1_2 interface~get_gamma1_2->proc~get_gamma1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma1_2.html"},{"title":"get_gamma2_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma2_1~~CallsGraph interface~get_gamma2_1 get_gamma2_1 proc~get_gamma2_1 get_gamma2_1 interface~get_gamma2_1->proc~get_gamma2_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma2_1.html"},{"title":"get_gamma2_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma2_2~~CallsGraph interface~get_gamma2_2 get_gamma2_2 proc~get_gamma2_2 get_gamma2_2 interface~get_gamma2_2->proc~get_gamma2_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma2_2.html"},{"title":"get_gamma3_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma3_1~~CallsGraph interface~get_gamma3_1 get_gamma3_1 proc~get_gamma3_1 get_gamma3_1 interface~get_gamma3_1->proc~get_gamma3_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma3_1.html"},{"title":"get_gamma3_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma3_2~~CallsGraph interface~get_gamma3_2 get_gamma3_2 proc~get_gamma3_2 get_gamma3_2 interface~get_gamma3_2->proc~get_gamma3_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma3_2.html"},{"title":"get_gamma_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma_1~~CallsGraph interface~get_gamma_1 get_gamma_1 proc~get_gamma_1 get_gamma_1 interface~get_gamma_1->proc~get_gamma_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma_1.html"},{"title":"get_gamma_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma_2~~CallsGraph interface~get_gamma_2 get_gamma_2 proc~get_gamma_2 get_gamma_2 interface~get_gamma_2->proc~get_gamma_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma_2.html"},{"title":"get_grav_mass1 – SPHINCS_LORENE","text":"interface Calls interface~~get_grav_mass1~~CallsGraph interface~get_grav_mass1 get_grav_mass1 proc~get_grav_mass1 get_grav_mass1 interface~get_grav_mass1->proc~get_grav_mass1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_grav_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_grav_mass1.html"},{"title":"get_grav_mass2 – SPHINCS_LORENE","text":"interface Calls interface~~get_grav_mass2~~CallsGraph interface~get_grav_mass2 get_grav_mass2 proc~get_grav_mass2 get_grav_mass2 interface~get_grav_mass2->proc~get_grav_mass2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_grav_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_grav_mass2.html"},{"title":"get_kappa0_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa0_1~~CallsGraph interface~get_kappa0_1 get_kappa0_1 proc~get_kappa0_1 get_kappa0_1 interface~get_kappa0_1->proc~get_kappa0_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa0_1.html"},{"title":"get_kappa0_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa0_2~~CallsGraph interface~get_kappa0_2 get_kappa0_2 proc~get_kappa0_2 get_kappa0_2 interface~get_kappa0_2->proc~get_kappa0_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa0_2.html"},{"title":"get_kappa1_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa1_1~~CallsGraph interface~get_kappa1_1 get_kappa1_1 proc~get_kappa1_1 get_kappa1_1 interface~get_kappa1_1->proc~get_kappa1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa1_1.html"},{"title":"get_kappa1_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa1_2~~CallsGraph interface~get_kappa1_2 get_kappa1_2 proc~get_kappa1_2 get_kappa1_2 interface~get_kappa1_2->proc~get_kappa1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa1_2.html"},{"title":"get_kappa2_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa2_1~~CallsGraph interface~get_kappa2_1 get_kappa2_1 proc~get_kappa2_1 get_kappa2_1 interface~get_kappa2_1->proc~get_kappa2_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa2_1.html"},{"title":"get_kappa2_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa2_2~~CallsGraph interface~get_kappa2_2 get_kappa2_2 proc~get_kappa2_2 get_kappa2_2 interface~get_kappa2_2->proc~get_kappa2_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa2_2.html"},{"title":"get_kappa3_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa3_1~~CallsGraph interface~get_kappa3_1 get_kappa3_1 proc~get_kappa3_1 get_kappa3_1 interface~get_kappa3_1->proc~get_kappa3_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa3_1.html"},{"title":"get_kappa3_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa3_2~~CallsGraph interface~get_kappa3_2 get_kappa3_2 proc~get_kappa3_2 get_kappa3_2 interface~get_kappa3_2->proc~get_kappa3_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa3_2.html"},{"title":"get_kappa_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa_1~~CallsGraph interface~get_kappa_1 get_kappa_1 proc~get_kappa_1 get_kappa_1 interface~get_kappa_1->proc~get_kappa_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa_1.html"},{"title":"get_kappa_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa_2~~CallsGraph interface~get_kappa_2 get_kappa_2 proc~get_kappa_2 get_kappa_2 interface~get_kappa_2->proc~get_kappa_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa_2.html"},{"title":"get_logP1_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_logp1_1~~CallsGraph interface~get_logp1_1 get_logP1_1 proc~get_logp1_1 get_logp1_1 interface~get_logp1_1->proc~get_logp1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logP1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logp1_1.html"},{"title":"get_logP1_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_logp1_2~~CallsGraph interface~get_logp1_2 get_logP1_2 proc~get_logp1_2 get_logp1_2 interface~get_logp1_2->proc~get_logp1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logP1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logp1_2.html"},{"title":"get_logRho0_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho0_1~~CallsGraph interface~get_logrho0_1 get_logRho0_1 proc~get_logrho0_1 get_logRho0_1 interface~get_logrho0_1->proc~get_logrho0_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho0_1.html"},{"title":"get_logRho0_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho0_2~~CallsGraph interface~get_logrho0_2 get_logRho0_2 proc~get_logrho0_2 get_logRho0_2 interface~get_logrho0_2->proc~get_logrho0_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho0_2.html"},{"title":"get_logRho1_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho1_1~~CallsGraph interface~get_logrho1_1 get_logRho1_1 proc~get_logrho1_1 get_logRho1_1 interface~get_logrho1_1->proc~get_logrho1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho1_1.html"},{"title":"get_logRho1_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho1_2~~CallsGraph interface~get_logrho1_2 get_logRho1_2 proc~get_logrho1_2 get_logRho1_2 interface~get_logrho1_2->proc~get_logrho1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho1_2.html"},{"title":"get_logRho2_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho2_1~~CallsGraph interface~get_logrho2_1 get_logRho2_1 proc~get_logrho2_1 get_logRho2_1 interface~get_logrho2_1->proc~get_logrho2_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho2_1.html"},{"title":"get_logRho2_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho2_2~~CallsGraph interface~get_logrho2_2 get_logRho2_2 proc~get_logrho2_2 get_logRho2_2 interface~get_logrho2_2->proc~get_logrho2_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho2_2.html"},{"title":"get_mass – SPHINCS_LORENE","text":"interface Calls interface~~get_mass~2~~CallsGraph interface~get_mass~2 get_mass proc~get_mass get_mass interface~get_mass~2->proc~get_mass Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_mass(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision","tags":"","loc":"interface/get_mass~2.html"},{"title":"get_mass1 – SPHINCS_LORENE","text":"interface Calls interface~~get_mass1~~CallsGraph interface~get_mass1 get_mass1 proc~get_mass1 get_mass1 interface~get_mass1->proc~get_mass1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_mass1.html"},{"title":"get_mass2 – SPHINCS_LORENE","text":"interface Calls interface~~get_mass2~~CallsGraph interface~get_mass2 get_mass2 proc~get_mass2 get_mass2 interface~get_mass2->proc~get_mass2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_mass2.html"},{"title":"get_nbar_center1 – SPHINCS_LORENE","text":"interface Calls interface~~get_nbar_center1~~CallsGraph interface~get_nbar_center1 get_nbar_center1 proc~get_nbar_center1 get_nbar_center1 interface~get_nbar_center1->proc~get_nbar_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nbar_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_nbar_center1.html"},{"title":"get_nbar_center2 – SPHINCS_LORENE","text":"interface Calls interface~~get_nbar_center2~~CallsGraph interface~get_nbar_center2 get_nbar_center2 proc~get_nbar_center2 get_nbar_center2 interface~get_nbar_center2->proc~get_nbar_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nbar_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_nbar_center2.html"},{"title":"get_npeos_1 – SPHINCS_LORENE","text":"interface Calls interface~~get_npeos_1~~CallsGraph interface~get_npeos_1 get_npeos_1 proc~get_npeos_1 get_npeos_1 interface~get_npeos_1->proc~get_npeos_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_npeos_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_npeos_1.html"},{"title":"get_npeos_2 – SPHINCS_LORENE","text":"interface Calls interface~~get_npeos_2~~CallsGraph interface~get_npeos_2 get_npeos_2 proc~get_npeos_2 get_npeos_2 interface~get_npeos_2->proc~get_npeos_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_npeos_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_npeos_2.html"},{"title":"get_pressure_center1 – SPHINCS_LORENE","text":"interface Calls interface~~get_pressure_center1~~CallsGraph interface~get_pressure_center1 get_pressure_center1 proc~get_pressure_center1 get_pressure_center1 interface~get_pressure_center1->proc~get_pressure_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_pressure_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_pressure_center1.html"},{"title":"get_pressure_center2 – SPHINCS_LORENE","text":"interface Calls interface~~get_pressure_center2~~CallsGraph interface~get_pressure_center2 get_pressure_center2 proc~get_pressure_center2 get_pressure_center2 interface~get_pressure_center2->proc~get_pressure_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_pressure_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_pressure_center2.html"},{"title":"get_radii – SPHINCS_LORENE","text":"interface Calls interface~~get_radii~~CallsGraph interface~get_radii get_radii proc~get_radii get_radii interface~get_radii->proc~get_radii Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6)","tags":"","loc":"interface/get_radii.html"},{"title":"get_radius1_x_comp – SPHINCS_LORENE","text":"interface Calls interface~~get_radius1_x_comp~~CallsGraph interface~get_radius1_x_comp get_radius1_x_comp proc~get_radius1_x_comp get_radius1_x_comp interface~get_radius1_x_comp->proc~get_radius1_x_comp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius1_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius1_x_comp.html"},{"title":"get_radius1_x_opp – SPHINCS_LORENE","text":"interface Calls interface~~get_radius1_x_opp~~CallsGraph interface~get_radius1_x_opp get_radius1_x_opp proc~get_radius1_x_opp get_radius1_x_opp interface~get_radius1_x_opp->proc~get_radius1_x_opp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius1_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius1_x_opp.html"},{"title":"get_radius1_y – SPHINCS_LORENE","text":"interface Calls interface~~get_radius1_y~~CallsGraph interface~get_radius1_y get_radius1_y proc~get_radius1_y get_radius1_y interface~get_radius1_y->proc~get_radius1_y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius1_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius1_y.html"},{"title":"get_radius1_z – SPHINCS_LORENE","text":"interface Calls interface~~get_radius1_z~~CallsGraph interface~get_radius1_z get_radius1_z proc~get_radius1_z get_radius1_z interface~get_radius1_z->proc~get_radius1_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius1_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius1_z.html"},{"title":"get_radius2_x_comp – SPHINCS_LORENE","text":"interface Calls interface~~get_radius2_x_comp~~CallsGraph interface~get_radius2_x_comp get_radius2_x_comp proc~get_radius2_x_comp get_radius2_x_comp interface~get_radius2_x_comp->proc~get_radius2_x_comp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius2_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius2_x_comp.html"},{"title":"get_radius2_x_opp – SPHINCS_LORENE","text":"interface Calls interface~~get_radius2_x_opp~~CallsGraph interface~get_radius2_x_opp get_radius2_x_opp proc~get_radius2_x_opp get_radius2_x_opp interface~get_radius2_x_opp->proc~get_radius2_x_opp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius2_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius2_x_opp.html"},{"title":"get_radius2_y – SPHINCS_LORENE","text":"interface Calls interface~~get_radius2_y~~CallsGraph interface~get_radius2_y get_radius2_y proc~get_radius2_y get_radius2_y interface~get_radius2_y->proc~get_radius2_y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius2_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius2_y.html"},{"title":"get_radius2_z – SPHINCS_LORENE","text":"interface Calls interface~~get_radius2_z~~CallsGraph interface~get_radius2_z get_radius2_z proc~get_radius2_z get_radius2_z interface~get_radius2_z->proc~get_radius2_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radius2_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_radius2_z.html"},{"title":"get_rho_center1 – SPHINCS_LORENE","text":"interface Calls interface~~get_rho_center1~~CallsGraph interface~get_rho_center1 get_rho_center1 proc~get_rho_center1 get_rho_center1 interface~get_rho_center1->proc~get_rho_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_rho_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_rho_center1.html"},{"title":"get_rho_center2 – SPHINCS_LORENE","text":"interface Calls interface~~get_rho_center2~~CallsGraph interface~get_rho_center2 get_rho_center2 proc~get_rho_center2 get_rho_center2 interface~get_rho_center2->proc~get_rho_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_rho_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_rho_center2.html"},{"title":"get_specific_energy_center1 – SPHINCS_LORENE","text":"interface Calls interface~~get_specific_energy_center1~~CallsGraph interface~get_specific_energy_center1 get_specific_energy_center1 proc~get_specific_energy_center1 get_specific_energy_center1 interface~get_specific_energy_center1->proc~get_specific_energy_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_specific_energy_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_specific_energy_center1.html"},{"title":"get_specific_energy_center2 – SPHINCS_LORENE","text":"interface Calls interface~~get_specific_energy_center2~~CallsGraph interface~get_specific_energy_center2 get_specific_energy_center2 proc~get_specific_energy_center2 get_specific_energy_center2 interface~get_specific_energy_center2->proc~get_specific_energy_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_specific_energy_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_specific_energy_center2.html"},{"title":"allocate_lorene_id_memory – SPHINCS_LORENE","text":"interface Calls interface~~allocate_lorene_id_memory~~CallsGraph interface~allocate_lorene_id_memory allocate_lorene_id_memory proc~allocate_lorene_id_memory allocate_lorene_id_memory interface~allocate_lorene_id_memory->proc~allocate_lorene_id_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine allocate_lorene_id_memory(THIS, d) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays Description Allocates allocatable arrays member of a bnslorene object","tags":"","loc":"interface/allocate_lorene_id_memory.html"},{"title":"bnslorene – SPHINCS_LORENE","text":"public interface bnslorene Interface of TYPE bnslorene Calls interface~~bnslorene~~CallsGraph interface~bnslorene bnslorene interface~construct_bnslorene construct_bnslorene interface~bnslorene->interface~construct_bnslorene proc~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene timer timer proc~construct_bnslorene->timer interface~import_id_params import_id_params proc~construct_bnslorene->interface~import_id_params proc~import_id_params import_id_params interface~import_id_params->proc~import_id_params interface~print_id_params print_id_params proc~import_id_params->interface~print_id_params interface~get_lorene_id_params get_lorene_id_params proc~import_id_params->interface~get_lorene_id_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_id_params->k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase k_lorene2hydrobase proc~import_id_params->k_lorene2hydrobase proc~print_id_params print_id_params interface~print_id_params->proc~print_id_params proc~print_id_params->k_lorene2hydrobase var paninterfacebnsloreneCallsGraph = svgPanZoom('#interfacebnsloreneCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~bnslorene~~CalledByGraph interface~bnslorene bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures construct_bnslorene Module Procedures public interface construct_bnslorene () Arguments None","tags":"","loc":"interface/bnslorene.html"},{"title":"construct_bin_ns – SPHINCS_LORENE","text":"interface Called by interface~~construct_bin_ns~~CalledByGraph interface~construct_bin_ns construct_bin_ns proc~construct_binary construct_binary proc~construct_binary->interface~construct_bin_ns interface~construct_binary construct_binary interface~construct_binary->proc~construct_binary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function construct_bin_ns(c_resu_file) result(optr) bind(C, NAME= \"construct_bin_ns\") Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), optional DIMENSION(*) :: c_resu_file C string of the name of the \\texttt{LORENE} binary file storing the spectral\n BNS ID Return Value type(C_PTR) C pointer pointing to the constructed \\texttt{LORENE} \\texttt{Bin_NS} object Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that constructs\n  the \\texttt{LORENE} \\texttt{Bin_NS} object FT","tags":"","loc":"interface/construct_bin_ns.html"},{"title":"construct_binary – SPHINCS_LORENE","text":"interface Calls interface~~construct_binary~~CallsGraph interface~construct_binary construct_binary proc~construct_binary construct_binary interface~construct_binary->proc~construct_binary interface~destruct_bin_ns destruct_bin_ns proc~construct_binary->interface~destruct_bin_ns interface~construct_bin_ns construct_bin_ns proc~construct_binary->interface~construct_bin_ns Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine construct_binary(THIS, resu_file) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID Description Interface of the subroutine that constructs the \\texttt{LORENE} \\texttt{Bin_NS} object","tags":"","loc":"interface/construct_binary.html"},{"title":"construct_bnslorene – SPHINCS_LORENE","text":"interface Calls interface~~construct_bnslorene~~CallsGraph interface~construct_bnslorene construct_bnslorene proc~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene timer timer proc~construct_bnslorene->timer interface~import_id_params import_id_params proc~construct_bnslorene->interface~import_id_params proc~import_id_params import_id_params interface~import_id_params->proc~import_id_params interface~print_id_params print_id_params proc~import_id_params->interface~print_id_params interface~get_lorene_id_params get_lorene_id_params proc~import_id_params->interface~get_lorene_id_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_id_params->k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase k_lorene2hydrobase proc~import_id_params->k_lorene2hydrobase proc~print_id_params print_id_params interface~print_id_params->proc~print_id_params proc~print_id_params->k_lorene2hydrobase var paninterfaceconstruct_bnsloreneCallsGraph = svgPanZoom('#interfaceconstruct_bnsloreneCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~construct_bnslorene~~CalledByGraph interface~construct_bnslorene construct_bnslorene interface~bnslorene bnslorene interface~bnslorene->interface~construct_bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function construct_bnslorene(resu_file) result(bns_obj) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID Return Value type( bnslorene ) Constructed bnslorene object Description Constructs a bnslorene object","tags":"","loc":"interface/construct_bnslorene.html"},{"title":"deallocate_lorene_id_memory – SPHINCS_LORENE","text":"interface Calls interface~~deallocate_lorene_id_memory~~CallsGraph interface~deallocate_lorene_id_memory deallocate_lorene_id_memory proc~deallocate_lorene_id_memory deallocate_lorene_id_memory interface~deallocate_lorene_id_memory->proc~deallocate_lorene_id_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine deallocate_lorene_id_memory(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Description Deallocates allocatable arrays member of a bnslorene object","tags":"","loc":"interface/deallocate_lorene_id_memory.html"},{"title":"destruct_bin_ns – SPHINCS_LORENE","text":"interface Called by interface~~destruct_bin_ns~~CalledByGraph interface~destruct_bin_ns destruct_bin_ns proc~destruct_binary destruct_binary proc~destruct_binary->interface~destruct_bin_ns proc~construct_binary construct_binary proc~construct_binary->interface~destruct_bin_ns interface~construct_binary construct_binary interface~construct_binary->proc~construct_binary interface~destruct_binary destruct_binary interface~destruct_binary->proc~destruct_binary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine destruct_bin_ns(optr) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to the \\texttt{LORENE} \\texttt{Bin_NS} object to destruct Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that destructs\n  the \\texttt{LORENE} \\texttt{Bin_NS} object FT","tags":"","loc":"interface/destruct_bin_ns.html"},{"title":"destruct_binary – SPHINCS_LORENE","text":"interface Calls interface~~destruct_binary~~CallsGraph interface~destruct_binary destruct_binary proc~destruct_binary destruct_binary interface~destruct_binary->proc~destruct_binary interface~destruct_bin_ns destruct_bin_ns proc~destruct_binary->interface~destruct_bin_ns Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine destruct_binary(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Description Destructs a \\texttt{LORENE} \\texttt{Bin_NS} object","tags":"","loc":"interface/destruct_binary.html"},{"title":"destruct_bnslorene – SPHINCS_LORENE","text":"interface Calls interface~~destruct_bnslorene~~CallsGraph interface~destruct_bnslorene destruct_bnslorene proc~destruct_bnslorene destruct_bnslorene interface~destruct_bnslorene->proc~destruct_bnslorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine destruct_bnslorene(THIS) Implementation → Arguments Type Intent Optional Attributes Name type( bnslorene ), intent(inout) :: THIS bnslorene object to be destructed Description Destruct a bnslorene object","tags":"","loc":"interface/destruct_bnslorene.html"},{"title":"get_bns_identifier – SPHINCS_LORENE","text":"interface Calls interface~~get_bns_identifier~~CallsGraph interface~get_bns_identifier get_bns_identifier proc~get_bns_identifier get_bns_identifier interface~get_bns_identifier->proc~get_bns_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_bns_identifier(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_bns_identifier.html"},{"title":"get_eos1_loreneid – SPHINCS_LORENE","text":"interface Calls interface~~get_eos1_loreneid~~CallsGraph interface~get_eos1_loreneid get_eos1_loreneid proc~get_eos1_loreneid get_eos1_loreneid interface~get_eos1_loreneid->proc~get_eos1_loreneid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_eos1_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_eos1_loreneid.html"},{"title":"get_eos2_loreneid – SPHINCS_LORENE","text":"interface Calls interface~~get_eos2_loreneid~~CallsGraph interface~get_eos2_loreneid get_eos2_loreneid proc~get_eos2_loreneid get_eos2_loreneid interface~get_eos2_loreneid->proc~get_eos2_loreneid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_eos2_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_eos2_loreneid.html"},{"title":"get_eos_parameters – SPHINCS_LORENE","text":"interface Calls interface~~get_eos_parameters~~CallsGraph interface~get_eos_parameters get_eos_parameters proc~get_eos_parameters get_eos_parameters interface~get_eos_parameters->proc~get_eos_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object","tags":"","loc":"interface/get_eos_parameters.html"},{"title":"get_field_array – SPHINCS_LORENE","text":"interface Calls interface~~get_field_array~~CallsGraph interface~get_field_array get_field_array proc~get_field_array get_field_array interface~get_field_array->proc~get_field_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_field_array(THIS, field) result(field_array) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array Return Value double precision,\n  DIMENSION(:),ALLOCATABLE Desired bnslorene member array Description Returns the bnslorene member arrays named field","tags":"","loc":"interface/get_field_array.html"},{"title":"get_field_value – SPHINCS_LORENE","text":"interface Calls interface~~get_field_value~~CallsGraph interface~get_field_value get_field_value proc~get_field_value get_field_value interface~get_field_value->proc~get_field_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_field_value(THIS, field, n) result(field_value) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array integer, intent(in) :: n Component of the desired bnslorene member array Return Value double precision Component n of the desired bnslorene member array Description Returns the component n of the bnslorene member arrays named field","tags":"","loc":"interface/get_field_value.html"},{"title":"get_lorene_id – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_id~~CalledByGraph interface~get_lorene_id get_lorene_id proc~import_id_full import_id_full proc~import_id_full->interface~get_lorene_id proc~import_id_int import_id_int proc~import_id_int->interface~get_lorene_id interface~import_id_full import_id_full interface~import_id_full->proc~import_id_full interface~import_id_int import_id_int interface~import_id_int->proc~import_id_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_lorene_id(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the full\n  \\texttt{LORENE} ID at the specified point.\n  That is, imports the metric fields, the\n  components of the extrinsic curvature [c/km],\n  and the hydro fields. shift vector [c] baryon mass density [kg m&#94;{-3}] energy density [kg c&#94;2 m&#94;{-3}] pressure [kg c&#94;2 m&#94;{-3}] specific internal energy [c&#94;2] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT","tags":"","loc":"interface/get_lorene_id.html"},{"title":"get_lorene_id_hydro – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_id_hydro~~CalledByGraph interface~get_lorene_id_hydro get_lorene_id_hydro proc~import_id_hydro import_id_hydro proc~import_id_hydro->interface~get_lorene_id_hydro interface~import_id_hydro import_id_hydro interface~import_id_hydro->proc~import_id_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_lorene_id_hydro(optr, x, y, z, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  hydro fields from \\texttt{LORENE}, at the\n  specified point baryon mass density [kg m&#94;{-3}] energy density [kg c&#94;2 m&#94;{-3}] pressure [kg c&#94;2 m&#94;{-3}] specific internal energy [c&#94;2] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT","tags":"","loc":"interface/get_lorene_id_hydro.html"},{"title":"get_lorene_id_k – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_id_k~~CalledByGraph interface~get_lorene_id_k get_lorene_id_k proc~import_id_k import_id_k proc~import_id_k->interface~get_lorene_id_k interface~import_id_k import_id_k interface~import_id_k->proc~import_id_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_lorene_id_k(optr, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  components of the extrinsic\n  curvature [c/km] from \\texttt{LORENE}, at the\n  specified point FT","tags":"","loc":"interface/get_lorene_id_k.html"},{"title":"get_lorene_id_mass_b – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_id_mass_b~~CalledByGraph interface~get_lorene_id_mass_b get_lorene_id_mass_b proc~import_id_mass_b import_id_mass_b proc~import_id_mass_b->interface~get_lorene_id_mass_b interface~import_id_mass_b import_id_mass_b interface~import_id_mass_b->proc~import_id_mass_b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_lorene_id_mass_b(optr, x, y, z, g_diag, baryon_density, gamma_euler) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: g_diag g_{xx}=g_{yy}=g_{zz} at x,y,z real(kind=C_DOUBLE), intent(out) :: baryon_density Baryon mass density at x,y,z real(kind=C_DOUBLE), intent(out) :: gamma_euler Relative Lorentz factor between the 4-velocity of the fluid\n wrt the Eulerian observer and the 4-velocity of the Eulerian observer\n at x,y,z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  hydro fields and the metric fields\n  from \\texttt{LORENE}, at the specified point,\n  needed to compute the baryon mass. shift vector [c] baryon mass density [kg m&#94;{-3}] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT","tags":"","loc":"interface/get_lorene_id_mass_b.html"},{"title":"get_lorene_id_params – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_id_params~~CalledByGraph interface~get_lorene_id_params get_lorene_id_params proc~import_id_params import_id_params proc~import_id_params->interface~get_lorene_id_params interface~import_id_params import_id_params interface~import_id_params->proc~import_id_params proc~construct_bnslorene construct_bnslorene proc~construct_bnslorene->interface~import_id_params interface~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene interface~bnslorene bnslorene interface~bnslorene->interface~construct_bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene var paninterfaceget_lorene_id_paramsCalledByGraph = svgPanZoom('#interfaceget_lorene_id_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_lorene_id_params(optr, angular_vel, distance, distance_com, mass1, mass2, mass_grav1, mass_grav2, adm_mass, angular_momentum, area_radius1, radius1_x_comp, radius1_y, radius1_z, radius1_x_opp, center1_x, barycenter1_x, area_radius2, radius2_x_comp, radius2_y, radius2_z, radius2_x_opp, center2_x, barycenter2_x, ent_center1, nbar_center1, rho_center1, energy_density_center1, specific_energy_center1, pressure_center1, ent_center2, nbar_center2, rho_center2, energy_density_center2, specific_energy_center2, pressure_center2, eos1, eos2, eos1_id, eos2_id, gamma_1, kappa_1, gamma_2, kappa_2, npeos_1, gamma0_1, gamma1_1, gamma2_1, gamma3_1, kappa0_1, kappa1_1, kappa2_1, kappa3_1, logP1_1, logRho0_1, logRho1_1, logRho2_1, npeos_2, gamma0_2, gamma1_2, gamma2_2, gamma3_2, kappa0_2, kappa1_2, kappa2_2, kappa3_2, logP1_2, logRho0_2, logRho1_2, logRho2_2) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(out) :: angular_vel real(kind=C_DOUBLE), intent(out) :: distance real(kind=C_DOUBLE), intent(out) :: distance_com real(kind=C_DOUBLE), intent(out) :: mass1 real(kind=C_DOUBLE), intent(out) :: mass2 real(kind=C_DOUBLE), intent(out) :: mass_grav1 real(kind=C_DOUBLE), intent(out) :: mass_grav2 real(kind=C_DOUBLE), intent(out) :: adm_mass real(kind=C_DOUBLE), intent(out) :: angular_momentum real(kind=C_DOUBLE), intent(out) :: area_radius1 real(kind=C_DOUBLE), intent(out) :: radius1_x_comp real(kind=C_DOUBLE), intent(out) :: radius1_y real(kind=C_DOUBLE), intent(out) :: radius1_z real(kind=C_DOUBLE), intent(out) :: radius1_x_opp real(kind=C_DOUBLE), intent(out) :: center1_x real(kind=C_DOUBLE), intent(out) :: barycenter1_x real(kind=C_DOUBLE), intent(out) :: area_radius2 real(kind=C_DOUBLE), intent(out) :: radius2_x_comp real(kind=C_DOUBLE), intent(out) :: radius2_y real(kind=C_DOUBLE), intent(out) :: radius2_z real(kind=C_DOUBLE), intent(out) :: radius2_x_opp real(kind=C_DOUBLE), intent(out) :: center2_x real(kind=C_DOUBLE), intent(out) :: barycenter2_x real(kind=C_DOUBLE), intent(out) :: ent_center1 real(kind=C_DOUBLE), intent(out) :: nbar_center1 real(kind=C_DOUBLE), intent(out) :: rho_center1 real(kind=C_DOUBLE), intent(out) :: energy_density_center1 real(kind=C_DOUBLE), intent(out) :: specific_energy_center1 real(kind=C_DOUBLE), intent(out) :: pressure_center1 real(kind=C_DOUBLE), intent(out) :: ent_center2 real(kind=C_DOUBLE), intent(out) :: nbar_center2 real(kind=C_DOUBLE), intent(out) :: rho_center2 real(kind=C_DOUBLE), intent(out) :: energy_density_center2 real(kind=C_DOUBLE), intent(out) :: specific_energy_center2 real(kind=C_DOUBLE), intent(out) :: pressure_center2 character(kind=C_CHAR), intent(out), DIMENSION(100) :: eos1 character(kind=C_CHAR), intent(out), DIMENSION(100) :: eos2 integer(kind=C_INT) :: eos1_id integer(kind=C_INT) :: eos2_id real(kind=C_DOUBLE), intent(out) :: gamma_1 real(kind=C_DOUBLE), intent(out) :: kappa_1 real(kind=C_DOUBLE), intent(out) :: gamma_2 real(kind=C_DOUBLE), intent(out) :: kappa_2 integer(kind=C_INT) :: npeos_1 real(kind=C_DOUBLE), intent(out) :: gamma0_1 real(kind=C_DOUBLE), intent(out) :: gamma1_1 real(kind=C_DOUBLE), intent(out) :: gamma2_1 real(kind=C_DOUBLE), intent(out) :: gamma3_1 real(kind=C_DOUBLE), intent(out) :: kappa0_1 real(kind=C_DOUBLE), intent(out) :: kappa1_1 real(kind=C_DOUBLE), intent(out) :: kappa2_1 real(kind=C_DOUBLE), intent(out) :: kappa3_1 real(kind=C_DOUBLE), intent(out) :: logP1_1 real(kind=C_DOUBLE), intent(out) :: logRho0_1 real(kind=C_DOUBLE), intent(out) :: logRho1_1 real(kind=C_DOUBLE), intent(out) :: logRho2_1 integer(kind=C_INT) :: npeos_2 real(kind=C_DOUBLE), intent(out) :: gamma0_2 real(kind=C_DOUBLE), intent(out) :: gamma1_2 real(kind=C_DOUBLE), intent(out) :: gamma2_2 real(kind=C_DOUBLE), intent(out) :: gamma3_2 real(kind=C_DOUBLE), intent(out) :: kappa0_2 real(kind=C_DOUBLE), intent(out) :: kappa1_2 real(kind=C_DOUBLE), intent(out) :: kappa2_2 real(kind=C_DOUBLE), intent(out) :: kappa3_2 real(kind=C_DOUBLE), intent(out) :: logP1_2 real(kind=C_DOUBLE), intent(out) :: logRho0_2 real(kind=C_DOUBLE), intent(out) :: logRho1_2 real(kind=C_DOUBLE), intent(out) :: logRho2_2 Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that stores\n  the physical parameters of the binary\n  system from \\texttt{LORENE} in the desired variables FT","tags":"","loc":"interface/get_lorene_id_params.html"},{"title":"get_lorene_id_particles – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_id_particles~~CalledByGraph interface~get_lorene_id_particles get_lorene_id_particles proc~import_id_particles import_id_particles proc~import_id_particles->interface~get_lorene_id_particles interface~import_id_particles import_id_particles interface~import_id_particles->proc~import_id_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_lorene_id_particles(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  hydro fields and the metric fields *\n  from \\texttt{LORENE}, at the specified point shift vector [c] baryon mass density [kg m&#94;{-3}] energy density [kg c&#94;2 m&#94;{-3}] pressure [kg c&#94;2 m&#94;{-3}] specific internal energy [c&#94;2] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT","tags":"","loc":"interface/get_lorene_id_particles.html"},{"title":"get_lorene_id_spacetime – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_id_spacetime~~CalledByGraph interface~get_lorene_id_spacetime get_lorene_id_spacetime proc~import_id_spacetime import_id_spacetime proc~import_id_spacetime->interface~get_lorene_id_spacetime interface~import_id_spacetime import_id_spacetime interface~import_id_spacetime->proc~import_id_spacetime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_lorene_id_spacetime(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  metric fields and the components\n  of the extrinsic curvature [c/km] from \\texttt{LORENE},\n  at the specified point FT","tags":"","loc":"interface/get_lorene_id_spacetime.html"},{"title":"get_lorene_mass_density – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_mass_density~~CalledByGraph interface~get_lorene_mass_density get_lorene_mass_density proc~import_mass_density import_mass_density proc~import_mass_density->interface~get_lorene_mass_density interface~import_mass_density import_mass_density interface~import_mass_density->proc~import_mass_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function get_lorene_mass_density(optr, x, y, z) result(res) bind(C, NAME= \"get_mass_density\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Baryon mass density [\\mathrm{kg}\\, \\mathrm{m}&#94;{-3}] at the desired\n point (x,y,z) Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that returns\n  the baryon mass density [\\mathrm{kg}\\,\n  \\mathrm{m}&#94;{-3}] from \\texttt{LORENE},\n  at the specified point FT","tags":"","loc":"interface/get_lorene_mass_density.html"},{"title":"get_lorene_spatial_metric – SPHINCS_LORENE","text":"interface Called by interface~~get_lorene_spatial_metric~~CalledByGraph interface~get_lorene_spatial_metric get_lorene_spatial_metric proc~import_spatial_metric import_spatial_metric proc~import_spatial_metric->interface~get_lorene_spatial_metric interface~import_spatial_metric import_spatial_metric interface~import_spatial_metric->proc~import_spatial_metric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function get_lorene_spatial_metric(optr, x, y, z) result(res) bind(C, NAME= \"get_lorene_id_g\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Spatial metric component g_{xx}=g_{yy}=g_{zz} at the point (x,y,z) Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that returns the\n  diagonal components of the metric,\n  all equal to the \\texttt{LORENE} conformal factor to\n  the 4th power. FT","tags":"","loc":"interface/get_lorene_spatial_metric.html"},{"title":"import_id_full – SPHINCS_LORENE","text":"interface Calls interface~~import_id_full~~CallsGraph interface~import_id_full import_id_full proc~import_id_full import_id_full interface~import_id_full->proc~import_id_full interface~get_lorene_id get_lorene_id proc~import_id_full->interface~get_lorene_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Description Stores the ID in non bnslorene -member arrays with the same shape as the bnslorene member arrays","tags":"","loc":"interface/import_id_full.html"},{"title":"import_id_hydro – SPHINCS_LORENE","text":"interface Calls interface~~import_id_hydro~~CallsGraph interface~import_id_hydro import_id_hydro proc~import_id_hydro import_id_hydro interface~import_id_hydro->proc~import_id_hydro interface~get_lorene_id_hydro get_lorene_id_hydro proc~import_id_hydro->interface~get_lorene_id_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler Description Stores the hydro ID in the arrays needed to compute the constraints\n on the refined mesh","tags":"","loc":"interface/import_id_hydro.html"},{"title":"import_id_int – SPHINCS_LORENE","text":"interface Calls interface~~import_id_int~~CallsGraph interface~import_id_int import_id_int proc~import_id_int import_id_int interface~import_id_int->proc~import_id_int interface~get_lorene_id get_lorene_id proc~import_id_int->interface~get_lorene_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_int(THIS, n, x, y, z) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z Description Stores the ID in the bnslorene member arrays","tags":"","loc":"interface/import_id_int.html"},{"title":"import_id_k – SPHINCS_LORENE","text":"interface Calls interface~~import_id_k~~CallsGraph interface~import_id_k import_id_k proc~import_id_k import_id_k interface~import_id_k->proc~import_id_k interface~get_lorene_id_k get_lorene_id_k proc~import_id_k->interface~get_lorene_id_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz Description Stores the components of the extrinsic curvature in arrays","tags":"","loc":"interface/import_id_k.html"},{"title":"import_id_mass_b – SPHINCS_LORENE","text":"interface Calls interface~~import_id_mass_b~~CallsGraph interface~import_id_mass_b import_id_mass_b proc~import_id_mass_b import_id_mass_b interface~import_id_mass_b->proc~import_id_mass_b interface~get_lorene_id_mass_b get_lorene_id_mass_b proc~import_id_mass_b->interface~get_lorene_id_mass_b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler Description Stores the hydro ID in the arrays needed to compute the baryon mass","tags":"","loc":"interface/import_id_mass_b.html"},{"title":"import_id_params – SPHINCS_LORENE","text":"interface Calls interface~~import_id_params~~CallsGraph interface~import_id_params import_id_params proc~import_id_params import_id_params interface~import_id_params->proc~import_id_params interface~print_id_params print_id_params proc~import_id_params->interface~print_id_params interface~get_lorene_id_params get_lorene_id_params proc~import_id_params->interface~get_lorene_id_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_id_params->k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase k_lorene2hydrobase proc~import_id_params->k_lorene2hydrobase proc~print_id_params print_id_params interface~print_id_params->proc~print_id_params proc~print_id_params->k_lorene2hydrobase var paninterfaceimport_id_paramsCallsGraph = svgPanZoom('#interfaceimport_id_paramsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~import_id_params~~CalledByGraph interface~import_id_params import_id_params proc~construct_bnslorene construct_bnslorene proc~construct_bnslorene->interface~import_id_params interface~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene interface~bnslorene bnslorene interface~bnslorene->interface~construct_bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_params(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Description Imports the BNS parameters from \\texttt{LORENE}","tags":"","loc":"interface/import_id_params.html"},{"title":"import_id_particles – SPHINCS_LORENE","text":"interface Calls interface~~import_id_particles~~CallsGraph interface~import_id_particles import_id_particles proc~import_id_particles import_id_particles interface~import_id_particles->proc~import_id_particles interface~get_lorene_id_particles get_lorene_id_particles proc~import_id_particles->interface~get_lorene_id_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Description Stores the hydro ID in the arrays needed to compute the SPH ID","tags":"","loc":"interface/import_id_particles.html"},{"title":"import_id_spacetime – SPHINCS_LORENE","text":"interface Calls interface~~import_id_spacetime~~CallsGraph interface~import_id_spacetime import_id_spacetime proc~import_id_spacetime import_id_spacetime interface~import_id_spacetime->proc~import_id_spacetime proc~compute_g4 compute_g4 proc~import_id_spacetime->proc~compute_g4 proc~determinant_sym4x4_grid determinant_sym4x4_grid proc~import_id_spacetime->proc~determinant_sym4x4_grid interface~get_lorene_id_spacetime get_lorene_id_spacetime proc~import_id_spacetime->interface~get_lorene_id_spacetime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek Description Stores the spacetime ID in multi-dimensional arrays needed to compute\n the BSSN variables and constraints","tags":"","loc":"interface/import_id_spacetime.html"},{"title":"import_mass_density – SPHINCS_LORENE","text":"interface Calls interface~~import_mass_density~~CallsGraph interface~import_mass_density import_mass_density proc~import_mass_density import_mass_density interface~import_mass_density->proc~import_mass_density interface~get_lorene_mass_density get_lorene_mass_density proc~import_mass_density->interface~get_lorene_mass_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function import_mass_density(THIS, x, y, z) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) Description Returns the \\texttt{LORENE} baryon mass density at a point (x,y,z)","tags":"","loc":"interface/import_mass_density.html"},{"title":"import_spatial_metric – SPHINCS_LORENE","text":"interface Calls interface~~import_spatial_metric~~CallsGraph interface~import_spatial_metric import_spatial_metric proc~import_spatial_metric import_spatial_metric interface~import_spatial_metric->proc~import_spatial_metric interface~get_lorene_spatial_metric get_lorene_spatial_metric proc~import_spatial_metric->interface~get_lorene_spatial_metric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function import_spatial_metric(THIS, x, y, z) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) Description Returns the \\texttt{LORENE} conformally flat spatial metric component g_{xx}=g_{yy}=g_{zz} at a point (x,y,z)","tags":"","loc":"interface/import_spatial_metric.html"},{"title":"is_hydro_negative – SPHINCS_LORENE","text":"interface Calls interface~~is_hydro_negative~~CallsGraph interface~is_hydro_negative is_hydro_negative proc~is_hydro_negative is_hydro_negative interface~is_hydro_negative->proc~is_hydro_negative interface~negative_hydro negative_hydro proc~is_hydro_negative->interface~negative_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function is_hydro_negative(THIS, x, y, z) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Description Returns 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise","tags":"","loc":"interface/is_hydro_negative.html"},{"title":"negative_hydro – SPHINCS_LORENE","text":"interface Called by interface~~negative_hydro~~CalledByGraph interface~negative_hydro negative_hydro proc~is_hydro_negative is_hydro_negative proc~is_hydro_negative->interface~negative_hydro interface~is_hydro_negative is_hydro_negative interface~is_hydro_negative->proc~is_hydro_negative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function negative_hydro(optr, x, y, z) result(res) bind(C, NAME= \"negative_hydro\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value integer(kind=C_INT) 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that returns 1\n  if the energy density is nonpositive,\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive,\n  at the specified point; it returns 0 otherwise FT 12.03.2021","tags":"","loc":"interface/negative_hydro.html"},{"title":"print_id_params – SPHINCS_LORENE","text":"interface Calls interface~~print_id_params~~CallsGraph interface~print_id_params print_id_params proc~print_id_params print_id_params interface~print_id_params->proc~print_id_params k_lorene2hydrobase k_lorene2hydrobase proc~print_id_params->k_lorene2hydrobase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~print_id_params~~CalledByGraph interface~print_id_params print_id_params proc~import_id_params import_id_params proc~import_id_params->interface~print_id_params interface~import_id_params import_id_params interface~import_id_params->proc~import_id_params proc~construct_bnslorene construct_bnslorene proc~construct_bnslorene->interface~import_id_params interface~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene interface~bnslorene bnslorene interface~bnslorene->interface~construct_bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene var paninterfaceprint_id_paramsCalledByGraph = svgPanZoom('#interfaceprint_id_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine print_id_params(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Description Prints the BNS parameters to the standard output","tags":"","loc":"interface/print_id_params.html"},{"title":"get_angular_momentum – SPHINCS_LORENE","text":"interface Calls interface~~get_angular_momentum~2~~CallsGraph interface~get_angular_momentum~2 get_angular_momentum proc~get_angular_momentum~2 get_angular_momentum interface~get_angular_momentum~2->proc~get_angular_momentum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_angular_momentum~2.html"},{"title":"get_area_radius – SPHINCS_LORENE","text":"interface Calls interface~~get_area_radius~~CallsGraph interface~get_area_radius get_area_radius proc~get_area_radius get_area_radius interface~get_area_radius->proc~get_area_radius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_area_radius(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_area_radius.html"},{"title":"get_barycenter – SPHINCS_LORENE","text":"interface Calls interface~~get_barycenter~2~~CallsGraph interface~get_barycenter~2 get_barycenter proc~get_barycenter~2 get_barycenter interface~get_barycenter~2->proc~get_barycenter~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3)","tags":"","loc":"interface/get_barycenter~2.html"},{"title":"get_center – SPHINCS_LORENE","text":"interface Calls interface~~get_center~2~~CallsGraph interface~get_center~2 get_center proc~get_center~2 get_center interface~get_center~2->proc~get_center~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3)","tags":"","loc":"interface/get_center~2.html"},{"title":"get_energy_density_center – SPHINCS_LORENE","text":"interface Calls interface~~get_energy_density_center~~CallsGraph interface~get_energy_density_center get_energy_density_center proc~get_energy_density_center get_energy_density_center interface~get_energy_density_center->proc~get_energy_density_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_energy_density_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_energy_density_center.html"},{"title":"get_ent_center – SPHINCS_LORENE","text":"interface Calls interface~~get_ent_center~~CallsGraph interface~get_ent_center get_ent_center proc~get_ent_center get_ent_center interface~get_ent_center->proc~get_ent_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_ent_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_ent_center.html"},{"title":"get_eos – SPHINCS_LORENE","text":"interface Calls interface~~get_eos~2~~CallsGraph interface~get_eos~2 get_eos proc~get_eos~2 get_eos interface~get_eos~2->proc~get_eos~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE","tags":"","loc":"interface/get_eos~2.html"},{"title":"get_f_isco – SPHINCS_LORENE","text":"interface Calls interface~~get_f_isco~~CallsGraph interface~get_f_isco get_f_isco proc~get_f_isco get_f_isco interface~get_f_isco->proc~get_f_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_f_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_f_isco.html"},{"title":"get_gamma – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma~~CallsGraph interface~get_gamma get_gamma proc~get_gamma get_gamma interface~get_gamma->proc~get_gamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma.html"},{"title":"get_gamma0 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma0~~CallsGraph interface~get_gamma0 get_gamma0 proc~get_gamma0 get_gamma0 interface~get_gamma0->proc~get_gamma0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma0.html"},{"title":"get_gamma1 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma1~~CallsGraph interface~get_gamma1 get_gamma1 proc~get_gamma1 get_gamma1 interface~get_gamma1->proc~get_gamma1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma1.html"},{"title":"get_gamma2 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma2~~CallsGraph interface~get_gamma2 get_gamma2 proc~get_gamma2 get_gamma2 interface~get_gamma2->proc~get_gamma2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma2.html"},{"title":"get_gamma3 – SPHINCS_LORENE","text":"interface Calls interface~~get_gamma3~~CallsGraph interface~get_gamma3 get_gamma3 proc~get_gamma3 get_gamma3 interface~get_gamma3->proc~get_gamma3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_gamma3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_gamma3.html"},{"title":"get_grv2 – SPHINCS_LORENE","text":"interface Calls interface~~get_grv2~~CallsGraph interface~get_grv2 get_grv2 proc~get_grv2 get_grv2 interface~get_grv2->proc~get_grv2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_grv2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_grv2.html"},{"title":"get_grv3 – SPHINCS_LORENE","text":"interface Calls interface~~get_grv3~~CallsGraph interface~get_grv3 get_grv3 proc~get_grv3 get_grv3 interface~get_grv3->proc~get_grv3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_grv3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_grv3.html"},{"title":"get_kappa – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa~~CallsGraph interface~get_kappa get_kappa proc~get_kappa get_kappa interface~get_kappa->proc~get_kappa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa.html"},{"title":"get_kappa0 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa0~~CallsGraph interface~get_kappa0 get_kappa0 proc~get_kappa0 get_kappa0 interface~get_kappa0->proc~get_kappa0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa0.html"},{"title":"get_kappa1 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa1~~CallsGraph interface~get_kappa1 get_kappa1 proc~get_kappa1 get_kappa1 interface~get_kappa1->proc~get_kappa1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa1.html"},{"title":"get_kappa2 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa2~~CallsGraph interface~get_kappa2 get_kappa2 proc~get_kappa2 get_kappa2 interface~get_kappa2->proc~get_kappa2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa2.html"},{"title":"get_kappa3 – SPHINCS_LORENE","text":"interface Calls interface~~get_kappa3~~CallsGraph interface~get_kappa3 get_kappa3 proc~get_kappa3 get_kappa3 interface~get_kappa3->proc~get_kappa3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_kappa3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_kappa3.html"},{"title":"get_logP1 – SPHINCS_LORENE","text":"interface Calls interface~~get_logp1~~CallsGraph interface~get_logp1 get_logP1 proc~get_logp1 get_logp1 interface~get_logp1->proc~get_logp1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logP1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logp1.html"},{"title":"get_logRho0 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho0~~CallsGraph interface~get_logrho0 get_logRho0 proc~get_logrho0 get_logRho0 interface~get_logrho0->proc~get_logrho0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho0.html"},{"title":"get_logRho1 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho1~~CallsGraph interface~get_logrho1 get_logRho1 proc~get_logrho1 get_logRho1 interface~get_logrho1->proc~get_logrho1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho1.html"},{"title":"get_logRho2 – SPHINCS_LORENE","text":"interface Calls interface~~get_logrho2~~CallsGraph interface~get_logrho2 get_logRho2 proc~get_logrho2 get_logRho2 interface~get_logrho2->proc~get_logrho2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_logRho2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_logrho2.html"},{"title":"get_mass – SPHINCS_LORENE","text":"interface Calls interface~~get_mass~~CallsGraph interface~get_mass get_mass proc~get_mass~2 get_mass interface~get_mass->proc~get_mass~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_mass(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision Description Returns mass","tags":"","loc":"interface/get_mass.html"},{"title":"get_mass_grav – SPHINCS_LORENE","text":"interface Calls interface~~get_mass_grav~~CallsGraph interface~get_mass_grav get_mass_grav proc~get_mass_grav get_mass_grav interface~get_mass_grav->proc~get_mass_grav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_mass_grav(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_mass_grav.html"},{"title":"get_nbar_center – SPHINCS_LORENE","text":"interface Calls interface~~get_nbar_center~~CallsGraph interface~get_nbar_center get_nbar_center proc~get_nbar_center get_nbar_center interface~get_nbar_center->proc~get_nbar_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_nbar_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_nbar_center.html"},{"title":"get_npeos – SPHINCS_LORENE","text":"interface Calls interface~~get_npeos~~CallsGraph interface~get_npeos get_npeos proc~get_npeos get_npeos interface~get_npeos->proc~get_npeos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_npeos(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_npeos.html"},{"title":"get_omega_c – SPHINCS_LORENE","text":"interface Calls interface~~get_omega_c~~CallsGraph interface~get_omega_c get_omega_c proc~get_omega_c get_omega_c interface~get_omega_c->proc~get_omega_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_omega_c(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Description Returns omega_c","tags":"","loc":"interface/get_omega_c.html"},{"title":"get_pressure_center – SPHINCS_LORENE","text":"interface Calls interface~~get_pressure_center~~CallsGraph interface~get_pressure_center get_pressure_center proc~get_pressure_center get_pressure_center interface~get_pressure_center->proc~get_pressure_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_pressure_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_pressure_center.html"},{"title":"get_r_circ – SPHINCS_LORENE","text":"interface Calls interface~~get_r_circ~~CallsGraph interface~get_r_circ get_r_circ proc~get_r_circ get_r_circ interface~get_r_circ->proc~get_r_circ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_circ(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_circ.html"},{"title":"get_r_eq – SPHINCS_LORENE","text":"interface Calls interface~~get_r_eq~~CallsGraph interface~get_r_eq get_r_eq proc~get_r_eq get_r_eq interface~get_r_eq->proc~get_r_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_eq(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_eq.html"},{"title":"get_r_eq_3pi2 – SPHINCS_LORENE","text":"interface Calls interface~~get_r_eq_3pi2~~CallsGraph interface~get_r_eq_3pi2 get_r_eq_3pi2 proc~get_r_eq_3pi2 get_r_eq_3pi2 interface~get_r_eq_3pi2->proc~get_r_eq_3pi2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_eq_3pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_eq_3pi2.html"},{"title":"get_r_eq_pi – SPHINCS_LORENE","text":"interface Calls interface~~get_r_eq_pi~~CallsGraph interface~get_r_eq_pi get_r_eq_pi proc~get_r_eq_pi get_r_eq_pi interface~get_r_eq_pi->proc~get_r_eq_pi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_eq_pi(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_eq_pi.html"},{"title":"get_r_eq_pi2 – SPHINCS_LORENE","text":"interface Calls interface~~get_r_eq_pi2~~CallsGraph interface~get_r_eq_pi2 get_r_eq_pi2 proc~get_r_eq_pi2 get_r_eq_pi2 interface~get_r_eq_pi2->proc~get_r_eq_pi2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_eq_pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_eq_pi2.html"},{"title":"get_r_isco – SPHINCS_LORENE","text":"interface Calls interface~~get_r_isco~~CallsGraph interface~get_r_isco get_r_isco proc~get_r_isco get_r_isco interface~get_r_isco->proc~get_r_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_isco.html"},{"title":"get_r_mean – SPHINCS_LORENE","text":"interface Calls interface~~get_r_mean~~CallsGraph interface~get_r_mean get_r_mean proc~get_r_mean get_r_mean interface~get_r_mean->proc~get_r_mean Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_mean(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_mean.html"},{"title":"get_r_pole – SPHINCS_LORENE","text":"interface Calls interface~~get_r_pole~~CallsGraph interface~get_r_pole get_r_pole proc~get_r_pole get_r_pole interface~get_r_pole->proc~get_r_pole Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_pole(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_pole.html"},{"title":"get_r_ratio – SPHINCS_LORENE","text":"interface Calls interface~~get_r_ratio~~CallsGraph interface~get_r_ratio get_r_ratio proc~get_r_ratio get_r_ratio interface~get_r_ratio->proc~get_r_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_r_ratio(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_r_ratio.html"},{"title":"get_radii – SPHINCS_LORENE","text":"interface Calls interface~~get_radii~2~~CallsGraph interface~get_radii~2 get_radii proc~get_radii~2 get_radii interface~get_radii~2->proc~get_radii~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6)","tags":"","loc":"interface/get_radii~2.html"},{"title":"get_rho_center – SPHINCS_LORENE","text":"interface Calls interface~~get_rho_center~~CallsGraph interface~get_rho_center get_rho_center proc~get_rho_center get_rho_center interface~get_rho_center->proc~get_rho_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_rho_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_rho_center.html"},{"title":"get_specific_angular_momentum_isco – SPHINCS_LORENE","text":"interface Calls interface~~get_specific_angular_momentum_isco~~CallsGraph interface~get_specific_angular_momentum_isco get_specific_angular_momentum_isco proc~get_specific_angular_momentum_isco get_specific_angular_momentum_isco interface~get_specific_angular_momentum_isco->proc~get_specific_angular_momentum_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_specific_angular_momentum_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_specific_angular_momentum_isco.html"},{"title":"get_specific_energy_center – SPHINCS_LORENE","text":"interface Calls interface~~get_specific_energy_center~~CallsGraph interface~get_specific_energy_center get_specific_energy_center proc~get_specific_energy_center get_specific_energy_center interface~get_specific_energy_center->proc~get_specific_energy_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_specific_energy_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_specific_energy_center.html"},{"title":"get_specific_energy_isco – SPHINCS_LORENE","text":"interface Calls interface~~get_specific_energy_isco~~CallsGraph interface~get_specific_energy_isco get_specific_energy_isco proc~get_specific_energy_isco get_specific_energy_isco interface~get_specific_energy_isco->proc~get_specific_energy_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_specific_energy_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_specific_energy_isco.html"},{"title":"get_surface_area – SPHINCS_LORENE","text":"interface Calls interface~~get_surface_area~~CallsGraph interface~get_surface_area get_surface_area proc~get_surface_area get_surface_area interface~get_surface_area->proc~get_surface_area Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_surface_area(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_surface_area.html"},{"title":"get_tsw – SPHINCS_LORENE","text":"interface Calls interface~~get_tsw~~CallsGraph interface~get_tsw get_tsw proc~get_tsw get_tsw interface~get_tsw->proc~get_tsw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_tsw(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_tsw.html"},{"title":"allocate_diffstar_memory – SPHINCS_LORENE","text":"interface Calls interface~~allocate_diffstar_memory~~CallsGraph interface~allocate_diffstar_memory allocate_diffstar_memory proc~allocate_diffstar_memory allocate_diffstar_memory interface~allocate_diffstar_memory->proc~allocate_diffstar_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine allocate_diffstar_memory(THIS, d) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays Description Allocates allocatable arrays member of a diffstarlorene object","tags":"","loc":"interface/allocate_diffstar_memory.html"},{"title":"construct_diffstarlorene – SPHINCS_LORENE","text":"interface Calls interface~~construct_diffstarlorene~~CallsGraph interface~construct_diffstarlorene construct_diffstarlorene proc~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~import_diffstar_params import_diffstar_params proc~construct_diffstarlorene->interface~import_diffstar_params timer timer proc~construct_diffstarlorene->timer proc~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params interface~get_diffstar_params get_diffstar_params proc~import_diffstar_params->interface~get_diffstar_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_diffstar_params->k_lorene2hydrobase_piecewisepolytrope interface~print_diffstar_params print_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~import_diffstar_params->k_lorene2hydrobase proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params proc~print_diffstar_params->k_lorene2hydrobase var paninterfaceconstruct_diffstarloreneCallsGraph = svgPanZoom('#interfaceconstruct_diffstarloreneCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~construct_diffstarlorene~~CalledByGraph interface~construct_diffstarlorene construct_diffstarlorene interface~diffstarlorene diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function construct_diffstarlorene(resu_file) result(drs) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID Return Value type( diffstarlorene ) Constructed diffstarlorene object Description Constructs a diffstarlorene object","tags":"","loc":"interface/construct_diffstarlorene.html"},{"title":"construct_drs – SPHINCS_LORENE","text":"interface Calls interface~~construct_drs~~CallsGraph interface~construct_drs construct_drs proc~construct_drs construct_drs interface~construct_drs->proc~construct_drs interface~construct_etdiffrot construct_etdiffrot proc~construct_drs->interface~construct_etdiffrot interface~destruct_etdiffrot destruct_etdiffrot proc~construct_drs->interface~destruct_etdiffrot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine construct_drs(THIS, resu_file) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID Description Interface of the subroutine that constructs the \\texttt{LORENE} Etdiffrot object","tags":"","loc":"interface/construct_drs.html"},{"title":"construct_etdiffrot – SPHINCS_LORENE","text":"interface Called by interface~~construct_etdiffrot~~CalledByGraph interface~construct_etdiffrot construct_etdiffrot proc~construct_drs construct_drs proc~construct_drs->interface~construct_etdiffrot interface~construct_drs construct_drs interface~construct_drs->proc~construct_drs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function construct_etdiffrot(c_resu_file) result(optr) bind(C, NAME= \"construct_et_diffrot\") Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), optional DIMENSION(*) :: c_resu_file C string of the name of the \\texttt{LORENE} binary file storing the spectral\n DRS ID Return Value type(C_PTR) C pointer pointing to the constructed \\texttt{LORENE} \\texttt{Et_diffrot} object Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that constructs\n  the \\texttt{LORENE} \\texttt{Et_diffrot} object FT 24.10.2021","tags":"","loc":"interface/construct_etdiffrot.html"},{"title":"deallocate_diffstar_memory – SPHINCS_LORENE","text":"interface Calls interface~~deallocate_diffstar_memory~~CallsGraph interface~deallocate_diffstar_memory deallocate_diffstar_memory proc~deallocate_diffstar_memory deallocate_diffstar_memory interface~deallocate_diffstar_memory->proc~deallocate_diffstar_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine deallocate_diffstar_memory(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Description Deallocates allocatable arrays member of a diffstarlorene object","tags":"","loc":"interface/deallocate_diffstar_memory.html"},{"title":"destruct_diffstarlorene – SPHINCS_LORENE","text":"interface Calls interface~~destruct_diffstarlorene~~CallsGraph interface~destruct_diffstarlorene destruct_diffstarlorene proc~destruct_diffstarlorene destruct_diffstarlorene interface~destruct_diffstarlorene->proc~destruct_diffstarlorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine destruct_diffstarlorene(THIS) Implementation → Arguments Type Intent Optional Attributes Name type( diffstarlorene ), intent(inout) :: THIS diffstarlorene object to be destructed Description Destruct a diffstarlorene object","tags":"","loc":"interface/destruct_diffstarlorene.html"},{"title":"destruct_drs – SPHINCS_LORENE","text":"interface Calls interface~~destruct_drs~~CallsGraph interface~destruct_drs destruct_drs proc~destruct_drs destruct_drs interface~destruct_drs->proc~destruct_drs interface~destruct_etdiffrot destruct_etdiffrot proc~destruct_drs->interface~destruct_etdiffrot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine destruct_drs(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Description Destructs a \\texttt{LORENE} Etdiffrot object","tags":"","loc":"interface/destruct_drs.html"},{"title":"destruct_etdiffrot – SPHINCS_LORENE","text":"interface Called by interface~~destruct_etdiffrot~~CalledByGraph interface~destruct_etdiffrot destruct_etdiffrot proc~destruct_drs destruct_drs proc~destruct_drs->interface~destruct_etdiffrot proc~construct_drs construct_drs proc~construct_drs->interface~destruct_etdiffrot interface~construct_drs construct_drs interface~construct_drs->proc~construct_drs interface~destruct_drs destruct_drs interface~destruct_drs->proc~destruct_drs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine destruct_etdiffrot(optr) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to the \\texttt{LORENE} \\texttt{Et_diffrot} object to destruct Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that destructs\n  the \\texttt{LORENE} \\texttt{Et_diffrot} object FT 24.10.2021","tags":"","loc":"interface/destruct_etdiffrot.html"},{"title":"diffstarlorene – SPHINCS_LORENE","text":"public interface diffstarlorene Interface of TYPE diffstarlorene Calls interface~~diffstarlorene~~CallsGraph interface~diffstarlorene diffstarlorene interface~construct_diffstarlorene construct_diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene proc~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~import_diffstar_params import_diffstar_params proc~construct_diffstarlorene->interface~import_diffstar_params timer timer proc~construct_diffstarlorene->timer proc~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params interface~get_diffstar_params get_diffstar_params proc~import_diffstar_params->interface~get_diffstar_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_diffstar_params->k_lorene2hydrobase_piecewisepolytrope interface~print_diffstar_params print_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~import_diffstar_params->k_lorene2hydrobase proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params proc~print_diffstar_params->k_lorene2hydrobase var paninterfacediffstarloreneCallsGraph = svgPanZoom('#interfacediffstarloreneCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~diffstarlorene~~CalledByGraph interface~diffstarlorene diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures construct_diffstarlorene Module Procedures public interface construct_diffstarlorene () Arguments None","tags":"","loc":"interface/diffstarlorene.html"},{"title":"get_diffstar_full – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_full~~CalledByGraph interface~get_diffstar_full get_diffstar_full proc~import_id_full~2 import_id_full proc~import_id_full~2->interface~get_diffstar_full proc~import_id_int~2 import_id_int proc~import_id_int~2->interface~get_diffstar_full interface~import_id_full~2 import_id_full interface~import_id_full~2->proc~import_id_full~2 interface~import_id_int~2 import_id_int interface~import_id_int~2->proc~import_id_int~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_diffstar_full(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the full\n  \\texttt{LORENE} ID at the specified point.\n  That is, imports the metric fields, the\n  components of the extrinsic curvature [c/km],\n  and the hydro fields. shift vector [c] baryon mass density [kg m&#94;{-3}] energy density [kg c&#94;2 m&#94;{-3}] pressure [kg c&#94;2 m&#94;{-3}] specific internal energy [c&#94;2] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT 24.10.2021","tags":"","loc":"interface/get_diffstar_full.html"},{"title":"get_diffstar_hydro – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_hydro~~CalledByGraph interface~get_diffstar_hydro get_diffstar_hydro proc~import_id_hydro~2 import_id_hydro proc~import_id_hydro~2->interface~get_diffstar_hydro interface~import_id_hydro~2 import_id_hydro interface~import_id_hydro~2->proc~import_id_hydro~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_diffstar_hydro(optr, x, y, z, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  hydro fields from \\texttt{LORENE}, at the\n  specified point baryon mass density [kg m&#94;{-3}] energy density [kg c&#94;2 m&#94;{-3}] pressure [kg c&#94;2 m&#94;{-3}] specific internal energy [c&#94;2] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT 24.10.2021","tags":"","loc":"interface/get_diffstar_hydro.html"},{"title":"get_diffstar_identifier – SPHINCS_LORENE","text":"interface Calls interface~~get_diffstar_identifier~~CallsGraph interface~get_diffstar_identifier get_diffstar_identifier proc~get_diffstar_identifier get_diffstar_identifier interface~get_diffstar_identifier->proc~get_diffstar_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_diffstar_identifier(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"interface/get_diffstar_identifier.html"},{"title":"get_diffstar_mass_b – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_mass_b~~CalledByGraph interface~get_diffstar_mass_b get_diffstar_mass_b proc~import_id_mass_b~2 import_id_mass_b proc~import_id_mass_b~2->interface~get_diffstar_mass_b interface~import_id_mass_b~2 import_id_mass_b interface~import_id_mass_b~2->proc~import_id_mass_b~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_diffstar_mass_b(optr, x, y, z, g_diag, baryon_density, gamma_euler) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: g_diag g_{xx}=g_{yy}=g_{zz} at x,y,z real(kind=C_DOUBLE), intent(out) :: baryon_density Baryon mass density at x,y,z real(kind=C_DOUBLE), intent(out) :: gamma_euler Relative Lorentz factor between the 4-velocity of the fluid\n wrt the Eulerian observer and the 4-velocity of the Eulerian observer\n at x,y,z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  hydro fields and the metric fields\n  from \\texttt{LORENE}, at the specified point,\n  needed to compute the baryon mass. shift vector [c] baryon mass density [kg m&#94;{-3}] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT 24.10.2021","tags":"","loc":"interface/get_diffstar_mass_b.html"},{"title":"get_diffstar_mass_density – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_mass_density~~CalledByGraph interface~get_diffstar_mass_density get_diffstar_mass_density proc~import_mass_density~2 import_mass_density proc~import_mass_density~2->interface~get_diffstar_mass_density interface~import_mass_density~2 import_mass_density interface~import_mass_density~2->proc~import_mass_density~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function get_diffstar_mass_density(optr, x, y, z) result(res) bind(C, NAME= \"get_rotdiff_mass_density\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Baryon mass density [\\mathrm{kg}\\, \\mathrm{m}&#94;{-3}] at the desired\n point (x,y,z) Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that returns\n  the baryon mass density [\\mathrm{kg}\\,\n  \\mathrm{m}&#94;{-3}] from \\texttt{LORENE},\n  at the specified point FT 24.10.2021","tags":"","loc":"interface/get_diffstar_mass_density.html"},{"title":"get_diffstar_params – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_params~~CalledByGraph interface~get_diffstar_params get_diffstar_params proc~import_diffstar_params import_diffstar_params proc~import_diffstar_params->interface~get_diffstar_params interface~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params proc~construct_diffstarlorene construct_diffstarlorene proc~construct_diffstarlorene->interface~import_diffstar_params interface~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~diffstarlorene diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene var paninterfaceget_diffstar_paramsCalledByGraph = svgPanZoom('#interfaceget_diffstar_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_diffstar_params(optr, omega_c, mass, mass_grav, angular_momentum, tsw, grv2, grv3, r_circ, surface_area, r_mean, r_eq, r_eq_pi2, r_eq_pi, r_eq_3pi2, r_eq_pole, r_ratio, r_isco, f_isco, specific_energy_isco, specific_angular_momentum_isco, area_radius, ent_center, nbar_center, rho_center, energy_density_center, specific_energy_center, pressure_center, redshift_eqf, redshift_eqb, redshift_pole, eos, eos_id, gamma, kappa, npeos, gamma0, gamma1, gamma2, gamma3, kappa0, kappa1, kappa2, kappa3, logP1, logRho0, logRho1, logRho2) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(out) :: omega_c real(kind=C_DOUBLE), intent(out) :: mass real(kind=C_DOUBLE), intent(out) :: mass_grav real(kind=C_DOUBLE), intent(out) :: angular_momentum real(kind=C_DOUBLE), intent(out) :: tsw real(kind=C_DOUBLE), intent(out) :: grv2 real(kind=C_DOUBLE), intent(out) :: grv3 real(kind=C_DOUBLE), intent(out) :: r_circ real(kind=C_DOUBLE), intent(out) :: surface_area real(kind=C_DOUBLE), intent(out) :: r_mean real(kind=C_DOUBLE), intent(out) :: r_eq real(kind=C_DOUBLE), intent(out) :: r_eq_pi2 real(kind=C_DOUBLE), intent(out) :: r_eq_pi real(kind=C_DOUBLE), intent(out) :: r_eq_3pi2 real(kind=C_DOUBLE), intent(out) :: r_eq_pole real(kind=C_DOUBLE), intent(out) :: r_ratio real(kind=C_DOUBLE), intent(out) :: r_isco real(kind=C_DOUBLE), intent(out) :: f_isco real(kind=C_DOUBLE), intent(out) :: specific_energy_isco real(kind=C_DOUBLE), intent(out) :: specific_angular_momentum_isco real(kind=C_DOUBLE), intent(out) :: area_radius real(kind=C_DOUBLE), intent(out) :: ent_center real(kind=C_DOUBLE), intent(out) :: nbar_center real(kind=C_DOUBLE), intent(out) :: rho_center real(kind=C_DOUBLE), intent(out) :: energy_density_center real(kind=C_DOUBLE), intent(out) :: specific_energy_center real(kind=C_DOUBLE), intent(out) :: pressure_center real(kind=C_DOUBLE), intent(out) :: redshift_eqf real(kind=C_DOUBLE), intent(out) :: redshift_eqb real(kind=C_DOUBLE), intent(out) :: redshift_pole character(kind=C_CHAR), intent(out), DIMENSION(100) :: eos integer(kind=C_INT) :: eos_id real(kind=C_DOUBLE), intent(out) :: gamma real(kind=C_DOUBLE), intent(out) :: kappa integer(kind=C_INT) :: npeos real(kind=C_DOUBLE), intent(out) :: gamma0 real(kind=C_DOUBLE), intent(out) :: gamma1 real(kind=C_DOUBLE), intent(out) :: gamma2 real(kind=C_DOUBLE), intent(out) :: gamma3 real(kind=C_DOUBLE), intent(out) :: kappa0 real(kind=C_DOUBLE), intent(out) :: kappa1 real(kind=C_DOUBLE), intent(out) :: kappa2 real(kind=C_DOUBLE), intent(out) :: kappa3 real(kind=C_DOUBLE), intent(out) :: logP1 real(kind=C_DOUBLE), intent(out) :: logRho0 real(kind=C_DOUBLE), intent(out) :: logRho1 real(kind=C_DOUBLE), intent(out) :: logRho2 Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that stores\n  the physical parameters of the binary\n  system from \\texttt{LORENE} in the desired variables FT 24.10.2021","tags":"","loc":"interface/get_diffstar_params.html"},{"title":"get_diffstar_particles – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_particles~~CalledByGraph interface~get_diffstar_particles get_diffstar_particles proc~import_id_particles~2 import_id_particles proc~import_id_particles~2->interface~get_diffstar_particles interface~import_id_particles~2 import_id_particles interface~import_id_particles~2->proc~import_id_particles~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_diffstar_particles(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  hydro fields and the metric fields *\n  from \\texttt{LORENE}, at the specified point shift vector [c] baryon mass density [kg m&#94;{-3}] energy density [kg c&#94;2 m&#94;{-3}] pressure [kg c&#94;2 m&#94;{-3}] specific internal energy [c&#94;2] fluid 3-velocity with respect to the\n    Eulerian observer [c] FT 24.10.2021","tags":"","loc":"interface/get_diffstar_particles.html"},{"title":"get_diffstar_spacetime – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_spacetime~~CalledByGraph interface~get_diffstar_spacetime get_diffstar_spacetime proc~import_id_spacetime~2 import_id_spacetime proc~import_id_spacetime~2->interface~get_diffstar_spacetime interface~import_id_spacetime~2 import_id_spacetime interface~import_id_spacetime~2->proc~import_id_spacetime~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private subroutine get_diffstar_spacetime(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) bind(C, NAME= \"0\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  metric fields and the components\n  of the extrinsic curvature [c/km] from \\texttt{LORENE},\n  at the specified point FT 24.10.2021","tags":"","loc":"interface/get_diffstar_spacetime.html"},{"title":"get_diffstar_spatial_metric – SPHINCS_LORENE","text":"interface Called by interface~~get_diffstar_spatial_metric~~CalledByGraph interface~get_diffstar_spatial_metric get_diffstar_spatial_metric proc~import_spatial_metric~2 import_spatial_metric proc~import_spatial_metric~2->interface~get_diffstar_spatial_metric interface~import_spatial_metric~2 import_spatial_metric interface~import_spatial_metric~2->proc~import_spatial_metric~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function get_diffstar_spatial_metric(optr, x, y, z) result(res) bind(C, NAME= \"get_g_diag\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Spatial metric component g_{xx}=g_{yy}=g_{zz} at the point (x,y,z) Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that returns the\n  diagonal components of the metric,\n  all equal to the \\texttt{LORENE} conformal factor to\n  the 4th power. FT 24.10.2021","tags":"","loc":"interface/get_diffstar_spatial_metric.html"},{"title":"get_eos_loreneid – SPHINCS_LORENE","text":"interface Calls interface~~get_eos_loreneid~~CallsGraph interface~get_eos_loreneid get_eos_loreneid proc~get_eos_loreneid get_eos_loreneid interface~get_eos_loreneid->proc~get_eos_loreneid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_eos_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value integer","tags":"","loc":"interface/get_eos_loreneid.html"},{"title":"get_eos_parameters – SPHINCS_LORENE","text":"interface Calls interface~~get_eos_parameters~2~~CallsGraph interface~get_eos_parameters~2 get_eos_parameters proc~get_eos_parameters~2 get_eos_parameters interface~get_eos_parameters~2->proc~get_eos_parameters~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the DRS","tags":"","loc":"interface/get_eos_parameters~2.html"},{"title":"get_field_array – SPHINCS_LORENE","text":"interface Calls interface~~get_field_array~2~~CallsGraph interface~get_field_array~2 get_field_array proc~get_field_array~2 get_field_array interface~get_field_array~2->proc~get_field_array~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_field_array(THIS, field) result(field_array) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array Return Value double precision,\n  DIMENSION(:),ALLOCATABLE Desired diffstarlorene member array Description Returns the diffstarlorene member arrays named field","tags":"","loc":"interface/get_field_array~2.html"},{"title":"get_field_value – SPHINCS_LORENE","text":"interface Calls interface~~get_field_value~2~~CallsGraph interface~get_field_value~2 get_field_value proc~get_field_value~2 get_field_value interface~get_field_value~2->proc~get_field_value~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function get_field_value(THIS, field, n) result(field_value) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array integer, intent(in) :: n Component of the desired diffstarlorene member array Return Value double precision Component n of the desired diffstarlorene member array Description Returns the component n of the diffstarlorene member arrays named field","tags":"","loc":"interface/get_field_value~2.html"},{"title":"import_diffstar_params – SPHINCS_LORENE","text":"interface Calls interface~~import_diffstar_params~~CallsGraph interface~import_diffstar_params import_diffstar_params proc~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params interface~get_diffstar_params get_diffstar_params proc~import_diffstar_params->interface~get_diffstar_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_diffstar_params->k_lorene2hydrobase_piecewisepolytrope interface~print_diffstar_params print_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~import_diffstar_params->k_lorene2hydrobase proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params proc~print_diffstar_params->k_lorene2hydrobase var paninterfaceimport_diffstar_paramsCallsGraph = svgPanZoom('#interfaceimport_diffstar_paramsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~import_diffstar_params~~CalledByGraph interface~import_diffstar_params import_diffstar_params proc~construct_diffstarlorene construct_diffstarlorene proc~construct_diffstarlorene->interface~import_diffstar_params interface~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~diffstarlorene diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene var paninterfaceimport_diffstar_paramsCalledByGraph = svgPanZoom('#interfaceimport_diffstar_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_diffstar_params(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Description Imports the DRS parameters from \\texttt{LORENE}","tags":"","loc":"interface/import_diffstar_params.html"},{"title":"import_id_full – SPHINCS_LORENE","text":"interface Calls interface~~import_id_full~2~~CallsGraph interface~import_id_full~2 import_id_full proc~import_id_full~2 import_id_full interface~import_id_full~2->proc~import_id_full~2 interface~get_diffstar_full get_diffstar_full proc~import_id_full~2->interface~get_diffstar_full Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Description Stores the ID in non diffstarlorene -member arrays with the same\n shape as the diffstarlorene member arrays","tags":"","loc":"interface/import_id_full~2.html"},{"title":"import_id_hydro – SPHINCS_LORENE","text":"interface Calls interface~~import_id_hydro~2~~CallsGraph interface~import_id_hydro~2 import_id_hydro proc~import_id_hydro~2 import_id_hydro interface~import_id_hydro~2->proc~import_id_hydro~2 interface~get_diffstar_hydro get_diffstar_hydro proc~import_id_hydro~2->interface~get_diffstar_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler Description Stores the hydro ID in the arrays needed to compute the constraints\n on the refined mesh","tags":"","loc":"interface/import_id_hydro~2.html"},{"title":"import_id_int – SPHINCS_LORENE","text":"interface Calls interface~~import_id_int~2~~CallsGraph interface~import_id_int~2 import_id_int proc~import_id_int~2 import_id_int interface~import_id_int~2->proc~import_id_int~2 interface~get_diffstar_full get_diffstar_full proc~import_id_int~2->interface~get_diffstar_full Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_int(THIS, n, x, y, z) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z Description Stores the ID in the diffstarlorene member arrays","tags":"","loc":"interface/import_id_int~2.html"},{"title":"import_id_k – SPHINCS_LORENE","text":"interface Calls interface~~import_id_k~2~~CallsGraph interface~import_id_k~2 import_id_k proc~import_id_k~2 import_id_k interface~import_id_k~2->proc~import_id_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz Description Stores the components of the extrinsic curvature in arrays","tags":"","loc":"interface/import_id_k~2.html"},{"title":"import_id_mass_b – SPHINCS_LORENE","text":"interface Calls interface~~import_id_mass_b~2~~CallsGraph interface~import_id_mass_b~2 import_id_mass_b proc~import_id_mass_b~2 import_id_mass_b interface~import_id_mass_b~2->proc~import_id_mass_b~2 interface~get_diffstar_mass_b get_diffstar_mass_b proc~import_id_mass_b~2->interface~get_diffstar_mass_b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler Description Stores the hydro ID in the arrays needed to compute the baryon mass","tags":"","loc":"interface/import_id_mass_b~2.html"},{"title":"import_id_particles – SPHINCS_LORENE","text":"interface Calls interface~~import_id_particles~2~~CallsGraph interface~import_id_particles~2 import_id_particles proc~import_id_particles~2 import_id_particles interface~import_id_particles~2->proc~import_id_particles~2 interface~get_diffstar_particles get_diffstar_particles proc~import_id_particles~2->interface~get_diffstar_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Description Stores the hydro ID in the arrays needed to compute the SPH ID","tags":"","loc":"interface/import_id_particles~2.html"},{"title":"import_id_spacetime – SPHINCS_LORENE","text":"interface Calls interface~~import_id_spacetime~2~~CallsGraph interface~import_id_spacetime~2 import_id_spacetime proc~import_id_spacetime~2 import_id_spacetime interface~import_id_spacetime~2->proc~import_id_spacetime~2 proc~compute_g4 compute_g4 proc~import_id_spacetime~2->proc~compute_g4 interface~get_diffstar_spacetime get_diffstar_spacetime proc~import_id_spacetime~2->interface~get_diffstar_spacetime proc~determinant_sym4x4_grid determinant_sym4x4_grid proc~import_id_spacetime~2->proc~determinant_sym4x4_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek Description Stores the spacetime ID in multi-dimensional arrays needed to compute\n the BSSN variables and constraints","tags":"","loc":"interface/import_id_spacetime~2.html"},{"title":"import_mass_density – SPHINCS_LORENE","text":"interface Calls interface~~import_mass_density~2~~CallsGraph interface~import_mass_density~2 import_mass_density proc~import_mass_density~2 import_mass_density interface~import_mass_density~2->proc~import_mass_density~2 interface~get_diffstar_mass_density get_diffstar_mass_density proc~import_mass_density~2->interface~get_diffstar_mass_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function import_mass_density(THIS, x, y, z) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) Description Returns the \\texttt{LORENE} baryon mass density at a point (x,y,z)","tags":"","loc":"interface/import_mass_density~2.html"},{"title":"import_spatial_metric – SPHINCS_LORENE","text":"interface Calls interface~~import_spatial_metric~2~~CallsGraph interface~import_spatial_metric~2 import_spatial_metric proc~import_spatial_metric~2 import_spatial_metric interface~import_spatial_metric~2->proc~import_spatial_metric~2 interface~get_diffstar_spatial_metric get_diffstar_spatial_metric proc~import_spatial_metric~2->interface~get_diffstar_spatial_metric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function import_spatial_metric(THIS, x, y, z) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) Description Returns the \\texttt{LORENE} conformally flat spatial metric component g_{xx}=g_{yy}=g_{zz} at a point (x,y,z)","tags":"","loc":"interface/import_spatial_metric~2.html"},{"title":"is_hydro_negative – SPHINCS_LORENE","text":"interface Calls interface~~is_hydro_negative~2~~CallsGraph interface~is_hydro_negative~2 is_hydro_negative proc~is_hydro_negative~2 is_hydro_negative interface~is_hydro_negative~2->proc~is_hydro_negative~2 interface~negative_hydro~2 negative_hydro proc~is_hydro_negative~2->interface~negative_hydro~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module function is_hydro_negative(THIS, x, y, z) result(res) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Description Returns 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise","tags":"","loc":"interface/is_hydro_negative~2.html"},{"title":"negative_hydro – SPHINCS_LORENE","text":"interface Called by interface~~negative_hydro~2~~CalledByGraph interface~negative_hydro~2 negative_hydro proc~is_hydro_negative~2 is_hydro_negative proc~is_hydro_negative~2->interface~negative_hydro~2 interface~is_hydro_negative~2 is_hydro_negative interface~is_hydro_negative~2->proc~is_hydro_negative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. private function negative_hydro(optr, x, y, z) result(res) bind(C, NAME= \"is_hydro_negative\") Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value integer(kind=C_INT) 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Description Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that returns 1\n  if the energy density is nonpositive,\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive,\n  at the specified point; it returns 0 otherwise FT 24.10.2021","tags":"","loc":"interface/negative_hydro~2.html"},{"title":"print_diffstar_params – SPHINCS_LORENE","text":"interface Calls interface~~print_diffstar_params~~CallsGraph interface~print_diffstar_params print_diffstar_params proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~print_diffstar_params->k_lorene2hydrobase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~print_diffstar_params~~CalledByGraph interface~print_diffstar_params print_diffstar_params proc~import_diffstar_params import_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params interface~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params proc~construct_diffstarlorene construct_diffstarlorene proc~construct_diffstarlorene->interface~import_diffstar_params interface~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~diffstarlorene diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene var paninterfaceprint_diffstar_paramsCalledByGraph = svgPanZoom('#interfaceprint_diffstar_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. public module module subroutine print_diffstar_params(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Description Prints the DRS parameters to the standard output","tags":"","loc":"interface/print_diffstar_params.html"},{"title":"get_HC – SPHINCS_LORENE","text":"module procedure get_HC module module function get_HC(THIS, i, j, k, l) result(HC_value) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision Called by proc~~get_hc~~CalledByGraph proc~get_hc get_HC interface~get_hc get_HC interface~get_hc->proc~get_hc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_hc.html"},{"title":"get_HC_parts – SPHINCS_LORENE","text":"module procedure get_HC_parts module module function get_HC_parts(THIS, i, j, k, l) result(HC_value) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision Called by proc~~get_hc_parts~~CalledByGraph proc~get_hc_parts get_HC_parts interface~get_hc_parts get_HC_parts interface~get_hc_parts->proc~get_hc_parts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_hc_parts.html"},{"title":"get_MC – SPHINCS_LORENE","text":"module procedure get_MC module module function get_MC(THIS, i, j, k, l) result(MC_value) Interface → Uses tensor proc~~get_mc~~UsesGraph proc~get_mc get_MC tensor tensor proc~get_mc->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) Called by proc~~get_mc~~CalledByGraph proc~get_mc get_MC interface~get_mc get_MC interface~get_mc->proc~get_mc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_mc.html"},{"title":"get_MC_parts – SPHINCS_LORENE","text":"module procedure get_MC_parts module module function get_MC_parts(THIS, i, j, k, l) result(MC_value) Interface → Uses tensor proc~~get_mc_parts~~UsesGraph proc~get_mc_parts get_MC_parts tensor tensor proc~get_mc_parts->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) Called by proc~~get_mc_parts~~CalledByGraph proc~get_mc_parts get_MC_parts interface~get_mc_parts get_MC_parts interface~get_mc_parts->proc~get_mc_parts Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_mc_parts.html"},{"title":"get_dx – SPHINCS_LORENE","text":"module procedure get_dx module module function get_dx(THIS, l) result(dx) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision Called by proc~~get_dx~~CalledByGraph proc~get_dx get_dx interface~get_dx get_dx interface~get_dx->proc~get_dx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_dx.html"},{"title":"get_dy – SPHINCS_LORENE","text":"module procedure get_dy module module function get_dy(THIS, l) result(dy) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision Called by proc~~get_dy~~CalledByGraph proc~get_dy get_dy interface~get_dy get_dy interface~get_dy->proc~get_dy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_dy.html"},{"title":"get_dz – SPHINCS_LORENE","text":"module procedure get_dz module module function get_dz(THIS, l) result(dz) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision Called by proc~~get_dz~~CalledByGraph proc~get_dz get_dz interface~get_dz get_dz interface~get_dz->proc~get_dz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_dz.html"},{"title":"get_grid_point – SPHINCS_LORENE","text":"module procedure get_grid_point module module function get_grid_point(THIS, i, j, k, l) result(grid_point) Interface → Uses tensor proc~~get_grid_point~~UsesGraph proc~get_grid_point get_grid_point tensor tensor proc~get_grid_point->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) Called by proc~~get_grid_point~~CalledByGraph proc~get_grid_point get_grid_point interface~get_grid_point get_grid_point interface~get_grid_point->proc~get_grid_point Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_grid_point.html"},{"title":"get_levels – SPHINCS_LORENE","text":"module procedure get_levels module module function get_levels(THIS, l) result(levels) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value type(level),\n  DIMENSION(:),ALLOCATABLE Called by proc~~get_levels~~CalledByGraph proc~get_levels get_levels interface~get_levels get_levels interface~get_levels->proc~get_levels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_levels.html"},{"title":"get_ngrid_x – SPHINCS_LORENE","text":"module procedure get_ngrid_x module module function get_ngrid_x(THIS, l) result(ngrid_x) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer Called by proc~~get_ngrid_x~~CalledByGraph proc~get_ngrid_x get_ngrid_x interface~get_ngrid_x get_ngrid_x interface~get_ngrid_x->proc~get_ngrid_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ngrid_x.html"},{"title":"get_ngrid_y – SPHINCS_LORENE","text":"module procedure get_ngrid_y module module function get_ngrid_y(THIS, l) result(ngrid_y) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer Called by proc~~get_ngrid_y~~CalledByGraph proc~get_ngrid_y get_ngrid_y interface~get_ngrid_y get_ngrid_y interface~get_ngrid_y->proc~get_ngrid_y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ngrid_y.html"},{"title":"get_ngrid_z – SPHINCS_LORENE","text":"module procedure get_ngrid_z module module function get_ngrid_z(THIS, l) result(ngrid_z) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer Called by proc~~get_ngrid_z~~CalledByGraph proc~get_ngrid_z get_ngrid_z interface~get_ngrid_z get_ngrid_z interface~get_ngrid_z->proc~get_ngrid_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ngrid_z.html"},{"title":"get_nlevels – SPHINCS_LORENE","text":"module procedure get_nlevels module module function get_nlevels(THIS) result(nlevels) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS Return Value double precision Called by proc~~get_nlevels~~CalledByGraph proc~get_nlevels get_nlevels interface~get_nlevels get_nlevels interface~get_nlevels->proc~get_nlevels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nlevels.html"},{"title":"get_xR – SPHINCS_LORENE","text":"module procedure get_xR module module function get_xR(THIS, l) result(xR) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer Called by proc~~get_xr~~CalledByGraph proc~get_xr get_xR interface~get_xr get_xR interface~get_xr->proc~get_xr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_xr.html"},{"title":"get_yR – SPHINCS_LORENE","text":"module procedure get_yR module module function get_yR(THIS, l) result(yR) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer Called by proc~~get_yr~~CalledByGraph proc~get_yr get_yR interface~get_yr get_yR interface~get_yr->proc~get_yr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_yr.html"},{"title":"get_zR – SPHINCS_LORENE","text":"module procedure get_zR module module function get_zR(THIS, l) result(zR) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer Called by proc~~get_zr~~CalledByGraph proc~get_zr get_zR interface~get_zr get_zR interface~get_zr->proc~get_zr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_zr.html"},{"title":"deallocate_standard3p1_variables – SPHINCS_LORENE","text":"module procedure deallocate_standard3p1_variables module module subroutine deallocate_standard3p1_variables(f3p1) Interface → Uses mesh_refinement proc~~deallocate_standard3p1_variables~~UsesGraph proc~deallocate_standard3p1_variables deallocate_standard3p1_variables mesh_refinement mesh_refinement proc~deallocate_standard3p1_variables->mesh_refinement Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Core of the destructors of TYPES derived from   *\n  formul_3p1. Their destructors should call this  *\n  SUBROUTINE. It deallocates memory.              *\n                                                  *\n  FT                                              *\n                                                  * Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 Calls proc~~deallocate_standard3p1_variables~~CallsGraph proc~deallocate_standard3p1_variables deallocate_standard3p1_variables deallocate_grid_function deallocate_grid_function proc~deallocate_standard3p1_variables->deallocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~deallocate_standard3p1_variables~~CalledByGraph proc~deallocate_standard3p1_variables deallocate_standard3p1_variables interface~deallocate_standard3p1_variables deallocate_standard3p1_variables interface~deallocate_standard3p1_variables->proc~deallocate_standard3p1_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/deallocate_standard3p1_variables.html"},{"title":"setup_standard3p1_variables – SPHINCS_LORENE","text":"module procedure setup_standard3p1_variables module module subroutine setup_standard3p1_variables(f3p1, id, dx, dy, dz) Interface → Uses tensor mesh_refinement utility proc~~setup_standard3p1_variables~~UsesGraph proc~setup_standard3p1_variables setup_standard3p1_variables tensor tensor proc~setup_standard3p1_variables->tensor mesh_refinement mesh_refinement proc~setup_standard3p1_variables->mesh_refinement module~utility utility proc~setup_standard3p1_variables->module~utility matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Read the gravity grid parameters, computes    *\n  gravity grid coordinates, imports the LORENE  *\n  spacetime ID on the gravity grid, and         *\n  performs some checks on it.                   *\n  Its input includes the numbers of grid points *\n  per axis, contrary to                         *\n  construct_formul_3p1_bns_grid                 *\n  where those numbers are replaced by the grid  *\n  spacings.                                     *\n                                                *\n  FT 22.10.2020                                 *\n                                                * Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Calls proc~~setup_standard3p1_variables~~CallsGraph proc~setup_standard3p1_variables setup_standard3p1_variables allocate_grid_function allocate_grid_function proc~setup_standard3p1_variables->allocate_grid_function deallocate_grid_function deallocate_grid_function proc~setup_standard3p1_variables->deallocate_grid_function levels levels proc~setup_standard3p1_variables->levels timer timer proc~setup_standard3p1_variables->timer initialize_grid initialize_grid proc~setup_standard3p1_variables->initialize_grid proc~determinant_sym3x3_grid determinant_sym3x3_grid proc~setup_standard3p1_variables->proc~determinant_sym3x3_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup_standard3p1_variables~~CalledByGraph proc~setup_standard3p1_variables setup_standard3p1_variables interface~setup_standard3p1_variables setup_standard3p1_variables interface~setup_standard3p1_variables->proc~setup_standard3p1_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables detg i j k l system_size Variables Type Visibility Attributes Name Initial double precision, private :: detg integer, private :: i integer, private :: j integer, private :: k integer, private :: l double precision, private, DIMENSION(6) :: system_size","tags":"","loc":"proc/setup_standard3p1_variables.html"},{"title":"abs_values_in – SPHINCS_LORENE","text":"module procedure abs_values_in module module subroutine abs_values_in(THIS, lower_bound, upper_bound, constraint, l, export, unit_analysis, cnt) Interface → Uses tensor proc~~abs_values_in~~UsesGraph proc~abs_values_in abs_values_in tensor tensor proc~abs_values_in->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS double precision :: lower_bound double precision :: upper_bound double precision, intent(in), DIMENSION(:,:,:) :: constraint integer, intent(in) :: l logical, intent(in) :: export integer, intent(in) :: unit_analysis integer, intent(out) :: cnt Called by proc~~abs_values_in~~CalledByGraph proc~abs_values_in abs_values_in interface~abs_values_in abs_values_in interface~abs_values_in->proc~abs_values_in Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j k nx ny nz Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: k integer, private :: nx integer, private :: ny integer, private :: nz","tags":"","loc":"proc/abs_values_in.html"},{"title":"analyze_constraint – SPHINCS_LORENE","text":"module procedure analyze_constraint module module subroutine analyze_constraint(THIS, l, constraint, name_constraint, unit_logfile, name_analysis, l2_norm, loo_norm) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l double precision, intent(in), DIMENSION(:,:,:) :: constraint character(len=*), intent(in) :: name_constraint integer, intent(in) :: unit_logfile character(len=*), intent(in) :: name_analysis double precision, intent(out) :: l2_norm double precision, intent(out) :: loo_norm Called by proc~~analyze_constraint~~CalledByGraph proc~analyze_constraint analyze_constraint interface~analyze_constraint analyze_constraint interface~analyze_constraint->proc~analyze_constraint Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables DEBUG cnt_0 cnt_m1 cnt_m2 cnt_m3 cnt_m4 cnt_m5 cnt_m6 cnt_m7 cnt_oo cnt_p1 cnt_p2 cnt_p3 exist grid_points i j k nx ny nz tmp total unit_analysis Variables Type Visibility Attributes Name Initial logical, private, parameter :: DEBUG = .FALSE. integer, private :: cnt_0 integer, private :: cnt_m1 integer, private :: cnt_m2 integer, private :: cnt_m3 integer, private :: cnt_m4 integer, private :: cnt_m5 integer, private :: cnt_m6 integer, private :: cnt_m7 integer, private :: cnt_oo integer, private :: cnt_p1 integer, private :: cnt_p2 integer, private :: cnt_p3 logical, private :: exist integer, private :: grid_points integer, private :: i integer, private :: j integer, private :: k integer, private :: nx integer, private :: ny integer, private :: nz double precision, private :: tmp double precision, private :: total integer, private :: unit_analysis","tags":"","loc":"proc/analyze_constraint.html"},{"title":"compute_and_export_bssn_variables – SPHINCS_LORENE","text":"module procedure compute_and_export_bssn_variables module module subroutine compute_and_export_bssn_variables(THIS, namefile) Interface → Uses constants GravityAcceleration_refine ADM_refine BSSN_refine mesh_refinement Tmunu_refine tensor McLachlan_refine proc~~compute_and_export_bssn_variables~~UsesGraph proc~compute_and_export_bssn_variables compute_and_export_bssn_variables constants constants proc~compute_and_export_bssn_variables->constants GravityAcceleration_refine GravityAcceleration_refine proc~compute_and_export_bssn_variables->GravityAcceleration_refine ADM_refine ADM_refine proc~compute_and_export_bssn_variables->ADM_refine BSSN_refine BSSN_refine proc~compute_and_export_bssn_variables->BSSN_refine mesh_refinement mesh_refinement proc~compute_and_export_bssn_variables->mesh_refinement Tmunu_refine Tmunu_refine proc~compute_and_export_bssn_variables->Tmunu_refine tensor tensor proc~compute_and_export_bssn_variables->tensor McLachlan_refine McLachlan_refine proc~compute_and_export_bssn_variables->McLachlan_refine Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile Calls proc~~compute_and_export_bssn_variables~~CallsGraph proc~compute_and_export_bssn_variables compute_and_export_bssn_variables allocate_gravityacceleration allocate_gravityacceleration proc~compute_and_export_bssn_variables->allocate_gravityacceleration adm_to_bssn adm_to_bssn proc~compute_and_export_bssn_variables->adm_to_bssn allocate_grid_function allocate_grid_function proc~compute_and_export_bssn_variables->allocate_grid_function allocate_bssn allocate_bssn proc~compute_and_export_bssn_variables->allocate_bssn deallocate_grid_function deallocate_grid_function proc~compute_and_export_bssn_variables->deallocate_grid_function deallocate_tmunu deallocate_tmunu proc~compute_and_export_bssn_variables->deallocate_tmunu allocate_tmunu allocate_tmunu proc~compute_and_export_bssn_variables->allocate_tmunu allocate_ztmp allocate_ztmp proc~compute_and_export_bssn_variables->allocate_ztmp levels levels proc~compute_and_export_bssn_variables->levels allocate_adm allocate_adm proc~compute_and_export_bssn_variables->allocate_adm deallocate_adm deallocate_adm proc~compute_and_export_bssn_variables->deallocate_adm deallocate_ztmp deallocate_ztmp proc~compute_and_export_bssn_variables->deallocate_ztmp write_bssn_dump write_bssn_dump proc~compute_and_export_bssn_variables->write_bssn_dump deallocate_gravityacceleration deallocate_gravityacceleration proc~compute_and_export_bssn_variables->deallocate_gravityacceleration deallocate_bssn deallocate_bssn proc~compute_and_export_bssn_variables->deallocate_bssn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~compute_and_export_bssn_variables~~CalledByGraph proc~compute_and_export_bssn_variables compute_and_export_bssn_variables interface~compute_and_export_bssn_variables compute_and_export_bssn_variables interface~compute_and_export_bssn_variables->proc~compute_and_export_bssn_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables call_flag l Variables Type Visibility Attributes Name Initial integer, private, SAVE :: call_flag = 0 integer, private :: l","tags":"","loc":"proc/compute_and_export_bssn_variables.html"},{"title":"print_formatted_lorene_id_bssn_variables – SPHINCS_LORENE","text":"module procedure print_formatted_lorene_id_bssn_variables module module subroutine print_formatted_lorene_id_bssn_variables(THIS, namefile) Interface → Uses tensor proc~~print_formatted_lorene_id_bssn_variables~~UsesGraph proc~print_formatted_lorene_id_bssn_variables print_formatted_lorene_id_bssn_variables tensor tensor proc~print_formatted_lorene_id_bssn_variables->tensor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile Calls proc~~print_formatted_lorene_id_bssn_variables~~CallsGraph proc~print_formatted_lorene_id_bssn_variables print_formatted_lorene_id_bssn_variables a_bssn3_ll a_bssn3_ll proc~print_formatted_lorene_id_bssn_variables->a_bssn3_ll gamma_u gamma_u proc~print_formatted_lorene_id_bssn_variables->gamma_u trk trk proc~print_formatted_lorene_id_bssn_variables->trk lapse lapse proc~print_formatted_lorene_id_bssn_variables->lapse phi phi proc~print_formatted_lorene_id_bssn_variables->phi shift_u shift_u proc~print_formatted_lorene_id_bssn_variables->shift_u g_bssn3_ll g_bssn3_ll proc~print_formatted_lorene_id_bssn_variables->g_bssn3_ll Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~print_formatted_lorene_id_bssn_variables~~CalledByGraph proc~print_formatted_lorene_id_bssn_variables print_formatted_lorene_id_bssn_variables interface~print_formatted_lorene_id_bssn_variables print_formatted_lorene_id_bssn_variables interface~print_formatted_lorene_id_bssn_variables->proc~print_formatted_lorene_id_bssn_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables exist finalnamefile i j k l min_abs_y min_abs_z min_ix_y min_ix_z min_iy_y min_iy_z min_iz_y min_iz_z Variables Type Visibility Attributes Name Initial logical, private :: exist character(len=:), private, ALLOCATABLE :: finalnamefile integer, private :: i integer, private :: j integer, private :: k integer, private :: l double precision, private :: min_abs_y double precision, private :: min_abs_z integer, private :: min_ix_y integer, private :: min_ix_z integer, private :: min_iy_y integer, private :: min_iy_z integer, private :: min_iz_y integer, private :: min_iz_z","tags":"","loc":"proc/print_formatted_lorene_id_bssn_variables.html"},{"title":"read_bssn_dump_print_formatted – SPHINCS_LORENE","text":"module procedure read_bssn_dump_print_formatted module module subroutine read_bssn_dump_print_formatted(THIS, namefile_bin, namefile) Interface → Uses tensor BSSN_refine mesh_refinement ADM_refine proc~~read_bssn_dump_print_formatted~~UsesGraph proc~read_bssn_dump_print_formatted read_bssn_dump_print_formatted tensor tensor proc~read_bssn_dump_print_formatted->tensor BSSN_refine BSSN_refine proc~read_bssn_dump_print_formatted->BSSN_refine mesh_refinement mesh_refinement proc~read_bssn_dump_print_formatted->mesh_refinement ADM_refine ADM_refine proc~read_bssn_dump_print_formatted->ADM_refine Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile_bin character(len=*), intent(inout), optional :: namefile Calls proc~~read_bssn_dump_print_formatted~~CallsGraph proc~read_bssn_dump_print_formatted read_bssn_dump_print_formatted a_bssn3_ll a_bssn3_ll proc~read_bssn_dump_print_formatted->a_bssn3_ll allocate_bssn allocate_bssn proc~read_bssn_dump_print_formatted->allocate_bssn read_bssn_dump read_bssn_dump proc~read_bssn_dump_print_formatted->read_bssn_dump lapse lapse proc~read_bssn_dump_print_formatted->lapse allocate_adm allocate_adm proc~read_bssn_dump_print_formatted->allocate_adm shift_u shift_u proc~read_bssn_dump_print_formatted->shift_u deallocate_adm deallocate_adm proc~read_bssn_dump_print_formatted->deallocate_adm trk trk proc~read_bssn_dump_print_formatted->trk gamma_u gamma_u proc~read_bssn_dump_print_formatted->gamma_u phi phi proc~read_bssn_dump_print_formatted->phi g_bssn3_ll g_bssn3_ll proc~read_bssn_dump_print_formatted->g_bssn3_ll deallocate_bssn deallocate_bssn proc~read_bssn_dump_print_formatted->deallocate_bssn Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_bssn_dump_print_formatted~~CalledByGraph proc~read_bssn_dump_print_formatted read_bssn_dump_print_formatted interface~read_bssn_dump_print_formatted read_bssn_dump_print_formatted interface~read_bssn_dump_print_formatted->proc~read_bssn_dump_print_formatted Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables exist finalnamefile i j k l min_abs_y min_abs_z min_ix_y min_ix_z min_iy_y min_iy_z min_iz_y min_iz_z Variables Type Visibility Attributes Name Initial logical, private :: exist character(len=:), private, ALLOCATABLE :: finalnamefile integer, private :: i integer, private :: j integer, private :: k integer, private :: l double precision, private :: min_abs_y double precision, private :: min_abs_z integer, private :: min_ix_y integer, private :: min_ix_z integer, private :: min_iy_y integer, private :: min_iy_z integer, private :: min_iz_y integer, private :: min_iz_z","tags":"","loc":"proc/read_bssn_dump_print_formatted.html"},{"title":"allocate_bssn_fields – SPHINCS_LORENE","text":"module procedure allocate_bssn_fields module module subroutine allocate_bssn_fields(THIS) Interface → Uses mesh_refinement proc~~allocate_bssn_fields~~UsesGraph proc~allocate_bssn_fields allocate_bssn_fields mesh_refinement mesh_refinement proc~allocate_bssn_fields->mesh_refinement Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS Calls proc~~allocate_bssn_fields~~CallsGraph proc~allocate_bssn_fields allocate_bssn_fields allocate_grid_function allocate_grid_function proc~allocate_bssn_fields->allocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~allocate_bssn_fields~~CalledByGraph proc~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields->proc~allocate_bssn_fields proc~construct_bssn_id construct_bssn_id proc~construct_bssn_id->interface~allocate_bssn_fields interface~construct_bssn_id construct_bssn_id interface~construct_bssn_id->proc~construct_bssn_id interface~bssn_id bssn_id interface~bssn_id->interface~construct_bssn_id program~convergence_test convergence_test program~convergence_test->interface~bssn_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~bssn_id var panprocallocate_bssn_fieldsCalledByGraph = svgPanZoom('#procallocate_bssn_fieldsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_bssn_fields.html"},{"title":"deallocate_bssn_fields – SPHINCS_LORENE","text":"module procedure deallocate_bssn_fields module module subroutine deallocate_bssn_fields(THIS) Interface → Uses mesh_refinement proc~~deallocate_bssn_fields~~UsesGraph proc~deallocate_bssn_fields deallocate_bssn_fields mesh_refinement mesh_refinement proc~deallocate_bssn_fields->mesh_refinement Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS Calls proc~~deallocate_bssn_fields~~CallsGraph proc~deallocate_bssn_fields deallocate_bssn_fields deallocate_grid_function deallocate_grid_function proc~deallocate_bssn_fields->deallocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~deallocate_bssn_fields~~CalledByGraph proc~deallocate_bssn_fields deallocate_bssn_fields interface~deallocate_bssn_fields deallocate_bssn_fields interface~deallocate_bssn_fields->proc~deallocate_bssn_fields proc~destruct_bssn_id destruct_bssn_id proc~destruct_bssn_id->interface~deallocate_bssn_fields interface~destruct_bssn_id destruct_bssn_id interface~destruct_bssn_id->proc~destruct_bssn_id proc~destructor destructor proc~destructor->interface~destruct_bssn_id interface~destructor destructor interface~destructor->proc~destructor var panprocdeallocate_bssn_fieldsCalledByGraph = svgPanZoom('#procdeallocate_bssn_fieldsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/deallocate_bssn_fields.html"},{"title":"compute_and_export_bssn_constraints_grid – SPHINCS_LORENE","text":"module procedure compute_and_export_bssn_constraints_grid module module subroutine compute_and_export_bssn_constraints_grid(THIS, id, namefile, name_logfile) Interface → Uses matrix constants mesh_refinement tensor McLachlan_refine proc~~compute_and_export_bssn_constraints_grid~~UsesGraph proc~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid matrix matrix proc~compute_and_export_bssn_constraints_grid->matrix constants constants proc~compute_and_export_bssn_constraints_grid->constants mesh_refinement mesh_refinement proc~compute_and_export_bssn_constraints_grid->mesh_refinement tensor tensor proc~compute_and_export_bssn_constraints_grid->tensor McLachlan_refine McLachlan_refine proc~compute_and_export_bssn_constraints_grid->McLachlan_refine Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. DEALLOCATE( u_coord )\nDEALLOCATE( u_coord_l ) Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile Calls proc~~compute_and_export_bssn_constraints_grid~~CallsGraph proc~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid g_bssn3_ll g_bssn3_ll proc~compute_and_export_bssn_constraints_grid->g_bssn3_ll a_bssn3_ll a_bssn3_ll proc~compute_and_export_bssn_constraints_grid->a_bssn3_ll allocate_grid_function allocate_grid_function proc~compute_and_export_bssn_constraints_grid->allocate_grid_function g_phys3_ll g_phys3_ll proc~compute_and_export_bssn_constraints_grid->g_phys3_ll proc~compute_g4 compute_g4 proc~compute_and_export_bssn_constraints_grid->proc~compute_g4 proc~determinant_sym4x4_grid determinant_sym4x4_grid proc~compute_and_export_bssn_constraints_grid->proc~determinant_sym4x4_grid gc gc proc~compute_and_export_bssn_constraints_grid->gc lapse lapse proc~compute_and_export_bssn_constraints_grid->lapse levels levels proc~compute_and_export_bssn_constraints_grid->levels shift_u shift_u proc~compute_and_export_bssn_constraints_grid->shift_u bssn_constraints_interior bssn_constraints_interior proc~compute_and_export_bssn_constraints_grid->bssn_constraints_interior mc mc proc~compute_and_export_bssn_constraints_grid->mc trk trk proc~compute_and_export_bssn_constraints_grid->trk gamma_u gamma_u proc~compute_and_export_bssn_constraints_grid->gamma_u invert_4x4_matrix invert_4x4_matrix proc~compute_and_export_bssn_constraints_grid->invert_4x4_matrix hc hc proc~compute_and_export_bssn_constraints_grid->hc phi phi proc~compute_and_export_bssn_constraints_grid->phi k_phys3_ll k_phys3_ll proc~compute_and_export_bssn_constraints_grid->k_phys3_ll Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~compute_and_export_bssn_constraints_grid~~CalledByGraph proc~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid interface~compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_grid interface~compute_and_export_bssn_constraints_grid->proc~compute_and_export_bssn_constraints_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables HC_A HC_derphi HC_hand HC_rho HC_trK Tmunu_ll abs_grid baryon_density debug detg4 energy_density exist fd_lim finalname_logfile g4 g4temp i ig4 imax imin j k l lorentz_factor min_abs_y min_abs_z min_ix_y min_ix_z min_iy_y min_iy_z min_iz_y min_iz_z n_reflev name_analysis name_constraint pressure specific_energy u_euler_l u_euler_norm unit_logfile v_euler v_euler_l Variables Type Visibility Attributes Name Initial type(grid_function_scalar), private :: HC_A type(grid_function_scalar), private :: HC_derphi type(grid_function_scalar), private :: HC_hand type(grid_function_scalar), private :: HC_rho type(grid_function_scalar), private :: HC_trK type(grid_function), private :: Tmunu_ll double precision, private, DIMENSION( :, :, :, : ), ALLOCATABLE :: abs_grid type(grid_function_scalar), private :: baryon_density logical, private, parameter :: debug = .FALSE. double precision, private :: detg4 type(grid_function_scalar), private :: energy_density logical, private :: exist integer, private :: fd_lim character(len=:), private, ALLOCATABLE :: finalname_logfile type(grid_function), private :: g4 double precision, private, DIMENSION( 4, 4 ) :: g4temp integer, private :: i double precision, private, DIMENSION( 4, 4 ) :: ig4 integer, private, DIMENSION(3) :: imax integer, private, DIMENSION(3) :: imin integer, private :: j integer, private :: k integer, private :: l type(grid_function_scalar), private :: lorentz_factor double precision, private :: min_abs_y double precision, private :: min_abs_z integer, private :: min_ix_y integer, private :: min_ix_z integer, private :: min_iy_y integer, private :: min_iy_z integer, private :: min_iz_y integer, private :: min_iz_z character(len=2), private :: n_reflev character(len=:), private, ALLOCATABLE :: name_analysis character(len=:), private, ALLOCATABLE :: name_constraint type(grid_function_scalar), private :: pressure type(grid_function_scalar), private :: specific_energy type(grid_function), private :: u_euler_l double precision, private :: u_euler_norm = 0.0D0 integer, private :: unit_logfile type(grid_function), private :: v_euler type(grid_function), private :: v_euler_l","tags":"","loc":"proc/compute_and_export_bssn_constraints_grid.html"},{"title":"compute_and_export_bssn_constraints_particles – SPHINCS_LORENE","text":"module procedure compute_and_export_bssn_constraints_particles module module subroutine compute_and_export_bssn_constraints_particles(THIS, parts_obj, namefile, name_logfile) Interface → Uses BSSN_refine Tmunu_refine units RCB_tree_3D map_particles_2_grid set_h sph_variables constants options particle_mesh_hash input_output particle_mesh tensor GravityAcceleration_refine sphincs_sph McLachlan_refine ADM_refine alive_flag mesh_refinement gradient kernel_table metric_on_particles proc~~compute_and_export_bssn_constraints_particles~~UsesGraph proc~compute_and_export_bssn_constraints_particles compute_and_export_bssn_constraints_particles BSSN_refine BSSN_refine proc~compute_and_export_bssn_constraints_particles->BSSN_refine Tmunu_refine Tmunu_refine proc~compute_and_export_bssn_constraints_particles->Tmunu_refine units units proc~compute_and_export_bssn_constraints_particles->units RCB_tree_3D RCB_tree_3D proc~compute_and_export_bssn_constraints_particles->RCB_tree_3D map_particles_2_grid map_particles_2_grid proc~compute_and_export_bssn_constraints_particles->map_particles_2_grid set_h set_h proc~compute_and_export_bssn_constraints_particles->set_h sph_variables sph_variables proc~compute_and_export_bssn_constraints_particles->sph_variables constants constants proc~compute_and_export_bssn_constraints_particles->constants options options proc~compute_and_export_bssn_constraints_particles->options particle_mesh_hash particle_mesh_hash proc~compute_and_export_bssn_constraints_particles->particle_mesh_hash input_output input_output proc~compute_and_export_bssn_constraints_particles->input_output particle_mesh particle_mesh proc~compute_and_export_bssn_constraints_particles->particle_mesh tensor tensor proc~compute_and_export_bssn_constraints_particles->tensor GravityAcceleration_refine GravityAcceleration_refine proc~compute_and_export_bssn_constraints_particles->GravityAcceleration_refine McLachlan_refine McLachlan_refine proc~compute_and_export_bssn_constraints_particles->McLachlan_refine sphincs_sph sphincs_sph proc~compute_and_export_bssn_constraints_particles->sphincs_sph ADM_refine ADM_refine proc~compute_and_export_bssn_constraints_particles->ADM_refine alive_flag alive_flag proc~compute_and_export_bssn_constraints_particles->alive_flag mesh_refinement mesh_refinement proc~compute_and_export_bssn_constraints_particles->mesh_refinement gradient gradient proc~compute_and_export_bssn_constraints_particles->gradient kernel_table kernel_table proc~compute_and_export_bssn_constraints_particles->kernel_table metric_on_particles metric_on_particles proc~compute_and_export_bssn_constraints_particles->metric_on_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile Calls proc~~compute_and_export_bssn_constraints_particles~~CallsGraph proc~compute_and_export_bssn_constraints_particles compute_and_export_bssn_constraints_particles iorig iorig proc~compute_and_export_bssn_constraints_particles->iorig allocate_metric_on_particles allocate_metric_on_particles proc~compute_and_export_bssn_constraints_particles->allocate_metric_on_particles deallocate_metric_on_particles deallocate_metric_on_particles proc~compute_and_export_bssn_constraints_particles->deallocate_metric_on_particles allocate_rcb_tree_memory_3d allocate_rcb_tree_memory_3d proc~compute_and_export_bssn_constraints_particles->allocate_rcb_tree_memory_3d levels levels proc~compute_and_export_bssn_constraints_particles->levels deallocate_adm deallocate_adm proc~compute_and_export_bssn_constraints_particles->deallocate_adm deallocate_pp_g deallocate_pp_g proc~compute_and_export_bssn_constraints_particles->deallocate_pp_g read_options read_options proc~compute_and_export_bssn_constraints_particles->read_options allocate_ztmp allocate_ztmp proc~compute_and_export_bssn_constraints_particles->allocate_ztmp allocate_gradient allocate_gradient proc~compute_and_export_bssn_constraints_particles->allocate_gradient lapse lapse proc~compute_and_export_bssn_constraints_particles->lapse get_metric_on_particles get_metric_on_particles proc~compute_and_export_bssn_constraints_particles->get_metric_on_particles set_units set_units proc~compute_and_export_bssn_constraints_particles->set_units shift_u shift_u proc~compute_and_export_bssn_constraints_particles->shift_u deallocate_bssn deallocate_bssn proc~compute_and_export_bssn_constraints_particles->deallocate_bssn deallocate_rcb_tree_memory_3d deallocate_rcb_tree_memory_3d proc~compute_and_export_bssn_constraints_particles->deallocate_rcb_tree_memory_3d a_bssn3_ll a_bssn3_ll proc~compute_and_export_bssn_constraints_particles->a_bssn3_ll allocate_gravityacceleration allocate_gravityacceleration proc~compute_and_export_bssn_constraints_particles->allocate_gravityacceleration allocate_grid_function allocate_grid_function proc~compute_and_export_bssn_constraints_particles->allocate_grid_function allocate_bssn allocate_bssn proc~compute_and_export_bssn_constraints_particles->allocate_bssn deallocate_grid_function deallocate_grid_function proc~compute_and_export_bssn_constraints_particles->deallocate_grid_function hc_parts hc_parts proc~compute_and_export_bssn_constraints_particles->hc_parts alive alive proc~compute_and_export_bssn_constraints_particles->alive allocate_sph_memory allocate_sph_memory proc~compute_and_export_bssn_constraints_particles->allocate_sph_memory allocate_adm allocate_adm proc~compute_and_export_bssn_constraints_particles->allocate_adm deallocate_hash_memory deallocate_hash_memory proc~compute_and_export_bssn_constraints_particles->deallocate_hash_memory map_2_grid_hash map_2_grid_hash proc~compute_and_export_bssn_constraints_particles->map_2_grid_hash deallocate_all_lists deallocate_all_lists proc~compute_and_export_bssn_constraints_particles->deallocate_all_lists phi phi proc~compute_and_export_bssn_constraints_particles->phi g_bssn3_ll g_bssn3_ll proc~compute_and_export_bssn_constraints_particles->g_bssn3_ll exact_nei_tree_update exact_nei_tree_update proc~compute_and_export_bssn_constraints_particles->exact_nei_tree_update deallocate_gradient deallocate_gradient proc~compute_and_export_bssn_constraints_particles->deallocate_gradient gc_parts gc_parts proc~compute_and_export_bssn_constraints_particles->gc_parts deallocate_flag_nei_cell deallocate_flag_nei_cell proc~compute_and_export_bssn_constraints_particles->deallocate_flag_nei_cell allocate_tmunu allocate_tmunu proc~compute_and_export_bssn_constraints_particles->allocate_tmunu deallocate_tmunu deallocate_tmunu proc~compute_and_export_bssn_constraints_particles->deallocate_tmunu deallocate_sph_memory deallocate_sph_memory proc~compute_and_export_bssn_constraints_particles->deallocate_sph_memory mc_parts mc_parts proc~compute_and_export_bssn_constraints_particles->mc_parts bssn_constraints_interior bssn_constraints_interior proc~compute_and_export_bssn_constraints_particles->bssn_constraints_interior deallocate_ztmp deallocate_ztmp proc~compute_and_export_bssn_constraints_particles->deallocate_ztmp trk trk proc~compute_and_export_bssn_constraints_particles->trk gamma_u gamma_u proc~compute_and_export_bssn_constraints_particles->gamma_u deallocate_gravityacceleration deallocate_gravityacceleration proc~compute_and_export_bssn_constraints_particles->deallocate_gravityacceleration k_phys3_ll k_phys3_ll proc~compute_and_export_bssn_constraints_particles->k_phys3_ll Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~compute_and_export_bssn_constraints_particles~~CalledByGraph proc~compute_and_export_bssn_constraints_particles compute_and_export_bssn_constraints_particles interface~compute_and_export_bssn_constraints_particles compute_and_export_bssn_constraints_particles interface~compute_and_export_bssn_constraints_particles->proc~compute_and_export_bssn_constraints_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a abs_grid allocation_status counter debug exist finalname_logfile i imax imin j k l min_abs_y min_abs_z min_ix_y min_ix_z min_iy_y min_iy_z min_iz_y min_iz_z n_reflev name_analysis name_constraint nlrf_loc nu_loc pos_loc pressure_loc sph_density theta_loc u_loc unit_logfile vel_loc Variables Type Visibility Attributes Name Initial integer, private :: a double precision, private, DIMENSION( :, :, :, : ), ALLOCATABLE :: abs_grid integer, private :: allocation_status integer, private, SAVE :: counter = 1 logical, private, parameter :: debug = .FALSE. logical, private :: exist character(len=:), private, ALLOCATABLE :: finalname_logfile integer, private :: i integer, private, DIMENSION(3) :: imax integer, private, DIMENSION(3) :: imin integer, private :: j integer, private :: k integer, private :: l double precision, private :: min_abs_y double precision, private :: min_abs_z integer, private :: min_ix_y integer, private :: min_ix_z integer, private :: min_iy_y integer, private :: min_iy_z integer, private :: min_iz_y integer, private :: min_iz_z character(len=2), private :: n_reflev character(len=:), private, ALLOCATABLE :: name_analysis character(len=:), private, ALLOCATABLE :: name_constraint double precision, private, DIMENSION(:), ALLOCATABLE :: nlrf_loc double precision, private, DIMENSION(:), ALLOCATABLE :: nu_loc double precision, private, DIMENSION(:,:), ALLOCATABLE :: pos_loc double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_loc double precision, private, DIMENSION(:), ALLOCATABLE :: sph_density double precision, private, DIMENSION(:), ALLOCATABLE :: theta_loc double precision, private, DIMENSION(:), ALLOCATABLE :: u_loc integer, private :: unit_logfile double precision, private, DIMENSION(:,:), ALLOCATABLE :: vel_loc","tags":"","loc":"proc/compute_and_export_bssn_constraints_particles.html"},{"title":"construct_bssn_id – SPHINCS_LORENE","text":"module procedure construct_bssn_id module module function construct_bssn_id(id, dx, dy, dz) result(bssnid) Interface → Uses mesh_refinement McLachlan_refine Extract_Mass proc~~construct_bssn_id~~UsesGraph proc~construct_bssn_id construct_bssn_id mesh_refinement mesh_refinement proc~construct_bssn_id->mesh_refinement McLachlan_refine McLachlan_refine proc~construct_bssn_id->McLachlan_refine Extract_Mass Extract_Mass proc~construct_bssn_id->Extract_Mass Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. This constructor of TYPE bssn_id calls the       *\n  SUBROUTINES that rely on an bns object, and      *\n  allocates memory. It constructs the grid         *\n  using the number of grid points along each axis. *\n                                                   *\n  FT 23.10.2020                                    *\n                                                   * Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Return Value type( bssn_id ) Calls proc~~construct_bssn_id~~CallsGraph proc~construct_bssn_id construct_bssn_id initialize_bssn initialize_bssn proc~construct_bssn_id->initialize_bssn interface~allocate_bssn_fields allocate_bssn_fields proc~construct_bssn_id->interface~allocate_bssn_fields timer timer proc~construct_bssn_id->timer deallocate_bssn deallocate_bssn proc~construct_bssn_id->deallocate_bssn proc~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields->proc~allocate_bssn_fields allocate_grid_function allocate_grid_function proc~allocate_bssn_fields->allocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~construct_bssn_id~~CalledByGraph proc~construct_bssn_id construct_bssn_id interface~construct_bssn_id construct_bssn_id interface~construct_bssn_id->proc~construct_bssn_id interface~bssn_id bssn_id interface~bssn_id->interface~construct_bssn_id program~convergence_test convergence_test program~convergence_test->interface~bssn_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~bssn_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/construct_bssn_id.html"},{"title":"destruct_bssn_id – SPHINCS_LORENE","text":"module procedure destruct_bssn_id module module subroutine destruct_bssn_id(THIS) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS Calls proc~~destruct_bssn_id~~CallsGraph proc~destruct_bssn_id destruct_bssn_id interface~deallocate_bssn_fields deallocate_bssn_fields proc~destruct_bssn_id->interface~deallocate_bssn_fields proc~deallocate_bssn_fields deallocate_bssn_fields interface~deallocate_bssn_fields->proc~deallocate_bssn_fields deallocate_grid_function deallocate_grid_function proc~deallocate_bssn_fields->deallocate_grid_function Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~destruct_bssn_id~~CalledByGraph proc~destruct_bssn_id destruct_bssn_id interface~destruct_bssn_id destruct_bssn_id interface~destruct_bssn_id->proc~destruct_bssn_id proc~destructor destructor proc~destructor->interface~destruct_bssn_id interface~destructor destructor interface~destructor->proc~destructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destruct_bssn_id.html"},{"title":"destructor – SPHINCS_LORENE","text":"module procedure destructor module module subroutine destructor(THIS) Interface → Arguments Type Intent Optional Attributes Name type( bssn_id ), intent(inout) :: THIS Calls proc~~destructor~~CallsGraph proc~destructor destructor interface~destruct_bssn_id destruct_bssn_id proc~destructor->interface~destruct_bssn_id deallocate_standard3p1_variables deallocate_standard3p1_variables proc~destructor->deallocate_standard3p1_variables proc~destruct_bssn_id destruct_bssn_id interface~destruct_bssn_id->proc~destruct_bssn_id interface~deallocate_bssn_fields deallocate_bssn_fields proc~destruct_bssn_id->interface~deallocate_bssn_fields proc~deallocate_bssn_fields deallocate_bssn_fields interface~deallocate_bssn_fields->proc~deallocate_bssn_fields deallocate_grid_function deallocate_grid_function proc~deallocate_bssn_fields->deallocate_grid_function var panprocdestructorCallsGraph = svgPanZoom('#procdestructorCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~destructor~~CalledByGraph proc~destructor destructor interface~destructor destructor interface~destructor->proc~destructor Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destructor.html"},{"title":"allocate_lorene_id_parts_memory – SPHINCS_LORENE","text":"module procedure allocate_lorene_id_parts_memory module module subroutine allocate_lorene_id_parts_memory(THIS) Interface → Allocate memory for the LORENE ID on the\n  particles FT 10.11.2020 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Called by proc~~allocate_lorene_id_parts_memory~~CalledByGraph proc~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory->proc~allocate_lorene_id_parts_memory proc~construct_particles construct_particles proc~construct_particles->interface~allocate_lorene_id_parts_memory interface~construct_particles construct_particles interface~construct_particles->proc~construct_particles interface~particles particles interface~particles->interface~construct_particles program~convergence_test convergence_test program~convergence_test->interface~particles program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~particles var panprocallocate_lorene_id_parts_memoryCalledByGraph = svgPanZoom('#procallocate_lorene_id_parts_memoryCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_lorene_id_parts_memory.html"},{"title":"deallocate_lorene_id_parts_memory – SPHINCS_LORENE","text":"module procedure deallocate_lorene_id_parts_memory module module subroutine deallocate_lorene_id_parts_memory(THIS) Interface → Deallocate memory for the LORENE ID on the\n  particles FT 12.07.2021 (this was part of the destructor\n                 of TYPE [[particles]]\n                 before this date) Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Called by proc~~deallocate_lorene_id_parts_memory~~CalledByGraph proc~deallocate_lorene_id_parts_memory deallocate_lorene_id_parts_memory interface~deallocate_lorene_id_parts_memory deallocate_lorene_id_parts_memory interface~deallocate_lorene_id_parts_memory->proc~deallocate_lorene_id_parts_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/deallocate_lorene_id_parts_memory.html"},{"title":"place_particles_spherical_surfaces – SPHINCS_LORENE","text":"module procedure place_particles_spherical_surfaces module module subroutine place_particles_spherical_surfaces(THIS, mass_star, radius, center, central_density, npart_approx, npart_out, pos, pvol, pmass, last_r, upper_bound, lower_bound, upper_factor, lower_factor, max_steps, filename_mass_profile, filename_shells_radii, filename_shells_pos, get_density, integrate_density, get_id, validate_position) Interface → Uses matrix NR constants APM proc~~place_particles_spherical_surfaces~~UsesGraph proc~place_particles_spherical_surfaces place_particles_spherical_surfaces matrix matrix proc~place_particles_spherical_surfaces->matrix NR NR proc~place_particles_spherical_surfaces->NR constants constants proc~place_particles_spherical_surfaces->constants APM APM proc~place_particles_spherical_surfaces->APM Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Places particles on spherical surfaces\n  inside a star FT 19.04.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: mass_star Baryonic mass of the star double precision, intent(in) :: radius Radius of the star in the x direction towards the companion double precision, intent(in) :: center (x|) coordinate of the center of the star, i.e.,\n of the point with highest density double precision, intent(in) :: central_density Central density of the star, i.e., highest density integer, intent(in) :: npart_approx idbase object needed to access the BNS data Todo Remove the idbase argument as done in SUBROUTINE perform_apm\nCLASS(idbase),       INTENT( IN OUT ):: id\n Approximate particle number on the star integer, intent(out) :: npart_out Final number of particles on the star double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos Array string the final positions double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pmass Array storing the final particle masses double precision, intent(in) :: last_r Radius of the last spherical surface double precision, intent(inout) :: upper_bound Desired upper bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(inout) :: lower_bound Desired lower bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(in) :: upper_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. upper_factor >= 1, usually an increase of 1% works double precision, intent(in) :: lower_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. lower_factor <= 1, usually a decrease of 1% works integer, intent(in) :: max_steps If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. max_steps >= 10. 100 is a nice value character(len=*), intent(inout), optional :: filename_mass_profile Name of the file to store the radial mass profile character(len=*), intent(inout), optional :: filename_shells_radii Name of the file to store the surface radii Todo change name of variable to filename_surfaces_radii character(len=*), intent(inout), optional :: filename_shells_pos Name of the file to store the final particle positions Todo change name of variable to filename_surfaces_pos function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine integrate_density(center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order subroutine get_id(x, y, z, g_xx, baryon_density, gamma_euler) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise Calls proc~~place_particles_spherical_surfaces~~CallsGraph proc~place_particles_spherical_surfaces place_particles_spherical_surfaces proc~place_surfaces place_surfaces proc~place_particles_spherical_surfaces->proc~place_surfaces proc~print_mass_profile_surface_radii print_mass_profile_surface_radii proc~place_particles_spherical_surfaces->proc~print_mass_profile_surface_radii proc~particle_volume particle_volume proc~place_particles_spherical_surfaces->proc~particle_volume proc~reallocate_array_1d reallocate_array_1d proc~place_particles_spherical_surfaces->proc~reallocate_array_1d proc~compute_colatitudes_uniformly_in compute_colatitudes_uniformly_in proc~place_particles_spherical_surfaces->proc~compute_colatitudes_uniformly_in proc~number_surfaces number_surfaces proc~place_particles_spherical_surfaces->proc~number_surfaces proc~reallocate_array_2d reallocate_array_2d proc~place_particles_spherical_surfaces->proc~reallocate_array_2d proc~assign_surfaces_mass assign_surfaces_mass proc~place_particles_spherical_surfaces->proc~assign_surfaces_mass none~validate_position_final~2 validate_position_final proc~place_particles_spherical_surfaces->none~validate_position_final~2 validate_position validate_position none~validate_position_final~2->validate_position Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~place_particles_spherical_surfaces~~CalledByGraph proc~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces place_particles_spherical_surfaces interface~place_particles_spherical_surfaces->proc~place_particles_spherical_surfaces Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha bar_density_tmp cnt cnt2 col col_tmp colatitude_pos debug delta_r dim_seed dphi dphi_shells dr dr_shells dth dth_shells exist finalnamefile finalnamefile2 g_xx_tmp gam_euler_tmp high_mass huge_real i_shell itr2 kept_all long low_mass lower_bound_tmp m_p m_parts mass mass_profile mass_profile_idx mass_shell mass_shell2 mass_test mass_test2 n_shells npart_discard npart_discarded npart_shell npart_shell_cnt npart_shell_kept npart_shell_tmp npart_shelleq npart_surface_tmp npart_test phase phase_th phi pos_shell_tmp pos_shells prev_shell proper_volume proper_volume_test pvol_tmp r r_cnt rad rand_num rand_num2 rel_sign seed shell_masses shell_radii shell_scales shell_thickness size_pos_shell th upper_bound_tmp vol_shell vol_shell2 xtemp ytemp ztemp Derived Types colatitude_pos_shell pos_on_shells Functions validate_position_final Variables Type Visibility Attributes Name Initial double precision, private, DIMENSION(:), ALLOCATABLE :: alpha double precision, private, DIMENSION(:,:), ALLOCATABLE :: bar_density_tmp integer, private :: cnt integer, private :: cnt2 double precision, private :: col double precision, private :: col_tmp type(colatitude_pos_shell), private, DIMENSION(:), ALLOCATABLE :: colatitude_pos logical, private, parameter :: debug = .FALSE. double precision, private :: delta_r integer, private :: dim_seed double precision, private :: dphi double precision, private :: dphi_shells double precision, private :: dr double precision, private :: dr_shells double precision, private :: dth double precision, private :: dth_shells logical, private :: exist character(len=:), private, ALLOCATABLE :: finalnamefile character(len=:), private, ALLOCATABLE :: finalnamefile2 double precision, private, DIMENSION(:,:), ALLOCATABLE :: g_xx_tmp double precision, private, DIMENSION(:,:), ALLOCATABLE :: gam_euler_tmp logical, private :: high_mass double precision, private, parameter :: huge_real = 1.0D30 integer, private :: i_shell integer, private :: itr2 logical, private :: kept_all double precision, private :: long logical, private :: low_mass double precision, private :: lower_bound_tmp double precision, private :: m_p double precision, private, DIMENSION(:), ALLOCATABLE :: m_parts double precision, private :: mass double precision, private, DIMENSION(:,:), ALLOCATABLE :: mass_profile integer, private, DIMENSION(:), ALLOCATABLE :: mass_profile_idx double precision, private, DIMENSION(:), ALLOCATABLE :: mass_shell double precision, private, DIMENSION(:), ALLOCATABLE :: mass_shell2 double precision, private :: mass_test double precision, private :: mass_test2 integer, private :: n_shells integer, private :: npart_discard double precision, private, DIMENSION(:,:), ALLOCATABLE :: npart_discarded integer, private, DIMENSION(:), ALLOCATABLE :: npart_shell integer, private :: npart_shell_cnt double precision, private :: npart_shell_kept integer, private :: npart_shell_tmp integer, private, DIMENSION(:), ALLOCATABLE :: npart_shelleq double precision, private, DIMENSION(:,:), ALLOCATABLE :: npart_surface_tmp integer, private :: npart_test double precision, private :: phase double precision, private :: phase_th integer, private :: phi double precision, private, DIMENSION(:,:,:), ALLOCATABLE :: pos_shell_tmp type(pos_on_shells), private, DIMENSION(:), ALLOCATABLE :: pos_shells integer, private :: prev_shell double precision, private :: proper_volume double precision, private :: proper_volume_test double precision, private, DIMENSION(:,:), ALLOCATABLE :: pvol_tmp integer, private :: r integer, private :: r_cnt double precision, private :: rad double precision, private :: rand_num double precision, private :: rand_num2 integer, private :: rel_sign integer, private, DIMENSION(:), ALLOCATABLE :: seed double precision, private, DIMENSION(:), ALLOCATABLE :: shell_masses double precision, private, DIMENSION(:), ALLOCATABLE :: shell_radii double precision, private, DIMENSION(:), ALLOCATABLE :: shell_scales double precision, private :: shell_thickness integer, private :: size_pos_shell integer, private :: th double precision, private :: upper_bound_tmp double precision, private, DIMENSION(:), ALLOCATABLE :: vol_shell double precision, private, DIMENSION(:), ALLOCATABLE :: vol_shell2 double precision, private :: xtemp double precision, private :: ytemp double precision, private :: ztemp Derived Types type :: colatitude_pos_shell Components Type Visibility Attributes Name Initial double precision, private, DIMENSION(:), ALLOCATABLE :: colatitudes type :: pos_on_shells Components Type Visibility Attributes Name Initial double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx double precision, private, DIMENSION(:), ALLOCATABLE :: gamma_euler double precision, private, DIMENSION(:), ALLOCATABLE :: pos_phi double precision, private, DIMENSION(:,:), ALLOCATABLE :: pos_shell double precision, private, DIMENSION(:), ALLOCATABLE :: pos_th double precision, private, DIMENSION(:), ALLOCATABLE :: pvol_shell double precision, private, DIMENSION(:), ALLOCATABLE :: pvol_shell2 Functions function validate_position_final(x, y, z) result(answer) Returns validate_position( x, y, z ) if the latter\n  is present, 0 otherwise FT 22.09.2021 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value integer validate_position( x, y, z ) if the latter is present, 0 otherwise","tags":"","loc":"proc/place_particles_spherical_surfaces.html"},{"title":"construct_particles – SPHINCS_LORENE","text":"module procedure construct_particles module module function construct_particles(id, dist) result(parts) Interface → Uses constants options alive_flag input_output kernel_table tensor units NR proc~~construct_particles~~UsesGraph proc~construct_particles construct_particles constants constants proc~construct_particles->constants options options proc~construct_particles->options alive_flag alive_flag proc~construct_particles->alive_flag input_output input_output proc~construct_particles->input_output kernel_table kernel_table proc~construct_particles->kernel_table tensor tensor proc~construct_particles->tensor units units proc~construct_particles->units NR NR proc~construct_particles->NR Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. The constructor performs all the tasks needed\n  to set up the particle distribution with the\n  \\texttt{LORENE} ID on it. It calls all the PROCEDURES\n  that rely on an object of TYPE bns. Todo assign sub-tasks to separate SUBROUTINES\n        CONTAINED in this SUBMODULE FT 17.10.2020 Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id idbase object representing the BNS for which we want to place\n particles integer, intent(in) :: dist Identifier of the desired particle distribution: 0: Read particle positions (and optionally the baryon number per\n    particle \\nu ) from a formatted file 1: Place particles on a single lattice that surrounds both stars 2: Place particles on two lattices, each one surrounding a star 3: Place particles on spherical surfaces inside the stars Warning Method 1 is almost deprecated, since method 2 is effectively\n          an improvement of method 1 Return Value type( particles ) Constructed particles object Calls proc~~construct_particles~~CallsGraph proc~construct_particles construct_particles proc~check_particle_positions check_particle_positions proc~construct_particles->proc~check_particle_positions timer timer proc~construct_particles->timer read_options read_options proc~construct_particles->read_options set_units set_units proc~construct_particles->set_units ktable ktable proc~construct_particles->ktable alive alive proc~construct_particles->alive interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory proc~construct_particles->interface~allocate_lorene_id_parts_memory indexx indexx proc~check_particle_positions->indexx proc~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory->proc~allocate_lorene_id_parts_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~construct_particles~~CalledByGraph proc~construct_particles construct_particles interface~construct_particles construct_particles interface~construct_particles->proc~construct_particles interface~particles particles interface~particles->interface~construct_particles program~convergence_test convergence_test program~convergence_test->interface~particles program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables apm_iterate apm_max_it barycenter center central_density column_nu columns compose_eos compose_filename compose_path correct_nu counter debug exist file_exists filename_apm_pos filename_apm_pos_id filename_apm_results filename_mass_profile filename_shells_pos filename_shells_radii header_lines i_matter last_r lower_bound lower_factor mass_it max_inc max_length max_mass max_steps n_cols nlines npart1_tmp npart2_tmp npart_des npart_des_i npart_tmp nu_ratio nuratio_des nuratio_thres nx_gh ny_gh nz_gh parts_all parts_pos parts_pos_namefile parts_pos_path pvol_tmp randomize_phi randomize_r randomize_theta read_nu redistribute_nu reflect_particles_x sizes str_i stretch thres tmp_pos tmp_pos2 total_mass unit_pos upper_bound upper_factor use_thres xmax xmin ymax ymin zmax zmin Derived Types parts_i Functions check_negative_hydro import_density Subroutines compute_nstar_p get_nstar_p import_id integrate_mass_density Variables Type Visibility Attributes Name Initial logical, private, DIMENSION(id% get_n_matter()) :: apm_iterate integer, private :: apm_max_it double precision, private, DIMENSION(id% get_n_matter(),3) :: barycenter double precision, private, DIMENSION(id% get_n_matter(),3) :: center double precision, private, DIMENSION(id% get_n_matter()) :: central_density integer, private :: column_nu integer, private, DIMENSION(3) :: columns logical, private :: compose_eos character(len=max_length), private :: compose_filename character(len=max_length), private :: compose_path logical, private :: correct_nu integer, private, SAVE :: counter = 1 logical, private, parameter :: debug = .FALSE. logical, private :: exist logical, private :: file_exists character(len=max_length), private :: filename_apm_pos character(len=max_length), private :: filename_apm_pos_id character(len=max_length), private :: filename_apm_results character(len=max_length), private :: filename_mass_profile character(len=max_length), private :: filename_shells_pos character(len=max_length), private :: filename_shells_radii integer, private :: header_lines integer, private :: i_matter double precision, private :: last_r double precision, private :: lower_bound double precision, private :: lower_factor logical, private :: mass_it integer, private :: max_inc integer, private, parameter :: max_length = 50 double precision, private :: max_mass integer, private :: max_steps integer, private :: n_cols integer, private :: nlines integer, private :: npart1_tmp integer, private :: npart2_tmp integer, private :: npart_des integer, private, DIMENSION(id% get_n_matter()) :: npart_des_i integer, private :: npart_tmp double precision, private :: nu_ratio double precision, private :: nuratio_des double precision, private :: nuratio_thres integer, private :: nx_gh integer, private :: ny_gh integer, private :: nz_gh type(parts_i), private, DIMENSION(id% get_n_matter()) :: parts_all character(len=max_length), private :: parts_pos character(len=:), private, ALLOCATABLE :: parts_pos_namefile character(len=max_length), private :: parts_pos_path double precision, private :: pvol_tmp logical, private :: randomize_phi logical, private :: randomize_r logical, private :: randomize_theta logical, private :: read_nu logical, private :: redistribute_nu logical, private :: reflect_particles_x double precision, private, DIMENSION(id% get_n_matter(),6) :: sizes character(len=3), private :: str_i double precision, private :: stretch double precision, private :: thres double precision, private, DIMENSION( :, : ), ALLOCATABLE :: tmp_pos double precision, private, DIMENSION( :, : ), ALLOCATABLE :: tmp_pos2 double precision, private :: total_mass integer, private, parameter :: unit_pos = 2289 double precision, private :: upper_bound double precision, private :: upper_factor logical, private :: use_thres double precision, private :: xmax double precision, private :: xmin double precision, private :: ymax double precision, private :: ymin double precision, private :: zmax double precision, private :: zmin Derived Types type :: parts_i Components Type Visibility Attributes Name Initial double precision, private, DIMENSION( : ), ALLOCATABLE :: pmass_i double precision, private, DIMENSION( :, : ), ALLOCATABLE :: pos_i double precision, private, DIMENSION( : ), ALLOCATABLE :: pvol_i Functions function check_negative_hydro(x, y, z) result(answer) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z Return Value integer function import_density(x, y, z) result(density) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z Return Value double precision Subroutines subroutine compute_nstar_p(npart_real, lapse, shift_x, shift_y, shift_z, v_euler_x, v_euler_y, v_euler_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, nstar_p) Compute nstar_p, the proper baryon mass density, given the\n  \\texttt{LORENE} ID FT 31.08.2021 Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real double precision, intent(in), DIMENSION(npart_real) :: lapse double precision, intent(in), DIMENSION(npart_real) :: shift_x double precision, intent(in), DIMENSION(npart_real) :: shift_y double precision, intent(in), DIMENSION(npart_real) :: shift_z double precision, intent(in), DIMENSION(npart_real) :: v_euler_x double precision, intent(in), DIMENSION(npart_real) :: v_euler_y double precision, intent(in), DIMENSION(npart_real) :: v_euler_z double precision, intent(in), DIMENSION(npart_real) :: g_xx double precision, intent(in), DIMENSION(npart_real) :: g_xy double precision, intent(in), DIMENSION(npart_real) :: g_xz double precision, intent(in), DIMENSION(npart_real) :: g_yy double precision, intent(in), DIMENSION(npart_real) :: g_yz double precision, intent(in), DIMENSION(npart_real) :: g_zz double precision, intent(in), DIMENSION(npart_real) :: baryon_density double precision, intent(out), DIMENSION(npart_real) :: nstar_p subroutine get_nstar_p(npart_real, x, y, z, nstar_p) Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real double precision, intent(in) :: x (npart_real) double precision, intent(in) :: y (npart_real) double precision, intent(in) :: z (npart_real) double precision, intent(out) :: nstar_p (npart_real) subroutine import_id(x, y, z, g_xx, baryon_density, gamma_euler) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler subroutine integrate_mass_density(center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order","tags":"","loc":"proc/construct_particles.html"},{"title":"destruct_particles – SPHINCS_LORENE","text":"module procedure destruct_particles module module subroutine destruct_particles(THIS) Interface → Destructor of a particles object FT Arguments Type Intent Optional Attributes Name type( particles ), intent(inout) :: THIS Finalizer (Destructor) of particles object particles object which this PROCEDURE is a member of Called by proc~~destruct_particles~~CalledByGraph proc~destruct_particles destruct_particles interface~destruct_particles destruct_particles interface~destruct_particles->proc~destruct_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destruct_particles.html"},{"title":"analyze_hydro – SPHINCS_LORENE","text":"module procedure analyze_hydro module module subroutine analyze_hydro(THIS, namefile) Interface → Export the points where some of the hydro\n  fields are negative to a formatted file\n  (deprecated?) FT 5.12.2020 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the particle positions at which\n some of the hydro fields are negative or zero are printed to Called by proc~~analyze_hydro~~CalledByGraph proc~analyze_hydro analyze_hydro interface~analyze_hydro analyze_hydro interface~analyze_hydro->proc~analyze_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables exist negative_hydro Variables Type Visibility Attributes Name Initial logical, private :: exist logical, private :: negative_hydro","tags":"","loc":"proc/analyze_hydro.html"},{"title":"compute_and_export_SPH_variables – SPHINCS_LORENE","text":"module procedure compute_and_export_SPH_variables module module subroutine compute_and_export_SPH_variables(THIS, namefile) Interface → Uses matrix constants RCB_tree_3D APM options alive_flag pwp_EOS input_output gradient kernel_table metric_on_particles units set_h NR sphincs_sph sph_variables proc~~compute_and_export_sph_variables~~UsesGraph proc~compute_and_export_sph_variables compute_and_export_SPH_variables matrix matrix proc~compute_and_export_sph_variables->matrix constants constants proc~compute_and_export_sph_variables->constants RCB_tree_3D RCB_tree_3D proc~compute_and_export_sph_variables->RCB_tree_3D APM APM proc~compute_and_export_sph_variables->APM options options proc~compute_and_export_sph_variables->options alive_flag alive_flag proc~compute_and_export_sph_variables->alive_flag pwp_EOS pwp_EOS proc~compute_and_export_sph_variables->pwp_EOS input_output input_output proc~compute_and_export_sph_variables->input_output gradient gradient proc~compute_and_export_sph_variables->gradient kernel_table kernel_table proc~compute_and_export_sph_variables->kernel_table metric_on_particles metric_on_particles proc~compute_and_export_sph_variables->metric_on_particles units units proc~compute_and_export_sph_variables->units set_h set_h proc~compute_and_export_sph_variables->set_h NR NR proc~compute_and_export_sph_variables->NR sphincs_sph sphincs_sph proc~compute_and_export_sph_variables->sphincs_sph sph_variables sph_variables proc~compute_and_export_sph_variables->sph_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the SPH quantities from the LORENE\n  ID, and export it to a binary file with\n  write_SPHINCS_dump, and to a formatted file FT 18.09.2020 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the SPH ID is printed to Calls proc~~compute_and_export_sph_variables~~CallsGraph proc~compute_and_export_sph_variables compute_and_export_SPH_variables vel_u vel_u proc~compute_and_export_sph_variables->vel_u iorig iorig proc~compute_and_export_sph_variables->iorig nu nu proc~compute_and_export_sph_variables->nu allocate_metric_on_particles allocate_metric_on_particles proc~compute_and_export_sph_variables->allocate_metric_on_particles gen_pwp_eos_all gen_pwp_eos_all proc~compute_and_export_sph_variables->gen_pwp_eos_all deallocate_metric_on_particles deallocate_metric_on_particles proc~compute_and_export_sph_variables->deallocate_metric_on_particles allocate_rcb_tree_memory_3d allocate_rcb_tree_memory_3d proc~compute_and_export_sph_variables->allocate_rcb_tree_memory_3d pos_u pos_u proc~compute_and_export_sph_variables->pos_u sq_det_g4 sq_det_g4 proc~compute_and_export_sph_variables->sq_det_g4 nlrf nlrf proc~compute_and_export_sph_variables->nlrf read_options read_options proc~compute_and_export_sph_variables->read_options select_eos_parameters select_eos_parameters proc~compute_and_export_sph_variables->select_eos_parameters pr pr proc~compute_and_export_sph_variables->pr density density proc~compute_and_export_sph_variables->density av av proc~compute_and_export_sph_variables->av u u proc~compute_and_export_sph_variables->u assign_h assign_h proc~compute_and_export_sph_variables->assign_h allocate_gradient allocate_gradient proc~compute_and_export_sph_variables->allocate_gradient set_units set_units proc~compute_and_export_sph_variables->set_units deallocate_rcb_tree_memory_3d deallocate_rcb_tree_memory_3d proc~compute_and_export_sph_variables->deallocate_rcb_tree_memory_3d write_sphincs_dump write_sphincs_dump proc~compute_and_export_sph_variables->write_sphincs_dump get_u_pwp get_u_pwp proc~compute_and_export_sph_variables->get_u_pwp ncand ncand proc~compute_and_export_sph_variables->ncand allocate_sph_memory allocate_sph_memory proc~compute_and_export_sph_variables->allocate_sph_memory divv divv proc~compute_and_export_sph_variables->divv shorten_eos_name shorten_eos_name proc~compute_and_export_sph_variables->shorten_eos_name determinant_4x4_matrix determinant_4x4_matrix proc~compute_and_export_sph_variables->determinant_4x4_matrix temp temp proc~compute_and_export_sph_variables->temp theta theta proc~compute_and_export_sph_variables->theta deallocate_gradient deallocate_gradient proc~compute_and_export_sph_variables->deallocate_gradient h h proc~compute_and_export_sph_variables->h deallocate_sph_memory deallocate_sph_memory proc~compute_and_export_sph_variables->deallocate_sph_memory density_loop density_loop proc~compute_and_export_sph_variables->density_loop exact_nei_tree_update exact_nei_tree_update proc~compute_and_export_sph_variables->exact_nei_tree_update Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~compute_and_export_sph_variables~~CalledByGraph proc~compute_and_export_sph_variables compute_and_export_SPH_variables interface~compute_and_export_sph_variables compute_and_export_SPH_variables interface~compute_and_export_sph_variables->proc~compute_and_export_sph_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Theta_a a call_flag cnt1 compose_namefile debug det few_ncand finalnamefile g4 good_h i_matter itr2 max_it_h mus nus sq_g Variables Type Visibility Attributes Name Initial double precision, private :: Theta_a integer, private :: a integer, private, SAVE :: call_flag = 0 integer, private :: cnt1 character(len=:), private, ALLOCATABLE :: compose_namefile logical, private, parameter :: debug = .FALSE. double precision, private :: det logical, private :: few_ncand character(len=:), private, ALLOCATABLE :: finalnamefile double precision, private :: g4 (0:3,0:3) logical, private :: good_h integer, private :: i_matter integer, private :: itr2 integer, private, parameter :: max_it_h = 1 integer, private :: mus integer, private :: nus double precision, private :: sq_g","tags":"","loc":"proc/compute_and_export_sph_variables.html"},{"title":"print_formatted_lorene_id_particles – SPHINCS_LORENE","text":"module procedure print_formatted_lorene_id_particles module module subroutine print_formatted_lorene_id_particles(THIS, namefile) Interface → Uses constants proc~~print_formatted_lorene_id_particles~~UsesGraph proc~print_formatted_lorene_id_particles print_formatted_lorene_id_particles constants constants proc~print_formatted_lorene_id_particles->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Print the LORENE ID on the particles in a\n  formatted file FT 18.09.2020 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted output file Called by proc~~print_formatted_lorene_id_particles~~CalledByGraph proc~print_formatted_lorene_id_particles print_formatted_lorene_id_particles interface~print_formatted_lorene_id_particles print_formatted_lorene_id_particles interface~print_formatted_lorene_id_particles->proc~print_formatted_lorene_id_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables abs_pos exist finalnamefile itr Variables Type Visibility Attributes Name Initial double precision, private, DIMENSION( :, : ), ALLOCATABLE :: abs_pos logical, private :: exist character(len=:), private, ALLOCATABLE :: finalnamefile integer, private :: itr","tags":"","loc":"proc/print_formatted_lorene_id_particles.html"},{"title":"read_sphincs_dump_print_formatted – SPHINCS_LORENE","text":"module procedure read_sphincs_dump_print_formatted module module subroutine read_sphincs_dump_print_formatted(THIS, namefile_bin, namefile) Interface → Uses metric_on_particles input_output sph_variables proc~~read_sphincs_dump_print_formatted~~UsesGraph proc~read_sphincs_dump_print_formatted read_sphincs_dump_print_formatted metric_on_particles metric_on_particles proc~read_sphincs_dump_print_formatted->metric_on_particles input_output input_output proc~read_sphincs_dump_print_formatted->input_output sph_variables sph_variables proc~read_sphincs_dump_print_formatted->sph_variables Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Read the SPH ID from the binary file output\n  by write_SPHINCS_dump, and print it to a\n  formatted file FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile_bin Name of the binary file to be read character(len=*), intent(inout), optional :: namefile Name of the formatted file to be printed Calls proc~~read_sphincs_dump_print_formatted~~CallsGraph proc~read_sphincs_dump_print_formatted read_sphincs_dump_print_formatted vel_u vel_u proc~read_sphincs_dump_print_formatted->vel_u nu nu proc~read_sphincs_dump_print_formatted->nu pr pr proc~read_sphincs_dump_print_formatted->pr allocate_metric_on_particles allocate_metric_on_particles proc~read_sphincs_dump_print_formatted->allocate_metric_on_particles temp temp proc~read_sphincs_dump_print_formatted->temp theta theta proc~read_sphincs_dump_print_formatted->theta ye ye proc~read_sphincs_dump_print_formatted->ye deallocate_metric_on_particles deallocate_metric_on_particles proc~read_sphincs_dump_print_formatted->deallocate_metric_on_particles h h proc~read_sphincs_dump_print_formatted->h u u proc~read_sphincs_dump_print_formatted->u av av proc~read_sphincs_dump_print_formatted->av allocate_sph_memory allocate_sph_memory proc~read_sphincs_dump_print_formatted->allocate_sph_memory deallocate_sph_memory deallocate_sph_memory proc~read_sphincs_dump_print_formatted->deallocate_sph_memory pos_u pos_u proc~read_sphincs_dump_print_formatted->pos_u nlrf nlrf proc~read_sphincs_dump_print_formatted->nlrf set_units set_units proc~read_sphincs_dump_print_formatted->set_units divv divv proc~read_sphincs_dump_print_formatted->divv read_sphincs_dump read_sphincs_dump proc~read_sphincs_dump_print_formatted->read_sphincs_dump Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_sphincs_dump_print_formatted~~CalledByGraph proc~read_sphincs_dump_print_formatted read_sphincs_dump_print_formatted interface~read_sphincs_dump_print_formatted read_sphincs_dump_print_formatted interface~read_sphincs_dump_print_formatted->proc~read_sphincs_dump_print_formatted Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables abs_pos exist finalnamefile itr min_abs_y min_abs_z1 min_abs_z2 min_y_index Variables Type Visibility Attributes Name Initial double precision, private, DIMENSION( :, : ), ALLOCATABLE :: abs_pos logical, private :: exist character(len=:), private, ALLOCATABLE :: finalnamefile integer, private :: itr double precision, private :: min_abs_y double precision, private :: min_abs_z1 double precision, private :: min_abs_z2 integer, private :: min_y_index","tags":"","loc":"proc/read_sphincs_dump_print_formatted.html"},{"title":"get_h – SPHINCS_LORENE","text":"module procedure get_h module module function get_h(THIS) result(h) Interface → Returns the array of initial guess for the\n smoothing length [Msun_geo] FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE h Called by proc~~get_h~~CalledByGraph proc~get_h get_h interface~get_h get_h interface~get_h->proc~get_h Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_h.html"},{"title":"get_nlrf – SPHINCS_LORENE","text":"module procedure get_nlrf module module function get_nlrf(THIS) result(nlrf) Interface → Returns the array of baryon density in the\n local rest frame FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE nlrf Called by proc~~get_nlrf~~CalledByGraph proc~get_nlrf get_nlrf interface~get_nlrf get_nlrf interface~get_nlrf->proc~get_nlrf Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nlrf.html"},{"title":"get_npart – SPHINCS_LORENE","text":"module procedure get_npart module module function get_npart(THIS) result(n_part) Interface → Returns the total number of particles FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer npart Called by proc~~get_npart~~CalledByGraph proc~get_npart get_npart interface~get_npart get_npart interface~get_npart->proc~get_npart Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_npart.html"},{"title":"get_npart1 – SPHINCS_LORENE","text":"module procedure get_npart1 module module function get_npart1(THIS) result(n_part) Interface → Returns the number of particles on star 1 FT 27.04.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles Called by proc~~get_npart1~~CalledByGraph proc~get_npart1 get_npart1 interface~get_npart1 get_npart1 interface~get_npart1->proc~get_npart1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_npart1.html"},{"title":"get_npart2 – SPHINCS_LORENE","text":"module procedure get_npart2 module module function get_npart2(THIS) result(n_part) Interface → Returns the number of particles on star 2 FT 27.04.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles Called by proc~~get_npart2~~CalledByGraph proc~get_npart2 get_npart2 interface~get_npart2 get_npart2 interface~get_npart2->proc~get_npart2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_npart2.html"},{"title":"get_nu – SPHINCS_LORENE","text":"module procedure get_nu module module function get_nu(THIS) result(nu) Interface → Returns the array of baryon per particle\n [baryon (Msun_geo)&#94;{-3}] FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE nu Called by proc~~get_nu~~CalledByGraph proc~get_nu get_nu interface~get_nu get_nu interface~get_nu->proc~get_nu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nu.html"},{"title":"get_nuratio – SPHINCS_LORENE","text":"module procedure get_nuratio module module function get_nuratio(THIS) result(nuratio) Interface → Returns the baryon number ratio on the stars FT 27.04.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision nuratio Called by proc~~get_nuratio~~CalledByGraph proc~get_nuratio get_nuratio interface~get_nuratio get_nuratio interface~get_nuratio->proc~get_nuratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nuratio.html"},{"title":"get_nuratio1 – SPHINCS_LORENE","text":"module procedure get_nuratio1 module module function get_nuratio1(THIS) result(nuratio1) Interface → Returns the baryon number ratio on star 1 FT 27.04.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles Called by proc~~get_nuratio1~~CalledByGraph proc~get_nuratio1 get_nuratio1 interface~get_nuratio1 get_nuratio1 interface~get_nuratio1->proc~get_nuratio1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nuratio1.html"},{"title":"get_nuratio2 – SPHINCS_LORENE","text":"module procedure get_nuratio2 module module function get_nuratio2(THIS) result(nuratio2) Interface → Returns the baryon number ratio on star 2 FT 27.04.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles Called by proc~~get_nuratio2~~CalledByGraph proc~get_nuratio2 get_nuratio2 interface~get_nuratio2 get_nuratio2 interface~get_nuratio2->proc~get_nuratio2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nuratio2.html"},{"title":"get_pos – SPHINCS_LORENE","text":"module procedure get_pos module module function get_pos(THIS) result(pos_u) Interface → Returns the array of particle positions FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:),ALLOCATABLE pos Called by proc~~get_pos~~CalledByGraph proc~get_pos get_pos interface~get_pos get_pos interface~get_pos->proc~get_pos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_pos.html"},{"title":"get_pressure – SPHINCS_LORENE","text":"module procedure get_pressure module module function get_pressure(THIS) result(pressure) Interface → Returns the array of pressure [kg c&#94;2 m&#94;{-3}] FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE pressure_parts Called by proc~~get_pressure~~CalledByGraph proc~get_pressure get_pressure interface~get_pressure get_pressure interface~get_pressure->proc~get_pressure Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_pressure.html"},{"title":"get_pressure_cu – SPHINCS_LORENE","text":"module procedure get_pressure_cu module module function get_pressure_cu(THIS) result(pressure_cu) Interface → Returns the array of pressure in code units\n [amu c 2/(Msun_geo *3)] FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE pressure_parts_cu Called by proc~~get_pressure_cu~~CalledByGraph proc~get_pressure_cu get_pressure_cu interface~get_pressure_cu get_pressure_cu interface~get_pressure_cu->proc~get_pressure_cu Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_pressure_cu.html"},{"title":"get_theta – SPHINCS_LORENE","text":"module procedure get_theta module module function get_theta(THIS) result(theta) Interface → Returns the array of generalized Lorentz\n factor FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE Theta Called by proc~~get_theta~~CalledByGraph proc~get_theta get_theta interface~get_theta get_theta interface~get_theta->proc~get_theta Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_theta.html"},{"title":"get_u – SPHINCS_LORENE","text":"module procedure get_u module module function get_u(THIS) result(u) Interface → Returns the array of specific internal\n energy [c&#94;2] FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:),ALLOCATABLE specific_energy_parts Called by proc~~get_u~~CalledByGraph proc~get_u get_u interface~get_u get_u interface~get_u->proc~get_u Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_u.html"},{"title":"get_vel – SPHINCS_LORENE","text":"module procedure get_vel module module function get_vel(THIS) result(vel) Interface → Returns the array of coordinate 3-velocity of\n particles FT Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:),ALLOCATABLE v Called by proc~~get_vel~~CalledByGraph proc~get_vel get_vel interface~get_vel get_vel interface~get_vel->proc~get_vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_vel.html"},{"title":"is_empty – SPHINCS_LORENE","text":"module procedure is_empty module module function is_empty(THIS) result(answer) Interface → Returns the variable empty_object Warning experimental, not actively used in\n          the code yet FT Arguments Type Intent Optional Attributes Name class( particles ), intent(in) :: THIS particles object which this PROCEDURE is a member of Return Value logical .TRUE if the particles object is empty, .FALSE otherwise Called by proc~~is_empty~~CalledByGraph proc~is_empty is_empty interface~is_empty is_empty interface~is_empty->proc~is_empty Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/is_empty.html"},{"title":"compute_Ye – SPHINCS_LORENE","text":"module procedure compute_Ye module module subroutine compute_Ye(THIS) Interface → Interpolates the electron fraction\n  Y_e = n_e/n_b\n  at the particle positions, using the data\n  read by read_compose_composition. FT 3.03.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Called by proc~~compute_ye~~CalledByGraph proc~compute_ye compute_Ye interface~compute_ye compute_Ye interface~compute_ye->proc~compute_ye Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables d itr2 max_nb_table min_nb_table Variables Type Visibility Attributes Name Initial integer, private :: d integer, private :: itr2 double precision, private :: max_nb_table double precision, private :: min_nb_table","tags":"","loc":"proc/compute_ye.html"},{"title":"read_compose_composition – SPHINCS_LORENE","text":"module procedure read_compose_composition module module subroutine read_compose_composition(THIS, namefile) Interface → Uses constants proc~~read_compose_composition~~UsesGraph proc~read_compose_composition read_compose_composition constants constants proc~read_compose_composition->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Reads the electron fraction Y_e = n_e/n_b,\n  with n_e electron number density and n_b\n  baryon number density, from the .compo file\n  taken from the CompOSE database of EoS.\n  Y_e is given as a function of T, n_b, Y_q on\n  a grid; the computation of Ye on the stars is\n  done by the SUBROUTINE compute_Ye_on_stars. FT 1.03.2021 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile To read the file great_eos.beta in directory compose_path/GREAT_EoS,\n namefile=\"GREAT_EoS/great_eos\" Called by proc~~read_compose_composition~~CalledByGraph proc~read_compose_composition read_compose_composition interface~read_compose_composition read_compose_composition interface~read_compose_composition->proc~read_compose_composition Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables cntr exist finalnamefile itr max_length_eos unit_compose Variables Type Visibility Attributes Name Initial integer, private :: cntr logical, private :: exist character(len=:), private, ALLOCATABLE :: finalnamefile integer, private :: itr integer, private, parameter :: max_length_eos = 10000 integer, private, parameter :: unit_compose = 56","tags":"","loc":"proc/read_compose_composition.html"},{"title":"place_particles_lattice – SPHINCS_LORENE","text":"module procedure place_particles_lattice module module subroutine place_particles_lattice(THIS, central_density, xmin, xmax, ymin, ymax, zmin, zmax, npart_des, npart_out, stretch, thres, pos, pvol, get_density, validate_position) Interface → Uses constants proc~~place_particles_lattice~~UsesGraph proc~place_particles_lattice place_particles_lattice constants constants proc~place_particles_lattice->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Places paricles on a 3D lattice containing both stars FT 5.10.2020 Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: central_density Maximum baryon mass density of the system double precision, intent(in) :: xmin Left x boundary of the lattice double precision, intent(in) :: xmax Right x boundary of the lattice double precision, intent(in) :: ymin Left y boundary of the lattice double precision, intent(in) :: ymax Right y boundary of the lattice double precision, intent(in) :: zmin Left z boundary of the lattice double precision, intent(in) :: zmax Right z boundary of the lattice integer, intent(in) :: npart_des Desired particle number integer, intent(out) :: npart_out Real, output particle number double precision, intent(in) :: stretch Stretching factor fo the lattice. xmin to zmax are multiplied by it double precision, intent(in) :: thres (~rho_max)/thres is the minimum mass density considered\nwhen placing particles. Used only when redistribute_nu is\n.FALSE. . When redistribute_nu is .TRUE. thres= 100*nu_ratio double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes\nArray storing the final particle volumes function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise Called by proc~~place_particles_lattice~~CalledByGraph proc~place_particles_lattice place_particles_lattice interface~place_particles_lattice place_particles_lattice interface~place_particles_lattice->proc~place_particles_lattice Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dx dy dz i j k npart_half npart_tmp nx ny nz pos_tmp sgn thres_baryon_density vol vol_a xtemp ytemp zlim ztemp Variables Type Visibility Attributes Name Initial double precision, private :: dx double precision, private :: dy double precision, private :: dz integer, private :: i integer, private :: j integer, private :: k integer, private :: npart_half integer, private :: npart_tmp integer, private :: nx integer, private :: ny integer, private :: nz double precision, private, DIMENSION(:,:,:,:), ALLOCATABLE :: pos_tmp integer, private :: sgn double precision, private :: thres_baryon_density double precision, private :: vol double precision, private :: vol_a double precision, private :: xtemp double precision, private :: ytemp double precision, private :: zlim double precision, private :: ztemp","tags":"","loc":"proc/place_particles_lattice.html"},{"title":"perform_apm – SPHINCS_LORENE","text":"module procedure perform_apm module module subroutine perform_apm(get_density, get_nstar_p, pos_input, pvol, h_output, nu_output, center, com_star, mass, radx_comp, radx_opp, rady, radz, apm_max_it, max_inc, mass_it, correct_nu, nuratio_thres, nuratio_des, nx_gh, ny_gh, nz_gh, namefile_pos_id, namefile_pos, namefile_results, validate_position) Interface → Uses matrix constants RCB_tree_3D APM analyze utility gradient metric_on_particles units set_h sphincs_sph sph_variables proc~~perform_apm~~UsesGraph proc~perform_apm perform_apm matrix matrix proc~perform_apm->matrix constants constants proc~perform_apm->constants RCB_tree_3D RCB_tree_3D proc~perform_apm->RCB_tree_3D module~utility utility proc~perform_apm->module~utility APM APM proc~perform_apm->APM analyze analyze proc~perform_apm->analyze gradient gradient proc~perform_apm->gradient metric_on_particles metric_on_particles proc~perform_apm->metric_on_particles units units proc~perform_apm->units set_h set_h proc~perform_apm->set_h sphincs_sph sphincs_sph proc~perform_apm->sphincs_sph sph_variables sph_variables proc~perform_apm->sph_variables module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Compute the particle positions as follows: - 1. Take initial particle distribution as input\n- 2. Assume that the particles have the same mass\n- 3. Do the APM iteration so that the final\n   SPH kernel estimate of the baryon mass\n   density matches the baryon density in the\n   star as given by \\texttt{LORENE}\n- 4. Correct the particle masses ONCE, in order\n   to match the density even better. Since we\n   don't want a large mass ratio, we impose a\n   maximum mass ratio when performing this\n   correction. After this procedure, the resulting particle\n  distribution has positions and baryon numbers\n  that kernel-estimate very well the mass density\n  of the star, and has a low mass ratio. This procedure assigns positions and \\nu . Warning If the outer layers of a star have a very low density\n  compared to the core, it can happen that, irrespective\n  of the initial particle distribution and the APM\n  parameters, the particle distribution output by the\n  APM does not have a smooth surface. In this case,\n  the only solution (that has been found as of 20.10.2021)\n  is to increase the particle number. As of 20.10.2021, this has only happened with the\n  CompOSE tabulated EOS (all of them), but not with\n  any piecewise polytropic or polytropic EOS. This problem can manifest itself with error messages\n  concerning particles occupying the sameposition,\n  or some smoothing lengths being 0, or a matrix not being\n  invertible. FT 20.10.2021 FT 04.06.2021 Arguments Type Intent Optional Attributes Name function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine get_nstar_p(npart_real, x, y, z, nstar_p) Computes the proper baryon number density at the particle positions Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real Number of real particles (i.e., no ghost particles included here) double precision, intent(in) :: x (npart_real) Array of x coordinates double precision, intent(in) :: y (npart_real) Array of y coordinates double precision, intent(in) :: z (npart_real) Array of z coordinates double precision, intent(out) :: nstar_p (npart_real) Array to store the computed proper baryon number density double precision, intent(inout), DIMENSION(:,:) :: pos_input Initial particle positions double precision, intent(inout), DIMENSION(:) :: pvol Initial particle volume double precision, intent(out), DIMENSION(:) :: h_output Array to store the smoothing lengths computed at the end of the\n APM iteration double precision, intent(out), DIMENSION(:) :: nu_output Array to store the baryon number per particle computed at the end of\n the APM iteration double precision, intent(in) :: center Center of the star (point of highest density), computed by \\texttt{LORENE} double precision, intent(in) :: com_star Center of mass of the star, computed by \\texttt{LORENE} double precision, intent(in) :: mass Mass of the star double precision, intent(in) :: radx_comp Radius of the star in the x direction, towards the companion double precision, intent(in) :: radx_opp Radius of the star in the x direction, opposite to companion double precision, intent(in) :: rady Radius of the star in the y direction double precision, intent(in) :: radz Radius of the star in the z direction integer, intent(in) :: apm_max_it Maximum number of APM iterations, irrespective of the EXIT condition integer, intent(in) :: max_inc Sets the EXIT condition: If the average over all the\n particles of the relative error in the density estimate\n grows max_inc times, exit the iteration. logical, intent(in) :: mass_it If .TRUE. performs a second iteration after the APM one, without moving\n the particles, changing their mass in order to better match\n the star density. The mass ratio grows very fast in all the tried\n experiments, hence the suggested value is .FALSE. logical, intent(in) :: correct_nu If .TRUE., the baryon number per particle nu is corrected\n to include the total baryonic masses of the\n stars. double precision, intent(in) :: nuratio_thres Maximum mass ratio (equivalently baryon number ratio)\n to be used in the one-time-only final correction\n of the particle masses to match the star density even\n better (without moving the particles) double precision, intent(in) :: nuratio_des Sets the EXIT condition: If the baryon number ratio\n is within 2.5% of nuratio_des, exit the iteration\n Set nuratio_des to 0 to deactivate and exit the APM\n iteration using max_inc integer, intent(in) :: nx_gh Number of lattice points in the x direction for ghosts integer, intent(in) :: ny_gh Number of lattice points in the y direction for ghosts integer, intent(in) :: nz_gh Number of lattice points in the z direction for ghosts character(len=*), intent(inout), optional :: namefile_pos_id Name for the formatted file where the initial particle positions character(len=*), intent(inout), optional :: namefile_pos Name for the formatted file where the particle positions character(len=*), intent(inout), optional :: namefile_results Name for the formatted file where various quantities related procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise Calls proc~~perform_apm~~CallsGraph proc~perform_apm perform_apm nu nu proc~perform_apm->nu iorig iorig proc~perform_apm->iorig allocate_metric_on_particles allocate_metric_on_particles proc~perform_apm->allocate_metric_on_particles deallocate_metric_on_particles deallocate_metric_on_particles proc~perform_apm->deallocate_metric_on_particles allocate_rcb_tree_memory_3d allocate_rcb_tree_memory_3d proc~perform_apm->allocate_rcb_tree_memory_3d com com proc~perform_apm->com none~validate_position_final validate_position_final proc~perform_apm->none~validate_position_final proc~check_particle_positions check_particle_positions proc~perform_apm->proc~check_particle_positions density density proc~perform_apm->density assign_h assign_h proc~perform_apm->assign_h allocate_gradient allocate_gradient proc~perform_apm->allocate_gradient proc~correct_center_of_mass correct_center_of_mass proc~perform_apm->proc~correct_center_of_mass proc~impose_equatorial_plane_symmetry impose_equatorial_plane_symmetry proc~perform_apm->proc~impose_equatorial_plane_symmetry deallocate_rcb_tree_memory_3d deallocate_rcb_tree_memory_3d proc~perform_apm->deallocate_rcb_tree_memory_3d ncand ncand proc~perform_apm->ncand allocate_sph_memory allocate_sph_memory proc~perform_apm->allocate_sph_memory position_correction position_correction proc~perform_apm->position_correction deallocate_gradient deallocate_gradient proc~perform_apm->deallocate_gradient h h proc~perform_apm->h deallocate_sph_memory deallocate_sph_memory proc~perform_apm->deallocate_sph_memory density_loop density_loop proc~perform_apm->density_loop exact_nei_tree_update exact_nei_tree_update proc~perform_apm->exact_nei_tree_update validate_position validate_position none~validate_position_final->validate_position indexx indexx proc~check_particle_positions->indexx proc~correct_center_of_mass->com proc~impose_equatorial_plane_symmetry->com Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~perform_apm~~CalledByGraph proc~perform_apm perform_apm interface~perform_apm perform_apm interface~perform_apm->proc~perform_apm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a a2 a_numax a_numax2 a_numin a_numin2 all_pos all_pos_best all_pos_tmp all_pos_tmp2 art_pr art_pr_max baryon_density cnt1 com_d com_x com_y com_z correction_pos dN dN_av dN_max dNstar debug dim_seed dx dy dz ellipse_thickness energy_density eps err_N_max err_N_mean err_N_mean_min err_N_mean_min_old err_mean_old err_n_min exist few_ncand finalnamefile freeze g_xx g_xy g_xz g_yy g_yz g_zz ghost_dist ghost_pos ghost_pos_tmp good_h h_av h_guess h_max h_tmp i iter_tol itr itr2 j k lapse larger_radius m_max_it max_npart max_nu max_nu2 max_r_real max_z_real mean_nu min_nu min_nu2 n_inc n_neighbors nearest_neighbors neighbors_lists nn_des npart_all npart_ghost npart_real npart_real_half nstar_int nstar_p nstar_p_err nstar_real nstar_real_err nu_all nu_one nu_ratio nu_tmp nu_tmp2 nu_tot nuratio_tmp nx ny nz particle_density_final pos pos_corr_tmp pos_maxerr pos_tmp pressure r_real r_tmp rad_x rad_y rad_z radius_y radius_z rand_num rand_num2 rel_sign search_pos seed shift_x shift_y shift_z smaller_radius specific_energy stddev_nu tmp tol v_euler_x v_euler_y v_euler_z variance_nu x_ell xmax xmin xtemp y_ell ymax ymin ytemp z_ell zmax zmin ztemp Functions validate_position_final Variables Type Visibility Attributes Name Initial integer, private :: a integer, private :: a2 integer, private :: a_numax integer, private :: a_numax2 integer, private :: a_numin integer, private :: a_numin2 double precision, private, DIMENSION(:,:), ALLOCATABLE :: all_pos double precision, private, DIMENSION(:,:), ALLOCATABLE :: all_pos_best double precision, private, DIMENSION(:,:), ALLOCATABLE :: all_pos_tmp double precision, private, DIMENSION(:,:), ALLOCATABLE :: all_pos_tmp2 double precision, private, DIMENSION(:), ALLOCATABLE :: art_pr double precision, private :: art_pr_max double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density integer, private :: cnt1 double precision, private :: com_d double precision, private :: com_x double precision, private :: com_y double precision, private :: com_z double precision, private, DIMENSION(:,:), ALLOCATABLE :: correction_pos double precision, private :: dN double precision, private :: dN_av double precision, private :: dN_max double precision, private, DIMENSION(:), ALLOCATABLE :: dNstar logical, private, parameter :: debug = .FALSE. integer, private :: dim_seed double precision, private :: dx double precision, private :: dy double precision, private :: dz double precision, private, parameter :: ellipse_thickness = 1.25D0 double precision, private, DIMENSION(:), ALLOCATABLE :: energy_density double precision, private :: eps double precision, private :: err_N_max double precision, private :: err_N_mean double precision, private :: err_N_mean_min double precision, private :: err_N_mean_min_old double precision, private :: err_mean_old double precision, private :: err_n_min logical, private :: exist logical, private :: few_ncand character(len=:), private, ALLOCATABLE :: finalnamefile double precision, private, DIMENSION(:), ALLOCATABLE :: freeze double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx double precision, private, DIMENSION(:), ALLOCATABLE :: g_xy double precision, private, DIMENSION(:), ALLOCATABLE :: g_xz double precision, private, DIMENSION(:), ALLOCATABLE :: g_yy double precision, private, DIMENSION(:), ALLOCATABLE :: g_yz double precision, private, DIMENSION(:), ALLOCATABLE :: g_zz double precision, private, parameter :: ghost_dist = 0.2D0 double precision, private, DIMENSION(:,:), ALLOCATABLE :: ghost_pos double precision, private, DIMENSION(:,:,:,:), ALLOCATABLE :: ghost_pos_tmp logical, private :: good_h double precision, private :: h_av double precision, private, DIMENSION(:), ALLOCATABLE :: h_guess double precision, private :: h_max double precision, private, DIMENSION(:), ALLOCATABLE :: h_tmp integer, private :: i double precision, private, parameter :: iter_tol = 2.0D-2 integer, private :: itr integer, private :: itr2 integer, private :: j integer, private :: k double precision, private, DIMENSION(:), ALLOCATABLE :: lapse double precision, private :: larger_radius integer, private, parameter :: m_max_it = 50 integer, private, parameter :: max_npart = 5D+6 double precision, private :: max_nu double precision, private :: max_nu2 double precision, private :: max_r_real double precision, private :: max_z_real double precision, private :: mean_nu double precision, private :: min_nu double precision, private :: min_nu2 integer, private :: n_inc integer, private, DIMENSION(:), ALLOCATABLE :: n_neighbors double precision, private, DIMENSION(:,:), ALLOCATABLE :: nearest_neighbors integer, private, DIMENSION(:), ALLOCATABLE :: neighbors_lists integer, private, parameter :: nn_des = 301 integer, private :: npart_all integer, private :: npart_ghost integer, private :: npart_real integer, private :: npart_real_half double precision, private, DIMENSION(:), ALLOCATABLE :: nstar_int double precision, private, DIMENSION(:), ALLOCATABLE :: nstar_p double precision, private :: nstar_p_err double precision, private, DIMENSION(:), ALLOCATABLE :: nstar_real double precision, private :: nstar_real_err double precision, private :: nu_all double precision, private, DIMENSION(:), ALLOCATABLE :: nu_one double precision, private :: nu_ratio double precision, private, DIMENSION(:), ALLOCATABLE :: nu_tmp double precision, private :: nu_tmp2 double precision, private :: nu_tot double precision, private :: nuratio_tmp integer, private :: nx integer, private :: ny integer, private :: nz double precision, private, DIMENSION(:), ALLOCATABLE :: particle_density_final double precision, private, DIMENSION(:,:), ALLOCATABLE :: pos double precision, private, DIMENSION(3) :: pos_corr_tmp double precision, private, DIMENSION(3) :: pos_maxerr double precision, private, DIMENSION(:,:), ALLOCATABLE :: pos_tmp double precision, private, DIMENSION(:), ALLOCATABLE :: pressure double precision, private :: r_real double precision, private :: r_tmp double precision, private :: rad_x double precision, private :: rad_y double precision, private :: rad_z double precision, private :: radius_y double precision, private :: radius_z double precision, private :: rand_num double precision, private :: rand_num2 integer, private :: rel_sign integer, private, parameter :: search_pos = 10 integer, private, DIMENSION(:), ALLOCATABLE :: seed double precision, private, DIMENSION(:), ALLOCATABLE :: shift_x double precision, private, DIMENSION(:), ALLOCATABLE :: shift_y double precision, private, DIMENSION(:), ALLOCATABLE :: shift_z double precision, private :: smaller_radius double precision, private, DIMENSION(:), ALLOCATABLE :: specific_energy double precision, private :: stddev_nu double precision, private :: tmp double precision, private, parameter :: tol = 1.0D-3 double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_x double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_y double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_z double precision, private :: variance_nu double precision, private :: x_ell double precision, private :: xmax double precision, private :: xmin double precision, private :: xtemp double precision, private :: y_ell double precision, private :: ymax double precision, private :: ymin double precision, private :: ytemp double precision, private :: z_ell double precision, private :: zmax double precision, private :: zmin double precision, private :: ztemp Functions function validate_position_final(x, y, z) result(answer) Returns validate_position( x, y, z ) if the latter\n  is present, 0 otherwise FT 22.09.2021 Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value integer validate_position( x, y, z ) if the latter is present, 0 otherwise","tags":"","loc":"proc/perform_apm.html"},{"title":"reshape_sph_field_1d – SPHINCS_LORENE","text":"module procedure reshape_sph_field_1d module procedure reshape_sph_field_1d() Read the SPH ID from the binary file output\n  by write_SPHINCS_dump, and print it to a\n  formatted file FT 31.03.2021 Arguments None Calls proc~~reshape_sph_field_1d~~CallsGraph proc~reshape_sph_field_1d reshape_sph_field_1d field field proc~reshape_sph_field_1d->field index_array index_array proc~reshape_sph_field_1d->index_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i_tmp itr tmp Variables Type Visibility Attributes Name Initial integer, private :: i_tmp integer, private :: itr double precision, private, DIMENSION(:), ALLOCATABLE :: tmp","tags":"","loc":"proc/reshape_sph_field_1d.html"},{"title":"reshape_sph_field_2d – SPHINCS_LORENE","text":"module procedure reshape_sph_field_2d module procedure reshape_sph_field_2d() Read the SPH ID from the binary file output\n  by write_SPHINCS_dump, and print it to a\n  formatted file FT 31.03.2021 Arguments None Calls proc~~reshape_sph_field_2d~~CallsGraph proc~reshape_sph_field_2d reshape_sph_field_2d field field proc~reshape_sph_field_2d->field index_array index_array proc~reshape_sph_field_2d->index_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i_tmp itr itr2 tmp Variables Type Visibility Attributes Name Initial integer, private :: i_tmp integer, private :: itr integer, private :: itr2 double precision, private, DIMENSION(:,:), ALLOCATABLE :: tmp","tags":"","loc":"proc/reshape_sph_field_2d.html"},{"title":"integrate_baryon_mass_density – SPHINCS_LORENE","text":"module procedure integrate_baryon_mass_density module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Interface → Uses NR constants utility proc~~integrate_baryon_mass_density~~UsesGraph proc~integrate_baryon_mass_density integrate_baryon_mass_density NR NR proc~integrate_baryon_mass_density->NR constants constants proc~integrate_baryon_mass_density->constants module~utility utility proc~integrate_baryon_mass_density->module~utility matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Perform 3D integration over a spherical grid\n  of the baryon mass density. Output baryon\n  mass and radial mass profile. FT 19.02.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order Calls proc~~integrate_baryon_mass_density~~CallsGraph proc~integrate_baryon_mass_density integrate_baryon_mass_density indexx indexx proc~integrate_baryon_mass_density->indexx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~integrate_baryon_mass_density~~CalledByGraph proc~integrate_baryon_mass_density integrate_baryon_mass_density interface~integrate_baryon_mass_density integrate_baryon_mass_density interface~integrate_baryon_mass_density->proc~integrate_baryon_mass_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables baryon_density colat debug g_xx gamma_euler long mass_element phi r rad_coord sq_g th Variables Type Visibility Attributes Name Initial double precision, private :: baryon_density double precision, private :: colat logical, private, parameter :: debug = .TRUE. double precision, private :: g_xx double precision, private :: gamma_euler double precision, private :: long double precision, private :: mass_element integer, private :: phi integer, private :: r double precision, private :: rad_coord double precision, private :: sq_g integer, private :: th","tags":"","loc":"proc/integrate_baryon_mass_density.html"},{"title":"check_i_matter – SPHINCS_LORENE","text":"module procedure check_i_matter module module subroutine check_i_matter(THIS, i_matter) Interface → Checks that the given index i_matter is\n  between 1 and [[idbase:n_matter]], included.\n  If not, it stops the execution of the program. FT 2.11.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked Called by proc~~check_i_matter~~CalledByGraph proc~check_i_matter check_i_matter interface~check_i_matter check_i_matter interface~check_i_matter->proc~check_i_matter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/check_i_matter.html"},{"title":"get_n_matter – SPHINCS_LORENE","text":"module procedure get_n_matter module module function get_n_matter(THIS) Interface → Returns [[idbase:n_matter]], the number of\n  matter objects in the physical system FT 28.10.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the Called by proc~~get_n_matter~~CalledByGraph proc~get_n_matter get_n_matter interface~get_n_matter get_n_matter interface~get_n_matter->proc~get_n_matter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_n_matter.html"},{"title":"get_one_lapse – SPHINCS_LORENE","text":"module procedure get_one_lapse module module function get_one_lapse(THIS) Interface → Returns [[idbase:one_lapse]] FT 3.11.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the Called by proc~~get_one_lapse~~CalledByGraph proc~get_one_lapse get_one_lapse interface~get_one_lapse get_one_lapse interface~get_one_lapse->proc~get_one_lapse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_one_lapse.html"},{"title":"get_total_spatial_extent – SPHINCS_LORENE","text":"module procedure get_total_spatial_extent module module function get_total_spatial_extent(THIS) result(box) Interface → Return the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box containing the entire physical system FT 28.10.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. Called by proc~~get_total_spatial_extent~~CalledByGraph proc~get_total_spatial_extent get_total_spatial_extent interface~get_total_spatial_extent get_total_spatial_extent interface~get_total_spatial_extent->proc~get_total_spatial_extent Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables center_matter i_matter size_matter Variables Type Visibility Attributes Name Initial double precision, private, DIMENSION(3) :: center_matter integer, private :: i_matter double precision, private, DIMENSION(6) :: size_matter","tags":"","loc":"proc/get_total_spatial_extent.html"},{"title":"get_zero_shift – SPHINCS_LORENE","text":"module procedure get_zero_shift module module function get_zero_shift(THIS) Interface → Returns [[idbase:zero_shift]] FT 3.11.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the Called by proc~~get_zero_shift~~CalledByGraph proc~get_zero_shift get_zero_shift interface~get_zero_shift get_zero_shift interface~get_zero_shift->proc~get_zero_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_zero_shift.html"},{"title":"set_n_matter – SPHINCS_LORENE","text":"module procedure set_n_matter module module subroutine set_n_matter(THIS, value) Interface → Sets [[idbase:n_matter]] to the given value FT 28.10.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to Called by proc~~set_n_matter~~CalledByGraph proc~set_n_matter set_n_matter interface~set_n_matter set_n_matter interface~set_n_matter->proc~set_n_matter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_n_matter.html"},{"title":"set_one_lapse – SPHINCS_LORENE","text":"module procedure set_one_lapse module module subroutine set_one_lapse(THIS, logic) Interface → Sets [[idbase:one_lapse]] to the given value FT 3.11.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to Called by proc~~set_one_lapse~~CalledByGraph proc~set_one_lapse set_one_lapse interface~set_one_lapse set_one_lapse interface~set_one_lapse->proc~set_one_lapse Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_one_lapse.html"},{"title":"set_zero_shift – SPHINCS_LORENE","text":"module procedure set_zero_shift module module subroutine set_zero_shift(THIS, logic) Interface → Sets [[idbase:zero_shift]] to the given value FT 3.11.2021 Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to Called by proc~~set_zero_shift~~CalledByGraph proc~set_zero_shift set_zero_shift interface~set_zero_shift set_zero_shift interface~set_zero_shift->proc~set_zero_shift Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/set_zero_shift.html"},{"title":"integrate_baryon_mass_density – SPHINCS_LORENE","text":"module procedure integrate_baryon_mass_density module procedure integrate_baryon_mass_density() Uses NR constants proc~~integrate_baryon_mass_density~2~~UsesGraph proc~integrate_baryon_mass_density~2 integrate_baryon_mass_density NR NR proc~integrate_baryon_mass_density~2->NR constants constants proc~integrate_baryon_mass_density~2->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Perform 3D integration over a spherical grid\n  of the baryon mass density. Output baryon\n  mass and radial mass profile. FT 19.02.2021 Arguments None Calls proc~~integrate_baryon_mass_density~2~~CallsGraph proc~integrate_baryon_mass_density~2 integrate_baryon_mass_density mass_profile_idx mass_profile_idx proc~integrate_baryon_mass_density~2->mass_profile_idx indexx indexx proc~integrate_baryon_mass_density~2->indexx mass_profile mass_profile proc~integrate_baryon_mass_density~2->mass_profile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables baryon_density colat debug g_xx gamma_euler long mass_element phi r rad_coord sq_g th Variables Type Visibility Attributes Name Initial double precision, private :: baryon_density double precision, private :: colat logical, private, parameter :: debug = .TRUE. double precision, private :: g_xx double precision, private :: gamma_euler double precision, private :: long double precision, private :: mass_element integer, private :: phi integer, private :: r double precision, private :: rad_coord double precision, private :: sq_g integer, private :: th","tags":"","loc":"proc/integrate_baryon_mass_density~2.html"},{"title":"get_adm_mass – SPHINCS_LORENE","text":"module procedure get_adm_mass module module function get_adm_mass(THIS) Interface → Returns the ADM mass of the system FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_adm_mass~~CalledByGraph proc~get_adm_mass get_adm_mass interface~get_adm_mass get_adm_mass interface~get_adm_mass->proc~get_adm_mass Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_adm_mass.html"},{"title":"get_angular_momentum – SPHINCS_LORENE","text":"module procedure get_angular_momentum module module function get_angular_momentum(THIS) Interface → Returns the angular momentum of the system FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_angular_momentum~~CalledByGraph proc~get_angular_momentum get_angular_momentum interface~get_angular_momentum get_angular_momentum interface~get_angular_momentum->proc~get_angular_momentum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_angular_momentum.html"},{"title":"get_angular_vel – SPHINCS_LORENE","text":"module procedure get_angular_vel module module function get_angular_vel(THIS) Interface → Returns the angular velocity of the system FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_angular_vel~~CalledByGraph proc~get_angular_vel get_angular_vel interface~get_angular_vel get_angular_vel interface~get_angular_vel->proc~get_angular_vel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_angular_vel.html"},{"title":"get_barycenter – SPHINCS_LORENE","text":"module procedure get_barycenter module module function get_barycenter(THIS, i_matter) Interface → Returns the barycenter of the i_matter -th star\n  [ L_\\odot ] FT 27.10.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Called by proc~~get_barycenter~~CalledByGraph proc~get_barycenter get_barycenter interface~get_barycenter get_barycenter interface~get_barycenter->proc~get_barycenter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_barycenter.html"},{"title":"get_barycenter1_x – SPHINCS_LORENE","text":"module procedure get_barycenter1_x module module function get_barycenter1_x(THIS) Interface → Returns the barycenter of NS 1 FT 09.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_barycenter1_x~~CalledByGraph proc~get_barycenter1_x get_barycenter1_x interface~get_barycenter1_x get_barycenter1_x interface~get_barycenter1_x->proc~get_barycenter1_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_barycenter1_x.html"},{"title":"get_barycenter2_x – SPHINCS_LORENE","text":"module procedure get_barycenter2_x module module function get_barycenter2_x(THIS) Interface → Returns the barycenter of NS 2 FT 09.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_barycenter2_x~~CalledByGraph proc~get_barycenter2_x get_barycenter2_x interface~get_barycenter2_x get_barycenter2_x interface~get_barycenter2_x->proc~get_barycenter2_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_barycenter2_x.html"},{"title":"get_center – SPHINCS_LORENE","text":"module procedure get_center module module function get_center(THIS, i_matter) Interface → Returns the center of the i_matter -th star\n  [ L_\\odot ] FT 27.10.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Called by proc~~get_center~~CalledByGraph proc~get_center get_center interface~get_center get_center interface~get_center->proc~get_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_center.html"},{"title":"get_center1_x – SPHINCS_LORENE","text":"module procedure get_center1_x module module function get_center1_x(THIS) Interface → Returns the stellar center of NS 1, i.e., the\n  origin of the LORENE chart centered on NS 1 FT 09.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_center1_x~~CalledByGraph proc~get_center1_x get_center1_x interface~get_center1_x get_center1_x interface~get_center1_x->proc~get_center1_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_center1_x.html"},{"title":"get_center2_x – SPHINCS_LORENE","text":"module procedure get_center2_x module module function get_center2_x(THIS) Interface → Returns the stellar center of NS 2, i.e., the\n  origin of the LORENE chart centered on NS 2 FT 09.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_center2_x~~CalledByGraph proc~get_center2_x get_center2_x interface~get_center2_x get_center2_x interface~get_center2_x->proc~get_center2_x Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_center2_x.html"},{"title":"get_distance – SPHINCS_LORENE","text":"module procedure get_distance module module function get_distance(THIS) Interface → Returns the distance between the NSs FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_distance~~CalledByGraph proc~get_distance get_distance interface~get_distance get_distance interface~get_distance->proc~get_distance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_distance.html"},{"title":"get_distance_com – SPHINCS_LORENE","text":"module procedure get_distance_com module module function get_distance_com(THIS) Interface → Returns the distance between the centers of\n  mass of the NSs FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_distance_com~~CalledByGraph proc~get_distance_com get_distance_com interface~get_distance_com get_distance_com interface~get_distance_com->proc~get_distance_com Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_distance_com.html"},{"title":"get_energy_density_center1 – SPHINCS_LORENE","text":"module procedure get_energy_density_center1 module module function get_energy_density_center1(THIS) Interface → Returns the central energy density of NS 1 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_energy_density_center1~~CalledByGraph proc~get_energy_density_center1 get_energy_density_center1 interface~get_energy_density_center1 get_energy_density_center1 interface~get_energy_density_center1->proc~get_energy_density_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_energy_density_center1.html"},{"title":"get_energy_density_center2 – SPHINCS_LORENE","text":"module procedure get_energy_density_center2 module module function get_energy_density_center2(THIS) Interface → Returns the central energy density of NS 2 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_energy_density_center2~~CalledByGraph proc~get_energy_density_center2 get_energy_density_center2 interface~get_energy_density_center2 get_energy_density_center2 interface~get_energy_density_center2->proc~get_energy_density_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_energy_density_center2.html"},{"title":"get_ent_center1 – SPHINCS_LORENE","text":"module procedure get_ent_center1 module module function get_ent_center1(THIS) Interface → Returns the central enthalpy of NS 1 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_ent_center1~~CalledByGraph proc~get_ent_center1 get_ent_center1 interface~get_ent_center1 get_ent_center1 interface~get_ent_center1->proc~get_ent_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ent_center1.html"},{"title":"get_ent_center2 – SPHINCS_LORENE","text":"module procedure get_ent_center2 module module function get_ent_center2(THIS) Interface → Returns the central enthalpy of NS 2 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_ent_center2~~CalledByGraph proc~get_ent_center2 get_ent_center2 interface~get_ent_center2 get_ent_center2 interface~get_ent_center2->proc~get_ent_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ent_center2.html"},{"title":"get_eos – SPHINCS_LORENE","text":"module procedure get_eos module module function get_eos(THIS, i_matter) Interface → Returns the EoS name of the i_matter -th star\n  [ L_\\odot ] FT 27.10.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE Called by proc~~get_eos~~CalledByGraph proc~get_eos get_eos interface~get_eos get_eos interface~get_eos->proc~get_eos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos.html"},{"title":"get_eos1 – SPHINCS_LORENE","text":"module procedure get_eos1 module module function get_eos1(THIS) Interface → Returns the name of the EOS for NS 1 FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE Called by proc~~get_eos1~~CalledByGraph proc~get_eos1 get_eos1 interface~get_eos1 get_eos1 interface~get_eos1->proc~get_eos1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos1.html"},{"title":"get_eos2 – SPHINCS_LORENE","text":"module procedure get_eos2 module module function get_eos2(THIS) Interface → Returns the name of the EOS for NS 2 FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE Called by proc~~get_eos2~~CalledByGraph proc~get_eos2 get_eos2 interface~get_eos2 get_eos2 interface~get_eos2->proc~get_eos2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos2.html"},{"title":"get_gamma0_1 – SPHINCS_LORENE","text":"module procedure get_gamma0_1 module module function get_gamma0_1(THIS) Interface → Returns the value of [[gamma0_1]], the crust's\n  polytropic index for NS 1 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma0_1~~CalledByGraph proc~get_gamma0_1 get_gamma0_1 interface~get_gamma0_1 get_gamma0_1 interface~get_gamma0_1->proc~get_gamma0_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma0_1.html"},{"title":"get_gamma0_2 – SPHINCS_LORENE","text":"module procedure get_gamma0_2 module module function get_gamma0_2(THIS) Interface → Returns the value of [[gamma0_2]], the crust's\n  polytropic index for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma0_2~~CalledByGraph proc~get_gamma0_2 get_gamma0_2 interface~get_gamma0_2 get_gamma0_2 interface~get_gamma0_2->proc~get_gamma0_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma0_2.html"},{"title":"get_gamma1_1 – SPHINCS_LORENE","text":"module procedure get_gamma1_1 module module function get_gamma1_1(THIS) Interface → Returns the value of [[gamma1_1]], the first\n  polytropic index for NS 1 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma1_1~~CalledByGraph proc~get_gamma1_1 get_gamma1_1 interface~get_gamma1_1 get_gamma1_1 interface~get_gamma1_1->proc~get_gamma1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma1_1.html"},{"title":"get_gamma1_2 – SPHINCS_LORENE","text":"module procedure get_gamma1_2 module module function get_gamma1_2(THIS) Interface → Returns the value of [[gamma1_2]], the first\n  polytropic index for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma1_2~~CalledByGraph proc~get_gamma1_2 get_gamma1_2 interface~get_gamma1_2 get_gamma1_2 interface~get_gamma1_2->proc~get_gamma1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma1_2.html"},{"title":"get_gamma2_1 – SPHINCS_LORENE","text":"module procedure get_gamma2_1 module module function get_gamma2_1(THIS) Interface → Returns the value of [[gamma2_1]], the second\n  polytropic index for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma2_1~~CalledByGraph proc~get_gamma2_1 get_gamma2_1 interface~get_gamma2_1 get_gamma2_1 interface~get_gamma2_1->proc~get_gamma2_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma2_1.html"},{"title":"get_gamma2_2 – SPHINCS_LORENE","text":"module procedure get_gamma2_2 module module function get_gamma2_2(THIS) Interface → Returns the value of [[gamma2_2]], the second\n  polytropic index for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma2_2~~CalledByGraph proc~get_gamma2_2 get_gamma2_2 interface~get_gamma2_2 get_gamma2_2 interface~get_gamma2_2->proc~get_gamma2_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma2_2.html"},{"title":"get_gamma3_1 – SPHINCS_LORENE","text":"module procedure get_gamma3_1 module module function get_gamma3_1(THIS) Interface → Returns the value of [[gamma3_1]], the third\n  polytropic index for NS 1 with piecewise\n  polytropic EOS (innermost index) FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma3_1~~CalledByGraph proc~get_gamma3_1 get_gamma3_1 interface~get_gamma3_1 get_gamma3_1 interface~get_gamma3_1->proc~get_gamma3_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma3_1.html"},{"title":"get_gamma3_2 – SPHINCS_LORENE","text":"module procedure get_gamma3_2 module module function get_gamma3_2(THIS) Interface → Returns the value of [[gamma3_2]], the third\n  polytropic index for NS 2 with piecewise\n  polytropic EOS (innermost index) FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma3_2~~CalledByGraph proc~get_gamma3_2 get_gamma3_2 interface~get_gamma3_2 get_gamma3_2 interface~get_gamma3_2->proc~get_gamma3_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma3_2.html"},{"title":"get_gamma_1 – SPHINCS_LORENE","text":"module procedure get_gamma_1 module module function get_gamma_1(THIS) Interface → Returns the value of [[gamma_1]], the\n  polytropic index for NS 1 with polytropic EOS,\n  not piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma_1~~CalledByGraph proc~get_gamma_1 get_gamma_1 interface~get_gamma_1 get_gamma_1 interface~get_gamma_1->proc~get_gamma_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma_1.html"},{"title":"get_gamma_2 – SPHINCS_LORENE","text":"module procedure get_gamma_2 module module function get_gamma_2(THIS) Interface → Returns the value of [[gamma_2]], the\n  polytropic index for NS 2 with polytropic EOS,\n  not piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma_2~~CalledByGraph proc~get_gamma_2 get_gamma_2 interface~get_gamma_2 get_gamma_2 interface~get_gamma_2->proc~get_gamma_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma_2.html"},{"title":"get_grav_mass1 – SPHINCS_LORENE","text":"module procedure get_grav_mass1 module module function get_grav_mass1(THIS) Interface → Returns the gravitational mass of NS 1 [ M_\\odot ] FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_grav_mass1~~CalledByGraph proc~get_grav_mass1 get_grav_mass1 interface~get_grav_mass1 get_grav_mass1 interface~get_grav_mass1->proc~get_grav_mass1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_grav_mass1.html"},{"title":"get_grav_mass2 – SPHINCS_LORENE","text":"module procedure get_grav_mass2 module module function get_grav_mass2(THIS) Interface → Returns the gravitational mass of NS 2 [ M_\\odot ] FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_grav_mass2~~CalledByGraph proc~get_grav_mass2 get_grav_mass2 interface~get_grav_mass2 get_grav_mass2 interface~get_grav_mass2->proc~get_grav_mass2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_grav_mass2.html"},{"title":"get_kappa0_1 – SPHINCS_LORENE","text":"module procedure get_kappa0_1 module module function get_kappa0_1(THIS) Interface → Returns the value of [[kappa0_1]], the crust's\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa0_1~~CalledByGraph proc~get_kappa0_1 get_kappa0_1 interface~get_kappa0_1 get_kappa0_1 interface~get_kappa0_1->proc~get_kappa0_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa0_1.html"},{"title":"get_kappa0_2 – SPHINCS_LORENE","text":"module procedure get_kappa0_2 module module function get_kappa0_2(THIS) Interface → Returns the value of [[kappa0_2]], the crust's\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa0_2~~CalledByGraph proc~get_kappa0_2 get_kappa0_2 interface~get_kappa0_2 get_kappa0_2 interface~get_kappa0_2->proc~get_kappa0_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa0_2.html"},{"title":"get_kappa1_1 – SPHINCS_LORENE","text":"module procedure get_kappa1_1 module module function get_kappa1_1(THIS) Interface → Returns the value of [[kappa1_1]], the first\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa1_1~~CalledByGraph proc~get_kappa1_1 get_kappa1_1 interface~get_kappa1_1 get_kappa1_1 interface~get_kappa1_1->proc~get_kappa1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa1_1.html"},{"title":"get_kappa1_2 – SPHINCS_LORENE","text":"module procedure get_kappa1_2 module module function get_kappa1_2(THIS) Interface → Returns the value of [[kappa1_2]], the first\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa1_2~~CalledByGraph proc~get_kappa1_2 get_kappa1_2 interface~get_kappa1_2 get_kappa1_2 interface~get_kappa1_2->proc~get_kappa1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa1_2.html"},{"title":"get_kappa2_1 – SPHINCS_LORENE","text":"module procedure get_kappa2_1 module module function get_kappa2_1(THIS) Interface → Returns the value of [[kappa2_1]], the second\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa2_1~~CalledByGraph proc~get_kappa2_1 get_kappa2_1 interface~get_kappa2_1 get_kappa2_1 interface~get_kappa2_1->proc~get_kappa2_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa2_1.html"},{"title":"get_kappa2_2 – SPHINCS_LORENE","text":"module procedure get_kappa2_2 module module function get_kappa2_2(THIS) Interface → Returns the value of [[kappa2_2]], the second\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa2_2~~CalledByGraph proc~get_kappa2_2 get_kappa2_2 interface~get_kappa2_2 get_kappa2_2 interface~get_kappa2_2->proc~get_kappa2_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa2_2.html"},{"title":"get_kappa3_1 – SPHINCS_LORENE","text":"module procedure get_kappa3_1 module module function get_kappa3_1(THIS) Interface → Returns the value of [[kappa3_1]], the third\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa3_1~~CalledByGraph proc~get_kappa3_1 get_kappa3_1 interface~get_kappa3_1 get_kappa3_1 interface~get_kappa3_1->proc~get_kappa3_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa3_1.html"},{"title":"get_kappa3_2 – SPHINCS_LORENE","text":"module procedure get_kappa3_2 module module function get_kappa3_2(THIS) Interface → Returns the value of [[kappa3_2]], the third\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa3_2~~CalledByGraph proc~get_kappa3_2 get_kappa3_2 interface~get_kappa3_2 get_kappa3_2 interface~get_kappa3_2->proc~get_kappa3_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa3_2.html"},{"title":"get_kappa_1 – SPHINCS_LORENE","text":"module procedure get_kappa_1 module module function get_kappa_1(THIS) Interface → Returns the value of [[kappa_1]], the\n  polytropic constant for NS 1 with polytropic\n  EOS, not piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa_1~~CalledByGraph proc~get_kappa_1 get_kappa_1 interface~get_kappa_1 get_kappa_1 interface~get_kappa_1->proc~get_kappa_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa_1.html"},{"title":"get_kappa_2 – SPHINCS_LORENE","text":"module procedure get_kappa_2 module module function get_kappa_2(THIS) Interface → Returns the value of [[kappa_2]], the\n  polytropic constant for NS 2 with polytropic\n  EOS, not piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa_2~~CalledByGraph proc~get_kappa_2 get_kappa_2 interface~get_kappa_2 get_kappa_2 interface~get_kappa_2->proc~get_kappa_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa_2.html"},{"title":"get_logRho0_1 – SPHINCS_LORENE","text":"module procedure get_logRho0_1 module module function get_logRho0_1(THIS) Interface → Returns the value of [[logRho0_1]], the base 10\n  logarithm of the mass density where the\n  gamma1_1 polytrope starts, for NS 1 with\n  piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho0_1~~CalledByGraph proc~get_logrho0_1 get_logRho0_1 interface~get_logrho0_1 get_logRho0_1 interface~get_logrho0_1->proc~get_logrho0_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho0_1.html"},{"title":"get_logRho0_2 – SPHINCS_LORENE","text":"module procedure get_logRho0_2 module module function get_logRho0_2(THIS) Interface → Returns the value of [[logRho0_2]], the base 10\n  logarithm of the mass density where the\n  gamma1_2 polytrope starts, for NS 2 with\n  piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho0_2~~CalledByGraph proc~get_logrho0_2 get_logRho0_2 interface~get_logrho0_2 get_logRho0_2 interface~get_logrho0_2->proc~get_logrho0_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho0_2.html"},{"title":"get_logRho1_1 – SPHINCS_LORENE","text":"module procedure get_logRho1_1 module module function get_logRho1_1(THIS) Interface → Returns the value of [[logRho1_1]], the base 10\n  logarithm of the mass density where the\n  gamma2_1 polytrope starts, for NS 1 with\n  piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho1_1~~CalledByGraph proc~get_logrho1_1 get_logRho1_1 interface~get_logrho1_1 get_logRho1_1 interface~get_logrho1_1->proc~get_logrho1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho1_1.html"},{"title":"get_logRho1_2 – SPHINCS_LORENE","text":"module procedure get_logRho1_2 module module function get_logRho1_2(THIS) Interface → Returns the value of [[logRho1_2]], the base 10\n  logarithm of the mass density where the\n  gamma2_2 polytrope starts, for NS 2 with\n  piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho1_2~~CalledByGraph proc~get_logrho1_2 get_logRho1_2 interface~get_logrho1_2 get_logRho1_2 interface~get_logrho1_2->proc~get_logrho1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho1_2.html"},{"title":"get_logRho2_1 – SPHINCS_LORENE","text":"module procedure get_logRho2_1 module module function get_logRho2_1(THIS) Interface → Returns the value of [[logRho2_1]], the base 10\n  logarithm of the mass density where the\n  gamma3_1 polytrope starts, for NS 1 with\n  piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho2_1~~CalledByGraph proc~get_logrho2_1 get_logRho2_1 interface~get_logrho2_1 get_logRho2_1 interface~get_logrho2_1->proc~get_logrho2_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho2_1.html"},{"title":"get_logRho2_2 – SPHINCS_LORENE","text":"module procedure get_logRho2_2 module module function get_logRho2_2(THIS) Interface → Returns the value of [[logRho2_2]]]], the base 10\n  logarithm of the mass density where the\n  gamma3_2 polytrope starts, for NS 2 with\n  piecewise polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho2_2~~CalledByGraph proc~get_logrho2_2 get_logRho2_2 interface~get_logrho2_2 get_logRho2_2 interface~get_logrho2_2->proc~get_logrho2_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho2_2.html"},{"title":"get_logp1_1 – SPHINCS_LORENE","text":"module procedure get_logp1_1 module module function get_logp1_1(THIS) result(get_logP1_1) Interface → Returns the value of [[logp1_1]], the base 10\n  logarithm of the pressure where the gamma1_1\n  polytrope starts, for NS 1 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logp1_1~~CalledByGraph proc~get_logp1_1 get_logp1_1 interface~get_logp1_1 get_logP1_1 interface~get_logp1_1->proc~get_logp1_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logp1_1.html"},{"title":"get_logp1_2 – SPHINCS_LORENE","text":"module procedure get_logp1_2 module module function get_logp1_2(THIS) result(get_logP1_2) Interface → Returns the value of [[logp1_2]], the base 10\n  logarithm of the pressure where the gamma1_2\n  polytrope starts, for NS 2 with piecewise\n  polytropic EOS FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logp1_2~~CalledByGraph proc~get_logp1_2 get_logp1_2 interface~get_logp1_2 get_logP1_2 interface~get_logp1_2->proc~get_logp1_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logp1_2.html"},{"title":"get_mass – SPHINCS_LORENE","text":"module procedure get_mass module module function get_mass(THIS, i_matter) Interface → Returns the baryon mass of NS i_matter -th star\n  [ M_\\odot ] FT 27.10.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision Called by proc~~get_mass~~CalledByGraph proc~get_mass get_mass interface~get_mass~2 get_mass interface~get_mass~2->proc~get_mass Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_mass.html"},{"title":"get_mass1 – SPHINCS_LORENE","text":"module procedure get_mass1 module module function get_mass1(THIS) Interface → Returns the baryon mass of NS 1 [ M_\\odot ] FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_mass1~~CalledByGraph proc~get_mass1 get_mass1 interface~get_mass1 get_mass1 interface~get_mass1->proc~get_mass1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_mass1.html"},{"title":"get_mass2 – SPHINCS_LORENE","text":"module procedure get_mass2 module module function get_mass2(THIS) Interface → Returns the baryon mass of NS 2 [ M_\\odot ] FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_mass2~~CalledByGraph proc~get_mass2 get_mass2 interface~get_mass2 get_mass2 interface~get_mass2->proc~get_mass2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_mass2.html"},{"title":"get_nbar_center1 – SPHINCS_LORENE","text":"module procedure get_nbar_center1 module module function get_nbar_center1(THIS) Interface → Returns the central baryon number density\n  of NS 1 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_nbar_center1~~CalledByGraph proc~get_nbar_center1 get_nbar_center1 interface~get_nbar_center1 get_nbar_center1 interface~get_nbar_center1->proc~get_nbar_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nbar_center1.html"},{"title":"get_nbar_center2 – SPHINCS_LORENE","text":"module procedure get_nbar_center2 module module function get_nbar_center2(THIS) Interface → Returns the central baryon number density\n  of NS 2 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_nbar_center2~~CalledByGraph proc~get_nbar_center2 get_nbar_center2 interface~get_nbar_center2 get_nbar_center2 interface~get_nbar_center2->proc~get_nbar_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nbar_center2.html"},{"title":"get_npeos_1 – SPHINCS_LORENE","text":"module procedure get_npeos_1 module module function get_npeos_1(THIS) Interface → Returns the identifier of the EOS for NS 1 FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer Called by proc~~get_npeos_1~~CalledByGraph proc~get_npeos_1 get_npeos_1 interface~get_npeos_1 get_npeos_1 interface~get_npeos_1->proc~get_npeos_1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_npeos_1.html"},{"title":"get_npeos_2 – SPHINCS_LORENE","text":"module procedure get_npeos_2 module module function get_npeos_2(THIS) Interface → Returns the identifier of the EOS for NS 2 FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer Called by proc~~get_npeos_2~~CalledByGraph proc~get_npeos_2 get_npeos_2 interface~get_npeos_2 get_npeos_2 interface~get_npeos_2->proc~get_npeos_2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_npeos_2.html"},{"title":"get_pressure_center1 – SPHINCS_LORENE","text":"module procedure get_pressure_center1 module module function get_pressure_center1(THIS) Interface → Returns the central pressure of NS 1 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_pressure_center1~~CalledByGraph proc~get_pressure_center1 get_pressure_center1 interface~get_pressure_center1 get_pressure_center1 interface~get_pressure_center1->proc~get_pressure_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_pressure_center1.html"},{"title":"get_pressure_center2 – SPHINCS_LORENE","text":"module procedure get_pressure_center2 module module function get_pressure_center2(THIS) Interface → Returns the central pressure of NS 2 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_pressure_center2~~CalledByGraph proc~get_pressure_center2 get_pressure_center2 interface~get_pressure_center2 get_pressure_center2 interface~get_pressure_center2->proc~get_pressure_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_pressure_center2.html"},{"title":"get_radii – SPHINCS_LORENE","text":"module procedure get_radii module module function get_radii(THIS, i_matter) Interface → Returns the radii of the i_matter -th star\n  [ L_\\odot ] FT 27.10.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) Called by proc~~get_radii~~CalledByGraph proc~get_radii get_radii interface~get_radii get_radii interface~get_radii->proc~get_radii Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radii.html"},{"title":"get_radius1_x_comp – SPHINCS_LORENE","text":"module procedure get_radius1_x_comp module module function get_radius1_x_comp(THIS) Interface → Returns the radius of NS 1 along the x axis\n  on the side of the companion FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius1_x_comp~~CalledByGraph proc~get_radius1_x_comp get_radius1_x_comp interface~get_radius1_x_comp get_radius1_x_comp interface~get_radius1_x_comp->proc~get_radius1_x_comp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius1_x_comp.html"},{"title":"get_radius1_x_opp – SPHINCS_LORENE","text":"module procedure get_radius1_x_opp module module function get_radius1_x_opp(THIS) Interface → Returns the radius of NS 1 along the x axis\n  on the side opposite to the companion FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius1_x_opp~~CalledByGraph proc~get_radius1_x_opp get_radius1_x_opp interface~get_radius1_x_opp get_radius1_x_opp interface~get_radius1_x_opp->proc~get_radius1_x_opp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius1_x_opp.html"},{"title":"get_radius1_y – SPHINCS_LORENE","text":"module procedure get_radius1_y module module function get_radius1_y(THIS) Interface → Returns the radius of NS 1 along the y axis FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius1_y~~CalledByGraph proc~get_radius1_y get_radius1_y interface~get_radius1_y get_radius1_y interface~get_radius1_y->proc~get_radius1_y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius1_y.html"},{"title":"get_radius1_z – SPHINCS_LORENE","text":"module procedure get_radius1_z module module function get_radius1_z(THIS) Interface → Returns the radius of NS 1 along the z axis FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius1_z~~CalledByGraph proc~get_radius1_z get_radius1_z interface~get_radius1_z get_radius1_z interface~get_radius1_z->proc~get_radius1_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius1_z.html"},{"title":"get_radius2_x_comp – SPHINCS_LORENE","text":"module procedure get_radius2_x_comp module module function get_radius2_x_comp(THIS) Interface → Returns the radius of NS 2 along the x axis\n  on the side of the companion FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius2_x_comp~~CalledByGraph proc~get_radius2_x_comp get_radius2_x_comp interface~get_radius2_x_comp get_radius2_x_comp interface~get_radius2_x_comp->proc~get_radius2_x_comp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius2_x_comp.html"},{"title":"get_radius2_x_opp – SPHINCS_LORENE","text":"module procedure get_radius2_x_opp module module function get_radius2_x_opp(THIS) Interface → Returns the radius of NS 2 along the x axis\n  on the side opposite to the companion FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius2_x_opp~~CalledByGraph proc~get_radius2_x_opp get_radius2_x_opp interface~get_radius2_x_opp get_radius2_x_opp interface~get_radius2_x_opp->proc~get_radius2_x_opp Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius2_x_opp.html"},{"title":"get_radius2_y – SPHINCS_LORENE","text":"module procedure get_radius2_y module module function get_radius2_y(THIS) Interface → Returns the radius of NS 2 along the y axis FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius2_y~~CalledByGraph proc~get_radius2_y get_radius2_y interface~get_radius2_y get_radius2_y interface~get_radius2_y->proc~get_radius2_y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius2_y.html"},{"title":"get_radius2_z – SPHINCS_LORENE","text":"module procedure get_radius2_z module module function get_radius2_z(THIS) Interface → Returns the radius of NS 2 along the z axis FT Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_radius2_z~~CalledByGraph proc~get_radius2_z get_radius2_z interface~get_radius2_z get_radius2_z interface~get_radius2_z->proc~get_radius2_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radius2_z.html"},{"title":"get_rho_center1 – SPHINCS_LORENE","text":"module procedure get_rho_center1 module module function get_rho_center1(THIS) Interface → Returns the central baryon mass density\n  of NS 1 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_rho_center1~~CalledByGraph proc~get_rho_center1 get_rho_center1 interface~get_rho_center1 get_rho_center1 interface~get_rho_center1->proc~get_rho_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_rho_center1.html"},{"title":"get_rho_center2 – SPHINCS_LORENE","text":"module procedure get_rho_center2 module module function get_rho_center2(THIS) Interface → Returns the central baryon mass density\n  of NS 2 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_rho_center2~~CalledByGraph proc~get_rho_center2 get_rho_center2 interface~get_rho_center2 get_rho_center2 interface~get_rho_center2->proc~get_rho_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_rho_center2.html"},{"title":"get_specific_energy_center1 – SPHINCS_LORENE","text":"module procedure get_specific_energy_center1 module module function get_specific_energy_center1(THIS) Interface → Returns the central specific energy of NS 1 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_specific_energy_center1~~CalledByGraph proc~get_specific_energy_center1 get_specific_energy_center1 interface~get_specific_energy_center1 get_specific_energy_center1 interface~get_specific_energy_center1->proc~get_specific_energy_center1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_specific_energy_center1.html"},{"title":"get_specific_energy_center2 – SPHINCS_LORENE","text":"module procedure get_specific_energy_center2 module module function get_specific_energy_center2(THIS) Interface → Returns the central specific energy of NS 2 FT 12.02.2021 Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_specific_energy_center2~~CalledByGraph proc~get_specific_energy_center2 get_specific_energy_center2 interface~get_specific_energy_center2 get_specific_energy_center2 interface~get_specific_energy_center2->proc~get_specific_energy_center2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_specific_energy_center2.html"},{"title":"import_id_full – SPHINCS_LORENE","text":"module procedure import_id_full module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Interface → Uses constants proc~~import_id_full~~UsesGraph proc~import_id_full import_id_full constants constants proc~import_id_full->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the ID in non-[[bnslorene]]-member arrays\n  with the same shape as the [[bnslorene]] member arrays FT 5.10.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Calls proc~~import_id_full~~CallsGraph proc~import_id_full import_id_full interface~get_lorene_id get_lorene_id proc~import_id_full->interface~get_lorene_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_full~~CalledByGraph proc~import_id_full import_id_full interface~import_id_full import_id_full interface~import_id_full->proc~import_id_full Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_full.html"},{"title":"import_id_hydro – SPHINCS_LORENE","text":"module procedure import_id_hydro module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Interface → Uses tensor constants proc~~import_id_hydro~~UsesGraph proc~import_id_hydro import_id_hydro tensor tensor proc~import_id_hydro->tensor constants constants proc~import_id_hydro->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the hydro ID in the arrays needed to compute\n  the constraints on the refined mesh FT 25.11.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler Calls proc~~import_id_hydro~~CallsGraph proc~import_id_hydro import_id_hydro interface~get_lorene_id_hydro get_lorene_id_hydro proc~import_id_hydro->interface~get_lorene_id_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_hydro~~CalledByGraph proc~import_id_hydro import_id_hydro interface~import_id_hydro import_id_hydro interface~import_id_hydro->proc~import_id_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix iy iz Variables Type Visibility Attributes Name Initial integer, private :: ix integer, private :: iy integer, private :: iz","tags":"","loc":"proc/import_id_hydro.html"},{"title":"import_id_int – SPHINCS_LORENE","text":"module procedure import_id_int module module subroutine import_id_int(THIS, n, x, y, z) Interface → Uses constants proc~~import_id_int~~UsesGraph proc~import_id_int import_id_int constants constants proc~import_id_int->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the ID in the [[bnslorene]] member arrays FT 5.10.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z Calls proc~~import_id_int~~CallsGraph proc~import_id_int import_id_int interface~get_lorene_id get_lorene_id proc~import_id_int->interface~get_lorene_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_int~~CalledByGraph proc~import_id_int import_id_int interface~import_id_int import_id_int interface~import_id_int->proc~import_id_int Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_int.html"},{"title":"import_id_k – SPHINCS_LORENE","text":"module procedure import_id_k module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Interface → Uses constants proc~~import_id_k~~UsesGraph proc~import_id_k import_id_k constants constants proc~import_id_k->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the components of the extrinsic curvature\n  in arrays FT 25.11.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz Calls proc~~import_id_k~~CallsGraph proc~import_id_k import_id_k interface~get_lorene_id_k get_lorene_id_k proc~import_id_k->interface~get_lorene_id_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_k~~CalledByGraph proc~import_id_k import_id_k interface~import_id_k import_id_k interface~import_id_k->proc~import_id_k Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_k.html"},{"title":"import_id_mass_b – SPHINCS_LORENE","text":"module procedure import_id_mass_b module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Interface → Uses constants proc~~import_id_mass_b~~UsesGraph proc~import_id_mass_b import_id_mass_b constants constants proc~import_id_mass_b->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the hydro ID in the arrays needed to\n  compute the baryon mass, storing it to variables\n  (not arrays as the others SUBROUTINES in\n  the [[bns_import]] SUBMODULE). FT 15.04.2021 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler Calls proc~~import_id_mass_b~~CallsGraph proc~import_id_mass_b import_id_mass_b interface~get_lorene_id_mass_b get_lorene_id_mass_b proc~import_id_mass_b->interface~get_lorene_id_mass_b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_mass_b~~CalledByGraph proc~import_id_mass_b import_id_mass_b interface~import_id_mass_b import_id_mass_b interface~import_id_mass_b->proc~import_id_mass_b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_mass_b.html"},{"title":"import_id_particles – SPHINCS_LORENE","text":"module procedure import_id_particles module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Interface → Uses constants proc~~import_id_particles~~UsesGraph proc~import_id_particles import_id_particles constants constants proc~import_id_particles->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the hydro ID in the arrays needed to\n  compute the SPH ID FT 19.11.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Calls proc~~import_id_particles~~CallsGraph proc~import_id_particles import_id_particles interface~get_lorene_id_particles get_lorene_id_particles proc~import_id_particles->interface~get_lorene_id_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_particles~~CalledByGraph proc~import_id_particles import_id_particles interface~import_id_particles import_id_particles interface~import_id_particles->proc~import_id_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables detg Variables Type Visibility Attributes Name Initial double precision, private :: detg","tags":"","loc":"proc/import_id_particles.html"},{"title":"import_id_spacetime – SPHINCS_LORENE","text":"module procedure import_id_spacetime module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Interface → Uses tensor constants proc~~import_id_spacetime~~UsesGraph proc~import_id_spacetime import_id_spacetime tensor tensor proc~import_id_spacetime->tensor constants constants proc~import_id_spacetime->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the spacetime ID in multi-dimensional arrays\n  needed to compute the BSSN variables and constraints FT 22.11.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek Calls proc~~import_id_spacetime~~CallsGraph proc~import_id_spacetime import_id_spacetime proc~compute_g4 compute_g4 proc~import_id_spacetime->proc~compute_g4 proc~determinant_sym4x4_grid determinant_sym4x4_grid proc~import_id_spacetime->proc~determinant_sym4x4_grid interface~get_lorene_id_spacetime get_lorene_id_spacetime proc~import_id_spacetime->interface~get_lorene_id_spacetime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_spacetime~~CalledByGraph proc~import_id_spacetime import_id_spacetime interface~import_id_spacetime import_id_spacetime interface~import_id_spacetime->proc~import_id_spacetime Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables detg detg4 g4 i j k Variables Type Visibility Attributes Name Initial double precision, private :: detg double precision, private :: detg4 double precision, private, DIMENSION( :, :, :, : ), ALLOCATABLE :: g4 integer, private :: i integer, private :: j integer, private :: k","tags":"","loc":"proc/import_id_spacetime.html"},{"title":"import_mass_density – SPHINCS_LORENE","text":"module procedure import_mass_density module module function import_mass_density(THIS, x, y, z) result(res) Interface → Uses constants iso_c_binding proc~~import_mass_density~~UsesGraph proc~import_mass_density import_mass_density constants constants proc~import_mass_density->constants iso_c_binding iso_c_binding proc~import_mass_density->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Returns the \\texttt{LORENE} mass density at the point\n  given as argument, in units of M_\\odot/L_\\odot&#94;3 . FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) Calls proc~~import_mass_density~~CallsGraph proc~import_mass_density import_mass_density interface~get_lorene_mass_density get_lorene_mass_density proc~import_mass_density->interface~get_lorene_mass_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_mass_density~~CalledByGraph proc~import_mass_density import_mass_density interface~import_mass_density import_mass_density interface~import_mass_density->proc~import_mass_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_mass_density.html"},{"title":"import_spatial_metric – SPHINCS_LORENE","text":"module procedure import_spatial_metric module module function import_spatial_metric(THIS, x, y, z) result(res) Interface → Uses constants iso_c_binding proc~~import_spatial_metric~~UsesGraph proc~import_spatial_metric import_spatial_metric constants constants proc~import_spatial_metric->constants iso_c_binding iso_c_binding proc~import_spatial_metric->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Returns the \\texttt{LORENE} conformal factor to the\n  4th power, equal to the diagonal components\n  of the conformally flat spatial ADM metric. FT 15.04.2021 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) Calls proc~~import_spatial_metric~~CallsGraph proc~import_spatial_metric import_spatial_metric interface~get_lorene_spatial_metric get_lorene_spatial_metric proc~import_spatial_metric->interface~get_lorene_spatial_metric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_spatial_metric~~CalledByGraph proc~import_spatial_metric import_spatial_metric interface~import_spatial_metric import_spatial_metric interface~import_spatial_metric->proc~import_spatial_metric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_spatial_metric.html"},{"title":"is_hydro_negative – SPHINCS_LORENE","text":"module procedure is_hydro_negative module module function is_hydro_negative(THIS, x, y, z) result(res) Interface → Uses constants iso_c_binding proc~~is_hydro_negative~~UsesGraph proc~is_hydro_negative is_hydro_negative constants constants proc~is_hydro_negative->constants iso_c_binding iso_c_binding proc~is_hydro_negative->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Return 1 if the energy density is nonpositive\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive\n  at the specified point FT 12.03.2021 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Calls proc~~is_hydro_negative~~CallsGraph proc~is_hydro_negative is_hydro_negative interface~negative_hydro negative_hydro proc~is_hydro_negative->interface~negative_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~is_hydro_negative~~CalledByGraph proc~is_hydro_negative is_hydro_negative interface~is_hydro_negative is_hydro_negative interface~is_hydro_negative->proc~is_hydro_negative Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/is_hydro_negative.html"},{"title":"get_bns_identifier – SPHINCS_LORENE","text":"module procedure get_bns_identifier module module function get_bns_identifier(THIS) Interface → Returns the value of [[bns_identifier]], the\n  integer identifier of the bns object FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_bns_identifier~~CalledByGraph proc~get_bns_identifier get_bns_identifier interface~get_bns_identifier get_bns_identifier interface~get_bns_identifier->proc~get_bns_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_bns_identifier.html"},{"title":"get_eos1_loreneid – SPHINCS_LORENE","text":"module procedure get_eos1_loreneid module module function get_eos1_loreneid(THIS) Interface → Returns the \\texttt{LORENE} ID-number of the EOS for NS 1 FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer Called by proc~~get_eos1_loreneid~~CalledByGraph proc~get_eos1_loreneid get_eos1_loreneid interface~get_eos1_loreneid get_eos1_loreneid interface~get_eos1_loreneid->proc~get_eos1_loreneid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos1_loreneid.html"},{"title":"get_eos2_loreneid – SPHINCS_LORENE","text":"module procedure get_eos2_loreneid module module function get_eos2_loreneid(THIS) Interface → Returns the \\texttt{LORENE} ID-number of the EOS for NS 2 FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer Called by proc~~get_eos2_loreneid~~CalledByGraph proc~get_eos2_loreneid get_eos2_loreneid interface~get_eos2_loreneid get_eos2_loreneid interface~get_eos2_loreneid->proc~get_eos2_loreneid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos2_loreneid.html"},{"title":"get_eos_parameters – SPHINCS_LORENE","text":"module procedure get_eos_parameters module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Interface → Returns the EoS parameters of the i_matter -s star FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object Called by proc~~get_eos_parameters~~CalledByGraph proc~get_eos_parameters get_eos_parameters interface~get_eos_parameters get_eos_parameters interface~get_eos_parameters->proc~get_eos_parameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos_parameters.html"},{"title":"get_field_array – SPHINCS_LORENE","text":"module procedure get_field_array module module function get_field_array(THIS, field) result(field_array) Interface → Returns one of the member arrays, selected\n  with the string input. FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array Return Value double precision,\n  DIMENSION(:),ALLOCATABLE Desired bnslorene member array Called by proc~~get_field_array~~CalledByGraph proc~get_field_array get_field_array interface~get_field_array get_field_array interface~get_field_array->proc~get_field_array Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_field_array.html"},{"title":"get_field_value – SPHINCS_LORENE","text":"module procedure get_field_value module module function get_field_value(THIS, field, n) result(field_value) Interface → Returns the value of one of the member arrays,\n  selected with the string input, at the point\n  given as argument. FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array integer, intent(in) :: n Component of the desired bnslorene member array Return Value double precision Component n of the desired bnslorene member array Called by proc~~get_field_value~~CalledByGraph proc~get_field_value get_field_value interface~get_field_value get_field_value interface~get_field_value->proc~get_field_value Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_field_value.html"},{"title":"import_id_params – SPHINCS_LORENE","text":"module procedure import_id_params module module subroutine import_id_params(THIS) Interface → Uses constants iso_c_binding proc~~import_id_params~~UsesGraph proc~import_id_params import_id_params constants constants proc~import_id_params->constants iso_c_binding iso_c_binding proc~import_id_params->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Store the parameters of the binary neutron\n  stars' \\texttt{LORENE} ID into member variables FT 5.10.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Calls proc~~import_id_params~~CallsGraph proc~import_id_params import_id_params interface~print_id_params print_id_params proc~import_id_params->interface~print_id_params interface~get_lorene_id_params get_lorene_id_params proc~import_id_params->interface~get_lorene_id_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_id_params->k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase k_lorene2hydrobase proc~import_id_params->k_lorene2hydrobase proc~print_id_params print_id_params interface~print_id_params->proc~print_id_params proc~print_id_params->k_lorene2hydrobase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_params~~CalledByGraph proc~import_id_params import_id_params interface~import_id_params import_id_params interface~import_id_params->proc~import_id_params proc~construct_bnslorene construct_bnslorene proc~construct_bnslorene->interface~import_id_params interface~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene interface~bnslorene bnslorene interface~bnslorene->interface~construct_bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene var panprocimport_id_paramsCalledByGraph = svgPanZoom('#procimport_id_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables eos1_tmp_c eos2_tmp_c i nchars str_length Variables Type Visibility Attributes Name Initial character(kind=C_CHAR), private, DIMENSION(str_length) :: eos1_tmp_c character(kind=C_CHAR), private, DIMENSION(str_length) :: eos2_tmp_c integer, private :: i integer, private :: nchars integer, private, parameter :: str_length = 100","tags":"","loc":"proc/import_id_params.html"},{"title":"print_id_params – SPHINCS_LORENE","text":"module procedure print_id_params module module subroutine print_id_params(THIS) Interface → Uses constants proc~~print_id_params~~UsesGraph proc~print_id_params print_id_params constants constants proc~print_id_params->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Print the parameters of the binary neutron\n  stars' initial data computed by \\texttt{LORENE} FT 8.10.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Calls proc~~print_id_params~~CallsGraph proc~print_id_params print_id_params k_lorene2hydrobase k_lorene2hydrobase proc~print_id_params->k_lorene2hydrobase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~print_id_params~~CalledByGraph proc~print_id_params print_id_params interface~print_id_params print_id_params interface~print_id_params->proc~print_id_params proc~import_id_params import_id_params proc~import_id_params->interface~print_id_params interface~import_id_params import_id_params interface~import_id_params->proc~import_id_params proc~construct_bnslorene construct_bnslorene proc~construct_bnslorene->interface~import_id_params interface~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene interface~bnslorene bnslorene interface~bnslorene->interface~construct_bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene var panprocprint_id_paramsCalledByGraph = svgPanZoom('#procprint_id_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_id_params.html"},{"title":"allocate_lorene_id_memory – SPHINCS_LORENE","text":"module procedure allocate_lorene_id_memory module module subroutine allocate_lorene_id_memory(THIS, d) Interface → Allocate the memory to store the LORENE ID\n  in the member arrays FT 17.09.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays Called by proc~~allocate_lorene_id_memory~~CalledByGraph proc~allocate_lorene_id_memory allocate_lorene_id_memory interface~allocate_lorene_id_memory allocate_lorene_id_memory interface~allocate_lorene_id_memory->proc~allocate_lorene_id_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_lorene_id_memory.html"},{"title":"deallocate_lorene_id_memory – SPHINCS_LORENE","text":"module procedure deallocate_lorene_id_memory module module subroutine deallocate_lorene_id_memory(THIS) Interface → Deallocate the memory for the member arrays FT 17.09.2020 Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Called by proc~~deallocate_lorene_id_memory~~CalledByGraph proc~deallocate_lorene_id_memory deallocate_lorene_id_memory interface~deallocate_lorene_id_memory deallocate_lorene_id_memory interface~deallocate_lorene_id_memory->proc~deallocate_lorene_id_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/deallocate_lorene_id_memory.html"},{"title":"construct_binary – SPHINCS_LORENE","text":"module procedure construct_binary module module subroutine construct_binary(THIS, resu_file) Interface → Construct the \\texttt{LORENE} \\texttt{Bin_NS} object FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID Calls proc~~construct_binary~~CallsGraph proc~construct_binary construct_binary interface~destruct_bin_ns destruct_bin_ns proc~construct_binary->interface~destruct_bin_ns interface~construct_bin_ns construct_bin_ns proc~construct_binary->interface~construct_bin_ns Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~construct_binary~~CalledByGraph proc~construct_binary construct_binary interface~construct_binary construct_binary interface~construct_binary->proc~construct_binary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables default_case exist Variables Type Visibility Attributes Name Initial character(kind=C_CHAR,len=7), private :: default_case logical, private :: exist","tags":"","loc":"proc/construct_binary.html"},{"title":"construct_bnslorene – SPHINCS_LORENE","text":"module procedure construct_bnslorene module module function construct_bnslorene(resu_file) result(bns_obj) Interface → Constructs an object of TYPE [[bnslorene]] FT Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID Return Value type( bnslorene ) Constructed bnslorene object Calls proc~~construct_bnslorene~~CallsGraph proc~construct_bnslorene construct_bnslorene timer timer proc~construct_bnslorene->timer interface~import_id_params import_id_params proc~construct_bnslorene->interface~import_id_params proc~import_id_params import_id_params interface~import_id_params->proc~import_id_params interface~print_id_params print_id_params proc~import_id_params->interface~print_id_params interface~get_lorene_id_params get_lorene_id_params proc~import_id_params->interface~get_lorene_id_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_id_params->k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase k_lorene2hydrobase proc~import_id_params->k_lorene2hydrobase proc~print_id_params print_id_params interface~print_id_params->proc~print_id_params proc~print_id_params->k_lorene2hydrobase var panprocconstruct_bnsloreneCallsGraph = svgPanZoom('#procconstruct_bnsloreneCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~construct_bnslorene~~CalledByGraph proc~construct_bnslorene construct_bnslorene interface~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene interface~bnslorene bnslorene interface~bnslorene->interface~construct_bnslorene program~convergence_test convergence_test program~convergence_test->interface~bnslorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables bns_counter Variables Type Visibility Attributes Name Initial integer, private, SAVE :: bns_counter = 1","tags":"","loc":"proc/construct_bnslorene.html"},{"title":"destruct_binary – SPHINCS_LORENE","text":"module procedure destruct_binary module module subroutine destruct_binary(THIS) Interface → Destructs the \\texttt{LORENE} \\texttt{Bin_NS} object and frees\n  the pointer [[bns:bns_ptr]] pointing to it FT Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Calls proc~~destruct_binary~~CallsGraph proc~destruct_binary destruct_binary interface~destruct_bin_ns destruct_bin_ns proc~destruct_binary->interface~destruct_bin_ns Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~destruct_binary~~CalledByGraph proc~destruct_binary destruct_binary interface~destruct_binary destruct_binary interface~destruct_binary->proc~destruct_binary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destruct_binary.html"},{"title":"destruct_bnslorene – SPHINCS_LORENE","text":"module procedure destruct_bnslorene module module subroutine destruct_bnslorene(THIS) Interface → Destructs an object of TYPE [[bnslorene]] FT Arguments Type Intent Optional Attributes Name type( bnslorene ), intent(inout) :: THIS bnslorene object to be destructed Called by proc~~destruct_bnslorene~~CalledByGraph proc~destruct_bnslorene destruct_bnslorene interface~destruct_bnslorene destruct_bnslorene interface~destruct_bnslorene->proc~destruct_bnslorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destruct_bnslorene.html"},{"title":"get_angular_momentum – SPHINCS_LORENE","text":"module procedure get_angular_momentum module module function get_angular_momentum(THIS) Interface → Returns the angular momentum of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_angular_momentum~2~~CalledByGraph proc~get_angular_momentum~2 get_angular_momentum interface~get_angular_momentum~2 get_angular_momentum interface~get_angular_momentum~2->proc~get_angular_momentum~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_angular_momentum~2.html"},{"title":"get_area_radius – SPHINCS_LORENE","text":"module procedure get_area_radius module module function get_area_radius(THIS) Interface → Returns [[diffstarbase:area_radius]], the\n  areal radius of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_area_radius~~CalledByGraph proc~get_area_radius get_area_radius interface~get_area_radius get_area_radius interface~get_area_radius->proc~get_area_radius Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_area_radius.html"},{"title":"get_barycenter – SPHINCS_LORENE","text":"module procedure get_barycenter module module function get_barycenter(THIS, i_matter) Interface → Returns the barycenter of the DRS [ L_\\odot ] FT 2.11.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Called by proc~~get_barycenter~2~~CalledByGraph proc~get_barycenter~2 get_barycenter interface~get_barycenter~2 get_barycenter interface~get_barycenter~2->proc~get_barycenter~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_barycenter~2.html"},{"title":"get_center – SPHINCS_LORENE","text":"module procedure get_center module module function get_center(THIS, i_matter) Interface → Returns the center of the DRS [ L_\\odot ] FT 2.11.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Called by proc~~get_center~2~~CalledByGraph proc~get_center~2 get_center interface~get_center~2 get_center interface~get_center~2->proc~get_center~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_center~2.html"},{"title":"get_energy_density_center – SPHINCS_LORENE","text":"module procedure get_energy_density_center module module function get_energy_density_center(THIS) Interface → Returns the central energy density of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_energy_density_center~~CalledByGraph proc~get_energy_density_center get_energy_density_center interface~get_energy_density_center get_energy_density_center interface~get_energy_density_center->proc~get_energy_density_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_energy_density_center.html"},{"title":"get_ent_center – SPHINCS_LORENE","text":"module procedure get_ent_center module module function get_ent_center(THIS) Interface → Returns the central enthalpy of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_ent_center~~CalledByGraph proc~get_ent_center get_ent_center interface~get_ent_center get_ent_center interface~get_ent_center->proc~get_ent_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_ent_center.html"},{"title":"get_eos – SPHINCS_LORENE","text":"module procedure get_eos module module function get_eos(THIS, i_matter) Interface → Returns the EoS name of the DRS FT 2.11.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE Called by proc~~get_eos~2~~CalledByGraph proc~get_eos~2 get_eos interface~get_eos~2 get_eos interface~get_eos~2->proc~get_eos~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos~2.html"},{"title":"get_f_isco – SPHINCS_LORENE","text":"module procedure get_f_isco module module function get_f_isco(THIS) Interface → Returns [[diffstarbase:f_isco]], the orbital\n  frequency of the Innermost Stable Circular Orbit\n  (ISCO) FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_f_isco~~CalledByGraph proc~get_f_isco get_f_isco interface~get_f_isco get_f_isco interface~get_f_isco->proc~get_f_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_f_isco.html"},{"title":"get_gamma – SPHINCS_LORENE","text":"module procedure get_gamma module module function get_gamma(THIS) Interface → Returns the value of [[gamma]], the\n  polytropic index for polytropic EOS,\n  not piecewise polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma~~CalledByGraph proc~get_gamma get_gamma interface~get_gamma get_gamma interface~get_gamma->proc~get_gamma Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma.html"},{"title":"get_gamma0 – SPHINCS_LORENE","text":"module procedure get_gamma0 module module function get_gamma0(THIS) Interface → Returns the value of [[gamma0]], the crust's\n  polytropic index for the DRS with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma0~~CalledByGraph proc~get_gamma0 get_gamma0 interface~get_gamma0 get_gamma0 interface~get_gamma0->proc~get_gamma0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma0.html"},{"title":"get_gamma1 – SPHINCS_LORENE","text":"module procedure get_gamma1 module module function get_gamma1(THIS) Interface → Returns the value of [[gamma1]], the first\n  polytropic index for the DRS with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma1~~CalledByGraph proc~get_gamma1 get_gamma1 interface~get_gamma1 get_gamma1 interface~get_gamma1->proc~get_gamma1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma1.html"},{"title":"get_gamma2 – SPHINCS_LORENE","text":"module procedure get_gamma2 module module function get_gamma2(THIS) Interface → Returns the value of [[gamma2]], the second\n  polytropic index for NS 2 with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma2~~CalledByGraph proc~get_gamma2 get_gamma2 interface~get_gamma2 get_gamma2 interface~get_gamma2->proc~get_gamma2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma2.html"},{"title":"get_gamma3 – SPHINCS_LORENE","text":"module procedure get_gamma3 module module function get_gamma3(THIS) Interface → Returns the value of [[gamma3]], the third\n  polytropic index for the DRS with piecewise\n  polytropic EOS (innermost index) FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_gamma3~~CalledByGraph proc~get_gamma3 get_gamma3 interface~get_gamma3 get_gamma3 interface~get_gamma3->proc~get_gamma3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_gamma3.html"},{"title":"get_grv2 – SPHINCS_LORENE","text":"module procedure get_grv2 module module function get_grv2(THIS) Interface → Returns [[diffstarbase:grv2]], the error on the\n  virial identity {\\rm GRV2} . FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_grv2~~CalledByGraph proc~get_grv2 get_grv2 interface~get_grv2 get_grv2 interface~get_grv2->proc~get_grv2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_grv2.html"},{"title":"get_grv3 – SPHINCS_LORENE","text":"module procedure get_grv3 module module function get_grv3(THIS) Interface → Returns [[diffstarbase:grv3]], the error on the\n  virial identity {\\rm GRV3} . FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_grv3~~CalledByGraph proc~get_grv3 get_grv3 interface~get_grv3 get_grv3 interface~get_grv3->proc~get_grv3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_grv3.html"},{"title":"get_kappa – SPHINCS_LORENE","text":"module procedure get_kappa module module function get_kappa(THIS) Interface → Returns the value of [[kappa]], the\n  polytropic constant for polytropic\n  EOS, not piecewise polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa~~CalledByGraph proc~get_kappa get_kappa interface~get_kappa get_kappa interface~get_kappa->proc~get_kappa Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa.html"},{"title":"get_kappa0 – SPHINCS_LORENE","text":"module procedure get_kappa0 module module function get_kappa0(THIS) Interface → Returns the value of [[kappa0]], the crust's\n  polytropic constant for the DRS with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa0~~CalledByGraph proc~get_kappa0 get_kappa0 interface~get_kappa0 get_kappa0 interface~get_kappa0->proc~get_kappa0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa0.html"},{"title":"get_kappa1 – SPHINCS_LORENE","text":"module procedure get_kappa1 module module function get_kappa1(THIS) Interface → Returns the value of [[kappa1]], the first\n  polytropic constant for the DRS with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa1~~CalledByGraph proc~get_kappa1 get_kappa1 interface~get_kappa1 get_kappa1 interface~get_kappa1->proc~get_kappa1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa1.html"},{"title":"get_kappa2 – SPHINCS_LORENE","text":"module procedure get_kappa2 module module function get_kappa2(THIS) Interface → Returns the value of [[kappa2]], the second\n  polytropic constant for the DRS with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa2~~CalledByGraph proc~get_kappa2 get_kappa2 interface~get_kappa2 get_kappa2 interface~get_kappa2->proc~get_kappa2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa2.html"},{"title":"get_kappa3 – SPHINCS_LORENE","text":"module procedure get_kappa3 module module function get_kappa3(THIS) Interface → Returns the value of [[kappa3]], the third\n  polytropic constant for the DRS with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_kappa3~~CalledByGraph proc~get_kappa3 get_kappa3 interface~get_kappa3 get_kappa3 interface~get_kappa3->proc~get_kappa3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_kappa3.html"},{"title":"get_logRho0 – SPHINCS_LORENE","text":"module procedure get_logRho0 module module function get_logRho0(THIS) Interface → Returns the value of [[logRho0]], the base 10\n  logarithm of the mass density where the\n  gamma1 polytrope starts, for the DRS with\n  piecewise polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho0~~CalledByGraph proc~get_logrho0 get_logRho0 interface~get_logrho0 get_logRho0 interface~get_logrho0->proc~get_logrho0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho0.html"},{"title":"get_logRho1 – SPHINCS_LORENE","text":"module procedure get_logRho1 module module function get_logRho1(THIS) Interface → Returns the value of [[logRho1]], the base 10\n  logarithm of the mass density where the\n  gamma2 polytrope starts, for the DRS with\n  piecewise polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho1~~CalledByGraph proc~get_logrho1 get_logRho1 interface~get_logrho1 get_logRho1 interface~get_logrho1->proc~get_logrho1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho1.html"},{"title":"get_logRho2 – SPHINCS_LORENE","text":"module procedure get_logRho2 module module function get_logRho2(THIS) Interface → Returns the value of [[logRho2]], the base 10\n  logarithm of the mass density where the\n  gamma3 polytrope starts, for the DRS with\n  piecewise polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logrho2~~CalledByGraph proc~get_logrho2 get_logRho2 interface~get_logrho2 get_logRho2 interface~get_logrho2->proc~get_logrho2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logrho2.html"},{"title":"get_logp1 – SPHINCS_LORENE","text":"module procedure get_logp1 module module function get_logp1(THIS) result(get_logP1) Interface → Returns the value of [[logp1]], the base 10\n  logarithm of the pressure where the gamma1\n  polytrope starts, for the DRS with piecewise\n  polytropic EOS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_logp1~~CalledByGraph proc~get_logp1 get_logp1 interface~get_logp1 get_logP1 interface~get_logp1->proc~get_logp1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_logp1.html"},{"title":"get_mass – SPHINCS_LORENE","text":"module procedure get_mass module module function get_mass(THIS, i_matter) Interface → Returns the baryon mass of the DRS [ M_\\odot ] FT 2.11.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision Called by proc~~get_mass~2~~CalledByGraph proc~get_mass~2 get_mass interface~get_mass get_mass interface~get_mass->proc~get_mass~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_mass~2.html"},{"title":"get_mass_grav – SPHINCS_LORENE","text":"module procedure get_mass_grav module module function get_mass_grav(THIS) Interface → Returns the gravitational mass of the DRS [ M_\\odot ] FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_mass_grav~~CalledByGraph proc~get_mass_grav get_mass_grav interface~get_mass_grav get_mass_grav interface~get_mass_grav->proc~get_mass_grav Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_mass_grav.html"},{"title":"get_nbar_center – SPHINCS_LORENE","text":"module procedure get_nbar_center module module function get_nbar_center(THIS) Interface → Returns the central baryon number density\n  of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_nbar_center~~CalledByGraph proc~get_nbar_center get_nbar_center interface~get_nbar_center get_nbar_center interface~get_nbar_center->proc~get_nbar_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_nbar_center.html"},{"title":"get_npeos – SPHINCS_LORENE","text":"module procedure get_npeos module module function get_npeos(THIS) Interface → Returns the identifier of the EOS for the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer Called by proc~~get_npeos~~CalledByGraph proc~get_npeos get_npeos interface~get_npeos get_npeos interface~get_npeos->proc~get_npeos Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_npeos.html"},{"title":"get_omega_c – SPHINCS_LORENE","text":"module procedure get_omega_c module module function get_omega_c(THIS) Interface → Returns [[omega_c]], the central  angular\n  velocity of the system FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_omega_c~~CalledByGraph proc~get_omega_c get_omega_c interface~get_omega_c get_omega_c interface~get_omega_c->proc~get_omega_c Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_omega_c.html"},{"title":"get_pressure_center – SPHINCS_LORENE","text":"module procedure get_pressure_center module module function get_pressure_center(THIS) Interface → Returns the central pressure of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_pressure_center~~CalledByGraph proc~get_pressure_center get_pressure_center interface~get_pressure_center get_pressure_center interface~get_pressure_center->proc~get_pressure_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_pressure_center.html"},{"title":"get_r_circ – SPHINCS_LORENE","text":"module procedure get_r_circ module module function get_r_circ(THIS) Interface → Returns [[diffstarbase:r_circ]], the\n  circumferential radius of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_circ~~CalledByGraph proc~get_r_circ get_r_circ interface~get_r_circ get_r_circ interface~get_r_circ->proc~get_r_circ Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_circ.html"},{"title":"get_r_eq – SPHINCS_LORENE","text":"module procedure get_r_eq module module function get_r_eq(THIS) Interface → Returns [[diffstarbase:r_eq]], the\n  equatorial radius of the DRS at \\phi=0 FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_eq~~CalledByGraph proc~get_r_eq get_r_eq interface~get_r_eq get_r_eq interface~get_r_eq->proc~get_r_eq Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_eq.html"},{"title":"get_r_eq_3pi2 – SPHINCS_LORENE","text":"module procedure get_r_eq_3pi2 module module function get_r_eq_3pi2(THIS) Interface → Returns [[diffstarbase:r_eq_3pi2]], the\n  equatorial radius of the DRS at \\phi=\\dfrac{3\\pi}{2} FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_eq_3pi2~~CalledByGraph proc~get_r_eq_3pi2 get_r_eq_3pi2 interface~get_r_eq_3pi2 get_r_eq_3pi2 interface~get_r_eq_3pi2->proc~get_r_eq_3pi2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_eq_3pi2.html"},{"title":"get_r_eq_pi – SPHINCS_LORENE","text":"module procedure get_r_eq_pi module module function get_r_eq_pi(THIS) Interface → Returns [[diffstarbase:r_eq_pi]], the\n  equatorial radius of the DRS at \\phi=\\pi FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_eq_pi~~CalledByGraph proc~get_r_eq_pi get_r_eq_pi interface~get_r_eq_pi get_r_eq_pi interface~get_r_eq_pi->proc~get_r_eq_pi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_eq_pi.html"},{"title":"get_r_eq_pi2 – SPHINCS_LORENE","text":"module procedure get_r_eq_pi2 module module function get_r_eq_pi2(THIS) Interface → Returns [[diffstarbase:r_eq_pi2]], the\n  equatorial radius of the DRS at \\phi=\\dfrac{\\pi}{2} FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_eq_pi2~~CalledByGraph proc~get_r_eq_pi2 get_r_eq_pi2 interface~get_r_eq_pi2 get_r_eq_pi2 interface~get_r_eq_pi2->proc~get_r_eq_pi2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_eq_pi2.html"},{"title":"get_r_isco – SPHINCS_LORENE","text":"module procedure get_r_isco module module function get_r_isco(THIS) Interface → Returns [[diffstarbase:r_isco]], the\n  radius of the Innermost Stable Circular Orbit (ISCO) FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_isco~~CalledByGraph proc~get_r_isco get_r_isco interface~get_r_isco get_r_isco interface~get_r_isco->proc~get_r_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_isco.html"},{"title":"get_r_mean – SPHINCS_LORENE","text":"module procedure get_r_mean module module function get_r_mean(THIS) Interface → Returns [[diffstarbase:r_mean]], the\n  circumferential radius of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_mean~~CalledByGraph proc~get_r_mean get_r_mean interface~get_r_mean get_r_mean interface~get_r_mean->proc~get_r_mean Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_mean.html"},{"title":"get_r_pole – SPHINCS_LORENE","text":"module procedure get_r_pole module module function get_r_pole(THIS) Interface → Returns [[diffstarbase:r_pole]], the\n  polar radius of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_pole~~CalledByGraph proc~get_r_pole get_r_pole interface~get_r_pole get_r_pole interface~get_r_pole->proc~get_r_pole Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_pole.html"},{"title":"get_r_ratio – SPHINCS_LORENE","text":"module procedure get_r_ratio module module function get_r_ratio(THIS) Interface → Returns [[diffstarbase:r_ratio]], the\n  Ratio [[diffstarbase:r_pole]]/[[diffstarbase:r_eq]] FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_r_ratio~~CalledByGraph proc~get_r_ratio get_r_ratio interface~get_r_ratio get_r_ratio interface~get_r_ratio->proc~get_r_ratio Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_r_ratio.html"},{"title":"get_radii – SPHINCS_LORENE","text":"module procedure get_radii module module function get_radii(THIS, i_matter) Interface → Returns the radii of the DRS [ L_\\odot ] FT 2.11.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) Called by proc~~get_radii~2~~CalledByGraph proc~get_radii~2 get_radii interface~get_radii~2 get_radii interface~get_radii~2->proc~get_radii~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_radii~2.html"},{"title":"get_rho_center – SPHINCS_LORENE","text":"module procedure get_rho_center module module function get_rho_center(THIS) Interface → Returns the central baryon mass density\n  of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_rho_center~~CalledByGraph proc~get_rho_center get_rho_center interface~get_rho_center get_rho_center interface~get_rho_center->proc~get_rho_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_rho_center.html"},{"title":"get_specific_angular_momentum_isco – SPHINCS_LORENE","text":"module procedure get_specific_angular_momentum_isco module module function get_specific_angular_momentum_isco(THIS) Interface → Returns [[diffstarbase:specific_angular_momentum_isco]],\n  the specific angular momentum of a test particle\n  at the Innermost Stable Circular Orbit (ISCO) FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_specific_angular_momentum_isco~~CalledByGraph proc~get_specific_angular_momentum_isco get_specific_angular_momentum_isco interface~get_specific_angular_momentum_isco get_specific_angular_momentum_isco interface~get_specific_angular_momentum_isco->proc~get_specific_angular_momentum_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_specific_angular_momentum_isco.html"},{"title":"get_specific_energy_center – SPHINCS_LORENE","text":"module procedure get_specific_energy_center module module function get_specific_energy_center(THIS) Interface → Returns the central specific energy of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_specific_energy_center~~CalledByGraph proc~get_specific_energy_center get_specific_energy_center interface~get_specific_energy_center get_specific_energy_center interface~get_specific_energy_center->proc~get_specific_energy_center Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_specific_energy_center.html"},{"title":"get_specific_energy_isco – SPHINCS_LORENE","text":"module procedure get_specific_energy_isco module module function get_specific_energy_isco(THIS) Interface → Returns [[diffstarbase:specific_energy_isco]],\n  the specific energy of a test particle at the\n  Innermost Stable Circular Orbit (ISCO) FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_specific_energy_isco~~CalledByGraph proc~get_specific_energy_isco get_specific_energy_isco interface~get_specific_energy_isco get_specific_energy_isco interface~get_specific_energy_isco->proc~get_specific_energy_isco Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_specific_energy_isco.html"},{"title":"get_surface_area – SPHINCS_LORENE","text":"module procedure get_surface_area module module function get_surface_area(THIS) Interface → Returns [[diffstarbase:surface_area]], the\n  surface area of the DRS FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_surface_area~~CalledByGraph proc~get_surface_area get_surface_area interface~get_surface_area get_surface_area interface~get_surface_area->proc~get_surface_area Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_surface_area.html"},{"title":"get_tsw – SPHINCS_LORENE","text":"module procedure get_tsw module module function get_tsw(THIS) Interface → Returns [[diffstarbase:tsw]], the ratio T/W between the kinetic and gravitational potential\n  energy of the DRS\n  FT 22.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_tsw~~CalledByGraph proc~get_tsw get_tsw interface~get_tsw get_tsw interface~get_tsw->proc~get_tsw Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_tsw.html"},{"title":"allocate_diffstar_memory – SPHINCS_LORENE","text":"module procedure allocate_diffstar_memory module module subroutine allocate_diffstar_memory(THIS, d) Interface → Allocate the memory to store the LORENE ID\n  in the member arrays FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays Called by proc~~allocate_diffstar_memory~~CalledByGraph proc~allocate_diffstar_memory allocate_diffstar_memory interface~allocate_diffstar_memory allocate_diffstar_memory interface~allocate_diffstar_memory->proc~allocate_diffstar_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/allocate_diffstar_memory.html"},{"title":"deallocate_diffstar_memory – SPHINCS_LORENE","text":"module procedure deallocate_diffstar_memory module module subroutine deallocate_diffstar_memory(THIS) Interface → Deallocate the memory for the member arrays FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Called by proc~~deallocate_diffstar_memory~~CalledByGraph proc~deallocate_diffstar_memory deallocate_diffstar_memory interface~deallocate_diffstar_memory deallocate_diffstar_memory interface~deallocate_diffstar_memory->proc~deallocate_diffstar_memory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/deallocate_diffstar_memory.html"},{"title":"get_diffstar_identifier – SPHINCS_LORENE","text":"module procedure get_diffstar_identifier module module function get_diffstar_identifier(THIS) Interface → Returns the value of [[diffstar_identifier]], the\n  integer identifier of the diffstar object FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value double precision Called by proc~~get_diffstar_identifier~~CalledByGraph proc~get_diffstar_identifier get_diffstar_identifier interface~get_diffstar_identifier get_diffstar_identifier interface~get_diffstar_identifier->proc~get_diffstar_identifier Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_diffstar_identifier.html"},{"title":"get_eos_loreneid – SPHINCS_LORENE","text":"module procedure get_eos_loreneid module module function get_eos_loreneid(THIS) Interface → Returns the \\texttt{LORENE} ID-number of the EOS of the DRS FT Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value integer Called by proc~~get_eos_loreneid~~CalledByGraph proc~get_eos_loreneid get_eos_loreneid interface~get_eos_loreneid get_eos_loreneid interface~get_eos_loreneid->proc~get_eos_loreneid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos_loreneid.html"},{"title":"get_eos_parameters – SPHINCS_LORENE","text":"module procedure get_eos_parameters module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Interface → Returns the EoS parameters of the DRS FT 2.11.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the DRS Called by proc~~get_eos_parameters~2~~CalledByGraph proc~get_eos_parameters~2 get_eos_parameters interface~get_eos_parameters~2 get_eos_parameters interface~get_eos_parameters~2->proc~get_eos_parameters~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_eos_parameters~2.html"},{"title":"get_field_array – SPHINCS_LORENE","text":"module procedure get_field_array module module function get_field_array(THIS, field) result(field_array) Interface → Returns one of the member arrays, selected\n  with the string input. FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array Return Value double precision,\n  DIMENSION(:),ALLOCATABLE Desired diffstarlorene member array Called by proc~~get_field_array~2~~CalledByGraph proc~get_field_array~2 get_field_array interface~get_field_array~2 get_field_array interface~get_field_array~2->proc~get_field_array~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_field_array~2.html"},{"title":"get_field_value – SPHINCS_LORENE","text":"module procedure get_field_value module module function get_field_value(THIS, field, n) result(field_value) Interface → Returns the value of one of the member arrays,\n  selected with the string input, at the point\n  given as argument. FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array integer, intent(in) :: n Component of the desired diffstarlorene member array Return Value double precision Component n of the desired diffstarlorene member array Called by proc~~get_field_value~2~~CalledByGraph proc~get_field_value~2 get_field_value interface~get_field_value~2 get_field_value interface~get_field_value~2->proc~get_field_value~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_field_value~2.html"},{"title":"import_diffstar_params – SPHINCS_LORENE","text":"module procedure import_diffstar_params module module subroutine import_diffstar_params(THIS) Interface → Uses constants iso_c_binding proc~~import_diffstar_params~~UsesGraph proc~import_diffstar_params import_diffstar_params constants constants proc~import_diffstar_params->constants iso_c_binding iso_c_binding proc~import_diffstar_params->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Store the parameters of the binary neutron\n  stars' \\texttt{LORENE} ID into member variables FT 5.10.2020 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Calls proc~~import_diffstar_params~~CallsGraph proc~import_diffstar_params import_diffstar_params interface~get_diffstar_params get_diffstar_params proc~import_diffstar_params->interface~get_diffstar_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_diffstar_params->k_lorene2hydrobase_piecewisepolytrope interface~print_diffstar_params print_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~import_diffstar_params->k_lorene2hydrobase proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params proc~print_diffstar_params->k_lorene2hydrobase var panprocimport_diffstar_paramsCallsGraph = svgPanZoom('#procimport_diffstar_paramsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_diffstar_params~~CalledByGraph proc~import_diffstar_params import_diffstar_params interface~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params proc~construct_diffstarlorene construct_diffstarlorene proc~construct_diffstarlorene->interface~import_diffstar_params interface~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~diffstarlorene diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene var panprocimport_diffstar_paramsCalledByGraph = svgPanZoom('#procimport_diffstar_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables eos_tmp_c i nchars str_length Variables Type Visibility Attributes Name Initial character(kind=C_CHAR), private, DIMENSION(str_length) :: eos_tmp_c integer, private :: i integer, private :: nchars integer, private, parameter :: str_length = 100","tags":"","loc":"proc/import_diffstar_params.html"},{"title":"print_diffstar_params – SPHINCS_LORENE","text":"module procedure print_diffstar_params module module subroutine print_diffstar_params(THIS) Interface → Uses constants proc~~print_diffstar_params~~UsesGraph proc~print_diffstar_params print_diffstar_params constants constants proc~print_diffstar_params->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Print the parameters of the binary neutron\n  stars' initial data computed by \\texttt{LORENE} FT 8.10.2020 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Calls proc~~print_diffstar_params~~CallsGraph proc~print_diffstar_params print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~print_diffstar_params->k_lorene2hydrobase Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~print_diffstar_params~~CalledByGraph proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params proc~import_diffstar_params import_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params interface~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params proc~construct_diffstarlorene construct_diffstarlorene proc~construct_diffstarlorene->interface~import_diffstar_params interface~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~diffstarlorene diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene var panprocprint_diffstar_paramsCalledByGraph = svgPanZoom('#procprint_diffstar_paramsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/print_diffstar_params.html"},{"title":"import_id_full – SPHINCS_LORENE","text":"module procedure import_id_full module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Interface → Uses constants proc~~import_id_full~2~~UsesGraph proc~import_id_full~2 import_id_full constants constants proc~import_id_full~2->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the ID in non-[[diffstarlorene]]-member arrays\n  with the same shape as the [[diffstarlorene]] member arrays FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Calls proc~~import_id_full~2~~CallsGraph proc~import_id_full~2 import_id_full interface~get_diffstar_full get_diffstar_full proc~import_id_full~2->interface~get_diffstar_full Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_full~2~~CalledByGraph proc~import_id_full~2 import_id_full interface~import_id_full~2 import_id_full interface~import_id_full~2->proc~import_id_full~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_full~2.html"},{"title":"import_id_hydro – SPHINCS_LORENE","text":"module procedure import_id_hydro module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Interface → Uses tensor constants proc~~import_id_hydro~2~~UsesGraph proc~import_id_hydro~2 import_id_hydro tensor tensor proc~import_id_hydro~2->tensor constants constants proc~import_id_hydro~2->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the hydro ID in the arrays needed to compute\n  the constraints on the refined mesh FT 25.11.2020 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler Calls proc~~import_id_hydro~2~~CallsGraph proc~import_id_hydro~2 import_id_hydro interface~get_diffstar_hydro get_diffstar_hydro proc~import_id_hydro~2->interface~get_diffstar_hydro Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_hydro~2~~CalledByGraph proc~import_id_hydro~2 import_id_hydro interface~import_id_hydro~2 import_id_hydro interface~import_id_hydro~2->proc~import_id_hydro~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ix iy iz Variables Type Visibility Attributes Name Initial integer, private :: ix integer, private :: iy integer, private :: iz","tags":"","loc":"proc/import_id_hydro~2.html"},{"title":"import_id_int – SPHINCS_LORENE","text":"module procedure import_id_int module module subroutine import_id_int(THIS, n, x, y, z) Interface → Uses constants proc~~import_id_int~2~~UsesGraph proc~import_id_int~2 import_id_int constants constants proc~import_id_int~2->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the ID in the [[diffstarlorene]] member arrays FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z Calls proc~~import_id_int~2~~CallsGraph proc~import_id_int~2 import_id_int interface~get_diffstar_full get_diffstar_full proc~import_id_int~2->interface~get_diffstar_full Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_int~2~~CalledByGraph proc~import_id_int~2 import_id_int interface~import_id_int~2 import_id_int interface~import_id_int~2->proc~import_id_int~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_int~2.html"},{"title":"import_id_k – SPHINCS_LORENE","text":"module procedure import_id_k module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Interface → Stores the components of the extrinsic curvature\n  in arrays Warning DEPRECATED FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz Called by proc~~import_id_k~2~~CalledByGraph proc~import_id_k~2 import_id_k interface~import_id_k~2 import_id_k interface~import_id_k~2->proc~import_id_k~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_k~2.html"},{"title":"import_id_mass_b – SPHINCS_LORENE","text":"module procedure import_id_mass_b module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Interface → Uses constants proc~~import_id_mass_b~2~~UsesGraph proc~import_id_mass_b~2 import_id_mass_b constants constants proc~import_id_mass_b~2->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the hydro ID in the arrays needed to\n  compute the baryon mass, storing it to variables\n  (not arrays as the others SUBROUTINES in\n  the [[bns_import]] SUBMODULE). FT 15.04.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler Calls proc~~import_id_mass_b~2~~CallsGraph proc~import_id_mass_b~2 import_id_mass_b interface~get_diffstar_mass_b get_diffstar_mass_b proc~import_id_mass_b~2->interface~get_diffstar_mass_b Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_mass_b~2~~CalledByGraph proc~import_id_mass_b~2 import_id_mass_b interface~import_id_mass_b~2 import_id_mass_b interface~import_id_mass_b~2->proc~import_id_mass_b~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_id_mass_b~2.html"},{"title":"import_id_particles – SPHINCS_LORENE","text":"module procedure import_id_particles module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Interface → Uses constants proc~~import_id_particles~2~~UsesGraph proc~import_id_particles~2 import_id_particles constants constants proc~import_id_particles~2->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the hydro ID in the arrays needed to\n  compute the SPH ID FT 19.11.2020 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z Calls proc~~import_id_particles~2~~CallsGraph proc~import_id_particles~2 import_id_particles interface~get_diffstar_particles get_diffstar_particles proc~import_id_particles~2->interface~get_diffstar_particles Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_particles~2~~CalledByGraph proc~import_id_particles~2 import_id_particles interface~import_id_particles~2 import_id_particles interface~import_id_particles~2->proc~import_id_particles~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables detg Variables Type Visibility Attributes Name Initial double precision, private :: detg","tags":"","loc":"proc/import_id_particles~2.html"},{"title":"import_id_spacetime – SPHINCS_LORENE","text":"module procedure import_id_spacetime module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Interface → Uses tensor constants proc~~import_id_spacetime~2~~UsesGraph proc~import_id_spacetime~2 import_id_spacetime tensor tensor proc~import_id_spacetime~2->tensor constants constants proc~import_id_spacetime~2->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Stores the spacetime ID in multi-dimensional arrays\n  needed to compute the BSSN variables and constraints FT 22.11.2020 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek Calls proc~~import_id_spacetime~2~~CallsGraph proc~import_id_spacetime~2 import_id_spacetime proc~compute_g4 compute_g4 proc~import_id_spacetime~2->proc~compute_g4 interface~get_diffstar_spacetime get_diffstar_spacetime proc~import_id_spacetime~2->interface~get_diffstar_spacetime proc~determinant_sym4x4_grid determinant_sym4x4_grid proc~import_id_spacetime~2->proc~determinant_sym4x4_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_id_spacetime~2~~CalledByGraph proc~import_id_spacetime~2 import_id_spacetime interface~import_id_spacetime~2 import_id_spacetime interface~import_id_spacetime~2->proc~import_id_spacetime~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables detg detg4 g4 i j k Variables Type Visibility Attributes Name Initial double precision, private :: detg double precision, private :: detg4 double precision, private, DIMENSION( :, :, :, : ), ALLOCATABLE :: g4 integer, private :: i integer, private :: j integer, private :: k","tags":"","loc":"proc/import_id_spacetime~2.html"},{"title":"import_mass_density – SPHINCS_LORENE","text":"module procedure import_mass_density module module function import_mass_density(THIS, x, y, z) result(res) Interface → Uses constants iso_c_binding proc~~import_mass_density~2~~UsesGraph proc~import_mass_density~2 import_mass_density constants constants proc~import_mass_density~2->constants iso_c_binding iso_c_binding proc~import_mass_density~2->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Returns the \\texttt{LORENE} mass density at the point\n  given as argument, in units of M_\\odot/L_\\odot&#94;3 . FT Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) Calls proc~~import_mass_density~2~~CallsGraph proc~import_mass_density~2 import_mass_density interface~get_diffstar_mass_density get_diffstar_mass_density proc~import_mass_density~2->interface~get_diffstar_mass_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_mass_density~2~~CalledByGraph proc~import_mass_density~2 import_mass_density interface~import_mass_density~2 import_mass_density interface~import_mass_density~2->proc~import_mass_density~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_mass_density~2.html"},{"title":"import_spatial_metric – SPHINCS_LORENE","text":"module procedure import_spatial_metric module module function import_spatial_metric(THIS, x, y, z) result(res) Interface → Uses constants iso_c_binding proc~~import_spatial_metric~2~~UsesGraph proc~import_spatial_metric~2 import_spatial_metric constants constants proc~import_spatial_metric~2->constants iso_c_binding iso_c_binding proc~import_spatial_metric~2->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Returns the \\texttt{LORENE} conformal factor to the\n  4th power, equal to the diagonal components\n  of the conformally flat spatial ADM metric. FT 15.04.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) Calls proc~~import_spatial_metric~2~~CallsGraph proc~import_spatial_metric~2 import_spatial_metric interface~get_diffstar_spatial_metric get_diffstar_spatial_metric proc~import_spatial_metric~2->interface~get_diffstar_spatial_metric Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~import_spatial_metric~2~~CalledByGraph proc~import_spatial_metric~2 import_spatial_metric interface~import_spatial_metric~2 import_spatial_metric interface~import_spatial_metric~2->proc~import_spatial_metric~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/import_spatial_metric~2.html"},{"title":"is_hydro_negative – SPHINCS_LORENE","text":"module procedure is_hydro_negative module module function is_hydro_negative(THIS, x, y, z) result(res) Interface → Uses constants iso_c_binding proc~~is_hydro_negative~2~~UsesGraph proc~is_hydro_negative~2 is_hydro_negative constants constants proc~is_hydro_negative~2->constants iso_c_binding iso_c_binding proc~is_hydro_negative~2->iso_c_binding Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Return 1 if the energy density is nonpositive\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive\n  at the specified point FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Calls proc~~is_hydro_negative~2~~CallsGraph proc~is_hydro_negative~2 is_hydro_negative interface~negative_hydro~2 negative_hydro proc~is_hydro_negative~2->interface~negative_hydro~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~is_hydro_negative~2~~CalledByGraph proc~is_hydro_negative~2 is_hydro_negative interface~is_hydro_negative~2 is_hydro_negative interface~is_hydro_negative~2->proc~is_hydro_negative~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/is_hydro_negative~2.html"},{"title":"construct_diffstarlorene – SPHINCS_LORENE","text":"module procedure construct_diffstarlorene module module function construct_diffstarlorene(resu_file) result(drs) Interface → Constructs an object of TYPE [[diffstarlorene]] FT 25.10.2021 Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID Return Value type( diffstarlorene ) Constructed diffstarlorene object Calls proc~~construct_diffstarlorene~~CallsGraph proc~construct_diffstarlorene construct_diffstarlorene interface~import_diffstar_params import_diffstar_params proc~construct_diffstarlorene->interface~import_diffstar_params timer timer proc~construct_diffstarlorene->timer proc~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params interface~get_diffstar_params get_diffstar_params proc~import_diffstar_params->interface~get_diffstar_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_diffstar_params->k_lorene2hydrobase_piecewisepolytrope interface~print_diffstar_params print_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~import_diffstar_params->k_lorene2hydrobase proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params proc~print_diffstar_params->k_lorene2hydrobase var panprocconstruct_diffstarloreneCallsGraph = svgPanZoom('#procconstruct_diffstarloreneCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~construct_diffstarlorene~~CalledByGraph proc~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene interface~diffstarlorene diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->interface~diffstarlorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables diffstar_counter Variables Type Visibility Attributes Name Initial integer, private, SAVE :: diffstar_counter = 1","tags":"","loc":"proc/construct_diffstarlorene.html"},{"title":"construct_drs – SPHINCS_LORENE","text":"module procedure construct_drs module module subroutine construct_drs(THIS, resu_file) Interface → Construct the \\texttt{LORENE} \\texttt{Et_diffrot} object FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID Calls proc~~construct_drs~~CallsGraph proc~construct_drs construct_drs interface~construct_etdiffrot construct_etdiffrot proc~construct_drs->interface~construct_etdiffrot interface~destruct_etdiffrot destruct_etdiffrot proc~construct_drs->interface~destruct_etdiffrot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~construct_drs~~CalledByGraph proc~construct_drs construct_drs interface~construct_drs construct_drs interface~construct_drs->proc~construct_drs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables default_case exist Variables Type Visibility Attributes Name Initial character(kind=C_CHAR,len=7), private :: default_case logical, private :: exist","tags":"","loc":"proc/construct_drs.html"},{"title":"destruct_diffstarlorene – SPHINCS_LORENE","text":"module procedure destruct_diffstarlorene module module subroutine destruct_diffstarlorene(THIS) Interface → Destructs an object of TYPE [[diffstarlorene]] FT 25.10.2021 Arguments Type Intent Optional Attributes Name type( diffstarlorene ), intent(inout) :: THIS diffstarlorene object to be destructed Called by proc~~destruct_diffstarlorene~~CalledByGraph proc~destruct_diffstarlorene destruct_diffstarlorene interface~destruct_diffstarlorene destruct_diffstarlorene interface~destruct_diffstarlorene->proc~destruct_diffstarlorene Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destruct_diffstarlorene.html"},{"title":"destruct_drs – SPHINCS_LORENE","text":"module procedure destruct_drs module module subroutine destruct_drs(THIS) Interface → Destructs the \\texttt{LORENE} \\texttt{Et_diffrot} object and frees\n  the pointer [[diffstar:diffstar_ptr]] pointing to it FT 25.10.2021 Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Calls proc~~destruct_drs~~CallsGraph proc~destruct_drs destruct_drs interface~destruct_etdiffrot destruct_etdiffrot proc~destruct_drs->interface~destruct_etdiffrot Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~destruct_drs~~CalledByGraph proc~destruct_drs destruct_drs interface~destruct_drs destruct_drs interface~destruct_drs->proc~destruct_drs Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/destruct_drs.html"},{"title":"utility – SPHINCS_LORENE","text":"Uses matrix module~~utility~~UsesGraph module~utility utility matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~utility~~UsedByGraph module~utility utility module~formul_3p1_id formul_3p1_id module~formul_3p1_id->module~utility module~particles_id particles_id module~formul_3p1_id->module~particles_id module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~utility module~sphincs_lorene->module~formul_3p1_id module~sphincs_lorene->module~particles_id module~diffstar_lorene diffstar_lorene module~sphincs_lorene->module~diffstar_lorene module~bns_lorene bns_lorene module~sphincs_lorene->module~bns_lorene module~formul_bssn_id formul_bssn_id module~sphincs_lorene->module~formul_bssn_id proc~perform_apm perform_apm proc~perform_apm->module~utility module~particles_id->module~utility module~diffstar_lorene->module~utility module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base module~bns_lorene->module~utility module~bns_base bns_base module~bns_lorene->module~bns_base module~diffstar_base->module~utility proc~integrate_baryon_mass_density integrate_baryon_mass_density proc~integrate_baryon_mass_density->module~utility proc~setup_standard3p1_variables setup_standard3p1_variables proc~setup_standard3p1_variables->module~utility module~formul_bssn_id->module~utility module~formul_bssn_id->module~formul_3p1_id module~formul_bssn_id->module~particles_id module~bns_base->module~utility module~particles_redistribute_nu particles_redistribute_nu module~particles_redistribute_nu->module~particles_id module~particles_compose particles_compose module~particles_compose->module~particles_id program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene module~diffstar_lorene_constructor diffstar_lorene_constructor module~diffstar_lorene_constructor->module~diffstar_lorene module~particles_constructor particles_constructor module~particles_constructor->module~particles_id module~bns_lorene_params bns_lorene_params module~bns_lorene_params->module~bns_lorene module~bssn_id_variables bssn_id_variables module~bssn_id_variables->module~formul_bssn_id module~diffstar_lorene_params diffstar_lorene_params module~diffstar_lorene_params->module~diffstar_lorene module~particles_lattices particles_lattices module~particles_lattices->module~particles_id module~diffstar_lorene_memory diffstar_lorene_memory module~diffstar_lorene_memory->module~diffstar_lorene module~diffstar_lorene_access diffstar_lorene_access module~diffstar_lorene_access->module~diffstar_lorene module~spherical_surfaces spherical_surfaces module~spherical_surfaces->module~particles_id module~bns_lorene_memory bns_lorene_memory module~bns_lorene_memory->module~bns_lorene module~formul_3p1_standard3p1_variables formul_3p1_standard3p1_variables module~formul_3p1_standard3p1_variables->module~formul_3p1_id module~diffstar_lorene_import diffstar_lorene_import module~diffstar_lorene_import->module~diffstar_lorene module~particles_access particles_access module~particles_access->module~particles_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene module~formul_3p1_analysis formul_3p1_analysis module~formul_3p1_analysis->module~formul_3p1_id module~bssn_id_constructor bssn_id_constructor module~bssn_id_constructor->module~formul_bssn_id module~bssn_id_constraints bssn_id_constraints module~bssn_id_constraints->module~formul_bssn_id module~particles_sph_variables particles_sph_variables module~particles_sph_variables->module~particles_id module~bns_lorene_access bns_lorene_access module~bns_lorene_access->module~bns_lorene module~particles_apm particles_apm module~particles_apm->module~particles_id module~formul_3p1_access formul_3p1_access module~formul_3p1_access->module~formul_3p1_id module~bns_lorene_import bns_lorene_import module~bns_lorene_import->module~bns_lorene module~diffstar_base_access diffstar_base_access module~diffstar_base_access->module~diffstar_base module~particles_memory particles_memory module~particles_memory->module~particles_id module~bns_base_mass_profile bns_base_mass_profile module~bns_base_mass_profile->module~bns_base module~bns_base_access bns_base_access module~bns_base_access->module~bns_base module~bns_lorene_constructor bns_lorene_constructor module~bns_lorene_constructor->module~bns_lorene module~bssn_id_memory bssn_id_memory module~bssn_id_memory->module~formul_bssn_id var panmoduleutilityUsedByGraph = svgPanZoom('#moduleutilityUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables cnt creturn date end_time err_msg file_exists ios itr itr3 itr4 perc perc2 run_id show_progress time values zone Subroutines compute_g4 determinant_sym3x3_grid determinant_sym4x4_grid test_status Variables Type Visibility Attributes Name Initial integer, public :: cnt = 0 character, public, parameter :: creturn = ACHAR(13) character(len=8), public :: date character(len=19), public :: end_time character(len=:), public, ALLOCATABLE :: err_msg logical, public :: file_exists integer, public :: ios integer, public :: itr integer, public :: itr3 integer, public :: itr4 integer, public :: perc double precision, public :: perc2 character(len=19), public :: run_id logical, public :: show_progress character(len=10), public :: time integer, public, DIMENSION(8) :: values character(len=5), public :: zone Subroutines public subroutine compute_g4 (ix, iy, iz, lapse, shift_u, g_phys3_ll, g4) Arguments Type Intent Optional Attributes Name integer :: ix integer :: iy integer :: iz double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift_u double precision, intent(inout), DIMENSION(:,:,:,:) :: g_phys3_ll double precision, intent(inout), DIMENSION(:,:,:,:) :: g4 public subroutine determinant_sym3x3_grid (i, j, k, A, det) Arguments Type Intent Optional Attributes Name integer :: i integer :: j integer :: k double precision, intent(in) :: A (:,:,:,:) double precision, intent(out) :: det public subroutine determinant_sym4x4_grid (ix, iy, iz, A, det) Arguments Type Intent Optional Attributes Name integer :: ix integer :: iy integer :: iz double precision, intent(in) :: A (:,:,:,:) double precision, intent(out) :: det public subroutine test_status (io_stat, io_msg, opt_msg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: io_stat character(len=100), intent(in) :: io_msg character(len=*), intent(in), optional :: opt_msg","tags":"","loc":"module/utility.html"},{"title":"sphincs_lorene – SPHINCS_LORENE","text":"Uses timing formul_bssn_id utility bns_lorene particles_id id_base formul_3p1_id diffstar_lorene module~~sphincs_lorene~~UsesGraph module~sphincs_lorene sphincs_lorene module~formul_3p1_id formul_3p1_id module~sphincs_lorene->module~formul_3p1_id module~id_base id_base module~sphincs_lorene->module~id_base timing timing module~sphincs_lorene->timing module~utility utility module~sphincs_lorene->module~utility module~particles_id particles_id module~sphincs_lorene->module~particles_id module~diffstar_lorene diffstar_lorene module~sphincs_lorene->module~diffstar_lorene module~bns_lorene bns_lorene module~sphincs_lorene->module~bns_lorene module~formul_bssn_id formul_bssn_id module~sphincs_lorene->module~formul_bssn_id module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id mesh_refinement mesh_refinement module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility module~diffstar_lorene->timing module~diffstar_lorene->module~utility iso_c_binding iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base module~bns_lorene->module~id_base module~bns_lorene->timing module~bns_lorene->module~utility module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~formul_bssn_id->module~formul_3p1_id module~formul_bssn_id->module~id_base module~formul_bssn_id->timing module~formul_bssn_id->module~utility module~formul_bssn_id->module~particles_id module~formul_bssn_id->mesh_refinement module~diffstar_base->module~id_base module~diffstar_base->module~utility module~bns_base->module~id_base module~bns_base->module~utility var panmodulesphincs_loreneUsesGraph = svgPanZoom('#modulesphincs_loreneUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~sphincs_lorene~~UsedByGraph module~sphincs_lorene sphincs_lorene program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents None","tags":"","loc":"module/sphincs_lorene.html"},{"title":"formul_3p1_id – SPHINCS_LORENE","text":"This module contains the definition of ABSTRACT TYPE formul_3p1 Uses timing utility mesh_refinement particles_id id_base module~~formul_3p1_id~~UsesGraph module~formul_3p1_id formul_3p1_id module~id_base id_base module~formul_3p1_id->module~id_base timing timing module~formul_3p1_id->timing module~utility utility module~formul_3p1_id->module~utility module~particles_id particles_id module~formul_3p1_id->module~particles_id mesh_refinement mesh_refinement module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: formul_3p1_access formul_3p1_analysis formul_3p1_standard3p1_variables module~~formul_3p1_id~~UsedByGraph module~formul_3p1_id formul_3p1_id module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~formul_3p1_id module~formul_bssn_id formul_bssn_id module~sphincs_lorene->module~formul_bssn_id module~formul_3p1_standard3p1_variables formul_3p1_standard3p1_variables module~formul_3p1_standard3p1_variables->module~formul_3p1_id module~formul_bssn_id->module~formul_3p1_id module~formul_3p1_analysis formul_3p1_analysis module~formul_3p1_analysis->module~formul_3p1_id module~formul_3p1_access formul_3p1_access module~formul_3p1_access->module~formul_3p1_id module~bssn_id_constraints bssn_id_constraints module~bssn_id_constraints->module~formul_bssn_id program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene module~bssn_id_variables bssn_id_variables module~bssn_id_variables->module~formul_bssn_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene module~bssn_id_constructor bssn_id_constructor module~bssn_id_constructor->module~formul_bssn_id module~bssn_id_memory bssn_id_memory module~bssn_id_memory->module~formul_bssn_id Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces abs_values_in analyze_constraint deallocate_standard3p1_variables get_HC get_HC_parts get_MC get_MC_parts get_dx get_dy get_dz get_grid_point get_levels get_ngrid_x get_ngrid_y get_ngrid_z get_nlevels get_xR get_yR get_zR setup_standard3p1_variables Abstract Interfaces compute_and_export_3p1_constraints_grid_interface compute_and_export_3p1_constraints_particles_interface compute_and_export_3p1_variables_interface deallocate_fields_interface define_allocate_fields_interface print_formatted_lorene_id_3p1_variables_interface Derived Types formul_3p1 Interfaces interface public module module subroutine abs_values_in(THIS, lower_bound, upper_bound, constraint, l, export, unit_analysis, cnt) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS double precision :: lower_bound double precision :: upper_bound double precision, intent(in), DIMENSION(:,:,:) :: constraint integer, intent(in) :: l logical, intent(in) :: export integer, intent(in) :: unit_analysis integer, intent(out) :: cnt interface public module module subroutine analyze_constraint(THIS, l, constraint, name_constraint, unit_logfile, name_analysis, l2_norm, loo_norm) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l double precision, intent(in), DIMENSION(:,:,:) :: constraint character(len=*), intent(in) :: name_constraint integer, intent(in) :: unit_logfile character(len=*), intent(in) :: name_analysis double precision, intent(out) :: l2_norm double precision, intent(out) :: loo_norm interface public module module subroutine deallocate_standard3p1_variables(f3p1) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 interface public module module function get_HC(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision interface public module module function get_HC_parts(THIS, i, j, k, l) result(HC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision interface public module module function get_MC(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) interface public module module function get_MC_parts(THIS, i, j, k, l) result(MC_value) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) interface public module module function get_dx(THIS, l) result(dx) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision interface public module module function get_dy(THIS, l) result(dy) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision interface public module module function get_dz(THIS, l) result(dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision interface public module module function get_grid_point(THIS, i, j, k, l) result(grid_point) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) interface public module module function get_levels(THIS, l) result(levels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value type(level),\n  DIMENSION(:), ALLOCATABLE interface public module module function get_ngrid_x(THIS, l) result(ngrid_x) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer interface public module module function get_ngrid_y(THIS, l) result(ngrid_y) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer interface public module module function get_ngrid_z(THIS, l) result(ngrid_z) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer interface public module module function get_nlevels(THIS) result(nlevels) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS Return Value double precision interface public module module function get_xR(THIS, l) result(xR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer interface public module module function get_yR(THIS, l) result(yR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer interface public module module function get_zR(THIS, l) result(zR) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer interface public module module subroutine setup_standard3p1_variables(f3p1, id, dx, dy, dz) Implementation → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Abstract Interfaces abstract interface public subroutine compute_and_export_3p1_constraints_grid_interface(THIS, id, namefile, name_logfile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile abstract interface public subroutine compute_and_export_3p1_constraints_particles_interface(THIS, parts_obj, namefile, name_logfile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile abstract interface public subroutine compute_and_export_3p1_variables_interface(THIS, namefile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile abstract interface public subroutine deallocate_fields_interface(THIS) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS abstract interface public subroutine define_allocate_fields_interface(THIS) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS abstract interface public subroutine print_formatted_lorene_id_3p1_variables_interface(THIS, namefile) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile Derived Types type, public, ABSTRACT :: formul_3p1 ABSTRACT TYPE representing a generic 3+1 formulation of the Einsten\n equations Components Type Visibility Attributes Name Initial type(grid_function_scalar), public :: HC Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh\n (i.e., its maximum) type(grid_function_scalar), public :: HC_parts Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) type(grid_function), public :: K_phys3_ll Grid function storing the extrinsic curvature type(grid_function), public :: MC Grid function storing the momentum constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_l2 \\ell_2 norm of the momentum constraint computed on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_loo \\ell_\\infty norm of the momentum constraint computed on the mesh\n (i.e., its maximum) type(grid_function), public :: MC_parts Grid function storing the momentum constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_loo \\ell_\\infty norm of the momentum constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) integer, public :: cons_step Constraint violations are printed to file every cons_step-th grid point type(grid_function), public :: coords Grid function storing the Cartesian coordinates logical, public :: export_constraints .TRUE. if the constraint violations  are to be printed to file, .FALSE. otherwise logical, public :: export_constraints_details .TRUE. if the points at which the constraints violations are within the\n intervals [0,10&#94;{-7}],[10&#94;3,\\infty],[10&#94;n,10&#94;m] , with n\\in\\{-7,2\\} and m=n+1 , are to be printed to file; .FALSE. otherwise logical, public :: export_constraints_x .TRUE. if only the constrain violations on the x axis are to be logical, public :: export_constraints_xy .TRUE. if only the constrain violations on the xy plane are to be type(grid_function), public :: g_phys3_ll Grid function storing the spatial metric type(timer), public :: grid_timer Timer that times how long it takes to set up the grid and allocate\n the grid functions type(timer), public :: importer_timer Timer that times how long it takes to import the \\texttt{LORENE} ID\n on the mesh type(grid_function_scalar), public :: lapse Grid scalar function storing the lapse function type(level), public, DIMENSION(:), ALLOCATABLE :: levels Array containing the information on each refinement level integer, public :: nlevels Number of refinement levels type(grid_function_scalar), public :: rad_coord Grid scalar function storing the radial coordinates of each grid point type(grid_function), public :: shift_u Grid function storing the shift vector Type-Bound Procedures procedure, public :: abs_values_in procedure, public, NON_OVERRIDABLE :: analyze_constraint generic, public :: compute_and_export_3p1_constraints => compute_and_export_3p1_constraints_grid, compute_and_export_3p1_constraints_particles procedure(compute_and_export_3p1_constraints_grid_interface), public :: compute_and_export_3p1_constraints_grid procedure(compute_and_export_3p1_constraints_particles_interface), public :: compute_and_export_3p1_constraints_particles procedure(compute_and_export_3p1_variables_interface), public :: compute_and_export_3p1_variables procedure(deallocate_fields_interface), public :: deallocate_fields procedure, public, NON_OVERRIDABLE :: deallocate_standard3p1_variables procedure(define_allocate_fields_interface), public :: define_allocate_fields procedure, public :: get_HC procedure, public :: get_HC_parts procedure, public :: get_MC procedure, public :: get_MC_parts procedure, public :: get_dx procedure, public :: get_dy procedure, public :: get_dz procedure, public :: get_grid_point procedure, public :: get_levels procedure, public :: get_ngrid_x procedure, public :: get_ngrid_y procedure, public :: get_ngrid_z procedure, public :: get_nlevels procedure, public :: get_xR procedure, public :: get_yR procedure, public :: get_zR procedure(print_formatted_lorene_id_3p1_variables_interface), public :: print_formatted_lorene_id_3p1_variables procedure, public, NON_OVERRIDABLE :: setup_standard3p1_variables","tags":"","loc":"module/formul_3p1_id.html"},{"title":"formul_bssn_id – SPHINCS_LORENE","text":"Uses timing utility mesh_refinement particles_id id_base formul_3p1_id module~~formul_bssn_id~~UsesGraph module~formul_bssn_id formul_bssn_id module~formul_3p1_id formul_3p1_id module~formul_bssn_id->module~formul_3p1_id module~id_base id_base module~formul_bssn_id->module~id_base timing timing module~formul_bssn_id->timing module~utility utility module~formul_bssn_id->module~utility module~particles_id particles_id module~formul_bssn_id->module~particles_id mesh_refinement mesh_refinement module~formul_bssn_id->mesh_refinement module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: bssn_id_constraints bssn_id_constructor bssn_id_memory bssn_id_variables module~~formul_bssn_id~~UsedByGraph module~formul_bssn_id formul_bssn_id module~bssn_id_constraints bssn_id_constraints module~bssn_id_constraints->module~formul_bssn_id module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~formul_bssn_id module~bssn_id_variables bssn_id_variables module~bssn_id_variables->module~formul_bssn_id module~bssn_id_constructor bssn_id_constructor module~bssn_id_constructor->module~formul_bssn_id module~bssn_id_memory bssn_id_memory module~bssn_id_memory->module~formul_bssn_id program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces allocate_bssn_fields bssn_id compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_particles compute_and_export_bssn_variables construct_bssn_id deallocate_bssn_fields destruct_bssn_id destructor print_formatted_lorene_id_bssn_variables read_bssn_dump_print_formatted Derived Types bssn_id Interfaces interface public module module subroutine allocate_bssn_fields(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS public interface bssn_id public interface construct_bssn_id () Arguments None interface public module module subroutine compute_and_export_bssn_constraints_grid(THIS, id, namefile, name_logfile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile interface public module module subroutine compute_and_export_bssn_constraints_particles(THIS, parts_obj, namefile, name_logfile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile interface public module module subroutine compute_and_export_bssn_variables(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile interface public module module function construct_bssn_id(id, dx, dy, dz) result(bssnid) Implementation → Constructs the bssn_id object from the number of grid points\n along each axis Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Return Value type( bssn_id ) interface public module module subroutine deallocate_bssn_fields(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS interface public module module subroutine destruct_bssn_id(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS interface public module module subroutine destructor(THIS) Implementation → Arguments Type Intent Optional Attributes Name type( bssn_id ), intent(inout) :: THIS interface public module module subroutine print_formatted_lorene_id_bssn_variables(THIS, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile interface public module module subroutine read_bssn_dump_print_formatted(THIS, namefile_bin, namefile) Implementation → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile_bin character(len=*), intent(inout), optional :: namefile Derived Types type, public, extends( formul_3p1 ) :: bssn_id Components Type Visibility Attributes Name Initial type(grid_function), public :: A_BSSN3_ll Conformal traceless extrinsic curvature type(grid_function), public :: GC double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_l2 double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_loo type(grid_function), public :: GC_parts double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_parts_l2 double precision, public, DIMENSION(:,:), ALLOCATABLE :: GC_parts_loo type(grid_function), public :: Gamma_u Conformal connection type(grid_function_scalar), public :: HC Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh\n (i.e., its maximum) type(grid_function_scalar), public :: HC_parts Grid scalar function storing the Hamiltonian constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:), ALLOCATABLE :: HC_parts_loo \\ell_\\infty norm of the Hamiltonian constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) type(grid_function), public :: K_phys3_ll Grid function storing the extrinsic curvature type(grid_function), public :: MC Grid function storing the momentum constraint (violations)\n computed using the full \\texttt{LORENE} ID on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_l2 \\ell_2 norm of the momentum constraint computed on the mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_loo \\ell_\\infty norm of the momentum constraint computed on the mesh\n (i.e., its maximum) type(grid_function), public :: MC_parts Grid function storing the momentum constraint (violations)\n computed using the stress-energy tensor mapped from the particles to the\n mesh double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_l2 \\ell_2 norm of the Hamiltonian constraint computed on the mesh, using\n the stress-energy tensor mapped from the particles double precision, public, DIMENSION(:,:), ALLOCATABLE :: MC_parts_loo \\ell_\\infty norm of the momentum constraint computed on the mesh,\n using the stress-energy tensor mapped from the particles\n (i.e., its maximum) type(timer), public :: bssn_computer_timer integer, public :: call_flag = 0 integer, public :: cons_step Constraint violations are printed to file every cons_step-th grid point type(grid_function), public :: coords Grid function storing the Cartesian coordinates logical, public :: export_bin logical, public :: export_constraints .TRUE. if the constraint violations  are to be printed to file, .FALSE. otherwise logical, public :: export_constraints_details .TRUE. if the points at which the constraints violations are within the\n intervals [0,10&#94;{-7}],[10&#94;3,\\infty],[10&#94;n,10&#94;m] , with n\\in\\{-7,2\\} and m=n+1 , are to be printed to file; .FALSE. otherwise logical, public :: export_constraints_x .TRUE. if only the constrain violations on the x axis are to be logical, public :: export_constraints_xy .TRUE. if only the constrain violations on the xy plane are to be logical, public :: export_form_x logical, public :: export_form_xy type(grid_function), public :: g_BSSN3_ll Conformal spatial metric type(grid_function), public :: g_phys3_ll Grid function storing the spatial metric type(timer), public :: grid_timer Timer that times how long it takes to set up the grid and allocate\n the grid functions type(timer), public :: importer_timer Timer that times how long it takes to import the \\texttt{LORENE} ID\n on the mesh type(grid_function_scalar), public :: lapse Grid scalar function storing the lapse function type(level), public, DIMENSION(:), ALLOCATABLE :: levels Array containing the information on each refinement level integer, public :: nlevels Number of refinement levels type(grid_function_scalar), public :: phi Conformal factor type(grid_function_scalar), public :: rad_coord Grid scalar function storing the radial coordinates of each grid point type(grid_function), public :: shift_u Grid function storing the shift vector type(grid_function_scalar), public :: trK Trace of extrinsic curvature Constructor public  interface construct_bssn_id () Finalizations Procedures final :: destructor Destructor; finalizes members from both CLASSES formul_3p1, and bssn_id,\n by calling destruct_formul_3p1 and destruct_bssn_id Type-Bound Procedures procedure, public :: abs_values_in procedure, public, NON_OVERRIDABLE :: analyze_constraint generic, public :: compute_and_export_3p1_constraints => compute_and_export_3p1_constraints_grid, compute_and_export_3p1_constraints_particles procedure, public :: compute_and_export_3p1_constraints_grid => compute_and_export_bssn_constraints_grid procedure, public :: compute_and_export_3p1_constraints_particles => compute_and_export_bssn_constraints_particles procedure, public :: compute_and_export_3p1_variables => compute_and_export_bssn_variables procedure, public :: deallocate_fields => deallocate_bssn_fields procedure, public, NON_OVERRIDABLE :: deallocate_standard3p1_variables procedure, public :: define_allocate_fields => allocate_bssn_fields procedure, public :: destruct_bssn_id Finalizer for members of the extended class bssn_id, not the\n primitive class formul_3p1 procedure, public :: get_HC procedure, public :: get_HC_parts procedure, public :: get_MC procedure, public :: get_MC_parts procedure, public :: get_dx procedure, public :: get_dy procedure, public :: get_dz procedure, public :: get_grid_point procedure, public :: get_levels procedure, public :: get_ngrid_x procedure, public :: get_ngrid_y procedure, public :: get_ngrid_z procedure, public :: get_nlevels procedure, public :: get_xR procedure, public :: get_yR procedure, public :: get_zR procedure, public :: print_formatted_lorene_id_3p1_variables => print_formatted_lorene_id_bssn_variables procedure, public :: read_bssn_dump_print_formatted procedure, public, NON_OVERRIDABLE :: setup_standard3p1_variables","tags":"","loc":"module/formul_bssn_id.html"},{"title":"particles_id – SPHINCS_LORENE","text":"This module contains the definition of TYPE particles Uses id_base timing utility module~~particles_id~~UsesGraph module~particles_id particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: particles_access particles_apm particles_compose particles_constructor particles_lattices particles_memory particles_redistribute_nu particles_sph_variables spherical_surfaces module~~particles_id~~UsedByGraph module~particles_id particles_id module~particles_lattices particles_lattices module~particles_lattices->module~particles_id module~formul_3p1_id formul_3p1_id module~formul_3p1_id->module~particles_id module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~particles_id module~sphincs_lorene->module~formul_3p1_id module~formul_bssn_id formul_bssn_id module~sphincs_lorene->module~formul_bssn_id module~particles_redistribute_nu particles_redistribute_nu module~particles_redistribute_nu->module~particles_id module~particles_compose particles_compose module~particles_compose->module~particles_id module~particles_sph_variables particles_sph_variables module~particles_sph_variables->module~particles_id module~spherical_surfaces spherical_surfaces module~spherical_surfaces->module~particles_id module~particles_memory particles_memory module~particles_memory->module~particles_id module~particles_constructor particles_constructor module~particles_constructor->module~particles_id module~particles_access particles_access module~particles_access->module~particles_id module~formul_bssn_id->module~particles_id module~formul_bssn_id->module~formul_3p1_id module~particles_apm particles_apm module~particles_apm->module~particles_id module~bssn_id_constraints bssn_id_constraints module~bssn_id_constraints->module~formul_bssn_id program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene module~bssn_id_variables bssn_id_variables module~bssn_id_variables->module~formul_bssn_id module~formul_3p1_standard3p1_variables formul_3p1_standard3p1_variables module~formul_3p1_standard3p1_variables->module~formul_3p1_id module~bssn_id_constructor bssn_id_constructor module~bssn_id_constructor->module~formul_bssn_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene module~formul_3p1_analysis formul_3p1_analysis module~formul_3p1_analysis->module~formul_3p1_id module~bssn_id_memory bssn_id_memory module~bssn_id_memory->module~formul_bssn_id module~formul_3p1_access formul_3p1_access module~formul_3p1_access->module~formul_3p1_id var panmoduleparticles_idUsedByGraph = svgPanZoom('#moduleparticles_idUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces allocate_lorene_id_parts_memory analyze_hydro compute_Ye compute_and_export_SPH_variables construct_particles deallocate_lorene_id_parts_memory destruct_particles get_h get_nlrf get_npart get_npart1 get_npart2 get_nu get_nuratio get_nuratio1 get_nuratio2 get_pos get_pressure get_pressure_cu get_theta get_u get_vel is_empty particles perform_apm place_particles_lattice place_particles_spherical_surfaces print_formatted_lorene_id_particles read_compose_composition read_sphincs_dump_print_formatted Derived Types eos particles Functions check_particle_position Subroutines check_particle_positions Interfaces interface public module module subroutine allocate_lorene_id_parts_memory(THIS) Implementation → Allocates allocatable arrays member of a particles object Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of interface public module module subroutine analyze_hydro(THIS, namefile) Implementation → Scans the hydro fields taken from \\texttt{\\texttt{LORENE}} to look\n for negative or zero values Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the particle positions at which\n some of the hydro fields are negative or zero are printed to interface public module module subroutine compute_Ye(THIS) Implementation → Interpolates linearly the electron fraction Y_e at the particle\n densities; that is, assigns Y_e at the particle positions Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of interface public module module subroutine compute_and_export_SPH_variables(THIS, namefile) Implementation → Computes the SPH variables at the particle positions, and optionally\n prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} and \\texttt{splash} , and to a formatted file to be read by \\texttt{gnuplot} , by calling print_formatted_lorene_id_particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the SPH ID is printed to interface public module module function construct_particles(id, dist) result(parts) Implementation → Constructs a particles object Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id idbase object representing the BNS for which we want to place\n particles integer, intent(in) :: dist Identifier of the desired particle distribution: 0: Read particle positions (and optionally the baryon number per\n    particle \\nu ) from a formatted file 1: Place particles on a single lattice that surrounds both stars 2: Place particles on two lattices, each one surrounding a star 3: Place particles on spherical surfaces inside the stars Warning Method 1 is almost deprecated, since method 2 is effectively\n          an improvement of method 1 Return Value type( particles ) Constructed particles object interface public module module subroutine deallocate_lorene_id_parts_memory(THIS) Implementation → Deallocates allocatable arrays member of a particles object Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of interface public module module subroutine destruct_particles(THIS) Implementation → Arguments Type Intent Optional Attributes Name type( particles ), intent(inout) :: THIS Finalizer (Destructor) of particles object particles object which this PROCEDURE is a member of interface public module module function get_h(THIS) result(h) Implementation → Returns h Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE h interface public module module function get_nlrf(THIS) result(nlrf) Implementation → Returns nlrf Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE nlrf interface public module module function get_npart(THIS) result(n_part) Implementation → Returns npart Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer npart interface public module module function get_npart1(THIS) result(n_part) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles interface public module module function get_npart2(THIS) result(n_part) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles interface public module module function get_nu(THIS) result(nu) Implementation → Returns nu Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE nu interface public module module function get_nuratio(THIS) result(nuratio) Implementation → Returns nuratio Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision nuratio interface public module module function get_nuratio1(THIS) result(nuratio1) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles interface public module module function get_nuratio2(THIS) result(nuratio2) Implementation → Returns particles Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles interface public module module function get_pos(THIS) result(pos_u) Implementation → Returns pos Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:), ALLOCATABLE pos interface public module module function get_pressure(THIS) result(pressure) Implementation → Returns pressure_parts Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE pressure_parts interface public module module function get_pressure_cu(THIS) result(pressure_cu) Implementation → Returns pressure_parts_cu Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE pressure_parts_cu interface public module module function get_theta(THIS) result(theta) Implementation → Returns Theta Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Theta interface public module module function get_u(THIS) result(u) Implementation → Returns specific_energy_parts Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE specific_energy_parts interface public module module function get_vel(THIS) result(vel) Implementation → Returns v Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:), ALLOCATABLE v interface public module module function is_empty(THIS) result(answer) Implementation → Returns .TRUE if the particles object is empty, .FALSE otherwise Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(in) :: THIS particles object which this PROCEDURE is a member of Return Value logical .TRUE if the particles object is empty, .FALSE otherwise public interface particles Interface of TYPE particles public interface construct_particles () Arguments None interface public module module subroutine perform_apm(get_density, get_nstar_p, pos_input, pvol, h_output, nu_output, center, com_star, mass, radx_comp, radx_opp, rady, radz, apm_max_it, max_inc, mass_it, correct_nu, nuratio_thres, nuratio_des, nx_gh, ny_gh, nz_gh, namefile_pos_id, namefile_pos, namefile_results, validate_position) Implementation → Performs the Artificial Pressure Method (APM) on one star's particles Arguments Type Intent Optional Attributes Name function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine get_nstar_p(npart_real, x, y, z, nstar_p) Computes the proper baryon number density at the particle positions Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real Number of real particles (i.e., no ghost particles included here) double precision, intent(in) :: x (npart_real) Array of x coordinates double precision, intent(in) :: y (npart_real) Array of y coordinates double precision, intent(in) :: z (npart_real) Array of z coordinates double precision, intent(out) :: nstar_p (npart_real) Array to store the computed proper baryon number density double precision, intent(inout), DIMENSION(:,:) :: pos_input Initial particle positions double precision, intent(inout), DIMENSION(:) :: pvol Initial particle volume double precision, intent(out), DIMENSION(:) :: h_output Array to store the smoothing lengths computed at the end of the\n APM iteration double precision, intent(out), DIMENSION(:) :: nu_output Array to store the baryon number per particle computed at the end of\n the APM iteration double precision, intent(in) :: center Center of the star (point of highest density), computed by \\texttt{LORENE} double precision, intent(in) :: com_star Center of mass of the star, computed by \\texttt{LORENE} double precision, intent(in) :: mass Mass of the star double precision, intent(in) :: radx_comp Radius of the star in the x direction, towards the companion double precision, intent(in) :: radx_opp Radius of the star in the x direction, opposite to companion double precision, intent(in) :: rady Radius of the star in the y direction double precision, intent(in) :: radz Radius of the star in the z direction integer, intent(in) :: apm_max_it Maximum number of APM iterations, irrespective of the EXIT condition integer, intent(in) :: max_inc Sets the EXIT condition: If the average over all the\n particles of the relative error in the density estimate\n grows max_inc times, exit the iteration. logical, intent(in) :: mass_it If .TRUE. performs a second iteration after the APM one, without moving\n the particles, changing their mass in order to better match\n the star density. The mass ratio grows very fast in all the tried\n experiments, hence the suggested value is .FALSE. logical, intent(in) :: correct_nu If .TRUE., the baryon number per particle nu is corrected\n to include the total baryonic masses of the\n stars. double precision, intent(in) :: nuratio_thres Maximum mass ratio (equivalently baryon number ratio)\n to be used in the one-time-only final correction\n of the particle masses to match the star density even\n better (without moving the particles) double precision, intent(in) :: nuratio_des Sets the EXIT condition: If the baryon number ratio\n is within 2.5% of nuratio_des, exit the iteration\n Set nuratio_des to 0 to deactivate and exit the APM\n iteration using max_inc integer, intent(in) :: nx_gh Number of lattice points in the x direction for ghosts integer, intent(in) :: ny_gh Number of lattice points in the y direction for ghosts integer, intent(in) :: nz_gh Number of lattice points in the z direction for ghosts character(len=*), intent(inout), optional :: namefile_pos_id Name for the formatted file where the initial particle positions character(len=*), intent(inout), optional :: namefile_pos Name for the formatted file where the particle positions character(len=*), intent(inout), optional :: namefile_results Name for the formatted file where various quantities related procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise interface public module module subroutine place_particles_lattice(THIS, central_density, xmin, xmax, ymin, ymax, zmin, zmax, npart_des, npart_out, stretch, thres, pos, pvol, get_density, validate_position) Implementation → Places particles on a lattice containing a physical object Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: central_density Maximum baryon mass density of the system double precision, intent(in) :: xmin Left x boundary of the lattice double precision, intent(in) :: xmax Right x boundary of the lattice double precision, intent(in) :: ymin Left y boundary of the lattice double precision, intent(in) :: ymax Right y boundary of the lattice double precision, intent(in) :: zmin Left z boundary of the lattice double precision, intent(in) :: zmax Right z boundary of the lattice integer, intent(in) :: npart_des Desired particle number integer, intent(out) :: npart_out Real, output particle number double precision, intent(in) :: stretch Stretching factor fo the lattice. xmin to zmax are multiplied by it double precision, intent(in) :: thres (~rho_max)/thres is the minimum mass density considered\nwhen placing particles. Used only when redistribute_nu is\n.FALSE. . When redistribute_nu is .TRUE. thres= 100*nu_ratio double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes\nArray storing the final particle volumes function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise interface public module module subroutine place_particles_spherical_surfaces(THIS, mass_star, radius, center, central_density, npart_approx, npart_out, pos, pvol, pmass, last_r, upper_bound, lower_bound, upper_factor, lower_factor, max_steps, filename_mass_profile, filename_shells_radii, filename_shells_pos, get_density, integrate_density, get_id, validate_position) Implementation → Places particles on spherical surfaces on one star Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: mass_star Baryonic mass of the star double precision, intent(in) :: radius Radius of the star in the x direction towards the companion double precision, intent(in) :: center (x|) coordinate of the center of the star, i.e.,\n of the point with highest density double precision, intent(in) :: central_density Central density of the star, i.e., highest density integer, intent(in) :: npart_approx idbase object needed to access the BNS data Todo Remove the idbase argument as done in SUBROUTINE perform_apm\nCLASS(idbase),       INTENT( IN OUT ):: id\n Approximate particle number on the star integer, intent(out) :: npart_out Final number of particles on the star double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos Array string the final positions double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pmass Array storing the final particle masses double precision, intent(in) :: last_r Radius of the last spherical surface double precision, intent(inout) :: upper_bound Desired upper bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(inout) :: lower_bound Desired lower bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(in) :: upper_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. upper_factor >= 1, usually an increase of 1% works double precision, intent(in) :: lower_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. lower_factor <= 1, usually a decrease of 1% works integer, intent(in) :: max_steps If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. max_steps >= 10. 100 is a nice value character(len=*), intent(inout), optional :: filename_mass_profile Name of the file to store the radial mass profile character(len=*), intent(inout), optional :: filename_shells_radii Name of the file to store the surface radii Todo change name of variable to filename_surfaces_radii character(len=*), intent(inout), optional :: filename_shells_pos Name of the file to store the final particle positions Todo change name of variable to filename_surfaces_pos function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine integrate_density(center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order subroutine get_id(x, y, z, g_xx, baryon_density, gamma_euler) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise interface public module module subroutine print_formatted_lorene_id_particles(THIS, namefile) Implementation → Prints the SPH ID to a formatted file Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted output file interface public module module subroutine read_compose_composition(THIS, namefile) Implementation → Reads the Y_e(n_b) table in the CompOSE file with extension .beta Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile To read the file great_eos.beta in directory compose_path/GREAT_EoS,\n namefile=\"GREAT_EoS/great_eos\" interface public module module subroutine read_sphincs_dump_print_formatted(THIS, namefile_bin, namefile) Implementation → Reads the binary ID file printed by compute_and_export_SPH_variables and prints the data stored in it to a formatted file Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile_bin Name of the binary file to be read character(len=*), intent(inout), optional :: namefile Name of the formatted file to be printed Derived Types type, public :: eos Data structure representing an EoS Components Type Visibility Attributes Name Initial character(len=:), public, ALLOCATABLE :: eos_name The EoS name double precision, public, DIMENSION(:), ALLOCATABLE :: eos_parameters The EoS parameters, in the following order: Read more… type, public :: particles TYPE representing a particle distribution Components Type Visibility Attributes Name Initial double precision, private, DIMENSION(:), ALLOCATABLE :: Theta 1-D array storing the generalized Lorentz factor double precision, private, DIMENSION(:), ALLOCATABLE :: Ye 1-D array storing the electron fraction double precision, private, DIMENSION(:), ALLOCATABLE :: Ye_table Array storing the values of the electron fraction in the CompOSE table type( eos ), private, DIMENSION(:), ALLOCATABLE :: all_eos String containing the \\texttt{LORENE} name of the EOS for star 1\nString containing the \\texttt{LORENE} name of the EOS for star 2 logical, private, DIMENSION(:), ALLOCATABLE :: apm_iterate .TRUE. if the Artificial Pressure Method (APM) has to be applied to the\n particles on star 1, .FALSE. otherwise type(timer), public, DIMENSION(:), ALLOCATABLE :: apm_timers Timer that times how long it takes to perform the APM on the matter\n objects integer, private, DIMENSION(:), ALLOCATABLE :: baryon_density_index Array storing the indices to use with baryon_density_parts to sort the elements of baryon_density_parts in increasing\n order double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density_parts 1-D array storing the baryon mass density in the fluid frame [\\mathrm{kg}\\,\\mathrm{m}&#94;{-3}] integer, private :: call_flag = 0 logical, private :: compose_eos .TRUE. if the electron fraction Y_e should be read from the CompOSE\n table with extension.beta, .FALSE. otherwise Read more… character(len=:), private, ALLOCATABLE :: compose_filename String storing the subpath of compose_path to the CompOSE file with character(len=:), private, ALLOCATABLE :: compose_path String storing the local path to the directory containing the CompOSE EOS logical, private :: correct_nu .TRUE. if the baryon number per particle should be corrected to account\n for the total baryon masses of the stars, .FALSE. otherwise integer, private :: distribution_id Identification number for the particle distribution Read more… logical, private :: empty_object .TRUE. if the object is empty, .FALSE. if it's not empty double precision, private, DIMENSION(:), ALLOCATABLE :: energy_density_parts 1-D array storing the energy density logical, public :: export_bin .TRUE. if the binary files for SPHINCS_BSSN are to be exported, .FALSE. otherwise logical, public :: export_form_x .TRUE. if the ID in the formatted files is to be on the x axis only, .FALSE. otherwise logical, public :: export_form_xy .TRUE. if the ID in the formatted files is to be on the xy plane only, .FALSE. otherwise double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx_parts Array storing the values of the xx component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_xy_parts Array storing the values of the xy component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_xz_parts Array storing the values of the xz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_yy_parts Array storing the values of the xz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_yz_parts Array storing the values of the yz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: g_zz_parts Array storing the values of the zz component of the spatial metric\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: h 1-D array storing the smoothing length L_\\odot type(timer), public :: importer_timer Timer that times how long it takes to import the \\texttt{\\texttt{LORENE}} ID\n at the particle positions double precision, private, DIMENSION(:), ALLOCATABLE :: lapse_parts Array storing the values of the lapse function on the particles character(len=50), private :: lorene_bns_id_parfile Polytropic index for single polytropic EOS for star 1\nPolytropic constant for single polytropic EOS for star 1 Read more… double precision, private, DIMENSION(:), ALLOCATABLE :: mass_fractions double precision, private, DIMENSION(:), ALLOCATABLE :: mass_ratios Ratio of baryonic masses of the stars M_\\odot Read more… double precision, private, DIMENSION(:), ALLOCATABLE :: masses Baryonic masses of the matter objects M_\\odot integer, private :: n_matter Particle number for star 1 double precision, private, DIMENSION(:), ALLOCATABLE :: nb_table Array storing the values of the baryon number density in the CompOSE\n table. Read more… double precision, private, DIMENSION(:), ALLOCATABLE :: nbar_i Baryon number on star 1 double precision, private :: nbar_tot Total baryon number double precision, private, DIMENSION(:), ALLOCATABLE :: nlrf 1-D array storing baryon density in the local rest frame [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] , computed directly from\n the \\texttt{LORENE} density double precision, private, DIMENSION(:), ALLOCATABLE :: nlrf_int 1-D array storing baryon density in the local rest frame [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] , computed from the kernel\n interpolated proper baryon number density nstar_int integer, private :: npart Total particle number Read more… integer, private, DIMENSION(:), ALLOCATABLE :: npart_i Particle number for star 2 double precision, private, DIMENSION(:), ALLOCATABLE :: nstar 1-D array storing the SPH estimate of the proper baryon number density [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: nstar_int 1-D array storing the SPH estimate of the proper baryon number density,\n from kernel interpolation [\\mathrm{baryon}\\, (L_\\odot)&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: nu 1-D array storing the baryon number per particle double precision, private :: nu_ratio Total grid volume\nVolume per particle\nRatio between the max and min of the baryon number per particle double precision, private :: nuratio Baryon number on star 2\nBaryon number ratio on both stars double precision, private, DIMENSION(:), ALLOCATABLE :: nuratio_i Baryon number ratio on star 1\nBaryon number ratio on star 2 double precision, private, DIMENSION(:), ALLOCATABLE :: particle_density 1-D array storing the particle number density [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: particle_density_int 1-D array storing the SPH estimate of the particle number density, from\n kernel interpolation [\\mathrm{particle}\\, (L_\\odot)&#94;{-3}] type(timer), public :: placer_timer Timer that times how long it takes to place particles on the stars double precision, private, DIMENSION(:), ALLOCATABLE :: pmass 1-D array storing the particle masses M_\\odot double precision, private, DIMENSION(:,:), ALLOCATABLE :: pos 2-D array storing the particle positions double precision, private, DIMENSION(:), ALLOCATABLE :: pos_x1 1-D array storing the position of the particles on the x axis for S 1 double precision, private, DIMENSION(:), ALLOCATABLE :: pos_x2 1-D array storing the position of the particles on the x axis for NS2 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_length_scale_x1 1-D array storing the typical length scale for the pressure change double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_length_scale_x2 1-D array storing the typical length scale for the pressure change double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts 1-D array storing the pressure [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_cu 1-D array storing the pressure in code units [\\mathrm{amu}\\,c&#94;2\\,\\mathrm{L_\\odot}&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x1 1-D array storing the pressure on the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x2 1-D array storing the pressure on the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 2 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x_der1 1-D array storing the first derivative of the pressure\n along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS 1 double precision, private, DIMENSION(:), ALLOCATABLE :: pressure_parts_x_der2 1-D array storing the first derivative of the pressure\n along the x axis [\\mathrm{kg}\\,c&#94;2\\,\\mathrm{m}&#94;{-3}] for NS2 double precision, private, DIMENSION(:), ALLOCATABLE :: pvol 1-D array storing the particle volumes L_\\odot&#94;3 logical, private :: randomize_phi .TRUE. if the particle positions on spherical surfaces are randomized\n in the \\phi direction, .FALSE. otherwise logical, private :: randomize_r .TRUE. if the particle positions on spherical surfaces are randomized\n in the r direction, .FALSE. otherwise logical, private :: randomize_theta .TRUE. if the particle positions on spherical surfaces are randomized\n in the \\theta direction, .FALSE. otherwise logical, private :: read_nu .TRUE. if the baryon number per particle \\nu has to be read from the\n formatted file containing the particle positions, .FALSE. otherwise logical, private :: redistribute_nu .TRUE. if the baryon number per particle should be reassigned, trying\n to obtain a baryon number ratio no larger than nu_ratio,\n when placing particles on lattices; .FALSE. otherwise logical, private :: reflect_particles_x .TRUE. if the particles on star 2 should be the reflection of the\n particles on star 1 with respect to the yz plane, only if the baryon\n masses of the stars differe less than 0.2\\% ; .FALSE. otherwise type(timer), public :: same_particle_timer Timer that times how long it takes to check if there are multiple\n particles at the same positions double precision, private, DIMENSION(:), ALLOCATABLE :: shift_parts_x Array storing the values of the x component of the shift vector\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: shift_parts_y Array storing the values of the y component of the shift vector\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: shift_parts_z Array storing the values of the z component of the shift vector\n on the particles double precision, private, DIMENSION(:), ALLOCATABLE :: specific_energy_parts 1-D array storing the specific internal energy [c&#94;2] type(timer), public :: sph_computer_timer Timer that times how long it takes to compute the SPH variables at the\n particle pitions double precision, private, DIMENSION(:), ALLOCATABLE :: u_pwp 1-D array storing the specific internal energy [c&#94;2] computed using\n formula (9) in Read et al., Phys.Rev.D79:124032,2009,\n [arXiv:0812.2163][https://arxiv.org/abs/0812.2163]{:target=\"_blank\"} logical, private :: use_thres .TRUE. if the threshold on the baryon mass density should e applied\n when placing particles on lattices, .FALSE. otherwise double precision, private, DIMENSION(:,:), ALLOCATABLE :: v 2-D array storing the coordinate fluid 4-velocity [c] double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_parts_x 1-D array storing the x component of the fluid 3-velocity wrt\n the Eulerian observer [c] double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_parts_y 1-D array storing the y component of the fluid 3-velocity wrt\n the Eulerian observer [c] double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_parts_z 1-D array storing the z component of the fluid 3-velocity wrt\n the Eulerian observer [c] Constructor Interface of TYPE particles public  interface construct_particles () Finalizations Procedures final :: destruct_particles Finalizer (Destructor) of [[particles]] object Type-Bound Procedures procedure, public :: allocate_lorene_id_parts_memory Allocates memory for the particles member arrays procedure, public :: analyze_hydro Scans the hydro fields taken from \\texttt{\\texttt{LORENE}} to look\n for negative or zero values procedure, public :: compute_Ye Interpates linearly the electron fraction Y_e at the particle\n densities; that is, assigns Y_e at the particle positions procedure, public :: compute_and_export_SPH_variables Computes the SPH variables at the particle positions, and optionally\n prints them to a binary file to be read by \\texttt{SPHINCS_BSSN} and \\texttt{splash} , and to a formatted file to be read by \\texttt{gnuplot} , by calling print_formatted_lorene_id_particles procedure, public :: deallocate_lorene_id_parts_memory Deallocates memory for the particles member arrays procedure, public :: get_h Returns h procedure, public :: get_nlrf Returns nlrf procedure, public :: get_npart Returns npart procedure, public :: get_npart1 Returns particles procedure, public :: get_npart2 Returns particles procedure, public :: get_nu Returns nu procedure, public :: get_nuratio Returns nuratio procedure, public :: get_nuratio1 Returns particles procedure, public :: get_nuratio2 Returns particles procedure, public :: get_pos Returns pos procedure, public :: get_pressure Returns pressure_parts procedure, public :: get_pressure_cu Returns pressure_parts_cu procedure, public :: get_theta Returns Theta procedure, public :: get_u Returns specific_energy_parts procedure, public :: get_vel Returns v procedure, public :: is_empty Returns .TRUE if the particles object is empty, .FALSE otherwise Read more… procedure, public, NOPASS :: perform_apm Performs the Artificial Pressure Method (APM) on one star's particles procedure, public :: place_particles_lattice Places particles on a single lattice that surrounds both stars Read more… procedure, public :: place_particles_spherical_surfaces Places particles on spherical surfaces on one star procedure, public :: print_formatted_lorene_id_particles Prints the SPH ID to a formatted file procedure, public :: read_compose_composition Reads the Y_e(n_b) table in the CompOSE file with extension .beta procedure, public :: read_sphincs_dump_print_formatted Reads the binary ID file printed by compute_and_export_SPH_variables Functions public function check_particle_position (npart, pos, pos_a) result(cnt) Return the number of times that pos_a appears\n  in the array pos Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart double precision, intent(in), DIMENSION(3,npart) :: pos double precision, intent(in), DIMENSION(3) :: pos_a Return Value integer Subroutines public subroutine check_particle_positions (npart, pos, debug) Check that the particles are not at the same\n  positions Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart double precision, intent(in), DIMENSION(3,npart) :: pos logical, intent(in), optional :: debug","tags":"","loc":"module/particles_id.html"},{"title":"id_base – SPHINCS_LORENE","text":"This MODULE contains the definition of TYPE idbase,\n  which is an ABSTRACT TYPE representing any possible\n  type of initial data (ID) to be set up for \\texttt{SPHINCS_BSSN}.\n  That is, a binary neutron star system, a rotating\n  star, a binary black hole system, etc. PROCEDURES and variables shared by all these types\n  of ID should belong to TYPE idbase, as\n  they are inherited by its EXTENDED TYPES that\n  represent more specific types of ID. FT 24.09.2021 Uses timing module~~id_base~~UsesGraph module~id_base id_base timing timing module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: id_base_access id_base_mass_profile module~~id_base~~UsedByGraph module~id_base id_base module~formul_3p1_id formul_3p1_id module~formul_3p1_id->module~id_base module~particles_id particles_id module~formul_3p1_id->module~particles_id module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~id_base module~sphincs_lorene->module~formul_3p1_id module~sphincs_lorene->module~particles_id module~bns_lorene bns_lorene module~sphincs_lorene->module~bns_lorene module~formul_bssn_id formul_bssn_id module~sphincs_lorene->module~formul_bssn_id module~diffstar_lorene diffstar_lorene module~sphincs_lorene->module~diffstar_lorene module~id_base_mass_profile id_base_mass_profile module~id_base_mass_profile->module~id_base module~id_base_access id_base_access module~id_base_access->module~id_base module~particles_id->module~id_base module~bns_lorene->module~id_base module~bns_base bns_base module~bns_lorene->module~bns_base module~diffstar_base diffstar_base module~diffstar_base->module~id_base module~formul_bssn_id->module~id_base module~formul_bssn_id->module~formul_3p1_id module~formul_bssn_id->module~particles_id module~bns_base->module~id_base module~particles_redistribute_nu particles_redistribute_nu module~particles_redistribute_nu->module~particles_id module~particles_compose particles_compose module~particles_compose->module~particles_id program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene module~particles_constructor particles_constructor module~particles_constructor->module~particles_id module~diffstar_lorene->module~diffstar_base module~bns_lorene_params bns_lorene_params module~bns_lorene_params->module~bns_lorene module~bssn_id_variables bssn_id_variables module~bssn_id_variables->module~formul_bssn_id module~particles_lattices particles_lattices module~particles_lattices->module~particles_id module~spherical_surfaces spherical_surfaces module~spherical_surfaces->module~particles_id module~bns_lorene_memory bns_lorene_memory module~bns_lorene_memory->module~bns_lorene module~formul_3p1_standard3p1_variables formul_3p1_standard3p1_variables module~formul_3p1_standard3p1_variables->module~formul_3p1_id module~particles_access particles_access module~particles_access->module~particles_id program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene module~formul_3p1_analysis formul_3p1_analysis module~formul_3p1_analysis->module~formul_3p1_id module~bssn_id_constructor bssn_id_constructor module~bssn_id_constructor->module~formul_bssn_id module~bssn_id_constraints bssn_id_constraints module~bssn_id_constraints->module~formul_bssn_id module~particles_sph_variables particles_sph_variables module~particles_sph_variables->module~particles_id module~bns_lorene_access bns_lorene_access module~bns_lorene_access->module~bns_lorene module~particles_apm particles_apm module~particles_apm->module~particles_id module~formul_3p1_access formul_3p1_access module~formul_3p1_access->module~formul_3p1_id module~bns_lorene_import bns_lorene_import module~bns_lorene_import->module~bns_lorene module~diffstar_base_access diffstar_base_access module~diffstar_base_access->module~diffstar_base module~particles_memory particles_memory module~particles_memory->module~particles_id module~bns_base_mass_profile bns_base_mass_profile module~bns_base_mass_profile->module~bns_base module~bns_base_access bns_base_access module~bns_base_access->module~bns_base module~bns_lorene_constructor bns_lorene_constructor module~bns_lorene_constructor->module~bns_lorene module~bssn_id_memory bssn_id_memory module~bssn_id_memory->module~formul_bssn_id module~diffstar_lorene_memory diffstar_lorene_memory module~diffstar_lorene_memory->module~diffstar_lorene module~diffstar_lorene_access diffstar_lorene_access module~diffstar_lorene_access->module~diffstar_lorene module~diffstar_lorene_constructor diffstar_lorene_constructor module~diffstar_lorene_constructor->module~diffstar_lorene module~diffstar_lorene_import diffstar_lorene_import module~diffstar_lorene_import->module~diffstar_lorene module~diffstar_lorene_params diffstar_lorene_params module~diffstar_lorene_params->module~diffstar_lorene var panmoduleid_baseUsedByGraph = svgPanZoom('#moduleid_baseUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces check_i_matter get_n_matter get_one_lapse get_total_spatial_extent get_zero_shift integrate_baryon_mass_density set_n_matter set_one_lapse set_zero_shift Abstract Interfaces integrate_field_int read_double_at_pos read_id_full_int read_id_hydro_int read_id_k_int read_id_mass_b_int read_id_particles_int read_id_spacetime_int read_integer_at_pos return_double_parameter return_eos_parameters_int return_integer_parameter return_position return_spatial_extent_int return_string_parameter return_total_spatial_extent_int Derived Types idbase Interfaces interface public module module subroutine check_i_matter(THIS, i_matter) Implementation → Checks that the given index i_matter is between 1 and n_matter , included. If not, it stops the execution of the\n program. Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked interface public module module function get_n_matter(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the interface public module module function get_one_lapse(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the interface public module module function get_total_spatial_extent(THIS) result(box) Implementation → INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. interface public module module function get_zero_shift(THIS) Implementation → Returns n_matter , the number of matter objects in the\n physical system Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the interface public module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Implementation → INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order interface public module module subroutine set_n_matter(THIS, value) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to interface public module module subroutine set_one_lapse(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to interface public module module subroutine set_zero_shift(THIS, logic) Implementation → Sets n_matter , the number of matter objects in the\n physical system, to the given value Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to Abstract Interfaces abstract interface public subroutine integrate_field_int(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) INTERFACE to the SUBROUTINE integrating the baryon mass density to\n compute the radial mass profile of a single star. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order abstract interface public function read_double_at_pos(THIS, x, y, z) result(res) INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION at a given\n position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Real number at (x,y,z) abstract interface public subroutine read_id_full_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) INTERFACE or the SUBROUTINE reading the full ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z abstract interface public subroutine read_id_hydro_int(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) INTERFACE or the SUBROUTINE reading the the hydro ID needed to compute\n the constraints on the refined mesh Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler abstract interface public subroutine read_id_k_int(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) INTERFACE or the SUBROUTINE reading the components of the extrinsic\n curvature Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz abstract interface public subroutine read_id_mass_b_int(THIS, x, y, z, g_xx, baryon_density, gamma_euler) INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n baryon mass Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler abstract interface public subroutine read_id_particles_int(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) INTERFACE or the SUBROUTINE reading the hydro ID needed to compute the\n SPH ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z abstract interface public subroutine read_id_spacetime_int(THIS, nx, ny, nz, pos, lapse, shift, g, ek) INTERFACE or the SUBROUTINE reading the spacetime ID Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek abstract interface public function read_integer_at_pos(THIS, x, y, z) result(res) INTERFACE for a PROCEDURE that returns an INTEGER at a given position Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer Integer at (x,y,z) abstract interface public function return_double_parameter(THIS, i_matter) result(res) INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision Real number. Parameter of the i_matter -th matter object abstract interface public subroutine return_eos_parameters_int(THIS, i_matter, eos_params) INTERFACE for a PROCEDURE that returns an array containing the\n parametersf the EoS for the matter objects Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object abstract interface public function return_integer_parameter(THIS, i_matter) result(res) INTERFACE for a PROCEDURE that returns an INTEGER Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value integer Real number. Parameter of the i_matter -th matter object abstract interface public function return_position(THIS, i_matter) result(res) INTERFACE for a PROCEDURE that returns a DOUBLE PRECISION Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) Centers of the matter objects. The first index runs over the matter\n objects, the second index over (x,y,z) . abstract interface public function return_spatial_extent_int(THIS, i_matter) result(box) INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  matter objects, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. abstract interface public function return_string_parameter(THIS, i_matter) result(string) INTERFACE for a PROCEDURE that returns a CHARACTER( LEN= : ) Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS idbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE abstract interface public function return_total_spatial_extent_int(THIS) result(box) INTERFACE to the SUBROUTINE that detects the spatial extent of the\n  physical system considered, and returns a 6-dimensional array\n  containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box centered at the center of the object and containing the\n  system. Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. Derived Types type, public, ABSTRACT :: idbase Represents a generic ID for \\texttt{SPHINCS_BSSN} (binary neutron star, rotating\n star, etc.) Components Type Visibility Attributes Name Initial type(timer), public :: construction_timer Timer that times the construction of the appropriate object integer, private :: n_matter = 0 Number of matter objects belonging the physical system.\n For example, n_objects= 2 for a binary system of stars, and n_objects= 1\n for a single star or for a binary system of a black hole and a star. logical, private :: one_lapse Logical variable that determines if the lapse function \\alpha=1 , logical, private :: zero_shift Logical variable that determines if the shift \\beta&#94;i=0 Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star procedure(read_id_full_int), public :: read_id_full Reads the full ID procedure(read_id_hydro_int), public :: read_id_hydro Reads the hydro ID needed to compute the constraints on the refined mesh procedure(read_id_k_int), public :: read_id_k Reads the components of the extrinsic curvature procedure(read_id_mass_b_int), public :: read_id_mass_b Reads the hydro ID needed to compute the baryon mass procedure(read_id_particles_int), public :: read_id_particles Reads the hydro ID needed to compute the SPH ID procedure(read_id_spacetime_int), public :: read_id_spacetime Reads the spacetime ID needed to compute\n the BSSN variables and constraints procedure(read_double_at_pos), public :: read_mass_density Returns the baryon mass density at the given point procedure(return_position), public :: return_barycenter Returns the barycenters (centers of mass) of the matter objects. procedure(return_position), public :: return_center Returns the centers of the matter objects. procedure(return_string_parameter), public :: return_eos_name Returns the name of the EoS of the matter objects. Read more… procedure(return_eos_parameters_int), public :: return_eos_parameters Returns the identification number of the EoS of the matter objects. Read more… procedure(return_double_parameter), public :: return_mass Returns the masses of the matter objects. procedure(return_spatial_extent_int), public :: return_spatial_extent Returns the spatial extent of the matter objects,\n  returning the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure(read_integer_at_pos), public :: test_position Returns 1 if the position has physically acceptable properties,\n 0 otherwise","tags":"","loc":"module/id_base.html"},{"title":"bns_base – SPHINCS_LORENE","text":"This MODULE contains the definition of TYPE bnsbase,\n  which is an ABSTRACT TYPE representing any possible\n  type of binary neutron star (BNS) initial data (ID)\n  to be set up for \\texttt{SPHINCS_BSSN}. That is, BNS ID\n  produced with LORENE, with \\texttt{FUKA}, etc. PROCEDURES and variables shared by all the types\n  of BNS ID should belong to TYPE bnsbase, as\n  they are inherited by its EXTENDED TYPES that\n  represent more specific typesof BNS ID. FT 24.09.2021 Uses id_base utility module~~bns_base~~UsesGraph module~bns_base bns_base module~id_base id_base module~bns_base->module~id_base module~utility utility module~bns_base->module~utility timing timing module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: bns_base_access bns_base_mass_profile module~~bns_base~~UsedByGraph module~bns_base bns_base module~bns_base_mass_profile bns_base_mass_profile module~bns_base_mass_profile->module~bns_base module~bns_lorene bns_lorene module~bns_lorene->module~bns_base module~bns_base_access bns_base_access module~bns_base_access->module~bns_base module~bns_lorene_import bns_lorene_import module~bns_lorene_import->module~bns_lorene module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~bns_lorene module~bns_lorene_memory bns_lorene_memory module~bns_lorene_memory->module~bns_lorene module~bns_lorene_access bns_lorene_access module~bns_lorene_access->module~bns_lorene module~bns_lorene_params bns_lorene_params module~bns_lorene_params->module~bns_lorene module~bns_lorene_constructor bns_lorene_constructor module~bns_lorene_constructor->module~bns_lorene program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces get_adm_mass get_angular_momentum get_angular_vel get_barycenter get_barycenter1_x get_barycenter2_x get_center get_center1_x get_center2_x get_distance get_distance_com get_energy_density_center1 get_energy_density_center2 get_ent_center1 get_ent_center2 get_eos get_eos1 get_eos2 get_gamma0_1 get_gamma0_2 get_gamma1_1 get_gamma1_2 get_gamma2_1 get_gamma2_2 get_gamma3_1 get_gamma3_2 get_gamma_1 get_gamma_2 get_grav_mass1 get_grav_mass2 get_kappa0_1 get_kappa0_2 get_kappa1_1 get_kappa1_2 get_kappa2_1 get_kappa2_2 get_kappa3_1 get_kappa3_2 get_kappa_1 get_kappa_2 get_logP1_1 get_logP1_2 get_logRho0_1 get_logRho0_2 get_logRho1_1 get_logRho1_2 get_logRho2_1 get_logRho2_2 get_mass get_mass1 get_mass2 get_nbar_center1 get_nbar_center2 get_npeos_1 get_npeos_2 get_pressure_center1 get_pressure_center2 get_radii get_radius1_x_comp get_radius1_x_opp get_radius1_y get_radius1_z get_radius2_x_comp get_radius2_x_opp get_radius2_y get_radius2_z get_rho_center1 get_rho_center2 get_specific_energy_center1 get_specific_energy_center2 Abstract Interfaces get_eos_id_int Derived Types bnsbase Interfaces interface public module module function get_adm_mass(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_angular_vel(THIS) Implementation → Returns angular_vel Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) interface public module module function get_barycenter1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_barycenter2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) interface public module module function get_center1_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_center2_x(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_distance(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_distance_com(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_energy_density_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_energy_density_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_ent_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_ent_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE interface public module module function get_eos1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE interface public module module function get_eos2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE interface public module module function get_gamma0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_grav_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_grav_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa3_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa3_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logP1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logP1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho0_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho0_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho1_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho1_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho2_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho2_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_mass(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision interface public module module function get_mass1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_mass2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_nbar_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_nbar_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_npeos_1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer interface public module module function get_npeos_2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer interface public module module function get_pressure_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_pressure_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) interface public module module function get_radius1_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radius1_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radius1_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radius1_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radius2_x_comp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radius2_x_opp(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radius2_y(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radius2_z(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_rho_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_rho_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_specific_energy_center1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_specific_energy_center2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision Abstract Interfaces abstract interface public function get_eos_id_int(THIS) Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer Derived Types type, public, ABSTRACT, extends( idbase ) :: bnsbase Represents a generic BNS ID for \\texttt{SPHINCS_BSSN} (produced with LORENE, or with\n \\texttt{FUKA}, etc.; or produced with the same tool, but read in different ways,\n for example by linking to the LORENE library, or reading the ID from\n a lattice, etc.) Components Type Visibility Attributes Name Initial double precision, public :: adm_mass ADM mass of the BNS [M_\\odot] double precision, public :: angular_momentum = 0.0D0 Angular momentum of the BNS system [G M_\\odot&#94;2/c] double precision, public :: angular_vel Angular velocity [{\\rm rad/s}] double precision, public :: area_radius1 Areal (or circumferential) radius of star 1 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public :: area_radius2 Areal (or circumferential) radius of star 2 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(2,3) :: barycenter Array containing the barycenters of the stars Read more… double precision, public :: barycenter1_x Barycenter of star 1 [L_\\odot] double precision, public :: barycenter2_x Barycenter of star 2 [L_\\odot] double precision, public, DIMENSION(2,3) :: center Array containing the centers of the stars Read more… double precision, public :: center1_x Stellar center of star 1 (origin of the LORENE chart centered on star 1) [L_\\odot] double precision, public :: center2_x Stellar center of star 2 (origin of the LORENE chart centered on star 2) [L_\\odot] type(timer), public :: construction_timer Timer that times the construction of the appropriate object double precision, public :: distance Distance d between the points of maximum baryon density [{\\rm km}] double precision, public :: distance_com Distance between the centers of mass [L_\\odot(=1.47662503825040{\\rm km})] double precision, public :: energy_density_center1 Central energy density for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: energy_density_center2 Central energy density for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center1 Central enthalpy for star 1 [c&#94;2] double precision, public :: ent_center2 Central enthalpy for star 2 [c&#94;2] character(len=:), public, ALLOCATABLE :: eos1 Name of the equation of state (EoS) of star 1 character(len=:), public, ALLOCATABLE :: eos2 Name of the equation of state (EoS) of star 2 double precision, public :: gamma0_1 Piecewise polytrope: polytropic index \\gamma_0 for star 1 double precision, public :: gamma0_2 Piecewise polytrope: polytropic index \\gamma_0 for star 2 double precision, public :: gamma1_1 Piecewise polytrope: polytropic index \\gamma_1 for star 1 double precision, public :: gamma1_2 Piecewise polytrope: polytropic index \\gamma_1 for star 2 double precision, public :: gamma2_1 Piecewise polytrope: polytropic index \\gamma_2 for star 1 double precision, public :: gamma2_2 Piecewise polytrope: polytropic index \\gamma_2 for star 2 double precision, public :: gamma3_1 Piecewise polytrope: polytropic index \\gamma_3 for star 1 double precision, public :: gamma3_2 Piecewise polytrope: polytropic index \\gamma_3 for star 2 double precision, public :: gamma_1 Single polytrope: polytropic index for star 1 double precision, public :: gamma_2 Single polytrope: polytropic index for star 2 double precision, public :: kappa0_1 Piecewise polytrope: polytropic constant \\kappa_0 for star 1\n [pure number] double precision, public :: kappa0_2 Piecewise polytrope: polytropic constant \\kappa_0 for star 2\n [pure number] double precision, public :: kappa1_1 Piecewise polytrope: polytropic constant \\kappa_1 for star 1\n [pure number] double precision, public :: kappa1_2 Piecewise polytrope: polytropic constant \\kappa_1 for star 2\n [pure number] double precision, public :: kappa2_1 Piecewise polytrope: polytropic constant \\kappa_2 for star 1\n [pure number] double precision, public :: kappa2_2 Piecewise polytrope: polytropic constant \\kappa_2 for star 2\n [pure number] double precision, public :: kappa3_1 Piecewise polytrope: polytropic constant \\kappa_3 for star 1\n [pure number] double precision, public :: kappa3_2 Piecewise polytrope: polytropic constant \\kappa_3 for star 2\n [pure number] double precision, public :: kappa_1 Single polytrope: polytropic constant for star 1 [pure number] double precision, public :: kappa_2 Single polytrope: polytropic constant for star 2 [pure number] double precision, public :: logP1_1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 1 double precision, public :: logP1_2 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 2 double precision, public :: logRho0_1 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho0_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho1_1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho1_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho2_1 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho2_2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: mOmega mOmega= ( angular_vel [{\\rm km&#94;{-1}}] ) \\times ( mass_grav1 [{\\rm km}] + mass_grav2 [{\\rm km}] ) [pure number] Read more… double precision, public, DIMENSION(2) :: mass Array containing the baryonic masses [M_\\odot] double precision, public :: mass1 Baryonic mass of star 1 [M_\\odot] double precision, public :: mass2 Baryonic mass of star 2 [M_\\odot] double precision, public, DIMENSION(2) :: mass_grav Array containing the gravitatil masses [M_\\odot] double precision, public :: mass_grav1 Gravitational mass of star 1 [M_\\odot] double precision, public :: mass_grav2 Gravitational mass of star 2 [M_\\odot] double precision, public :: nbar_center1 Central baryon number density for star 1 [L_\\odot&#94;{-3}] double precision, public :: nbar_center2 Central baryon number density for star 2 [L_\\odot&#94;{-3}] integer, public :: npeos_1 Piecewise polytrope: Number of polytropic pieces for star 1 integer, public :: npeos_2 Piecewise polytrope: Number of polytropic pieces for star 2 double precision, public :: pressure_center1 Central pressure for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: pressure_center2 Central pressure for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public, DIMENSION(2,6) :: radii Array containing the signed radii of the stars Read more… double precision, public :: radius1_x_comp Radius of star 1, in the x direction, towards the companion [L_\\odot] double precision, public :: radius1_x_opp Radius of star 1, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius1_y Radius of star 1, in the y direction [L_\\odot] double precision, public :: radius1_z Radius of star 1, in the z direction [L_\\odot] double precision, public :: radius2_x_comp Radius of star 2, in the x direction, towards the companion [L_\\odot] double precision, public :: radius2_x_opp Radius of star 2, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius2_y Radius of star 2, in the y direction [L_\\odot] double precision, public :: radius2_z Radius of star 2, in the z direction [L_\\odot] double precision, public :: rho_center1 Central baryon mass density for star 1 [M_\\odot L_\\odot&#94;{-3}] double precision, public :: rho_center2 Central baryon mass density for star 2 [M_\\odot L_\\odot&#94;{-3}] double precision, public :: specific_energy_center1 Central specific energy for star 1 [c&#94;2] double precision, public :: specific_energy_center2 Central specific energy for star 2 [c&#94;2] double precision, public :: t_merger Estimated time of the merger [M_\\odot] t_\\mathrm{merger}=\\dfrac{5}{256}\n \\dfrac{d&#94;4}{M&#94;1_\\mathrm{g}M&#94;2_\\mathrm{g}(M&#94;1_\\mathrm{g}+M&#94;2_\\mathrm{g})} P. C. Peters, \"Gravitational Radiation and the Motion of Two Point\n Masses\", Phys. Rev. 136, B1224 (1964) Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. procedure, public :: get_adm_mass Returns adm_mass procedure, public :: get_angular_momentum Returns angular_momentum procedure, public :: get_angular_vel Returns angular_vel procedure, public :: get_barycenter1_x Returns barycenter1_x procedure, public :: get_barycenter2_x Returns barycenter2_x procedure, public :: get_center1_x Returns center1_x procedure, public :: get_center2_x Returns center2_x procedure, public :: get_distance Returns distance procedure, public :: get_distance_com Returns distance_com procedure, public :: get_energy_density_center1 Returns energy_density_center1 procedure, public :: get_energy_density_center2 Returns energy_density_center2 procedure, public :: get_ent_center1 Returns ent_center1 procedure, public :: get_ent_center2 Returns ent_center2 procedure, public :: get_eos1 Returns eos1 procedure(get_eos_id_int), public :: get_eos1_id Returns an integer that identifies the equation of state of star 1 procedure, public :: get_eos2 Returns eos2 procedure(get_eos_id_int), public :: get_eos2_id Returns an integer that identifies the equation of state of star 2 Read more… procedure, public :: get_gamma0_1 Returns gamma0_1 procedure, public :: get_gamma0_2 Returns gamma0_2 procedure, public :: get_gamma1_1 Returns gamma1_1 procedure, public :: get_gamma1_2 Returns gamma1_2 procedure, public :: get_gamma2_1 Returns gamma2_1 procedure, public :: get_gamma2_2 Returns gamma2_2 procedure, public :: get_gamma3_1 Returns gamma3_1 procedure, public :: get_gamma3_2 Returns gamma3_2 procedure, public :: get_gamma_1 Returns gamma_1 procedure, public :: get_gamma_2 Returns gamma_2 procedure, public :: get_grav_mass1 Returns mass_grav1 procedure, public :: get_grav_mass2 Returns mass_grav2 procedure, public :: get_kappa0_1 Returns kappa0_1 procedure, public :: get_kappa0_2 Returns kappa0_2 procedure, public :: get_kappa1_1 Returns kappa1_1 procedure, public :: get_kappa1_2 Returns kappa1_2 procedure, public :: get_kappa2_1 Returns kappa2_1 procedure, public :: get_kappa2_2 Returns kappa2_2 procedure, public :: get_kappa3_1 Returns kappa3_1 procedure, public :: get_kappa3_2 Returns kappa3_2 procedure, public :: get_kappa_1 Returns kappa_1 procedure, public :: get_kappa_2 Returns kappa_2 procedure, public :: get_logP1_1 Returns logP1_1 procedure, public :: get_logP1_2 Returns logP1_2 procedure, public :: get_logRho0_1 Returns logRho0_1 procedure, public :: get_logRho0_2 Returns logRho0_2 procedure, public :: get_logRho1_1 Returns logRho1_1 procedure, public :: get_logRho1_2 Returns logRho1_2 procedure, public :: get_logRho2_1 Returns logRho2_1 procedure, public :: get_logRho2_2 Returns logRho2_2 procedure, public :: get_mass1 Returns mass1 procedure, public :: get_mass2 Returns mass2 procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system procedure, public :: get_nbar_center1 Returns nbar_center1 procedure, public :: get_nbar_center2 Returns nbar_center2 procedure, public :: get_npeos_1 Returns npeos_1 procedure, public :: get_npeos_2 Returns npeos_2 procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public :: get_pressure_center1 Returns pressure_center1 procedure, public :: get_pressure_center2 Returns pressure_center2 procedure, public :: get_radius1_x_comp Returns radius1_x_comp procedure, public :: get_radius1_x_opp Returns radius1_x_opp procedure, public :: get_radius1_y Returns radius1_y procedure, public :: get_radius1_z Returns radius1_z procedure, public :: get_radius2_x_comp Returns radius2_x_comp procedure, public :: get_radius2_x_opp Returns radius2_x_opp procedure, public :: get_radius2_y Returns radius2_y procedure, public :: get_radius2_z Returns radius2_y procedure, public :: get_rho_center1 Returns rho_center1 procedure, public :: get_rho_center2 Returns rho_center2 procedure, public :: get_specific_energy_center1 Returns specific_energy_center1 procedure, public :: get_specific_energy_center2 Returns specific_energy_center2 procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star procedure(read_id_full_int), public :: read_id_full Reads the full ID procedure(read_id_hydro_int), public :: read_id_hydro Reads the hydro ID needed to compute the constraints on the refined mesh procedure(read_id_k_int), public :: read_id_k Reads the components of the extrinsic curvature procedure(read_id_mass_b_int), public :: read_id_mass_b Reads the hydro ID needed to compute the baryon mass procedure(read_id_particles_int), public :: read_id_particles Reads the hydro ID needed to compute the SPH ID procedure(read_id_spacetime_int), public :: read_id_spacetime Reads the spacetime ID needed to compute\n the BSSN variables and constraints procedure(read_double_at_pos), public :: read_mass_density Returns the baryon mass density at the given point procedure, public :: return_barycenter => get_barycenter procedure, public :: return_center => get_center procedure, public :: return_eos_name => get_eos procedure(return_eos_parameters_int), public :: return_eos_parameters Returns the identification number of the EoS of the matter objects. Read more… procedure, public :: return_mass => get_mass procedure, public :: return_spatial_extent => get_radii procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure(read_integer_at_pos), public :: test_position Returns 1 if the position has physically acceptable properties,\n 0 otherwise","tags":"","loc":"module/bns_base.html"},{"title":"bns_lorene – SPHINCS_LORENE","text":"This module contains the definition of TYPE bnslorene,\n   and the SUBROUTINES that bind to the methods\n   of \\texttt{LORENE}'s class \\texttt{Bin_NS}, defined in\n   Lorene/Export/BinNS \\texttt{LORENE} official repository Uses timing iso_c_binding bns_base utility id_base module~~bns_lorene~~UsesGraph module~bns_lorene bns_lorene module~id_base id_base module~bns_lorene->module~id_base timing timing module~bns_lorene->timing module~utility utility module~bns_lorene->module~utility iso_c_binding iso_c_binding module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~id_base->timing matrix matrix module~utility->matrix module~bns_base->module~id_base module~bns_base->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: bns_lorene_access bns_lorene_constructor bns_lorene_import bns_lorene_memory bns_lorene_params module~~bns_lorene~~UsedByGraph module~bns_lorene bns_lorene module~bns_lorene_import bns_lorene_import module~bns_lorene_import->module~bns_lorene module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~bns_lorene module~bns_lorene_memory bns_lorene_memory module~bns_lorene_memory->module~bns_lorene module~bns_lorene_access bns_lorene_access module~bns_lorene_access->module~bns_lorene module~bns_lorene_params bns_lorene_params module~bns_lorene_params->module~bns_lorene module~bns_lorene_constructor bns_lorene_constructor module~bns_lorene_constructor->module~bns_lorene program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces allocate_lorene_id_memory bnslorene construct_bin_ns construct_binary construct_bnslorene deallocate_lorene_id_memory destruct_bin_ns destruct_binary destruct_bnslorene get_bns_identifier get_eos1_loreneid get_eos2_loreneid get_eos_parameters get_field_array get_field_value get_lorene_id get_lorene_id_hydro get_lorene_id_k get_lorene_id_mass_b get_lorene_id_params get_lorene_id_particles get_lorene_id_spacetime get_lorene_mass_density get_lorene_spatial_metric import_id_full import_id_hydro import_id_int import_id_k import_id_mass_b import_id_params import_id_particles import_id_spacetime import_mass_density import_spatial_metric is_hydro_negative negative_hydro print_id_params Derived Types bnslorene Interfaces interface public module module subroutine allocate_lorene_id_memory(THIS, d) Implementation → Allocates allocatable arrays member of a bnslorene object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays public interface bnslorene Interface of TYPE bnslorene public interface construct_bnslorene () Arguments None interface private function construct_bin_ns(c_resu_file) result(optr) bind(C, NAME= \"construct_bin_ns\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that constructs\n  the \\texttt{LORENE} \\texttt{Bin_NS} object Read more… Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), optional DIMENSION(*) :: c_resu_file C string of the name of the \\texttt{LORENE} binary file storing the spectral\n BNS ID Return Value type(C_PTR) C pointer pointing to the constructed \\texttt{LORENE} \\texttt{Bin_NS} object interface public module module subroutine construct_binary(THIS, resu_file) Implementation → Interface of the subroutine that constructs the \\texttt{LORENE} \\texttt{Bin_NS} object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID interface public module module function construct_bnslorene(resu_file) result(bns_obj) Implementation → Constructs a bnslorene object Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID Return Value type( bnslorene ) Constructed bnslorene object interface public module module subroutine deallocate_lorene_id_memory(THIS) Implementation → Deallocates allocatable arrays member of a bnslorene object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of interface private subroutine destruct_bin_ns(optr) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that destructs\n  the \\texttt{LORENE} \\texttt{Bin_NS} object Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to the \\texttt{LORENE} \\texttt{Bin_NS} object to destruct interface public module module subroutine destruct_binary(THIS) Implementation → Destructs a \\texttt{LORENE} \\texttt{Bin_NS} object Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of interface public module module subroutine destruct_bnslorene(THIS) Implementation → Destruct a bnslorene object Arguments Type Intent Optional Attributes Name type( bnslorene ), intent(inout) :: THIS bnslorene object to be destructed interface public module module function get_bns_identifier(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value double precision interface public module module function get_eos1_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer interface public module module function get_eos2_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer interface public module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Implementation → Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object interface public module module function get_field_array(THIS, field) result(field_array) Implementation → Returns the bnslorene member arrays named field Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Desired bnslorene member array interface public module module function get_field_value(THIS, field, n) result(field_value) Implementation → Returns the component n of the bnslorene member arrays named field Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array integer, intent(in) :: n Component of the desired bnslorene member array Return Value double precision Component n of the desired bnslorene member array interface private subroutine get_lorene_id(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the full\n  \\texttt{LORENE} ID at the specified point.\n  That is, imports the metric fields, the\n  components of the extrinsic curvature [c/km],\n  and the hydro fields. Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z interface private subroutine get_lorene_id_hydro(optr, x, y, z, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  hydro fields from \\texttt{LORENE}, at the\n  specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z interface private subroutine get_lorene_id_k(optr, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  components of the extrinsic\n  curvature [c/km] from \\texttt{LORENE}, at the\n  specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz interface private subroutine get_lorene_id_mass_b(optr, x, y, z, g_diag, baryon_density, gamma_euler) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  hydro fields and the metric fields\n  from \\texttt{LORENE}, at the specified point,\n  needed to compute the baryon mass. Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: g_diag g_{xx}=g_{yy}=g_{zz} at x,y,z real(kind=C_DOUBLE), intent(out) :: baryon_density Baryon mass density at x,y,z real(kind=C_DOUBLE), intent(out) :: gamma_euler Relative Lorentz factor between the 4-velocity of the fluid\n wrt the Eulerian observer and the 4-velocity of the Eulerian observer\n at x,y,z interface private subroutine get_lorene_id_params(optr, angular_vel, distance, distance_com, mass1, mass2, mass_grav1, mass_grav2, adm_mass, angular_momentum, area_radius1, radius1_x_comp, radius1_y, radius1_z, radius1_x_opp, center1_x, barycenter1_x, area_radius2, radius2_x_comp, radius2_y, radius2_z, radius2_x_opp, center2_x, barycenter2_x, ent_center1, nbar_center1, rho_center1, energy_density_center1, specific_energy_center1, pressure_center1, ent_center2, nbar_center2, rho_center2, energy_density_center2, specific_energy_center2, pressure_center2, eos1, eos2, eos1_id, eos2_id, gamma_1, kappa_1, gamma_2, kappa_2, npeos_1, gamma0_1, gamma1_1, gamma2_1, gamma3_1, kappa0_1, kappa1_1, kappa2_1, kappa3_1, logP1_1, logRho0_1, logRho1_1, logRho2_1, npeos_2, gamma0_2, gamma1_2, gamma2_2, gamma3_2, kappa0_2, kappa1_2, kappa2_2, kappa3_2, logP1_2, logRho0_2, logRho1_2, logRho2_2) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that stores\n  the physical parameters of the binary\n  system from \\texttt{LORENE} in the desired variables Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(out) :: angular_vel real(kind=C_DOUBLE), intent(out) :: distance real(kind=C_DOUBLE), intent(out) :: distance_com real(kind=C_DOUBLE), intent(out) :: mass1 real(kind=C_DOUBLE), intent(out) :: mass2 real(kind=C_DOUBLE), intent(out) :: mass_grav1 real(kind=C_DOUBLE), intent(out) :: mass_grav2 real(kind=C_DOUBLE), intent(out) :: adm_mass real(kind=C_DOUBLE), intent(out) :: angular_momentum real(kind=C_DOUBLE), intent(out) :: area_radius1 real(kind=C_DOUBLE), intent(out) :: radius1_x_comp real(kind=C_DOUBLE), intent(out) :: radius1_y real(kind=C_DOUBLE), intent(out) :: radius1_z real(kind=C_DOUBLE), intent(out) :: radius1_x_opp real(kind=C_DOUBLE), intent(out) :: center1_x real(kind=C_DOUBLE), intent(out) :: barycenter1_x real(kind=C_DOUBLE), intent(out) :: area_radius2 real(kind=C_DOUBLE), intent(out) :: radius2_x_comp real(kind=C_DOUBLE), intent(out) :: radius2_y real(kind=C_DOUBLE), intent(out) :: radius2_z real(kind=C_DOUBLE), intent(out) :: radius2_x_opp real(kind=C_DOUBLE), intent(out) :: center2_x real(kind=C_DOUBLE), intent(out) :: barycenter2_x real(kind=C_DOUBLE), intent(out) :: ent_center1 real(kind=C_DOUBLE), intent(out) :: nbar_center1 real(kind=C_DOUBLE), intent(out) :: rho_center1 real(kind=C_DOUBLE), intent(out) :: energy_density_center1 real(kind=C_DOUBLE), intent(out) :: specific_energy_center1 real(kind=C_DOUBLE), intent(out) :: pressure_center1 real(kind=C_DOUBLE), intent(out) :: ent_center2 real(kind=C_DOUBLE), intent(out) :: nbar_center2 real(kind=C_DOUBLE), intent(out) :: rho_center2 real(kind=C_DOUBLE), intent(out) :: energy_density_center2 real(kind=C_DOUBLE), intent(out) :: specific_energy_center2 real(kind=C_DOUBLE), intent(out) :: pressure_center2 character(kind=C_CHAR), intent(out), DIMENSION(100) :: eos1 character(kind=C_CHAR), intent(out), DIMENSION(100) :: eos2 integer(kind=C_INT) :: eos1_id integer(kind=C_INT) :: eos2_id real(kind=C_DOUBLE), intent(out) :: gamma_1 real(kind=C_DOUBLE), intent(out) :: kappa_1 real(kind=C_DOUBLE), intent(out) :: gamma_2 real(kind=C_DOUBLE), intent(out) :: kappa_2 integer(kind=C_INT) :: npeos_1 real(kind=C_DOUBLE), intent(out) :: gamma0_1 real(kind=C_DOUBLE), intent(out) :: gamma1_1 real(kind=C_DOUBLE), intent(out) :: gamma2_1 real(kind=C_DOUBLE), intent(out) :: gamma3_1 real(kind=C_DOUBLE), intent(out) :: kappa0_1 real(kind=C_DOUBLE), intent(out) :: kappa1_1 real(kind=C_DOUBLE), intent(out) :: kappa2_1 real(kind=C_DOUBLE), intent(out) :: kappa3_1 real(kind=C_DOUBLE), intent(out) :: logP1_1 real(kind=C_DOUBLE), intent(out) :: logRho0_1 real(kind=C_DOUBLE), intent(out) :: logRho1_1 real(kind=C_DOUBLE), intent(out) :: logRho2_1 integer(kind=C_INT) :: npeos_2 real(kind=C_DOUBLE), intent(out) :: gamma0_2 real(kind=C_DOUBLE), intent(out) :: gamma1_2 real(kind=C_DOUBLE), intent(out) :: gamma2_2 real(kind=C_DOUBLE), intent(out) :: gamma3_2 real(kind=C_DOUBLE), intent(out) :: kappa0_2 real(kind=C_DOUBLE), intent(out) :: kappa1_2 real(kind=C_DOUBLE), intent(out) :: kappa2_2 real(kind=C_DOUBLE), intent(out) :: kappa3_2 real(kind=C_DOUBLE), intent(out) :: logP1_2 real(kind=C_DOUBLE), intent(out) :: logRho0_2 real(kind=C_DOUBLE), intent(out) :: logRho1_2 real(kind=C_DOUBLE), intent(out) :: logRho2_2 interface private subroutine get_lorene_id_particles(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  hydro fields and the metric fields *\n  from \\texttt{LORENE}, at the specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z interface private subroutine get_lorene_id_spacetime(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that reads the\n  metric fields and the components\n  of the extrinsic curvature [c/km] from \\texttt{LORENE},\n  at the specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz interface private function get_lorene_mass_density(optr, x, y, z) result(res) bind(C, NAME= \"get_mass_density\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that returns\n  the baryon mass density [\\mathrm{kg}\\,\n  \\mathrm{m}&#94;{-3}] from \\texttt{LORENE},\n  at the specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Baryon mass density [\\mathrm{kg}\\, \\mathrm{m}&#94;{-3}] at the desired\n point (x,y,z) interface private function get_lorene_spatial_metric(optr, x, y, z) result(res) bind(C, NAME= \"get_lorene_id_g\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that returns the\n  diagonal components of the metric,\n  all equal to the \\texttt{LORENE} conformal factor to\n  the 4th power. Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Spatial metric component g_{xx}=g_{yy}=g_{zz} at the point (x,y,z) interface public module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the ID in non bnslorene -member arrays with the same shape as the bnslorene member arrays Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z interface public module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Implementation → Stores the hydro ID in the arrays needed to compute the constraints\n on the refined mesh Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler interface public module module subroutine import_id_int(THIS, n, x, y, z) Implementation → Stores the ID in the bnslorene member arrays Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z interface public module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Implementation → Stores the components of the extrinsic curvature in arrays Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz interface public module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Implementation → Stores the hydro ID in the arrays needed to compute the baryon mass Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler interface public module module subroutine import_id_params(THIS) Implementation → Imports the BNS parameters from \\texttt{LORENE} Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of interface public module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the hydro ID in the arrays needed to compute the SPH ID Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z interface public module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Implementation → Stores the spacetime ID in multi-dimensional arrays needed to compute\n the BSSN variables and constraints Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek interface public module module function import_mass_density(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} baryon mass density at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) interface public module module function import_spatial_metric(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} conformally flat spatial metric component g_{xx}=g_{yy}=g_{zz} at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) interface public module module function is_hydro_negative(THIS, x, y, z) result(res) Implementation → Returns 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise interface private function negative_hydro(optr, x, y, z) result(res) bind(C, NAME= \"negative_hydro\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Bin_NS} with the same name, that returns 1\n  if the energy density is nonpositive,\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive,\n  at the specified point; it returns 0 otherwise Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Bin_NS} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value integer(kind=C_INT) 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise interface public module module subroutine print_id_params(THIS) Implementation → Prints the BNS parameters to the standard output Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of Derived Types type, public, extends( bnsbase ) :: bnslorene TYPE representing a binary system of neutron stars (bns) Components Type Visibility Attributes Name Initial double precision, public :: adm_mass ADM mass of the BNS [M_\\odot] double precision, public :: angular_momentum = 0.0D0 Angular momentum of the BNS system [G M_\\odot&#94;2/c] double precision, public :: angular_vel Angular velocity [{\\rm rad/s}] double precision, public :: area_radius1 Areal (or circumferential) radius of star 1 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public :: area_radius2 Areal (or circumferential) radius of star 2 [L_\\odot] Note that these is the areal radius of the star in the binary system,\nwhich is different than that of an isolated star. The latter is used\nin the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(2,3) :: barycenter Array containing the barycenters of the stars Read more… double precision, public :: barycenter1_x Barycenter of star 1 [L_\\odot] double precision, public :: barycenter2_x Barycenter of star 2 [L_\\odot] double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] integer, private :: bns_identifier = 0 Identifier of the bnslorene object type(C_PTR), private :: bns_ptr C pointer to the \\texttt{LORENE}'s \\texttt{Bin_NS} object\nN.B. This variable is global. The pointer to the second \\texttt{LORENE} \\texttt{Bin_NS}\n     object will overwrite the first one, and so on.\n     This variable stores the pointer to the last defined \\texttt{LORENE} \\texttt{Bin_NS}\n     object. That's why it is not freed in the destructor of a bns object.\n     Presently, it has to be freed by the user at the end of the PROGRAM.\n     See the last part of the PROGRAM in setup_lorene_id.f90, for example. double precision, public, DIMENSION(2,3) :: center Array containing the centers of the stars Read more… double precision, public :: center1_x Stellar center of star 1 (origin of the LORENE chart centered on star 1) [L_\\odot] double precision, public :: center2_x Stellar center of star 2 (origin of the LORENE chart centered on star 2) [L_\\odot] type(timer), public :: construction_timer Timer that times the construction of the appropriate object double precision, public :: distance Distance d between the points of maximum baryon density [{\\rm km}] double precision, public :: distance_com Distance between the centers of mass [L_\\odot(=1.47662503825040{\\rm km})] double precision, private, DIMENSION(:), ALLOCATABLE :: energy_density 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] double precision, public :: energy_density_center1 Central energy density for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: energy_density_center2 Central energy density for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center1 Central enthalpy for star 1 [c&#94;2] double precision, public :: ent_center2 Central enthalpy for star 2 [c&#94;2] character(len=:), public, ALLOCATABLE :: eos1 Name of the equation of state (EoS) of star 1 integer, private :: eos1_loreneid \\texttt{LORENE} identifiers for the EoS character(len=:), public, ALLOCATABLE :: eos2 Name of the equation of state (EoS) of star 2 integer, private :: eos2_loreneid \\texttt{LORENE} identifiers for the EoS double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx 1-D array storing the xx component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xy 1-D array storing the xy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xz 1-D array storing the xz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yy 1-D array storing the yy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yz 1-D array storing the yz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_zz 1-D array storing the zz component of the spatial metric [pure number] double precision, public :: gamma0_1 Piecewise polytrope: polytropic index \\gamma_0 for star 1 double precision, public :: gamma0_2 Piecewise polytrope: polytropic index \\gamma_0 for star 2 double precision, public :: gamma1_1 Piecewise polytrope: polytropic index \\gamma_1 for star 1 double precision, public :: gamma1_2 Piecewise polytrope: polytropic index \\gamma_1 for star 2 double precision, public :: gamma2_1 Piecewise polytrope: polytropic index \\gamma_2 for star 1 double precision, public :: gamma2_2 Piecewise polytrope: polytropic index \\gamma_2 for star 2 double precision, public :: gamma3_1 Piecewise polytrope: polytropic index \\gamma_3 for star 1 double precision, public :: gamma3_2 Piecewise polytrope: polytropic index \\gamma_3 for star 2 double precision, public :: gamma_1 Single polytrope: polytropic index for star 1 double precision, public :: gamma_2 Single polytrope: polytropic index for star 2 double precision, private, DIMENSION(:), ALLOCATABLE :: k_xx 1-D array storing the xx component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xy 1-D array storing the xy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xz 1-D array storing the xz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yy 1-D array storing the yy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yz 1-D array storing the yz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_zz 1-D array storing the zz component of the extrinsic curvature\n [c/MSun_geo] double precision, public :: kappa0_1 Piecewise polytrope: polytropic constant \\kappa_0 for star 1\n [pure number] double precision, public :: kappa0_2 Piecewise polytrope: polytropic constant \\kappa_0 for star 2\n [pure number] double precision, public :: kappa1_1 Piecewise polytrope: polytropic constant \\kappa_1 for star 1\n [pure number] double precision, public :: kappa1_2 Piecewise polytrope: polytropic constant \\kappa_1 for star 2\n [pure number] double precision, public :: kappa2_1 Piecewise polytrope: polytropic constant \\kappa_2 for star 1\n [pure number] double precision, public :: kappa2_2 Piecewise polytrope: polytropic constant \\kappa_2 for star 2\n [pure number] double precision, public :: kappa3_1 Piecewise polytrope: polytropic constant \\kappa_3 for star 1\n [pure number] double precision, public :: kappa3_2 Piecewise polytrope: polytropic constant \\kappa_3 for star 2\n [pure number] double precision, public :: kappa_1 Single polytrope: polytropic constant for star 1 [pure number] double precision, public :: kappa_2 Single polytrope: polytropic constant for star 2 [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: lapse 1-D array storing the lapse function double precision, public :: logP1_1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 1 double precision, public :: logP1_2 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] for star 2 double precision, public :: logRho0_1 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho0_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho1_1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho1_2 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: logRho2_1 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 1 double precision, public :: logRho2_2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] for star 2 double precision, public :: mOmega mOmega= ( angular_vel [{\\rm km&#94;{-1}}] ) \\times ( mass_grav1 [{\\rm km}] + mass_grav2 [{\\rm km}] ) [pure number] Read more… double precision, public, DIMENSION(2) :: mass Array containing the baryonic masses [M_\\odot] double precision, public :: mass1 Baryonic mass of star 1 [M_\\odot] double precision, public :: mass2 Baryonic mass of star 2 [M_\\odot] double precision, public, DIMENSION(2) :: mass_grav Array containing the gravitatil masses [M_\\odot] double precision, public :: mass_grav1 Gravitational mass of star 1 [M_\\odot] double precision, public :: mass_grav2 Gravitational mass of star 2 [M_\\odot] double precision, public :: nbar_center1 Central baryon number density for star 1 [L_\\odot&#94;{-3}] double precision, public :: nbar_center2 Central baryon number density for star 2 [L_\\odot&#94;{-3}] integer, public :: npeos_1 Piecewise polytrope: Number of polytropic pieces for star 1 integer, public :: npeos_2 Piecewise polytrope: Number of polytropic pieces for star 2 double precision, public :: pressure_center1 Central pressure for star 1 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: pressure_center2 Central pressure for star 2 [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public, DIMENSION(2,6) :: radii Array containing the signed radii of the stars Read more… double precision, public :: radius1_x_comp Radius of star 1, in the x direction, towards the companion [L_\\odot] double precision, public :: radius1_x_opp Radius of star 1, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius1_y Radius of star 1, in the y direction [L_\\odot] double precision, public :: radius1_z Radius of star 1, in the z direction [L_\\odot] double precision, public :: radius2_x_comp Radius of star 2, in the x direction, towards the companion [L_\\odot] double precision, public :: radius2_x_opp Radius of star 2, in the x direction, opposite to companion [L_\\odot] double precision, public :: radius2_y Radius of star 2, in the y direction [L_\\odot] double precision, public :: radius2_z Radius of star 2, in the z direction [L_\\odot] double precision, public :: rho_center1 Central baryon mass density for star 1 [M_\\odot L_\\odot&#94;{-3}] double precision, public :: rho_center2 Central baryon mass density for star 2 [M_\\odot L_\\odot&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_x 1-D array storing the x component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_y 1-D array storing the y component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_z 1-D array storing the z component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: specific_energy 1-D array storing the specific internal energy [c&#94;2] double precision, public :: specific_energy_center1 Central specific energy for star 1 [c&#94;2] double precision, public :: specific_energy_center2 Central specific energy for star 2 [c&#94;2] double precision, public :: t_merger Estimated time of the merger [M_\\odot] t_\\mathrm{merger}=\\dfrac{5}{256}\n \\dfrac{d&#94;4}{M&#94;1_\\mathrm{g}M&#94;2_\\mathrm{g}(M&#94;1_\\mathrm{g}+M&#94;2_\\mathrm{g})} P. C. Peters, \"Gravitational Radiation and the Motion of Two Point\n Masses\", Phys. Rev. 136, B1224 (1964) double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_x 1-D array storing the x component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_y 1-D array storing the y component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_z 1-D array storing the z component of the fluid 3-velocity with respect to Constructor Interface of TYPE bnslorene public  interface construct_bnslorene () Finalizations Procedures final :: destruct_bnslorene Finalizer (Destructor) of a [[bnslorene]] object Type-Bound Procedures procedure, public :: allocate_lorene_id_memory Allocates memory for the bnslorene member arrays procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. procedure, public :: construct_binary Constructs the \\texttt{LORENE} \\texttt{Bin_NS} object procedure, public :: deallocate_lorene_id_memory Deallocates memory for the bnslorene member arrays procedure, public :: destruct_binary Destructs the \\texttt{LORENE} \\texttt{Bin_NS} object procedure, public :: get_adm_mass Returns adm_mass procedure, public :: get_angular_momentum Returns angular_momentum procedure, public :: get_angular_vel Returns angular_vel procedure, public :: get_barycenter1_x Returns barycenter1_x procedure, public :: get_barycenter2_x Returns barycenter2_x procedure, public :: get_bns_identifier Returns bns_identifier procedure, public :: get_center1_x Returns center1_x procedure, public :: get_center2_x Returns center2_x procedure, public :: get_distance Returns distance procedure, public :: get_distance_com Returns distance_com procedure, public :: get_energy_density_center1 Returns energy_density_center1 procedure, public :: get_energy_density_center2 Returns energy_density_center2 procedure, public :: get_ent_center1 Returns ent_center1 procedure, public :: get_ent_center2 Returns ent_center2 procedure, public :: get_eos1 Returns eos1 procedure, public :: get_eos1_id => get_eos1_loreneid Returns the \\texttt{LORENE} identifier for the EOS of star 1 procedure, public :: get_eos1_loreneid Returns eos1_loreneid procedure, public :: get_eos2 Returns eos2 procedure, public :: get_eos2_id => get_eos2_loreneid Returns the \\texttt{LORENE} identifier for the EOS of star 2 procedure, public :: get_eos2_loreneid Returns eos2_loreneid procedure, public :: get_fa => get_field_array Access the bnslorene -member arrays generic, public :: get_field => get_fa, get_fv GENERIC PROCEDURE, overloded to access the bnslorene -member variables\n as arrays and as values procedure, public :: get_fv => get_field_value Access the components of the bnslorene -member arrays procedure, public :: get_gamma0_1 Returns gamma0_1 procedure, public :: get_gamma0_2 Returns gamma0_2 procedure, public :: get_gamma1_1 Returns gamma1_1 procedure, public :: get_gamma1_2 Returns gamma1_2 procedure, public :: get_gamma2_1 Returns gamma2_1 procedure, public :: get_gamma2_2 Returns gamma2_2 procedure, public :: get_gamma3_1 Returns gamma3_1 procedure, public :: get_gamma3_2 Returns gamma3_2 procedure, public :: get_gamma_1 Returns gamma_1 procedure, public :: get_gamma_2 Returns gamma_2 procedure, public :: get_grav_mass1 Returns mass_grav1 procedure, public :: get_grav_mass2 Returns mass_grav2 procedure, public :: get_kappa0_1 Returns kappa0_1 procedure, public :: get_kappa0_2 Returns kappa0_2 procedure, public :: get_kappa1_1 Returns kappa1_1 procedure, public :: get_kappa1_2 Returns kappa1_2 procedure, public :: get_kappa2_1 Returns kappa2_1 procedure, public :: get_kappa2_2 Returns kappa2_2 procedure, public :: get_kappa3_1 Returns kappa3_1 procedure, public :: get_kappa3_2 Returns kappa3_2 procedure, public :: get_kappa_1 Returns kappa_1 procedure, public :: get_kappa_2 Returns kappa_2 procedure, public :: get_logP1_1 Returns logP1_1 procedure, public :: get_logP1_2 Returns logP1_2 procedure, public :: get_logRho0_1 Returns logRho0_1 procedure, public :: get_logRho0_2 Returns logRho0_2 procedure, public :: get_logRho1_1 Returns logRho1_1 procedure, public :: get_logRho1_2 Returns logRho1_2 procedure, public :: get_logRho2_1 Returns logRho2_1 procedure, public :: get_logRho2_2 Returns logRho2_2 procedure, public :: get_mass1 Returns mass1 procedure, public :: get_mass2 Returns mass2 procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system procedure, public :: get_nbar_center1 Returns nbar_center1 procedure, public :: get_nbar_center2 Returns nbar_center2 procedure, public :: get_npeos_1 Returns npeos_1 procedure, public :: get_npeos_2 Returns npeos_2 procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public :: get_pressure_center1 Returns pressure_center1 procedure, public :: get_pressure_center2 Returns pressure_center2 procedure, public :: get_radius1_x_comp Returns radius1_x_comp procedure, public :: get_radius1_x_opp Returns radius1_x_opp procedure, public :: get_radius1_y Returns radius1_y procedure, public :: get_radius1_z Returns radius1_z procedure, public :: get_radius2_x_comp Returns radius2_x_comp procedure, public :: get_radius2_x_opp Returns radius2_x_opp procedure, public :: get_radius2_y Returns radius2_y procedure, public :: get_radius2_z Returns radius2_y procedure, public :: get_rho_center1 Returns rho_center1 procedure, public :: get_rho_center2 Returns rho_center2 procedure, public :: get_specific_energy_center1 Returns specific_energy_center1 procedure, public :: get_specific_energy_center2 Returns specific_energy_center2 procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure, public :: import_id_int Stores the ID in the bnslorene member arrays procedure, public :: import_id_params Imports the parameters of the BNS from \\texttt{LORENE} Read more… procedure, public :: import_spatial_metric Returns the \\texttt{LORENE}'s conformally flat spatial ADM metric procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star procedure, public :: print_id_params Prints the parameters of the BNS to the standard output procedure, public :: read_id_full => import_id_full procedure, public :: read_id_hydro => import_id_hydro procedure, public :: read_id_k => import_id_k procedure, public :: read_id_mass_b => import_id_mass_b procedure, public :: read_id_particles => import_id_particles procedure, public :: read_id_spacetime => import_id_spacetime procedure, public :: read_mass_density => import_mass_density Returns the \\texttt{LORENE}'s mass density at the given point procedure, public :: return_barycenter => get_barycenter procedure, public :: return_center => get_center procedure, public :: return_eos_name => get_eos procedure, public :: return_eos_parameters => get_eos_parameters procedure, public :: return_mass => get_mass procedure, public :: return_spatial_extent => get_radii procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure, public :: test_position => is_hydro_negative Returns 1 if the energy density or the specific energy or the pressure\n are negative","tags":"","loc":"module/bns_lorene.html"},{"title":"diffstar_base – SPHINCS_LORENE","text":"This MODULE contains the definition of TYPE diffstarbase,\n  which is an ABSTRACT TYPE representing any possible\n  type of initial data (ID) for a differentially rotating\n  star (DRS) to be set up for \\texttt{SPHINCS_BSSN}. That is, DRS ID\n  produced with \\texttt{LORENE}, with \\texttt{FUKA}, etc. PROCEDURES and variables shared by all the types\n  of DRS ID should belong to TYPE diffstarbase, as\n  they are inherited by its EXTENDED TYPES that\n  represent more specific typesof DRS ID. FT 22.10.2021 Uses id_base utility module~~diffstar_base~~UsesGraph module~diffstar_base diffstar_base module~id_base id_base module~diffstar_base->module~id_base module~utility utility module~diffstar_base->module~utility timing timing module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: diffstar_base_access module~~diffstar_base~~UsedByGraph module~diffstar_base diffstar_base module~diffstar_lorene diffstar_lorene module~diffstar_lorene->module~diffstar_base module~diffstar_base_access diffstar_base_access module~diffstar_base_access->module~diffstar_base module~diffstar_lorene_memory diffstar_lorene_memory module~diffstar_lorene_memory->module~diffstar_lorene module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~diffstar_lorene module~diffstar_lorene_access diffstar_lorene_access module~diffstar_lorene_access->module~diffstar_lorene module~diffstar_lorene_constructor diffstar_lorene_constructor module~diffstar_lorene_constructor->module~diffstar_lorene module~diffstar_lorene_import diffstar_lorene_import module~diffstar_lorene_import->module~diffstar_lorene module~diffstar_lorene_params diffstar_lorene_params module~diffstar_lorene_params->module~diffstar_lorene program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces get_angular_momentum get_area_radius get_barycenter get_center get_energy_density_center get_ent_center get_eos get_f_isco get_gamma get_gamma0 get_gamma1 get_gamma2 get_gamma3 get_grv2 get_grv3 get_kappa get_kappa0 get_kappa1 get_kappa2 get_kappa3 get_logP1 get_logRho0 get_logRho1 get_logRho2 get_mass get_mass_grav get_nbar_center get_npeos get_omega_c get_pressure_center get_r_circ get_r_eq get_r_eq_3pi2 get_r_eq_pi get_r_eq_pi2 get_r_isco get_r_mean get_r_pole get_r_ratio get_radii get_rho_center get_specific_angular_momentum_isco get_specific_energy_center get_specific_energy_isco get_surface_area get_tsw Abstract Interfaces get_eos_id_int Derived Types diffstarbase Interfaces interface public module module function get_angular_momentum(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_area_radius(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_barycenter(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) interface public module module function get_center(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) interface public module module function get_energy_density_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_ent_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_eos(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE interface public module module function get_f_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_gamma3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_grv2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_grv3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_kappa3(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logP1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho0(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho1(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_logRho2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_mass(THIS, i_matter) Implementation → Returns mass Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision interface public module module function get_mass_grav(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_nbar_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_npeos(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer interface public module module function get_omega_c(THIS) Implementation → Returns omega_c Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_pressure_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_circ(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_eq(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_eq_3pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_eq_pi(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_eq_pi2(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_mean(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_pole(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_r_ratio(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_radii(THIS, i_matter) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) interface public module module function get_rho_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_specific_angular_momentum_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_specific_energy_center(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_specific_energy_isco(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_surface_area(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision interface public module module function get_tsw(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision Abstract Interfaces abstract interface public function get_eos_id_int(THIS) Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer Derived Types type, public, ABSTRACT, extends( idbase ) :: diffstarbase Base TYPE for DRS ID for \\texttt{SPHINCS_BSSN} (produced with \\texttt{LORENE}, or with\n \\texttt{FUKA}, etc.; or produced with the same tool, but read in different ways,\n for example by linking to the \\texttt{LORENE} library, or reading the ID from\n a lattice, etc.) Components Type Visibility Attributes Name Initial double precision, public :: angular_momentum = 0.0D0 Angular momentum of the DRS [G M_\\odot&#94;2/c] double precision, public :: area_radius Areal (or circumferential) radius of DRS [Msun_geo]\n Note that these is the areal radius of the star in the binary system,\n which is different than that of an isolated star. The latter is used\n in the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(3) :: barycenter Array containing the barycenters of the stars Read more… double precision, public, DIMENSION(3) :: center Array containing the centers of the stars Read more… type(timer), public :: construction_timer Timer that times the construction of the appropriate object double precision, public :: energy_density_center Central energy density [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center Central enthalpy [c&#94;2] character(len=:), public, ALLOCATABLE :: eos Name of the equation of state (EoS) of star 1 double precision, public :: f_isco Orbital frequency of the Innermost Stable Circular Orbit (ISCO) double precision, public :: gamma Single polytrope: polytropic index double precision, public :: gamma0 Piecewise polytrope: polytropic index \\gamma_0 double precision, public :: gamma1 Piecewise polytrope: polytropic index \\gamma_1 double precision, public :: gamma2 Piecewise polytrope: polytropic index \\gamma_2 double precision, public :: gamma3 Piecewise polytrope: polytropic index \\gamma_3 double precision, public :: grv2 Error on the virial identity {\\rm GRV2} . Read more… double precision, public :: grv3 Error on the virial identity {\\rm GRV3} . Read more… double precision, public :: kappa Single polytrope: polytropic constant [pure number] double precision, public :: kappa0 Piecewise polytrope: polytropic constant \\kappa_0 [pure number] double precision, public :: kappa1 Piecewise polytrope: polytropic constant \\kappa_1 [pure number] double precision, public :: kappa2 Piecewise polytrope: polytropic constant \\kappa_2 [pure number] double precision, public :: kappa3 Piecewise polytrope: polytropic constant \\kappa_3 [pure number] double precision, public :: logP1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] double precision, public :: logRho0 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] double precision, public :: mass Baryonic mass of DRS [M_\\odot] double precision, public :: mass_grav Gravitational mass of DRS [M_\\odot] double precision, public :: nbar_center Central baryon number density [L_\\odot&#94;{-3}] integer, public :: npeos Piecewise polytrope: Number of polytropic pieces double precision, public :: omega_c Central angular velocity [{\\rm rad/s}] double precision, public :: pressure_center Central pressure [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: r_circ Circumferential radius double precision, public :: r_eq Equatorial radius at \\phi=0 double precision, public :: r_eq_3pi2 Equatorial radius at \\phi=\\dfrac{3\\pi}{2} double precision, public :: r_eq_pi Equatorial radius at \\phi=\\pi double precision, public :: r_eq_pi2 Equatorial radius at \\phi=\\dfrac{\\pi}{2} double precision, public :: r_isco Radius of the Innermost Stable Circular Orbit (ISCO) double precision, public :: r_mean Mean radius double precision, public :: r_pole Polar radius double precision, public :: r_ratio Ratio r_pole / r_eq double precision, public, DIMENSION(6) :: radii double precision, public :: redshift_eqb Backward redshift factor at equator double precision, public :: redshift_eqf Forward redshift factor at equator double precision, public :: redshift_pole Redshift factor at North pole double precision, public :: rho_center Central baryon mass density [M_\\odot L_\\odot&#94;{-3}] double precision, public :: specific_angular_momentum_isco Specific angular momentum of a test particle at the Innermost Stable\n Circular Orbit (ISCO) double precision, public :: specific_energy_center Central specific energy [c&#94;2] double precision, public :: specific_energy_isco Specific energy of a test particle at the Innermost Stable Circular\n Orbit (ISCO) double precision, public :: surface_area Surface area double precision, public :: tsw Ratio between the kinetic and gravitatial potential energy T/W . Read more… Type-Bound Procedures procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. procedure, public :: get_angular_momentum Returns angular_momentum procedure, public :: get_area_radius Returns area_radius procedure, public :: get_energy_density_center Returns energy_density_center procedure, public :: get_ent_center Returns ent_center procedure(get_eos_id_int), public :: get_eos_id Returns an integer that identifies the equation of state Read more… procedure, public :: get_f_isco Returns f_isco procedure, public :: get_gamma Returns gamma procedure, public :: get_gamma0 Returns gamma0 procedure, public :: get_gamma1 Returns gamma1 procedure, public :: get_gamma2 Returns gamma2 procedure, public :: get_gamma3 Returns gamma3 procedure, public :: get_grv2 Returns grv2 procedure, public :: get_grv3 Returns grv3 procedure, public :: get_kappa Returns kappa procedure, public :: get_kappa0 Returns kappa0 procedure, public :: get_kappa1 Returns kappa1 procedure, public :: get_kappa2 Returns kappa2 procedure, public :: get_kappa3 Returns kappa3 procedure, public :: get_logP1 Returns logP1 procedure, public :: get_logRho0 Returns logRho0 procedure, public :: get_logRho1 Returns logRho1 procedure, public :: get_logRho2 Returns logRho2 procedure, public :: get_mass_grav Returns mass_grav procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system procedure, public :: get_nbar_center Returns nbar_center procedure, public :: get_npeos Returns npeos procedure, public :: get_omega_c Returns omega_c Read more… procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public :: get_pressure_center Returns pressure_center Read more… procedure, public :: get_r_circ Returns r_circ procedure, public :: get_r_eq Returns r_eq procedure, public :: get_r_eq_3pi2 Returns r_eq_3pi2 procedure, public :: get_r_eq_pi Returns r_eq_pi procedure, public :: get_r_eq_pi2 Returns r_eq_pi2 procedure, public :: get_r_isco Returns r_isco procedure, public :: get_r_mean Returns r_mean procedure, public :: get_r_pole Returns r_pole procedure, public :: get_r_ratio Returns r_ratio procedure, public :: get_rho_center Returns rho_center procedure, public :: get_specific_angular_momentum_isco Returns specific_angular_momentum_isco procedure, public :: get_specific_energy_center Returns specific_energy_center procedure, public :: get_specific_energy_isco Returns specific_energy_isco procedure, public :: get_surface_area Returns surface_area procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} procedure, public :: get_tsw Returns tsw procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star procedure(read_id_full_int), public :: read_id_full Reads the full ID procedure(read_id_hydro_int), public :: read_id_hydro Reads the hydro ID needed to compute the constraints on the refined mesh procedure(read_id_k_int), public :: read_id_k Reads the components of the extrinsic curvature procedure(read_id_mass_b_int), public :: read_id_mass_b Reads the hydro ID needed to compute the baryon mass procedure(read_id_particles_int), public :: read_id_particles Reads the hydro ID needed to compute the SPH ID procedure(read_id_spacetime_int), public :: read_id_spacetime Reads the spacetime ID needed to compute\n the BSSN variables and constraints procedure(read_double_at_pos), public :: read_mass_density Returns the baryon mass density at the given point procedure, public :: return_barycenter => get_barycenter procedure, public :: return_center => get_center procedure, public :: return_eos_name => get_eos procedure(return_eos_parameters_int), public :: return_eos_parameters Returns the identification number of the EoS of the matter objects. Read more… procedure, public :: return_mass => get_mass procedure, public :: return_spatial_extent => get_radii procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure(read_integer_at_pos), public :: test_position Returns 1 if the position has physically acceptable properties,\n 0 otherwise","tags":"","loc":"module/diffstar_base.html"},{"title":"diffstar_lorene – SPHINCS_LORENE","text":"This module contains the definition of TYPE diffstarlorene,\n   and the SUBROUTINES that bind to the methods\n   of \\texttt{LORENE}'s class \\texttt{Et_rot_diff}, defined in\n   Lorene/Export/C++/Source/Etoile \\texttt{LORENE} official repository Uses diffstar_base timing iso_c_binding utility module~~diffstar_lorene~~UsesGraph module~diffstar_lorene diffstar_lorene module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base timing timing module~diffstar_lorene->timing module~utility utility module~diffstar_lorene->module~utility iso_c_binding iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base->module~utility module~id_base id_base module~diffstar_base->module~id_base matrix matrix module~utility->matrix module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by Descendants: diffstar_lorene_access diffstar_lorene_constructor diffstar_lorene_import diffstar_lorene_memory diffstar_lorene_params module~~diffstar_lorene~~UsedByGraph module~diffstar_lorene diffstar_lorene module~diffstar_lorene_memory diffstar_lorene_memory module~diffstar_lorene_memory->module~diffstar_lorene module~sphincs_lorene sphincs_lorene module~sphincs_lorene->module~diffstar_lorene module~diffstar_lorene_access diffstar_lorene_access module~diffstar_lorene_access->module~diffstar_lorene module~diffstar_lorene_constructor diffstar_lorene_constructor module~diffstar_lorene_constructor->module~diffstar_lorene module~diffstar_lorene_import diffstar_lorene_import module~diffstar_lorene_import->module~diffstar_lorene module~diffstar_lorene_params diffstar_lorene_params module~diffstar_lorene_params->module~diffstar_lorene program~convergence_test convergence_test program~convergence_test->module~sphincs_lorene program~sphincs_lorene_bns sphincs_lorene_bns program~sphincs_lorene_bns->module~sphincs_lorene Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces allocate_diffstar_memory construct_diffstarlorene construct_drs construct_etdiffrot deallocate_diffstar_memory destruct_diffstarlorene destruct_drs destruct_etdiffrot diffstarlorene get_diffstar_full get_diffstar_hydro get_diffstar_identifier get_diffstar_mass_b get_diffstar_mass_density get_diffstar_params get_diffstar_particles get_diffstar_spacetime get_diffstar_spatial_metric get_eos_loreneid get_eos_parameters get_field_array get_field_value import_diffstar_params import_id_full import_id_hydro import_id_int import_id_k import_id_mass_b import_id_particles import_id_spacetime import_mass_density import_spatial_metric is_hydro_negative negative_hydro print_diffstar_params Derived Types diffstarlorene Interfaces interface public module module subroutine allocate_diffstar_memory(THIS, d) Implementation → Allocates allocatable arrays member of a diffstarlorene object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays interface public module module function construct_diffstarlorene(resu_file) result(drs) Implementation → Constructs a diffstarlorene object Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID Return Value type( diffstarlorene ) Constructed diffstarlorene object interface public module module subroutine construct_drs(THIS, resu_file) Implementation → Interface of the subroutine that constructs the \\texttt{LORENE} Etdiffrot object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID interface private function construct_etdiffrot(c_resu_file) result(optr) bind(C, NAME= \"construct_et_diffrot\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that constructs\n  the \\texttt{LORENE} \\texttt{Et_diffrot} object Read more… Arguments Type Intent Optional Attributes Name character(kind=C_CHAR), intent(in), optional DIMENSION(*) :: c_resu_file C string of the name of the \\texttt{LORENE} binary file storing the spectral\n DRS ID Return Value type(C_PTR) C pointer pointing to the constructed \\texttt{LORENE} \\texttt{Et_diffrot} object interface public module module subroutine deallocate_diffstar_memory(THIS) Implementation → Deallocates allocatable arrays member of a diffstarlorene object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of interface public module module subroutine destruct_diffstarlorene(THIS) Implementation → Destruct a diffstarlorene object Arguments Type Intent Optional Attributes Name type( diffstarlorene ), intent(inout) :: THIS diffstarlorene object to be destructed interface public module module subroutine destruct_drs(THIS) Implementation → Destructs a \\texttt{LORENE} Etdiffrot object Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of interface private subroutine destruct_etdiffrot(optr) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that destructs\n  the \\texttt{LORENE} \\texttt{Et_diffrot} object Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to the \\texttt{LORENE} \\texttt{Et_diffrot} object to destruct public interface diffstarlorene Interface of TYPE diffstarlorene public interface construct_diffstarlorene () Arguments None interface private subroutine get_diffstar_full(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the full\n  \\texttt{LORENE} ID at the specified point.\n  That is, imports the metric fields, the\n  components of the extrinsic curvature [c/km],\n  and the hydro fields. Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z interface private subroutine get_diffstar_hydro(optr, x, y, z, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  hydro fields from \\texttt{LORENE}, at the\n  specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z interface public module module function get_diffstar_identifier(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value double precision interface private subroutine get_diffstar_mass_b(optr, x, y, z, g_diag, baryon_density, gamma_euler) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  hydro fields and the metric fields\n  from \\texttt{LORENE}, at the specified point,\n  needed to compute the baryon mass. Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: g_diag g_{xx}=g_{yy}=g_{zz} at x,y,z real(kind=C_DOUBLE), intent(out) :: baryon_density Baryon mass density at x,y,z real(kind=C_DOUBLE), intent(out) :: gamma_euler Relative Lorentz factor between the 4-velocity of the fluid\n wrt the Eulerian observer and the 4-velocity of the Eulerian observer\n at x,y,z interface private function get_diffstar_mass_density(optr, x, y, z) result(res) bind(C, NAME= \"get_rotdiff_mass_density\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that returns\n  the baryon mass density [\\mathrm{kg}\\,\n  \\mathrm{m}&#94;{-3}] from \\texttt{LORENE},\n  at the specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Baryon mass density [\\mathrm{kg}\\, \\mathrm{m}&#94;{-3}] at the desired\n point (x,y,z) interface private subroutine get_diffstar_params(optr, omega_c, mass, mass_grav, angular_momentum, tsw, grv2, grv3, r_circ, surface_area, r_mean, r_eq, r_eq_pi2, r_eq_pi, r_eq_3pi2, r_eq_pole, r_ratio, r_isco, f_isco, specific_energy_isco, specific_angular_momentum_isco, area_radius, ent_center, nbar_center, rho_center, energy_density_center, specific_energy_center, pressure_center, redshift_eqf, redshift_eqb, redshift_pole, eos, eos_id, gamma, kappa, npeos, gamma0, gamma1, gamma2, gamma3, kappa0, kappa1, kappa2, kappa3, logP1, logRho0, logRho1, logRho2) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that stores\n  the physical parameters of the binary\n  system from \\texttt{LORENE} in the desired variables Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(out) :: omega_c real(kind=C_DOUBLE), intent(out) :: mass real(kind=C_DOUBLE), intent(out) :: mass_grav real(kind=C_DOUBLE), intent(out) :: angular_momentum real(kind=C_DOUBLE), intent(out) :: tsw real(kind=C_DOUBLE), intent(out) :: grv2 real(kind=C_DOUBLE), intent(out) :: grv3 real(kind=C_DOUBLE), intent(out) :: r_circ real(kind=C_DOUBLE), intent(out) :: surface_area real(kind=C_DOUBLE), intent(out) :: r_mean real(kind=C_DOUBLE), intent(out) :: r_eq real(kind=C_DOUBLE), intent(out) :: r_eq_pi2 real(kind=C_DOUBLE), intent(out) :: r_eq_pi real(kind=C_DOUBLE), intent(out) :: r_eq_3pi2 real(kind=C_DOUBLE), intent(out) :: r_eq_pole real(kind=C_DOUBLE), intent(out) :: r_ratio real(kind=C_DOUBLE), intent(out) :: r_isco real(kind=C_DOUBLE), intent(out) :: f_isco real(kind=C_DOUBLE), intent(out) :: specific_energy_isco real(kind=C_DOUBLE), intent(out) :: specific_angular_momentum_isco real(kind=C_DOUBLE), intent(out) :: area_radius real(kind=C_DOUBLE), intent(out) :: ent_center real(kind=C_DOUBLE), intent(out) :: nbar_center real(kind=C_DOUBLE), intent(out) :: rho_center real(kind=C_DOUBLE), intent(out) :: energy_density_center real(kind=C_DOUBLE), intent(out) :: specific_energy_center real(kind=C_DOUBLE), intent(out) :: pressure_center real(kind=C_DOUBLE), intent(out) :: redshift_eqf real(kind=C_DOUBLE), intent(out) :: redshift_eqb real(kind=C_DOUBLE), intent(out) :: redshift_pole character(kind=C_CHAR), intent(out), DIMENSION(100) :: eos integer(kind=C_INT) :: eos_id real(kind=C_DOUBLE), intent(out) :: gamma real(kind=C_DOUBLE), intent(out) :: kappa integer(kind=C_INT) :: npeos real(kind=C_DOUBLE), intent(out) :: gamma0 real(kind=C_DOUBLE), intent(out) :: gamma1 real(kind=C_DOUBLE), intent(out) :: gamma2 real(kind=C_DOUBLE), intent(out) :: gamma3 real(kind=C_DOUBLE), intent(out) :: kappa0 real(kind=C_DOUBLE), intent(out) :: kappa1 real(kind=C_DOUBLE), intent(out) :: kappa2 real(kind=C_DOUBLE), intent(out) :: kappa3 real(kind=C_DOUBLE), intent(out) :: logP1 real(kind=C_DOUBLE), intent(out) :: logRho0 real(kind=C_DOUBLE), intent(out) :: logRho1 real(kind=C_DOUBLE), intent(out) :: logRho2 interface private subroutine get_diffstar_particles(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, baryon_density, energy_density, specific_energy, pressure, v_euler_x, v_euler_y, v_euler_z) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  hydro fields and the metric fields *\n  from \\texttt{LORENE}, at the specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: baryon_density real(kind=C_DOUBLE), intent(out) :: energy_density real(kind=C_DOUBLE), intent(out) :: specific_energy real(kind=C_DOUBLE), intent(out) :: pressure real(kind=C_DOUBLE), intent(out) :: v_euler_x real(kind=C_DOUBLE), intent(out) :: v_euler_y real(kind=C_DOUBLE), intent(out) :: v_euler_z interface private subroutine get_diffstar_spacetime(optr, x, y, z, lapse, shift_x, shift_y, shift_z, g_diag, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) bind(C, NAME= \"0\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that reads the\n  metric fields and the components\n  of the extrinsic curvature [c/km] from \\texttt{LORENE},\n  at the specified point Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point real(kind=C_DOUBLE), intent(out) :: lapse real(kind=C_DOUBLE), intent(out) :: shift_x real(kind=C_DOUBLE), intent(out) :: shift_y real(kind=C_DOUBLE), intent(out) :: shift_z real(kind=C_DOUBLE), intent(out) :: g_diag real(kind=C_DOUBLE), intent(out) :: k_xx real(kind=C_DOUBLE), intent(out) :: k_xy real(kind=C_DOUBLE), intent(out) :: k_xz real(kind=C_DOUBLE), intent(out) :: k_yy real(kind=C_DOUBLE), intent(out) :: k_yz real(kind=C_DOUBLE), intent(out) :: k_zz interface private function get_diffstar_spatial_metric(optr, x, y, z) result(res) bind(C, NAME= \"get_g_diag\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that returns the\n  diagonal components of the metric,\n  all equal to the \\texttt{LORENE} conformal factor to\n  the 4th power. Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) Spatial metric component g_{xx}=g_{yy}=g_{zz} at the point (x,y,z) interface public module module function get_eos_loreneid(THIS) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value integer interface public module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Implementation → Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the DRS interface public module module function get_field_array(THIS, field) result(field_array) Implementation → Returns the diffstarlorene member arrays named field Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Desired diffstarlorene member array interface public module module function get_field_value(THIS, field, n) result(field_value) Implementation → Returns the component n of the diffstarlorene member arrays named field Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array integer, intent(in) :: n Component of the desired diffstarlorene member array Return Value double precision Component n of the desired diffstarlorene member array interface public module module subroutine import_diffstar_params(THIS) Implementation → Imports the DRS parameters from \\texttt{LORENE} Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of interface public module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the ID in non diffstarlorene -member arrays with the same\n shape as the diffstarlorene member arrays Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z interface public module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Implementation → Stores the hydro ID in the arrays needed to compute the constraints\n on the refined mesh Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler interface public module module subroutine import_id_int(THIS, n, x, y, z) Implementation → Stores the ID in the diffstarlorene member arrays Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z interface public module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Implementation → Stores the components of the extrinsic curvature in arrays Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz interface public module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Implementation → Stores the hydro ID in the arrays needed to compute the baryon mass Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler interface public module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Implementation → Stores the hydro ID in the arrays needed to compute the SPH ID Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z interface public module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Implementation → Stores the spacetime ID in multi-dimensional arrays needed to compute\n the BSSN variables and constraints Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek interface public module module function import_mass_density(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} baryon mass density at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) interface public module module function import_spatial_metric(THIS, x, y, z) result(res) Implementation → Returns the \\texttt{LORENE} conformally flat spatial metric component g_{xx}=g_{yy}=g_{zz} at a point (x,y,z) Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) interface public module module function is_hydro_negative(THIS, x, y, z) result(res) Implementation → Returns 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise interface private function negative_hydro(optr, x, y, z) result(res) bind(C, NAME= \"is_hydro_negative\") Interface to the \\texttt{LORENE} method of class\n  \\texttt{Et_diffrot} with the same name, that returns 1\n  if the energy density is nonpositive,\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive,\n  at the specified point; it returns 0 otherwise Read more… Arguments Type Intent Optional Attributes Name type(C_PTR), intent(in), VALUE :: optr C pointer pointing to a \\texttt{LORENE} \\texttt{Et_diffrot} object real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value integer(kind=C_INT) 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise interface public module module subroutine print_diffstar_params(THIS) Implementation → Prints the DRS parameters to the standard output Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of Derived Types type, public, extends( diffstarbase ) :: diffstarlorene TYPE representing a differentially rotating star (DRS) Components Type Visibility Attributes Name Initial double precision, public :: angular_momentum = 0.0D0 Angular momentum of the DRS [G M_\\odot&#94;2/c] double precision, public :: area_radius Areal (or circumferential) radius of DRS [Msun_geo]\n Note that these is the areal radius of the star in the binary system,\n which is different than that of an isolated star. The latter is used\n in the mass-radius diagrams, together with the gravitatonal mass double precision, public, DIMENSION(3) :: barycenter Array containing the barycenters of the stars Read more… double precision, private, DIMENSION(:), ALLOCATABLE :: baryon_density 1-D array storing the baryon mass density in the fluid frame [kg m&#94;{-3}] double precision, public, DIMENSION(3) :: center Array containing the centers of the stars Read more… type(timer), public :: construction_timer Timer that times the construction of the appropriate object integer, private :: diffstar_identifier = 0 Identifier of the diffstarlorene object type(C_PTR), private :: diffstar_ptr C pointer to the \\texttt{LORENE}'s Etdiffrot object\nN.B. This variable is global. The pointer to the second \\texttt{LORENE} Etdiffrot\n     object will overwrite the first one, and so on.\n     This variable stores the pointer to the last defined \\texttt{LORENE} Etdiffrot\n     object. That's why it is not freed in the destructor of a bns object.\n     Presently, it has to be freed by the user at the end of the PROGRAM.\n     See the last part of the PROGRAM in setup_diffstar.f90, for example. double precision, private, DIMENSION(:), ALLOCATABLE :: energy_density 1-D array storing the energy density [kg c&#94;2 m&#94;{-3}] double precision, public :: energy_density_center Central energy density [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: ent_center Central enthalpy [c&#94;2] character(len=:), public, ALLOCATABLE :: eos Name of the equation of state (EoS) of star 1 integer, private :: eos_loreneid \\texttt{LORENE} identifier for the EoS double precision, public :: f_isco Orbital frequency of the Innermost Stable Circular Orbit (ISCO) double precision, private, DIMENSION(:), ALLOCATABLE :: g_xx 1-D array storing the xx component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xy 1-D array storing the xy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_xz 1-D array storing the xz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yy 1-D array storing the yy component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_yz 1-D array storing the yz component of the spatial metric [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: g_zz 1-D array storing the zz component of the spatial metric [pure number] double precision, public :: gamma Single polytrope: polytropic index double precision, public :: gamma0 Piecewise polytrope: polytropic index \\gamma_0 double precision, public :: gamma1 Piecewise polytrope: polytropic index \\gamma_1 double precision, public :: gamma2 Piecewise polytrope: polytropic index \\gamma_2 double precision, public :: gamma3 Piecewise polytrope: polytropic index \\gamma_3 double precision, public :: grv2 Error on the virial identity {\\rm GRV2} . Read more… double precision, public :: grv3 Error on the virial identity {\\rm GRV3} . Read more… double precision, private, DIMENSION(:), ALLOCATABLE :: k_xx 1-D array storing the xx component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xy 1-D array storing the xy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_xz 1-D array storing the xz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yy 1-D array storing the yy component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_yz 1-D array storing the yz component of the extrinsic curvature\n [c/MSun_geo] double precision, private, DIMENSION(:), ALLOCATABLE :: k_zz 1-D array storing the zz component of the extrinsic curvature\n [c/MSun_geo] double precision, public :: kappa Single polytrope: polytropic constant [pure number] double precision, public :: kappa0 Piecewise polytrope: polytropic constant \\kappa_0 [pure number] double precision, public :: kappa1 Piecewise polytrope: polytropic constant \\kappa_1 [pure number] double precision, public :: kappa2 Piecewise polytrope: polytropic constant \\kappa_2 [pure number] double precision, public :: kappa3 Piecewise polytrope: polytropic constant \\kappa_3 [pure number] double precision, private, DIMENSION(:), ALLOCATABLE :: lapse 1-D array storing the lapse function double precision, public :: logP1 Piecewise polytrope: Base 10 exponent of the pressure at the first\n fiducial density (between \\gamma_0 and \\gamma_1 ) [{\\rm dyne/cm&#94;2}] double precision, public :: logRho0 Piecewise polytrope: Base 10 exponent of the first fiducial density\n (between \\gamma_0 and \\gamma_1 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho1 Piecewise polytrope: Base 10 exponent of the second fiducial density\n (between \\gamma_1 and \\gamma_2 ) [{\\rm g/cm&#94;3}] double precision, public :: logRho2 Piecewise polytrope: Base 10 exponent of the third fiducial density\n (between \\gamma_2 and \\gamma_3 ) [{\\rm g/cm&#94;3}] double precision, public :: mass Baryonic mass of DRS [M_\\odot] double precision, public :: mass_grav Gravitational mass of DRS [M_\\odot] double precision, public :: nbar_center Central baryon number density [L_\\odot&#94;{-3}] integer, public :: npeos Piecewise polytrope: Number of polytropic pieces double precision, public :: omega_c Central angular velocity [{\\rm rad/s}] double precision, public :: pressure_center Central pressure [M_\\odot c&#94;2 L_\\odot&#94;{-3}] double precision, public :: r_circ Circumferential radius double precision, public :: r_eq Equatorial radius at \\phi=0 double precision, public :: r_eq_3pi2 Equatorial radius at \\phi=\\dfrac{3\\pi}{2} double precision, public :: r_eq_pi Equatorial radius at \\phi=\\pi double precision, public :: r_eq_pi2 Equatorial radius at \\phi=\\dfrac{\\pi}{2} double precision, public :: r_isco Radius of the Innermost Stable Circular Orbit (ISCO) double precision, public :: r_mean Mean radius double precision, public :: r_pole Polar radius double precision, public :: r_ratio Ratio r_pole / r_eq double precision, public, DIMENSION(6) :: radii double precision, public :: redshift_eqb Backward redshift factor at equator double precision, public :: redshift_eqf Forward redshift factor at equator double precision, public :: redshift_pole Redshift factor at North pole double precision, public :: rho_center Central baryon mass density [M_\\odot L_\\odot&#94;{-3}] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_x 1-D array storing the x component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_y 1-D array storing the y component of the shift vector [c] double precision, private, DIMENSION(:), ALLOCATABLE :: shift_z 1-D array storing the z component of the shift vector [c] double precision, public :: specific_angular_momentum_isco Specific angular momentum of a test particle at the Innermost Stable\n Circular Orbit (ISCO) double precision, private, DIMENSION(:), ALLOCATABLE :: specific_energy 1-D array storing the specific internal energy [c&#94;2] double precision, public :: specific_energy_center Central specific energy [c&#94;2] double precision, public :: specific_energy_isco Specific energy of a test particle at the Innermost Stable Circular\n Orbit (ISCO) double precision, public :: surface_area Surface area double precision, public :: tsw Ratio between the kinetic and gravitatial potential energy T/W . Read more… double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_x 1-D array storing the x component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_y 1-D array storing the y component of the fluid 3-velocity with respect to double precision, private, DIMENSION(:), ALLOCATABLE :: v_euler_z 1-D array storing the z component of the fluid 3-velocity with respect to Constructor Interface of TYPE diffstarlorene public  interface construct_diffstarlorene () Finalizations Procedures final :: destruct_diffstarlorene Finalizer (Destructor) of a [[diffstarlorene]] object Type-Bound Procedures procedure, public :: allocate_diffstar_memory Allocates memory for the diffstarlorene member arrays procedure, public, NON_OVERRIDABLE :: check_i_matter Checks that the given index is between 1 and n_matter ,\n included. If not, it stops the execution of the program. procedure, public :: construct_drs Constructs the \\texttt{LORENE} Etdiffrot object procedure, public :: deallocate_diffstar_memory Deallocates memory for the diffstarlorene member arrays procedure, public :: destruct_drs Destructs the \\texttt{LORENE} Etdiffrot object procedure, public :: get_angular_momentum Returns angular_momentum procedure, public :: get_area_radius Returns area_radius procedure, public :: get_diffstar_identifier Returns diffstar_identifier ] procedure, public :: get_energy_density_center Returns energy_density_center procedure, public :: get_ent_center Returns ent_center procedure, public :: get_eos_id => get_eos_loreneid Returns the \\texttt{LORENE} identifier for the EOS procedure, public :: get_eos_loreneid Returns eos_loreneid procedure, public :: get_f_isco Returns f_isco procedure, public :: get_fa => get_field_array Access the diffstarlorene -member arrays generic, public :: get_field => get_fa, get_fv GENERIC PROCEDURE, overloded to access the diffstarlorene -member\n variables as arrays and as values procedure, public :: get_fv => get_field_value Access the components of the diffstarlorene -member arrays procedure, public :: get_gamma Returns gamma procedure, public :: get_gamma0 Returns gamma0 procedure, public :: get_gamma1 Returns gamma1 procedure, public :: get_gamma2 Returns gamma2 procedure, public :: get_gamma3 Returns gamma3 procedure, public :: get_grv2 Returns grv2 procedure, public :: get_grv3 Returns grv3 procedure, public :: get_kappa Returns kappa procedure, public :: get_kappa0 Returns kappa0 procedure, public :: get_kappa1 Returns kappa1 procedure, public :: get_kappa2 Returns kappa2 procedure, public :: get_kappa3 Returns kappa3 procedure, public :: get_logP1 Returns logP1 procedure, public :: get_logRho0 Returns logRho0 procedure, public :: get_logRho1 Returns logRho1 procedure, public :: get_logRho2 Returns logRho2 procedure, public :: get_mass_grav Returns mass_grav procedure, public, NON_OVERRIDABLE :: get_n_matter Returns n_matter , the number of matter objects in the\n physical system procedure, public :: get_nbar_center Returns nbar_center procedure, public :: get_npeos Returns npeos procedure, public :: get_omega_c Returns omega_c Read more… procedure, public, NON_OVERRIDABLE :: get_one_lapse Returns one_lapse , the logical variable that determines if\nthe lapse function \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public :: get_pressure_center Returns pressure_center Read more… procedure, public :: get_r_circ Returns r_circ procedure, public :: get_r_eq Returns r_eq procedure, public :: get_r_eq_3pi2 Returns r_eq_3pi2 procedure, public :: get_r_eq_pi Returns r_eq_pi procedure, public :: get_r_eq_pi2 Returns r_eq_pi2 procedure, public :: get_r_isco Returns r_isco procedure, public :: get_r_mean Returns r_mean procedure, public :: get_r_pole Returns r_pole procedure, public :: get_r_ratio Returns r_ratio procedure, public :: get_rho_center Returns rho_center procedure, public :: get_specific_angular_momentum_isco Returns specific_angular_momentum_isco procedure, public :: get_specific_energy_center Returns specific_energy_center procedure, public :: get_specific_energy_isco Returns specific_energy_isco procedure, public :: get_surface_area Returns surface_area procedure, public, NON_OVERRIDABLE :: get_total_spatial_extent Returns the spatial extent of the physical system considered,\n  as the array of 6 numbers x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} procedure, public :: get_tsw Returns tsw procedure, public, NON_OVERRIDABLE :: get_zero_shift Returns zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure, public :: import_diffstar_params Imports the parameters of the DRS from \\texttt{LORENE} procedure, public :: import_id_int Stores the ID in the diffstarlorene member arrays procedure, public :: import_spatial_metric Returns the \\texttt{LORENE}'s conformally flat spatial ADM metric procedure, public :: integrate_baryon_mass_density Integrates the baryon mass density over a matter object, using spherical\n coordinates, and computes its radial profile inside the star procedure, public :: print_diffstar_params Prints the parameters of the DRS to the standard output procedure, public :: read_id_full => import_id_full procedure, public :: read_id_hydro => import_id_hydro procedure, public :: read_id_k => import_id_k procedure, public :: read_id_mass_b => import_id_mass_b procedure, public :: read_id_particles => import_id_particles procedure, public :: read_id_spacetime => import_id_spacetime procedure, public :: read_mass_density => import_mass_density Returns the \\texttt{LORENE}'s mass density at the given point procedure, public :: return_barycenter => get_barycenter procedure, public :: return_center => get_center procedure, public :: return_eos_name => get_eos procedure, public :: return_eos_parameters => get_eos_parameters procedure, public :: return_mass => get_mass procedure, public :: return_spatial_extent => get_radii procedure, public, NON_OVERRIDABLE :: set_n_matter Sets n_matter , the number of matter objects in the\n physical system, to a value procedure, public, NON_OVERRIDABLE :: set_one_lapse Sets one_lapse , the logical variable that determines if\n the lapse \\alpha=1 , i.e., if the geodesic gauge is to be used procedure, public, NON_OVERRIDABLE :: set_zero_shift Sets zero_shift , the logical variable that determines if\n the shift \\beta&#94;i=0 procedure, public :: test_position => is_hydro_negative Returns 1 if the energy density or the specific energy or the pressure\n are negative","tags":"","loc":"module/diffstar_lorene.html"},{"title":"formul_3p1_access – SPHINCS_LORENE","text":"Uses Ancestors: formul_3p1_id module~~formul_3p1_access~~UsesGraph module~formul_3p1_access formul_3p1_access module~formul_3p1_id formul_3p1_id module~formul_3p1_access->module~formul_3p1_id module~id_base id_base module~formul_3p1_id->module~id_base timing timing module~formul_3p1_id->timing module~utility utility module~formul_3p1_id->module~utility module~particles_id particles_id module~formul_3p1_id->module~particles_id mesh_refinement mesh_refinement module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures get_HC get_HC_parts get_MC get_MC_parts get_dx get_dy get_dz get_grid_point get_levels get_ngrid_x get_ngrid_y get_ngrid_z get_nlevels get_xR get_yR get_zR Module Procedures module procedure get_HC module module function get_HC(THIS, i, j, k, l) result(HC_value) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision module procedure get_HC_parts module module function get_HC_parts(THIS, i, j, k, l) result(HC_value) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision module procedure get_MC module module function get_MC(THIS, i, j, k, l) result(MC_value) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) module procedure get_MC_parts module module function get_MC_parts(THIS, i, j, k, l) result(MC_value) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) module procedure get_dx module module function get_dx(THIS, l) result(dx) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision module procedure get_dy module module function get_dy(THIS, l) result(dy) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision module procedure get_dz module module function get_dz(THIS, l) result(dz) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value double precision module procedure get_grid_point module module function get_grid_point(THIS, i, j, k, l) result(grid_point) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: i integer, intent(in) :: j integer, intent(in) :: k integer, intent(in) :: l Return Value double precision,\n  DIMENSION(3) module procedure get_levels module module function get_levels(THIS, l) result(levels) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value type(level),\n  DIMENSION(:), ALLOCATABLE module procedure get_ngrid_x module module function get_ngrid_x(THIS, l) result(ngrid_x) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer module procedure get_ngrid_y module module function get_ngrid_y(THIS, l) result(ngrid_y) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer module procedure get_ngrid_z module module function get_ngrid_z(THIS, l) result(ngrid_z) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer module procedure get_nlevels module module function get_nlevels(THIS) result(nlevels) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS Return Value double precision module procedure get_xR module module function get_xR(THIS, l) result(xR) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer module procedure get_yR module module function get_yR(THIS, l) result(yR) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer module procedure get_zR module module function get_zR(THIS, l) result(zR) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l Return Value integer","tags":"","loc":"module/formul_3p1_access.html"},{"title":"formul_3p1_standard3p1_variables – SPHINCS_LORENE","text":"Implementation of the methods of TYPE formul_3p1 *\n  that are called from the constructors and        *\n  destructors of its EXTENDED TYPES                *\n                                                   *\n  FT 22.10.2020                                    *\n                                                   * Uses Ancestors: formul_3p1_id module~~formul_3p1_standard3p1_variables~~UsesGraph module~formul_3p1_standard3p1_variables formul_3p1_standard3p1_variables module~formul_3p1_id formul_3p1_id module~formul_3p1_standard3p1_variables->module~formul_3p1_id module~id_base id_base module~formul_3p1_id->module~id_base timing timing module~formul_3p1_id->timing module~utility utility module~formul_3p1_id->module~utility module~particles_id particles_id module~formul_3p1_id->module~particles_id mesh_refinement mesh_refinement module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures deallocate_standard3p1_variables setup_standard3p1_variables Module Procedures module procedure deallocate_standard3p1_variables module module subroutine deallocate_standard3p1_variables(f3p1) Interface → Core of the destructors of TYPES derived from   *\n  formul_3p1. Their destructors should call this  *\n  SUBROUTINE. It deallocates memory.              *\n                                                  *\n  FT                                              *\n                                                  * Read more… Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 module procedure setup_standard3p1_variables module module subroutine setup_standard3p1_variables(f3p1, id, dx, dy, dz) Interface → Read the gravity grid parameters, computes    *\n  gravity grid coordinates, imports the LORENE  *\n  spacetime ID on the gravity grid, and         *\n  performs some checks on it.                   *\n  Its input includes the numbers of grid points *\n  per axis, contrary to                         *\n  construct_formul_3p1_bns_grid                 *\n  where those numbers are replaced by the grid  *\n  spacings.                                     *\n                                                *\n  FT 22.10.2020                                 *\n                                                * Read more… Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: f3p1 class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz","tags":"","loc":"module/formul_3p1_standard3p1_variables.html"},{"title":"formul_3p1_analysis – SPHINCS_LORENE","text":"Uses Ancestors: formul_3p1_id module~~formul_3p1_analysis~~UsesGraph module~formul_3p1_analysis formul_3p1_analysis module~formul_3p1_id formul_3p1_id module~formul_3p1_analysis->module~formul_3p1_id module~id_base id_base module~formul_3p1_id->module~id_base timing timing module~formul_3p1_id->timing module~utility utility module~formul_3p1_id->module~utility module~particles_id particles_id module~formul_3p1_id->module~particles_id mesh_refinement mesh_refinement module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures abs_values_in analyze_constraint Module Procedures module procedure abs_values_in module module subroutine abs_values_in(THIS, lower_bound, upper_bound, constraint, l, export, unit_analysis, cnt) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS double precision :: lower_bound double precision :: upper_bound double precision, intent(in), DIMENSION(:,:,:) :: constraint integer, intent(in) :: l logical, intent(in) :: export integer, intent(in) :: unit_analysis integer, intent(out) :: cnt module procedure analyze_constraint module module subroutine analyze_constraint(THIS, l, constraint, name_constraint, unit_logfile, name_analysis, l2_norm, loo_norm) Interface → Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: THIS integer, intent(in) :: l double precision, intent(in), DIMENSION(:,:,:) :: constraint character(len=*), intent(in) :: name_constraint integer, intent(in) :: unit_logfile character(len=*), intent(in) :: name_analysis double precision, intent(out) :: l2_norm double precision, intent(out) :: loo_norm","tags":"","loc":"module/formul_3p1_analysis.html"},{"title":"bssn_id_variables – SPHINCS_LORENE","text":"Uses Ancestors: formul_bssn_id module~~bssn_id_variables~~UsesGraph module~bssn_id_variables bssn_id_variables module~formul_bssn_id formul_bssn_id module~bssn_id_variables->module~formul_bssn_id module~formul_3p1_id formul_3p1_id module~formul_bssn_id->module~formul_3p1_id module~id_base id_base module~formul_bssn_id->module~id_base timing timing module~formul_bssn_id->timing module~utility utility module~formul_bssn_id->module~utility module~particles_id particles_id module~formul_bssn_id->module~particles_id mesh_refinement mesh_refinement module~formul_bssn_id->mesh_refinement module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility var panmodulebssn_id_variablesUsesGraph = svgPanZoom('#modulebssn_id_variablesUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures compute_and_export_bssn_variables print_formatted_lorene_id_bssn_variables read_bssn_dump_print_formatted Module Procedures module procedure compute_and_export_bssn_variables module module subroutine compute_and_export_bssn_variables(THIS, namefile) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile module procedure print_formatted_lorene_id_bssn_variables module module subroutine print_formatted_lorene_id_bssn_variables(THIS, namefile) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile module procedure read_bssn_dump_print_formatted module module subroutine read_bssn_dump_print_formatted(THIS, namefile_bin, namefile) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS character(len=*), intent(inout), optional :: namefile_bin character(len=*), intent(inout), optional :: namefile","tags":"","loc":"module/bssn_id_variables.html"},{"title":"bssn_id_memory – SPHINCS_LORENE","text":"Uses Ancestors: formul_bssn_id module~~bssn_id_memory~~UsesGraph module~bssn_id_memory bssn_id_memory module~formul_bssn_id formul_bssn_id module~bssn_id_memory->module~formul_bssn_id module~formul_3p1_id formul_3p1_id module~formul_bssn_id->module~formul_3p1_id module~id_base id_base module~formul_bssn_id->module~id_base timing timing module~formul_bssn_id->timing module~utility utility module~formul_bssn_id->module~utility module~particles_id particles_id module~formul_bssn_id->module~particles_id mesh_refinement mesh_refinement module~formul_bssn_id->mesh_refinement module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility var panmodulebssn_id_memoryUsesGraph = svgPanZoom('#modulebssn_id_memoryUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures allocate_bssn_fields deallocate_bssn_fields Module Procedures module procedure allocate_bssn_fields module module subroutine allocate_bssn_fields(THIS) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS module procedure deallocate_bssn_fields module module subroutine deallocate_bssn_fields(THIS) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS","tags":"","loc":"module/bssn_id_memory.html"},{"title":"bssn_id_constraints – SPHINCS_LORENE","text":"Uses Ancestors: formul_bssn_id module~~bssn_id_constraints~~UsesGraph module~bssn_id_constraints bssn_id_constraints module~formul_bssn_id formul_bssn_id module~bssn_id_constraints->module~formul_bssn_id module~formul_3p1_id formul_3p1_id module~formul_bssn_id->module~formul_3p1_id module~id_base id_base module~formul_bssn_id->module~id_base timing timing module~formul_bssn_id->timing module~utility utility module~formul_bssn_id->module~utility module~particles_id particles_id module~formul_bssn_id->module~particles_id mesh_refinement mesh_refinement module~formul_bssn_id->mesh_refinement module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility var panmodulebssn_id_constraintsUsesGraph = svgPanZoom('#modulebssn_id_constraintsUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures compute_and_export_bssn_constraints_grid compute_and_export_bssn_constraints_particles Module Procedures module procedure compute_and_export_bssn_constraints_grid module module subroutine compute_and_export_bssn_constraints_grid(THIS, id, namefile, name_logfile) Interface → DEALLOCATE( u_coord )\nDEALLOCATE( u_coord_l ) Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( idbase ), intent(inout) :: id character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile module procedure compute_and_export_bssn_constraints_particles module module subroutine compute_and_export_bssn_constraints_particles(THIS, parts_obj, namefile, name_logfile) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS class( particles ), intent(inout) :: parts_obj character(len=*), intent(inout) :: namefile character(len=*), intent(inout) :: name_logfile","tags":"","loc":"module/bssn_id_constraints.html"},{"title":"bssn_id_constructor – SPHINCS_LORENE","text":"Implementation of the constructor and        *\n  destructor of TYPE bssn_id                   *\n                                               *\n  FT 23.10.2020                                *\n                                               *\n  Updated to mesh refinement                   *\n                                               *\n  FT 26.03.2021                                *\n                                               * Uses Ancestors: formul_bssn_id module~~bssn_id_constructor~~UsesGraph module~bssn_id_constructor bssn_id_constructor module~formul_bssn_id formul_bssn_id module~bssn_id_constructor->module~formul_bssn_id module~formul_3p1_id formul_3p1_id module~formul_bssn_id->module~formul_3p1_id module~id_base id_base module~formul_bssn_id->module~id_base timing timing module~formul_bssn_id->timing module~utility utility module~formul_bssn_id->module~utility module~particles_id particles_id module~formul_bssn_id->module~particles_id mesh_refinement mesh_refinement module~formul_bssn_id->mesh_refinement module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility var panmodulebssn_id_constructorUsesGraph = svgPanZoom('#modulebssn_id_constructorUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures construct_bssn_id destruct_bssn_id destructor Module Procedures module procedure construct_bssn_id module module function construct_bssn_id(id, dx, dy, dz) result(bssnid) Interface → This constructor of TYPE bssn_id calls the       *\n  SUBROUTINES that rely on an bns object, and      *\n  allocates memory. It constructs the grid         *\n  using the number of grid points along each axis. *\n                                                   *\n  FT 23.10.2020                                    *\n                                                   * Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id double precision, optional :: dx double precision, optional :: dy double precision, optional :: dz Return Value type( bssn_id ) module procedure destruct_bssn_id module module subroutine destruct_bssn_id(THIS) Interface → Arguments Type Intent Optional Attributes Name class( bssn_id ), intent(inout) :: THIS module procedure destructor module module subroutine destructor(THIS) Interface → Arguments Type Intent Optional Attributes Name type( bssn_id ), intent(inout) :: THIS","tags":"","loc":"module/bssn_id_constructor.html"},{"title":"particles_memory – SPHINCS_LORENE","text":"This SUBMODULE contains the implementation of\n  the methods of TYPE particles\n  that place particles on 1 or 2 lattices around\n  the stars. FT 12.07.2021 Uses Ancestors: particles_id module~~particles_memory~~UsesGraph module~particles_memory particles_memory module~particles_id particles_id module~particles_memory->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures allocate_lorene_id_parts_memory deallocate_lorene_id_parts_memory Module Procedures module procedure allocate_lorene_id_parts_memory module module subroutine allocate_lorene_id_parts_memory(THIS) Interface → Allocate memory for the LORENE ID on the\n  particles Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of module procedure deallocate_lorene_id_parts_memory module module subroutine deallocate_lorene_id_parts_memory(THIS) Interface → Deallocate memory for the LORENE ID on the\n  particles Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of","tags":"","loc":"module/particles_memory.html"},{"title":"spherical_surfaces – SPHINCS_LORENE","text":"This SUBMODULE contains the implementation\n  of the method of TYPE particles that places\n  particles on spherical surfaces inside\n  a star FT 19.04.2021 Uses Ancestors: particles_id module~~spherical_surfaces~~UsesGraph module~spherical_surfaces spherical_surfaces module~particles_id particles_id module~spherical_surfaces->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions number_surfaces particle_volume Subroutines assign_surfaces_mass compute_colatitudes_uniformly_in place_surfaces print_mass_profile_surface_radii reallocate_array_1d reallocate_array_2d Module Procedures place_particles_spherical_surfaces Functions function number_surfaces (m_p, center, radius, get_dens) result(n_shells_tmp) Compute the number of spherical surfaces\n  by integrating the linear particle density\n  along the larger equatorial radius Read more… Arguments Type Intent Optional Attributes Name double precision, intent(in) :: m_p double precision, intent(in) :: center double precision, intent(in) :: radius function get_dens(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Return Value double precision function particle_volume (rad, col, dr_shells, dth_shells, dphi_shells, th, colatitudes, npart_equator) result(pvol) Compute the geometrical particle volume\n  not the proper particle volume. Read more… Arguments Type Intent Optional Attributes Name double precision, intent(in) :: rad double precision, intent(in) :: col double precision, intent(in) :: dr_shells double precision, intent(inout) :: dth_shells double precision, intent(in) :: dphi_shells integer, intent(in) :: th double precision, intent(in), DIMENSION(:) :: colatitudes integer, intent(in) :: npart_equator Return Value double precision Subroutines subroutine assign_surfaces_mass (shell_masses, shell_radii, radius, dr, n_shells, mass_profile_idx, mass_profile, mass_star) Assign a mass to each spherical surface,\n  based on the radial mass profile of the star\n  (computed along the larger equatorial radius) Read more… Arguments Type Intent Optional Attributes Name double precision, intent(inout), DIMENSION( n_shells ) :: shell_masses double precision, intent(in), DIMENSION( n_shells ) :: shell_radii double precision, intent(in) :: radius double precision, intent(in) :: dr integer, intent(in) :: n_shells integer, intent(in), DIMENSION( : ) :: mass_profile_idx double precision, intent(in), DIMENSION( :, : ) :: mass_profile double precision, intent(in) :: mass_star subroutine compute_colatitudes_uniformly_in (alpha, beta, colatitudes) Compute the colatitudes according to a\n  uniform distribution over a spherical\n  surface, between alpha and beta, with\n  pi/2 < alpha < beta < pi.\n  The values are stored in the array colatitudes\n  See https://mathworld.wolfram.com/SpherePointPicking.html Read more… Arguments Type Intent Optional Attributes Name double precision, intent(in) :: alpha double precision, intent(in) :: beta double precision, intent(inout), DIMENSION(:) :: colatitudes subroutine place_surfaces (central_dens, center, radius, m_p, n_shells, shell_radii, last_r, get_dens) Place the spherical surface, according to\n  the baryon mass density of the star\n  along the larger equatorial radius Read more… Arguments Type Intent Optional Attributes Name double precision, intent(in) :: central_dens double precision, intent(in) :: center double precision, intent(in) :: radius double precision, intent(in) :: m_p integer, intent(in) :: n_shells double precision, intent(inout), DIMENSION( n_shells ) :: shell_radii double precision, intent(in) :: last_r function get_dens(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision subroutine print_mass_profile_surface_radii (mass_profile, mass_profile_idx, shell_radii, radius, dr, n_shells, filename_mass_profile, filename_shells_radii) Print star's radial mass profile and radii of\n  spherical surfaces to different ASCII files Read more… Arguments Type Intent Optional Attributes Name double precision, intent(in), DIMENSION( :, : ) :: mass_profile integer, intent(in), DIMENSION( : ) :: mass_profile_idx double precision, intent(in), DIMENSION( n_shells ) :: shell_radii double precision, intent(in) :: radius double precision, intent(in) :: dr integer, intent(in) :: n_shells character(len=*), intent(in) :: filename_mass_profile character(len=*), intent(in) :: filename_shells_radii subroutine reallocate_array_1d (array, new_dim) Reallocate a 1-dimensional array Read more… Arguments Type Intent Optional Attributes Name double precision, intent(inout), DIMENSION(:), ALLOCATABLE :: array integer, intent(in) :: new_dim subroutine reallocate_array_2d (array, new_dim, new_dim2) Reallocate a 2-dimensional array Read more… Arguments Type Intent Optional Attributes Name double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: array integer, intent(in) :: new_dim integer, intent(in) :: new_dim2 Module Procedures module procedure place_particles_spherical_surfaces module module subroutine place_particles_spherical_surfaces(THIS, mass_star, radius, center, central_density, npart_approx, npart_out, pos, pvol, pmass, last_r, upper_bound, lower_bound, upper_factor, lower_factor, max_steps, filename_mass_profile, filename_shells_radii, filename_shells_pos, get_density, integrate_density, get_id, validate_position) Interface → Places particles on spherical surfaces\n  inside a star Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: mass_star Baryonic mass of the star double precision, intent(in) :: radius Radius of the star in the x direction towards the companion double precision, intent(in) :: center (x|) coordinate of the center of the star, i.e.,\n of the point with highest density double precision, intent(in) :: central_density Central density of the star, i.e., highest density integer, intent(in) :: npart_approx idbase object needed to access the BNS data Todo Remove the idbase argument as done in SUBROUTINE perform_apm\nCLASS(idbase),       INTENT( IN OUT ):: id\n Approximate particle number on the star integer, intent(out) :: npart_out Final number of particles on the star double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos Array string the final positions double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pmass Array storing the final particle masses double precision, intent(in) :: last_r Radius of the last spherical surface double precision, intent(inout) :: upper_bound Desired upper bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(inout) :: lower_bound Desired lower bound for the differences between particle\n masses on neighbouring spherical surfaces double precision, intent(in) :: upper_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. upper_factor >= 1, usually an increase of 1% works double precision, intent(in) :: lower_factor If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. lower_factor <= 1, usually a decrease of 1% works integer, intent(in) :: max_steps If, after max_steps, the iteration did not converge,\n multiply upper_bound by upper_factor, and lower_bound\n by lower_factor. max_steps >= 10. 100 is a nice value character(len=*), intent(inout), optional :: filename_mass_profile Name of the file to store the radial mass profile character(len=*), intent(inout), optional :: filename_shells_radii Name of the file to store the surface radii Todo change name of variable to filename_surfaces_radii character(len=*), intent(inout), optional :: filename_shells_pos Name of the file to store the final particle positions Todo change name of variable to filename_surfaces_pos function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine integrate_density(center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order subroutine get_id(x, y, z, g_xx, baryon_density, gamma_euler) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise","tags":"","loc":"module/spherical_surfaces.html"},{"title":"particles_constructor – SPHINCS_LORENE","text":"This SUBMODULE contains the implementation\n  of the constructor and the\n  destructor of TYPE particles. FT 16.10.2020 Uses Ancestors: particles_id module~~particles_constructor~~UsesGraph module~particles_constructor particles_constructor module~particles_id particles_id module~particles_constructor->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures construct_particles destruct_particles Module Procedures module procedure construct_particles module module function construct_particles(id, dist) result(parts) Interface → The constructor performs all the tasks needed\n  to set up the particle distribution with the\n  \\texttt{LORENE} ID on it. It calls all the PROCEDURES\n  that rely on an object of TYPE bns. Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: id idbase object representing the BNS for which we want to place\n particles integer, intent(in) :: dist Identifier of the desired particle distribution: 0: Read particle positions (and optionally the baryon number per\n    particle \\nu ) from a formatted file 1: Place particles on a single lattice that surrounds both stars 2: Place particles on two lattices, each one surrounding a star 3: Place particles on spherical surfaces inside the stars Warning Method 1 is almost deprecated, since method 2 is effectively\n          an improvement of method 1 Return Value type( particles ) Constructed particles object module procedure destruct_particles module module subroutine destruct_particles(THIS) Interface → Destructor of a particles object Read more… Arguments Type Intent Optional Attributes Name type( particles ), intent(inout) :: THIS Finalizer (Destructor) of particles object particles object which this PROCEDURE is a member of","tags":"","loc":"module/particles_constructor.html"},{"title":"particles_sph_variables – SPHINCS_LORENE","text":"THIS SUBMODULE contains the implementation of\n  the methods of TYPE particles\n  that compute, print and read the SPH variables. FT 16.10.2020 Renamed from particles_methods to\n  particles_sph_variables upon improving modularity FT 12.07.2021 Uses Ancestors: particles_id module~~particles_sph_variables~~UsesGraph module~particles_sph_variables particles_sph_variables module~particles_id particles_id module~particles_sph_variables->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures analyze_hydro compute_and_export_SPH_variables print_formatted_lorene_id_particles read_sphincs_dump_print_formatted Module Procedures module procedure analyze_hydro module module subroutine analyze_hydro(THIS, namefile) Interface → Export the points where some of the hydro\n  fields are negative to a formatted file\n  (deprecated?) Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the particle positions at which\n some of the hydro fields are negative or zero are printed to module procedure compute_and_export_SPH_variables module module subroutine compute_and_export_SPH_variables(THIS, namefile) Interface → Compute the SPH quantities from the LORENE\n  ID, and export it to a binary file with\n  write_SPHINCS_dump, and to a formatted file Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted file where the SPH ID is printed to module procedure print_formatted_lorene_id_particles module module subroutine print_formatted_lorene_id_particles(THIS, namefile) Interface → Print the LORENE ID on the particles in a\n  formatted file Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile Name of the formatted output file module procedure read_sphincs_dump_print_formatted module module subroutine read_sphincs_dump_print_formatted(THIS, namefile_bin, namefile) Interface → Read the SPH ID from the binary file output\n  by write_SPHINCS_dump, and print it to a\n  formatted file Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile_bin Name of the binary file to be read character(len=*), intent(inout), optional :: namefile Name of the formatted file to be printed","tags":"","loc":"module/particles_sph_variables.html"},{"title":"particles_access – SPHINCS_LORENE","text":"This SUBMODULE contains the implementation of\n  the methods of TYPE particles\n  that allow to access PRIVATE members. FT 12.07.2021 Uses Ancestors: particles_id module~~particles_access~~UsesGraph module~particles_access particles_access module~particles_id particles_id module~particles_access->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures get_h get_nlrf get_npart get_npart1 get_npart2 get_nu get_nuratio get_nuratio1 get_nuratio2 get_pos get_pressure get_pressure_cu get_theta get_u get_vel is_empty Module Procedures module procedure get_h module module function get_h(THIS) result(h) Interface → Returns the array of initial guess for the\n smoothing length [Msun_geo] Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE h module procedure get_nlrf module module function get_nlrf(THIS) result(nlrf) Interface → Returns the array of baryon density in the\n local rest frame Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE nlrf module procedure get_npart module module function get_npart(THIS) result(n_part) Interface → Returns the total number of particles Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer npart module procedure get_npart1 module module function get_npart1(THIS) result(n_part) Interface → Returns the number of particles on star 1 Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles module procedure get_npart2 module module function get_npart2(THIS) result(n_part) Interface → Returns the number of particles on star 2 Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value integer particles module procedure get_nu module module function get_nu(THIS) result(nu) Interface → Returns the array of baryon per particle\n [baryon (Msun_geo)&#94;{-3}] Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE nu module procedure get_nuratio module module function get_nuratio(THIS) result(nuratio) Interface → Returns the baryon number ratio on the stars Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision nuratio module procedure get_nuratio1 module module function get_nuratio1(THIS) result(nuratio1) Interface → Returns the baryon number ratio on star 1 Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles module procedure get_nuratio2 module module function get_nuratio2(THIS) result(nuratio2) Interface → Returns the baryon number ratio on star 2 Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision particles module procedure get_pos module module function get_pos(THIS) result(pos_u) Interface → Returns the array of particle positions Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:), ALLOCATABLE pos module procedure get_pressure module module function get_pressure(THIS) result(pressure) Interface → Returns the array of pressure [kg c&#94;2 m&#94;{-3}] Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE pressure_parts module procedure get_pressure_cu module module function get_pressure_cu(THIS) result(pressure_cu) Interface → Returns the array of pressure in code units\n [amu c 2/(Msun_geo *3)] Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE pressure_parts_cu module procedure get_theta module module function get_theta(THIS) result(theta) Interface → Returns the array of generalized Lorentz\n factor Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Theta module procedure get_u module module function get_u(THIS) result(u) Interface → Returns the array of specific internal\n energy [c&#94;2] Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:), ALLOCATABLE specific_energy_parts module procedure get_vel module module function get_vel(THIS) result(vel) Interface → Returns the array of coordinate 3-velocity of\n particles Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(:,:), ALLOCATABLE v module procedure is_empty module module function is_empty(THIS) result(answer) Interface → Returns the variable empty_object Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(in) :: THIS particles object which this PROCEDURE is a member of Return Value logical .TRUE if the particles object is empty, .FALSE otherwise","tags":"","loc":"module/particles_access.html"},{"title":"particles_compose – SPHINCS_LORENE","text":"This SUBMODULE contains the implementation of\n  the methods of TYPE particles\n  that compute Ye on the particles, using the\n  data from the CompOSE database https://compose.obspm.fr/ FT 12.07.2021 Uses Ancestors: particles_id module~~particles_compose~~UsesGraph module~particles_compose particles_compose module~particles_id particles_id module~particles_compose->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures compute_Ye read_compose_composition Module Procedures module procedure compute_Ye module module subroutine compute_Ye(THIS) Interface → Interpolates the electron fraction\n  Y_e = n_e/n_b\n  at the particle positions, using the data\n  read by read_compose_composition. Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of module procedure read_compose_composition module module subroutine read_compose_composition(THIS, namefile) Interface → Reads the electron fraction Y_e = n_e/n_b,\n  with n_e electron number density and n_b\n  baryon number density, from the .compo file\n  taken from the CompOSE database of EoS.\n  Y_e is given as a function of T, n_b, Y_q on\n  a grid; the computation of Ye on the stars is\n  done by the SUBROUTINE compute_Ye_on_stars. Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of character(len=*), intent(inout), optional :: namefile To read the file great_eos.beta in directory compose_path/GREAT_EoS,\n namefile=\"GREAT_EoS/great_eos\"","tags":"","loc":"module/particles_compose.html"},{"title":"particles_lattices – SPHINCS_LORENE","text":"This SUBMODULE contains the implementation of\n  the methods of TYPE particles\n  that place particles on 1 or 2 lattices around\n  the stars. FT 12.07.2021 Uses Ancestors: particles_id module~~particles_lattices~~UsesGraph module~particles_lattices particles_lattices module~particles_id particles_id module~particles_lattices->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures place_particles_lattice Module Procedures module procedure place_particles_lattice module module subroutine place_particles_lattice(THIS, central_density, xmin, xmax, ymin, ymax, zmin, zmax, npart_des, npart_out, stretch, thres, pos, pvol, get_density, validate_position) Interface → Places paricles on a 3D lattice containing both stars Read more… Arguments Type Intent Optional Attributes Name class( particles ), intent(inout) :: THIS particles object which this PROCEDURE is a member of double precision, intent(in) :: central_density Maximum baryon mass density of the system double precision, intent(in) :: xmin Left x boundary of the lattice double precision, intent(in) :: xmax Right x boundary of the lattice double precision, intent(in) :: ymin Left y boundary of the lattice double precision, intent(in) :: ymax Right y boundary of the lattice double precision, intent(in) :: zmin Left z boundary of the lattice double precision, intent(in) :: zmax Right z boundary of the lattice integer, intent(in) :: npart_des Desired particle number integer, intent(out) :: npart_out Real, output particle number double precision, intent(in) :: stretch Stretching factor fo the lattice. xmin to zmax are multiplied by it double precision, intent(in) :: thres (~rho_max)/thres is the minimum mass density considered\nwhen placing particles. Used only when redistribute_nu is\n.FALSE. . When redistribute_nu is .TRUE. thres= 100*nu_ratio double precision, intent(out), DIMENSION(:,:), ALLOCATABLE :: pos double precision, intent(out), DIMENSION(:), ALLOCATABLE :: pvol Array soring the inal particle volumes\nArray storing the final particle volumes function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise","tags":"","loc":"module/particles_lattices.html"},{"title":"particles_apm – SPHINCS_LORENE","text":"This SUBMODULE contains the\n  implementation of the method\n  perform_apm of TYPE particles. FT 04.06.2021 Uses Ancestors: particles_id module~~particles_apm~~UsesGraph module~particles_apm particles_apm module~particles_id particles_id module~particles_apm->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines correct_center_of_mass get_neighbours_bf impose_equatorial_plane_symmetry Module Procedures perform_apm Subroutines subroutine correct_center_of_mass (npart_real, pos, nu, get_density, validate_pos, com_star, verbose) Translate the particles so that their center of mass\n  coincides with the center of mass of the star, given by\n  LORENE Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real double precision, intent(inout), DIMENSION(3,npart_real) :: pos double precision, intent(inout), DIMENSION(npart_real) :: nu function get_density(x, y, z) result(density) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z Return Value double precision function validate_pos(x, y, z) result(answer) Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z Return Value integer double precision, intent(in) :: com_star logical, intent(in), optional :: verbose subroutine get_neighbours_bf (ipart, npart, pos, h, dimensions, nnei, neilist) just for test purposes: get neighbours of particle ipart in\n  a \"brute force\" way; ipart is ALSO on the neighbour list;\n  SKR 8.2.2010 Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: ipart integer, intent(in) :: npart double precision, intent(in) :: pos (dimensions,npart) double precision, intent(in) :: h (npart) integer, intent(in) :: dimensions integer, intent(out) :: nnei integer, intent(out) :: neilist (npart) subroutine impose_equatorial_plane_symmetry (npart_real, pos, nu, com_star, verbose) Mirror the particle with z>0 with respect to the xy plane,\n  to impose the equatorial-plane symmetry Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real double precision, intent(inout), DIMENSION(3,npart_real) :: pos double precision, intent(inout), DIMENSION(npart_real) :: nu double precision, intent(in), optional :: com_star logical, intent(in), optional :: verbose Module Procedures module procedure perform_apm module module subroutine perform_apm(get_density, get_nstar_p, pos_input, pvol, h_output, nu_output, center, com_star, mass, radx_comp, radx_opp, rady, radz, apm_max_it, max_inc, mass_it, correct_nu, nuratio_thres, nuratio_des, nx_gh, ny_gh, nz_gh, namefile_pos_id, namefile_pos, namefile_results, validate_position) Interface → Compute the particle positions as follows: Read more… Arguments Type Intent Optional Attributes Name function get_density(x, y, z) result(density) Returns the baryon mass density at the desired point Arguments Type Intent Optional Attributes Name double precision, intent(in) :: x x coordinate of the desired point double precision, intent(in) :: y y coordinate of the desired point double precision, intent(in) :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) subroutine get_nstar_p(npart_real, x, y, z, nstar_p) Computes the proper baryon number density at the particle positions Arguments Type Intent Optional Attributes Name integer, intent(in) :: npart_real Number of real particles (i.e., no ghost particles included here) double precision, intent(in) :: x (npart_real) Array of x coordinates double precision, intent(in) :: y (npart_real) Array of y coordinates double precision, intent(in) :: z (npart_real) Array of z coordinates double precision, intent(out) :: nstar_p (npart_real) Array to store the computed proper baryon number density double precision, intent(inout), DIMENSION(:,:) :: pos_input Initial particle positions double precision, intent(inout), DIMENSION(:) :: pvol Initial particle volume double precision, intent(out), DIMENSION(:) :: h_output Array to store the smoothing lengths computed at the end of the\n APM iteration double precision, intent(out), DIMENSION(:) :: nu_output Array to store the baryon number per particle computed at the end of\n the APM iteration double precision, intent(in) :: center Center of the star (point of highest density), computed by \\texttt{LORENE} double precision, intent(in) :: com_star Center of mass of the star, computed by \\texttt{LORENE} double precision, intent(in) :: mass Mass of the star double precision, intent(in) :: radx_comp Radius of the star in the x direction, towards the companion double precision, intent(in) :: radx_opp Radius of the star in the x direction, opposite to companion double precision, intent(in) :: rady Radius of the star in the y direction double precision, intent(in) :: radz Radius of the star in the z direction integer, intent(in) :: apm_max_it Maximum number of APM iterations, irrespective of the EXIT condition integer, intent(in) :: max_inc Sets the EXIT condition: If the average over all the\n particles of the relative error in the density estimate\n grows max_inc times, exit the iteration. logical, intent(in) :: mass_it If .TRUE. performs a second iteration after the APM one, without moving\n the particles, changing their mass in order to better match\n the star density. The mass ratio grows very fast in all the tried\n experiments, hence the suggested value is .FALSE. logical, intent(in) :: correct_nu If .TRUE., the baryon number per particle nu is corrected\n to include the total baryonic masses of the\n stars. double precision, intent(in) :: nuratio_thres Maximum mass ratio (equivalently baryon number ratio)\n to be used in the one-time-only final correction\n of the particle masses to match the star density even\n better (without moving the particles) double precision, intent(in) :: nuratio_des Sets the EXIT condition: If the baryon number ratio\n is within 2.5% of nuratio_des, exit the iteration\n Set nuratio_des to 0 to deactivate and exit the APM\n iteration using max_inc integer, intent(in) :: nx_gh Number of lattice points in the x direction for ghosts integer, intent(in) :: ny_gh Number of lattice points in the y direction for ghosts integer, intent(in) :: nz_gh Number of lattice points in the z direction for ghosts character(len=*), intent(inout), optional :: namefile_pos_id Name for the formatted file where the initial particle positions character(len=*), intent(inout), optional :: namefile_pos Name for the formatted file where the particle positions character(len=*), intent(inout), optional :: namefile_results Name for the formatted file where various quantities related procedure(validate_position_int), optional :: validate_position Returns 1 if the position is not valid, 0 otherwise","tags":"","loc":"module/particles_apm.html"},{"title":"particles_redistribute_nu – SPHINCS_LORENE","text":"This SUBMODULE contains the implementation of\n  the methods of TYPE particles\n  that reallocate the sph variables and\n  redistribute nu (baryon number per particle)\n  on the particles. These methods find application when one wants to\n  decrease the particle mass ratio with particles\n  on lattices. They DON'T HAVE ANYTHING to do with the APM. TODO: Add other SUBROUTINES to improve\n        modularity in SUBMODULE\n        particles_sph_variables FT 12.07.2021 Uses Ancestors: particles_id module~~particles_redistribute_nu~~UsesGraph module~particles_redistribute_nu particles_redistribute_nu module~particles_id particles_id module~particles_redistribute_nu->module~particles_id module~id_base id_base module~particles_id->module~id_base timing timing module~particles_id->timing module~utility utility module~particles_id->module~utility module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures reshape_sph_field_1d reshape_sph_field_2d Module Procedures module procedure reshape_sph_field_1d module procedure reshape_sph_field_1d() Read the SPH ID from the binary file output\n  by write_SPHINCS_dump, and print it to a\n  formatted file Read more… Arguments None module procedure reshape_sph_field_2d module procedure reshape_sph_field_2d() Read the SPH ID from the binary file output\n  by write_SPHINCS_dump, and print it to a\n  formatted file Read more… Arguments None","tags":"","loc":"module/particles_redistribute_nu.html"},{"title":"id_base_mass_profile – SPHINCS_LORENE","text":"Implementation of the method of TYPE idbase\n  that integrates the baryon mass density to\n  extract the radial baryon mass profile. FT 12.07.2021 Uses Ancestors: id_base module~~id_base_mass_profile~~UsesGraph module~id_base_mass_profile id_base_mass_profile module~id_base id_base module~id_base_mass_profile->module~id_base timing timing module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures integrate_baryon_mass_density Module Procedures module procedure integrate_baryon_mass_density module module subroutine integrate_baryon_mass_density(THIS, center, radius, central_density, dr, dth, dphi, mass, mass_profile, mass_profile_idx) Interface → Perform 3D integration over a spherical grid\n  of the baryon mass density. Output baryon\n  mass and radial mass profile. Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of double precision, intent(in) :: center Center of the star double precision, intent(in) :: radius Radius of the star double precision, intent(in) :: central_density Central density of the star double precision, intent(in) :: dr Integration steps double precision, intent(in) :: dth Integration steps double precision, intent(in) :: dphi Integration steps double precision, intent(inout) :: mass Integrated mass of the star double precision, intent(inout), DIMENSION(:,:), ALLOCATABLE :: mass_profile Array storing the radial mass profile of the star integer, intent(inout), DIMENSION(:), ALLOCATABLE :: mass_profile_idx Array to store the indices for array mass_profile, sorted so that\n mass_profile[mass_profile_idx] is in increasing order","tags":"","loc":"module/id_base_mass_profile.html"},{"title":"id_base_access – SPHINCS_LORENE","text":"Implementation of the methods of TYPE\n  idbase to access PRIVATE data FT 28.10.2021 Uses Ancestors: id_base module~~id_base_access~~UsesGraph module~id_base_access id_base_access module~id_base id_base module~id_base_access->module~id_base timing timing module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures check_i_matter get_n_matter get_one_lapse get_total_spatial_extent get_zero_shift set_n_matter set_one_lapse set_zero_shift Module Procedures module procedure check_i_matter module module subroutine check_i_matter(THIS, i_matter) Interface → Checks that the given index i_matter is\n  between 1 and [[idbase:n_matter]], included.\n  If not, it stops the execution of the program. Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS integer, intent(in) :: i_matter Value to be checked module procedure get_n_matter module module function get_n_matter(THIS) Interface → Returns [[idbase:n_matter]], the number of\n  matter objects in the physical system Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value double precision n_matter , the number of matter objects in the module procedure get_one_lapse module module function get_one_lapse(THIS) Interface → Returns [[idbase:one_lapse]] Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the module procedure get_total_spatial_extent module module function get_total_spatial_extent(THIS) result(box) Interface → Return the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},z_{\\rm min},z_{\\rm max} of a box containing the entire physical system Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS Object of class idbase which this PROCEDURE is a member of Return Value double precision,\n  DIMENSION(6) 6-dimensional array containing the coordinates x_{\\rm min},x_{\\rm max},y_{\\rm min},y_{\\rm max},\n   z_{\\rm min},z_{\\rm max} of a box containing the physical system. module procedure get_zero_shift module module function get_zero_shift(THIS) Interface → Returns [[idbase:zero_shift]] Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(in) :: THIS Return Value logical n_matter , the number of matter objects in the module procedure set_n_matter module module subroutine set_n_matter(THIS, value) Interface → Sets [[idbase:n_matter]] to the given value Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS integer, intent(in) :: value Value to set n_matter to module procedure set_one_lapse module module subroutine set_one_lapse(THIS, logic) Interface → Sets [[idbase:one_lapse]] to the given value Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to module procedure set_zero_shift module module subroutine set_zero_shift(THIS, logic) Interface → Sets [[idbase:zero_shift]] to the given value Read more… Arguments Type Intent Optional Attributes Name class( idbase ), intent(inout) :: THIS logical, intent(in) :: logic Value to set n_matter to","tags":"","loc":"module/id_base_access.html"},{"title":"bns_base_mass_profile – SPHINCS_LORENE","text":"Implementation of the method of TYPE bns\n  that integrates the baryon mass density to\n  extract the radial baryon mass profile. FT 12.07.2021 Uses Ancestors: bns_base module~~bns_base_mass_profile~~UsesGraph module~bns_base_mass_profile bns_base_mass_profile module~bns_base bns_base module~bns_base_mass_profile->module~bns_base module~id_base id_base module~bns_base->module~id_base module~utility utility module~bns_base->module~utility timing timing module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures integrate_baryon_mass_density Module Procedures module procedure integrate_baryon_mass_density module procedure integrate_baryon_mass_density() Perform 3D integration over a spherical grid\n  of the baryon mass density. Output baryon\n  mass and radial mass profile. Read more… Arguments None","tags":"","loc":"module/bns_base_mass_profile.html"},{"title":"bns_base_access – SPHINCS_LORENE","text":"The module contains the implementation of the\n  methods of TYPE bnsbase that allow to access\n  PRIVATE members. FT 12.07.2021 Uses Ancestors: bns_base module~~bns_base_access~~UsesGraph module~bns_base_access bns_base_access module~bns_base bns_base module~bns_base_access->module~bns_base module~id_base id_base module~bns_base->module~id_base module~utility utility module~bns_base->module~utility timing timing module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures get_adm_mass get_angular_momentum get_angular_vel get_barycenter get_barycenter1_x get_barycenter2_x get_center get_center1_x get_center2_x get_distance get_distance_com get_energy_density_center1 get_energy_density_center2 get_ent_center1 get_ent_center2 get_eos get_eos1 get_eos2 get_gamma0_1 get_gamma0_2 get_gamma1_1 get_gamma1_2 get_gamma2_1 get_gamma2_2 get_gamma3_1 get_gamma3_2 get_gamma_1 get_gamma_2 get_grav_mass1 get_grav_mass2 get_kappa0_1 get_kappa0_2 get_kappa1_1 get_kappa1_2 get_kappa2_1 get_kappa2_2 get_kappa3_1 get_kappa3_2 get_kappa_1 get_kappa_2 get_logRho0_1 get_logRho0_2 get_logRho1_1 get_logRho1_2 get_logRho2_1 get_logRho2_2 get_logp1_1 get_logp1_2 get_mass get_mass1 get_mass2 get_nbar_center1 get_nbar_center2 get_npeos_1 get_npeos_2 get_pressure_center1 get_pressure_center2 get_radii get_radius1_x_comp get_radius1_x_opp get_radius1_y get_radius1_z get_radius2_x_comp get_radius2_x_opp get_radius2_y get_radius2_z get_rho_center1 get_rho_center2 get_specific_energy_center1 get_specific_energy_center2 Module Procedures module procedure get_adm_mass module module function get_adm_mass(THIS) Interface → Returns the ADM mass of the system Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_angular_momentum module module function get_angular_momentum(THIS) Interface → Returns the angular momentum of the system Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_angular_vel module module function get_angular_vel(THIS) Interface → Returns the angular velocity of the system Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_barycenter module module function get_barycenter(THIS, i_matter) Interface → Returns the barycenter of the i_matter -th star\n  [ L_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) module procedure get_barycenter1_x module module function get_barycenter1_x(THIS) Interface → Returns the barycenter of NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_barycenter2_x module module function get_barycenter2_x(THIS) Interface → Returns the barycenter of NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_center module module function get_center(THIS, i_matter) Interface → Returns the center of the i_matter -th star\n  [ L_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) module procedure get_center1_x module module function get_center1_x(THIS) Interface → Returns the stellar center of NS 1, i.e., the\n  origin of the LORENE chart centered on NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_center2_x module module function get_center2_x(THIS) Interface → Returns the stellar center of NS 2, i.e., the\n  origin of the LORENE chart centered on NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_distance module module function get_distance(THIS) Interface → Returns the distance between the NSs Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_distance_com module module function get_distance_com(THIS) Interface → Returns the distance between the centers of\n  mass of the NSs Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_energy_density_center1 module module function get_energy_density_center1(THIS) Interface → Returns the central energy density of NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_energy_density_center2 module module function get_energy_density_center2(THIS) Interface → Returns the central energy density of NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_ent_center1 module module function get_ent_center1(THIS) Interface → Returns the central enthalpy of NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_ent_center2 module module function get_ent_center2(THIS) Interface → Returns the central enthalpy of NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_eos module module function get_eos(THIS, i_matter) Interface → Returns the EoS name of the i_matter -th star\n  [ L_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE module procedure get_eos1 module module function get_eos1(THIS) Interface → Returns the name of the EOS for NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE module procedure get_eos2 module module function get_eos2(THIS) Interface → Returns the name of the EOS for NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value character(len=:),\n  ALLOCATABLE module procedure get_gamma0_1 module module function get_gamma0_1(THIS) Interface → Returns the value of [[gamma0_1]], the crust's\n  polytropic index for NS 1 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma0_2 module module function get_gamma0_2(THIS) Interface → Returns the value of [[gamma0_2]], the crust's\n  polytropic index for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma1_1 module module function get_gamma1_1(THIS) Interface → Returns the value of [[gamma1_1]], the first\n  polytropic index for NS 1 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma1_2 module module function get_gamma1_2(THIS) Interface → Returns the value of [[gamma1_2]], the first\n  polytropic index for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma2_1 module module function get_gamma2_1(THIS) Interface → Returns the value of [[gamma2_1]], the second\n  polytropic index for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma2_2 module module function get_gamma2_2(THIS) Interface → Returns the value of [[gamma2_2]], the second\n  polytropic index for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma3_1 module module function get_gamma3_1(THIS) Interface → Returns the value of [[gamma3_1]], the third\n  polytropic index for NS 1 with piecewise\n  polytropic EOS (innermost index) Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma3_2 module module function get_gamma3_2(THIS) Interface → Returns the value of [[gamma3_2]], the third\n  polytropic index for NS 2 with piecewise\n  polytropic EOS (innermost index) Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma_1 module module function get_gamma_1(THIS) Interface → Returns the value of [[gamma_1]], the\n  polytropic index for NS 1 with polytropic EOS,\n  not piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma_2 module module function get_gamma_2(THIS) Interface → Returns the value of [[gamma_2]], the\n  polytropic index for NS 2 with polytropic EOS,\n  not piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_grav_mass1 module module function get_grav_mass1(THIS) Interface → Returns the gravitational mass of NS 1 [ M_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_grav_mass2 module module function get_grav_mass2(THIS) Interface → Returns the gravitational mass of NS 2 [ M_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa0_1 module module function get_kappa0_1(THIS) Interface → Returns the value of [[kappa0_1]], the crust's\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa0_2 module module function get_kappa0_2(THIS) Interface → Returns the value of [[kappa0_2]], the crust's\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa1_1 module module function get_kappa1_1(THIS) Interface → Returns the value of [[kappa1_1]], the first\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa1_2 module module function get_kappa1_2(THIS) Interface → Returns the value of [[kappa1_2]], the first\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa2_1 module module function get_kappa2_1(THIS) Interface → Returns the value of [[kappa2_1]], the second\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa2_2 module module function get_kappa2_2(THIS) Interface → Returns the value of [[kappa2_2]], the second\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa3_1 module module function get_kappa3_1(THIS) Interface → Returns the value of [[kappa3_1]], the third\n  polytropic constant for NS 1 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa3_2 module module function get_kappa3_2(THIS) Interface → Returns the value of [[kappa3_2]], the third\n  polytropic constant for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa_1 module module function get_kappa_1(THIS) Interface → Returns the value of [[kappa_1]], the\n  polytropic constant for NS 1 with polytropic\n  EOS, not piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa_2 module module function get_kappa_2(THIS) Interface → Returns the value of [[kappa_2]], the\n  polytropic constant for NS 2 with polytropic\n  EOS, not piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho0_1 module module function get_logRho0_1(THIS) Interface → Returns the value of [[logRho0_1]], the base 10\n  logarithm of the mass density where the\n  gamma1_1 polytrope starts, for NS 1 with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho0_2 module module function get_logRho0_2(THIS) Interface → Returns the value of [[logRho0_2]], the base 10\n  logarithm of the mass density where the\n  gamma1_2 polytrope starts, for NS 2 with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho1_1 module module function get_logRho1_1(THIS) Interface → Returns the value of [[logRho1_1]], the base 10\n  logarithm of the mass density where the\n  gamma2_1 polytrope starts, for NS 1 with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho1_2 module module function get_logRho1_2(THIS) Interface → Returns the value of [[logRho1_2]], the base 10\n  logarithm of the mass density where the\n  gamma2_2 polytrope starts, for NS 2 with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho2_1 module module function get_logRho2_1(THIS) Interface → Returns the value of [[logRho2_1]], the base 10\n  logarithm of the mass density where the\n  gamma3_1 polytrope starts, for NS 1 with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho2_2 module module function get_logRho2_2(THIS) Interface → Returns the value of [[logRho2_2]]]], the base 10\n  logarithm of the mass density where the\n  gamma3_2 polytrope starts, for NS 2 with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logp1_1 module module function get_logp1_1(THIS) result(get_logP1_1) Interface → Returns the value of [[logp1_1]], the base 10\n  logarithm of the pressure where the gamma1_1\n  polytrope starts, for NS 1 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logp1_2 module module function get_logp1_2(THIS) result(get_logP1_2) Interface → Returns the value of [[logp1_2]], the base 10\n  logarithm of the pressure where the gamma1_2\n  polytrope starts, for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_mass module module function get_mass(THIS, i_matter) Interface → Returns the baryon mass of NS i_matter -th star\n  [ M_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision module procedure get_mass1 module module function get_mass1(THIS) Interface → Returns the baryon mass of NS 1 [ M_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_mass2 module module function get_mass2(THIS) Interface → Returns the baryon mass of NS 2 [ M_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_nbar_center1 module module function get_nbar_center1(THIS) Interface → Returns the central baryon number density\n  of NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_nbar_center2 module module function get_nbar_center2(THIS) Interface → Returns the central baryon number density\n  of NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_npeos_1 module module function get_npeos_1(THIS) Interface → Returns the identifier of the EOS for NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer module procedure get_npeos_2 module module function get_npeos_2(THIS) Interface → Returns the identifier of the EOS for NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value integer module procedure get_pressure_center1 module module function get_pressure_center1(THIS) Interface → Returns the central pressure of NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_pressure_center2 module module function get_pressure_center2(THIS) Interface → Returns the central pressure of NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radii module module function get_radii(THIS, i_matter) Interface → Returns the radii of the i_matter -th star\n  [ L_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(inout) :: THIS bnsbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) module procedure get_radius1_x_comp module module function get_radius1_x_comp(THIS) Interface → Returns the radius of NS 1 along the x axis\n  on the side of the companion Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radius1_x_opp module module function get_radius1_x_opp(THIS) Interface → Returns the radius of NS 1 along the x axis\n  on the side opposite to the companion Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radius1_y module module function get_radius1_y(THIS) Interface → Returns the radius of NS 1 along the y axis Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radius1_z module module function get_radius1_z(THIS) Interface → Returns the radius of NS 1 along the z axis Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radius2_x_comp module module function get_radius2_x_comp(THIS) Interface → Returns the radius of NS 2 along the x axis\n  on the side of the companion Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radius2_x_opp module module function get_radius2_x_opp(THIS) Interface → Returns the radius of NS 2 along the x axis\n  on the side opposite to the companion Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radius2_y module module function get_radius2_y(THIS) Interface → Returns the radius of NS 2 along the y axis Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radius2_z module module function get_radius2_z(THIS) Interface → Returns the radius of NS 2 along the z axis Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_rho_center1 module module function get_rho_center1(THIS) Interface → Returns the central baryon mass density\n  of NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_rho_center2 module module function get_rho_center2(THIS) Interface → Returns the central baryon mass density\n  of NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_specific_energy_center1 module module function get_specific_energy_center1(THIS) Interface → Returns the central specific energy of NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision module procedure get_specific_energy_center2 module module function get_specific_energy_center2(THIS) Interface → Returns the central specific energy of NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnsbase ), intent(in) :: THIS bnsbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"module/bns_base_access.html"},{"title":"bns_lorene_import – SPHINCS_LORENE","text":"Implementation of the methods of TYPE bns that\n  import BNS data using \\texttt{LORENE} FT 23.10.2020 Renamed from bns_methods to bns_import upon\n  improving modularity OMP parallelized loops that call \\texttt{LORENE}\n  in all MODULE PROCEDURE FT 12.07.2021 Uses Ancestors: bns_lorene module~~bns_lorene_import~~UsesGraph module~bns_lorene_import bns_lorene_import module~bns_lorene bns_lorene module~bns_lorene_import->module~bns_lorene module~id_base id_base module~bns_lorene->module~id_base timing timing module~bns_lorene->timing module~utility utility module~bns_lorene->module~utility iso_c_binding iso_c_binding module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~id_base->timing matrix matrix module~utility->matrix module~bns_base->module~id_base module~bns_base->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures import_id_full import_id_hydro import_id_int import_id_k import_id_mass_b import_id_particles import_id_spacetime import_mass_density import_spatial_metric is_hydro_negative Module Procedures module procedure import_id_full module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Interface → Stores the ID in non-[[bnslorene]]-member arrays\n  with the same shape as the [[bnslorene]] member arrays Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z module procedure import_id_hydro module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Interface → Stores the hydro ID in the arrays needed to compute\n  the constraints on the refined mesh Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler module procedure import_id_int module module subroutine import_id_int(THIS, n, x, y, z) Interface → Stores the ID in the [[bnslorene]] member arrays Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z module procedure import_id_k module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Interface → Stores the components of the extrinsic curvature\n  in arrays Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz module procedure import_id_mass_b module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Interface → Stores the hydro ID in the arrays needed to\n  compute the baryon mass, storing it to variables\n  (not arrays as the others SUBROUTINES in\n  the [[bns_import]] SUBMODULE). Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler module procedure import_id_particles module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Interface → Stores the hydro ID in the arrays needed to\n  compute the SPH ID Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z module procedure import_id_spacetime module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Interface → Stores the spacetime ID in multi-dimensional arrays\n  needed to compute the BSSN variables and constraints Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek module procedure import_mass_density module module function import_mass_density(THIS, x, y, z) result(res) Interface → Returns the \\texttt{LORENE} mass density at the point\n  given as argument, in units of M_\\odot/L_\\odot&#94;3 . Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) module procedure import_spatial_metric module module function import_spatial_metric(THIS, x, y, z) result(res) Interface → Returns the \\texttt{LORENE} conformal factor to the\n  4th power, equal to the diagonal components\n  of the conformally flat spatial ADM metric. Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) module procedure is_hydro_negative module module function is_hydro_negative(THIS, x, y, z) result(res) Interface → Return 1 if the energy density is nonpositive\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive\n  at the specified point Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise","tags":"","loc":"module/bns_lorene_import.html"},{"title":"bns_lorene_access – SPHINCS_LORENE","text":"The module contains the implementation of the\n  methods of TYPE bns that allow to access PRIVATE\n  members. FT 12.07.2021 Uses Ancestors: bns_lorene module~~bns_lorene_access~~UsesGraph module~bns_lorene_access bns_lorene_access module~bns_lorene bns_lorene module~bns_lorene_access->module~bns_lorene module~id_base id_base module~bns_lorene->module~id_base timing timing module~bns_lorene->timing module~utility utility module~bns_lorene->module~utility iso_c_binding iso_c_binding module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~id_base->timing matrix matrix module~utility->matrix module~bns_base->module~id_base module~bns_base->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures get_bns_identifier get_eos1_loreneid get_eos2_loreneid get_eos_parameters get_field_array get_field_value Module Procedures module procedure get_bns_identifier module module function get_bns_identifier(THIS) Interface → Returns the value of [[bns_identifier]], the\n  integer identifier of the bns object Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value double precision module procedure get_eos1_loreneid module module function get_eos1_loreneid(THIS) Interface → Returns the \\texttt{LORENE} ID-number of the EOS for NS 1 Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer module procedure get_eos2_loreneid module module function get_eos2_loreneid(THIS) Interface → Returns the \\texttt{LORENE} ID-number of the EOS for NS 2 Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of Return Value integer module procedure get_eos_parameters module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Interface → Returns the EoS parameters of the i_matter -s star Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the i_matter -th\n matter object module procedure get_field_array module module function get_field_array(THIS, field) result(field_array) Interface → Returns one of the member arrays, selected\n  with the string input. Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Desired bnslorene member array module procedure get_field_value module module function get_field_value(THIS, field, n) result(field_value) Interface → Returns the value of one of the member arrays,\n  selected with the string input, at the point\n  given as argument. Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(in) :: THIS bnslorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired bnslorene member array integer, intent(in) :: n Component of the desired bnslorene member array Return Value double precision Component n of the desired bnslorene member array","tags":"","loc":"module/bns_lorene_access.html"},{"title":"bns_lorene_params – SPHINCS_LORENE","text":"Implementation of the methods of TYPE bns\n  that import from \\texttt{LORENE} the\n  parameters of the binary system,\n  and print them to the standard output. FT 09.07.2021 Uses Ancestors: bns_lorene module~~bns_lorene_params~~UsesGraph module~bns_lorene_params bns_lorene_params module~bns_lorene bns_lorene module~bns_lorene_params->module~bns_lorene module~id_base id_base module~bns_lorene->module~id_base timing timing module~bns_lorene->timing module~utility utility module~bns_lorene->module~utility iso_c_binding iso_c_binding module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~id_base->timing matrix matrix module~utility->matrix module~bns_base->module~id_base module~bns_base->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures import_id_params print_id_params Module Procedures module procedure import_id_params module module subroutine import_id_params(THIS) Interface → Store the parameters of the binary neutron\n  stars' \\texttt{LORENE} ID into member variables Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of module procedure print_id_params module module subroutine print_id_params(THIS) Interface → Print the parameters of the binary neutron\n  stars' initial data computed by \\texttt{LORENE} Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of","tags":"","loc":"module/bns_lorene_params.html"},{"title":"bns_lorene_memory – SPHINCS_LORENE","text":"Implementation of the methods of TYPE bns\n  that (de)allocate memory FT 9.07.2021 Uses Ancestors: bns_lorene module~~bns_lorene_memory~~UsesGraph module~bns_lorene_memory bns_lorene_memory module~bns_lorene bns_lorene module~bns_lorene_memory->module~bns_lorene module~id_base id_base module~bns_lorene->module~id_base timing timing module~bns_lorene->timing module~utility utility module~bns_lorene->module~utility iso_c_binding iso_c_binding module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~id_base->timing matrix matrix module~utility->matrix module~bns_base->module~id_base module~bns_base->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures allocate_lorene_id_memory deallocate_lorene_id_memory Module Procedures module procedure allocate_lorene_id_memory module module subroutine allocate_lorene_id_memory(THIS, d) Interface → Allocate the memory to store the LORENE ID\n  in the member arrays Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays module procedure deallocate_lorene_id_memory module module subroutine deallocate_lorene_id_memory(THIS) Interface → Deallocate the memory for the member arrays Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of","tags":"","loc":"module/bns_lorene_memory.html"},{"title":"bns_lorene_constructor – SPHINCS_LORENE","text":"Implementation of the constructor and\n  destructor of TYPE bnslorene , and of the bnslorene -member\n  PROCEDURES that call the C-bound PROCEDURES\n  constructig and destructing the \\texttt{LORENE}\n  \\texttt{Bin_NS} object FT 23.10.2020 Uses Ancestors: bns_lorene module~~bns_lorene_constructor~~UsesGraph module~bns_lorene_constructor bns_lorene_constructor module~bns_lorene bns_lorene module~bns_lorene_constructor->module~bns_lorene module~id_base id_base module~bns_lorene->module~id_base timing timing module~bns_lorene->timing module~utility utility module~bns_lorene->module~utility iso_c_binding iso_c_binding module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~id_base->timing matrix matrix module~utility->matrix module~bns_base->module~id_base module~bns_base->module~utility Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures construct_binary construct_bnslorene destruct_binary destruct_bnslorene Module Procedures module procedure construct_binary module module subroutine construct_binary(THIS, resu_file) Interface → Construct the \\texttt{LORENE} \\texttt{Bin_NS} object Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID module procedure construct_bnslorene module module function construct_bnslorene(resu_file) result(bns_obj) Interface → Constructs an object of TYPE [[bnslorene]] Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral BNS ID Return Value type( bnslorene ) Constructed bnslorene object module procedure destruct_binary module module subroutine destruct_binary(THIS) Interface → Destructs the \\texttt{LORENE} \\texttt{Bin_NS} object and frees\n  the pointer [[bns:bns_ptr]] pointing to it Read more… Arguments Type Intent Optional Attributes Name class( bnslorene ), intent(inout) :: THIS bnslorene object which this PROCEDURE is a member of module procedure destruct_bnslorene module module subroutine destruct_bnslorene(THIS) Interface → Destructs an object of TYPE [[bnslorene]] Read more… Arguments Type Intent Optional Attributes Name type( bnslorene ), intent(inout) :: THIS bnslorene object to be destructed","tags":"","loc":"module/bns_lorene_constructor.html"},{"title":"diffstar_base_access – SPHINCS_LORENE","text":"The module contains the implementation of the\n  methods of TYPE diffstarbase that allow to\n  access PRIVATE members. FT 22.10.2021 Uses Ancestors: diffstar_base module~~diffstar_base_access~~UsesGraph module~diffstar_base_access diffstar_base_access module~diffstar_base diffstar_base module~diffstar_base_access->module~diffstar_base module~id_base id_base module~diffstar_base->module~id_base module~utility utility module~diffstar_base->module~utility timing timing module~id_base->timing matrix matrix module~utility->matrix Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures get_angular_momentum get_area_radius get_barycenter get_center get_energy_density_center get_ent_center get_eos get_f_isco get_gamma get_gamma0 get_gamma1 get_gamma2 get_gamma3 get_grv2 get_grv3 get_kappa get_kappa0 get_kappa1 get_kappa2 get_kappa3 get_logRho0 get_logRho1 get_logRho2 get_logp1 get_mass get_mass_grav get_nbar_center get_npeos get_omega_c get_pressure_center get_r_circ get_r_eq get_r_eq_3pi2 get_r_eq_pi get_r_eq_pi2 get_r_isco get_r_mean get_r_pole get_r_ratio get_radii get_rho_center get_specific_angular_momentum_isco get_specific_energy_center get_specific_energy_isco get_surface_area get_tsw Module Procedures module procedure get_angular_momentum module module function get_angular_momentum(THIS) Interface → Returns the angular momentum of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_area_radius module module function get_area_radius(THIS) Interface → Returns [[diffstarbase:area_radius]], the\n  areal radius of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_barycenter module module function get_barycenter(THIS, i_matter) Interface → Returns the barycenter of the DRS [ L_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) module procedure get_center module module function get_center(THIS, i_matter) Interface → Returns the center of the DRS [ L_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return Return Value double precision,\n  DIMENSION(3) module procedure get_energy_density_center module module function get_energy_density_center(THIS) Interface → Returns the central energy density of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_ent_center module module function get_ent_center(THIS) Interface → Returns the central enthalpy of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_eos module module function get_eos(THIS, i_matter) Interface → Returns the EoS name of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value character(len=:),\n  ALLOCATABLE module procedure get_f_isco module module function get_f_isco(THIS) Interface → Returns [[diffstarbase:f_isco]], the orbital\n  frequency of the Innermost Stable Circular Orbit\n  (ISCO) Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma module module function get_gamma(THIS) Interface → Returns the value of [[gamma]], the\n  polytropic index for polytropic EOS,\n  not piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma0 module module function get_gamma0(THIS) Interface → Returns the value of [[gamma0]], the crust's\n  polytropic index for the DRS with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma1 module module function get_gamma1(THIS) Interface → Returns the value of [[gamma1]], the first\n  polytropic index for the DRS with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma2 module module function get_gamma2(THIS) Interface → Returns the value of [[gamma2]], the second\n  polytropic index for NS 2 with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_gamma3 module module function get_gamma3(THIS) Interface → Returns the value of [[gamma3]], the third\n  polytropic index for the DRS with piecewise\n  polytropic EOS (innermost index) Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_grv2 module module function get_grv2(THIS) Interface → Returns [[diffstarbase:grv2]], the error on the\n  virial identity {\\rm GRV2} . Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_grv3 module module function get_grv3(THIS) Interface → Returns [[diffstarbase:grv3]], the error on the\n  virial identity {\\rm GRV3} . Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa module module function get_kappa(THIS) Interface → Returns the value of [[kappa]], the\n  polytropic constant for polytropic\n  EOS, not piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa0 module module function get_kappa0(THIS) Interface → Returns the value of [[kappa0]], the crust's\n  polytropic constant for the DRS with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa1 module module function get_kappa1(THIS) Interface → Returns the value of [[kappa1]], the first\n  polytropic constant for the DRS with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa2 module module function get_kappa2(THIS) Interface → Returns the value of [[kappa2]], the second\n  polytropic constant for the DRS with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_kappa3 module module function get_kappa3(THIS) Interface → Returns the value of [[kappa3]], the third\n  polytropic constant for the DRS with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho0 module module function get_logRho0(THIS) Interface → Returns the value of [[logRho0]], the base 10\n  logarithm of the mass density where the\n  gamma1 polytrope starts, for the DRS with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho1 module module function get_logRho1(THIS) Interface → Returns the value of [[logRho1]], the base 10\n  logarithm of the mass density where the\n  gamma2 polytrope starts, for the DRS with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logRho2 module module function get_logRho2(THIS) Interface → Returns the value of [[logRho2]], the base 10\n  logarithm of the mass density where the\n  gamma3 polytrope starts, for the DRS with\n  piecewise polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_logp1 module module function get_logp1(THIS) result(get_logP1) Interface → Returns the value of [[logp1]], the base 10\n  logarithm of the pressure where the gamma1\n  polytrope starts, for the DRS with piecewise\n  polytropic EOS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_mass module module function get_mass(THIS, i_matter) Interface → Returns the baryon mass of the DRS [ M_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Return Value double precision module procedure get_mass_grav module module function get_mass_grav(THIS) Interface → Returns the gravitational mass of the DRS [ M_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_nbar_center module module function get_nbar_center(THIS) Interface → Returns the central baryon number density\n  of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_npeos module module function get_npeos(THIS) Interface → Returns the identifier of the EOS for the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value integer module procedure get_omega_c module module function get_omega_c(THIS) Interface → Returns [[omega_c]], the central  angular\n  velocity of the system Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_pressure_center module module function get_pressure_center(THIS) Interface → Returns the central pressure of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_circ module module function get_r_circ(THIS) Interface → Returns [[diffstarbase:r_circ]], the\n  circumferential radius of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_eq module module function get_r_eq(THIS) Interface → Returns [[diffstarbase:r_eq]], the\n  equatorial radius of the DRS at \\phi=0 Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_eq_3pi2 module module function get_r_eq_3pi2(THIS) Interface → Returns [[diffstarbase:r_eq_3pi2]], the\n  equatorial radius of the DRS at \\phi=\\dfrac{3\\pi}{2} Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_eq_pi module module function get_r_eq_pi(THIS) Interface → Returns [[diffstarbase:r_eq_pi]], the\n  equatorial radius of the DRS at \\phi=\\pi Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_eq_pi2 module module function get_r_eq_pi2(THIS) Interface → Returns [[diffstarbase:r_eq_pi2]], the\n  equatorial radius of the DRS at \\phi=\\dfrac{\\pi}{2} Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_isco module module function get_r_isco(THIS) Interface → Returns [[diffstarbase:r_isco]], the\n  radius of the Innermost Stable Circular Orbit (ISCO) Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_mean module module function get_r_mean(THIS) Interface → Returns [[diffstarbase:r_mean]], the\n  circumferential radius of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_pole module module function get_r_pole(THIS) Interface → Returns [[diffstarbase:r_pole]], the\n  polar radius of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_r_ratio module module function get_r_ratio(THIS) Interface → Returns [[diffstarbase:r_ratio]], the\n  Ratio [[diffstarbase:r_pole]]/[[diffstarbase:r_eq]] Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_radii module module function get_radii(THIS, i_matter) Interface → Returns the radii of the DRS [ L_\\odot ] Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(inout) :: THIS diffstarbase object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose string is to return Return Value double precision,\n  DIMENSION(6) module procedure get_rho_center module module function get_rho_center(THIS) Interface → Returns the central baryon mass density\n  of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_specific_angular_momentum_isco module module function get_specific_angular_momentum_isco(THIS) Interface → Returns [[diffstarbase:specific_angular_momentum_isco]],\n  the specific angular momentum of a test particle\n  at the Innermost Stable Circular Orbit (ISCO) Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_specific_energy_center module module function get_specific_energy_center(THIS) Interface → Returns the central specific energy of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_specific_energy_isco module module function get_specific_energy_isco(THIS) Interface → Returns [[diffstarbase:specific_energy_isco]],\n  the specific energy of a test particle at the\n  Innermost Stable Circular Orbit (ISCO) Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_surface_area module module function get_surface_area(THIS) Interface → Returns [[diffstarbase:surface_area]], the\n  surface area of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision module procedure get_tsw module module function get_tsw(THIS) Interface → Returns [[diffstarbase:tsw]], the ratio T/W between the kinetic and gravitational potential\n  energy of the DRS\n  FT 22.10.2021 Read more… Arguments Type Intent Optional Attributes Name class( diffstarbase ), intent(in) :: THIS diffstarbase object which this PROCEDURE is a member of Return Value double precision","tags":"","loc":"module/diffstar_base_access.html"},{"title":"diffstar_lorene_memory – SPHINCS_LORENE","text":"Implementation of the methods of TYPE diffstar\n  that (de)allocate memory FT 25.10.2021 Uses Ancestors: diffstar_lorene module~~diffstar_lorene_memory~~UsesGraph module~diffstar_lorene_memory diffstar_lorene_memory module~diffstar_lorene diffstar_lorene module~diffstar_lorene_memory->module~diffstar_lorene module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base timing timing module~diffstar_lorene->timing module~utility utility module~diffstar_lorene->module~utility iso_c_binding iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base->module~utility module~id_base id_base module~diffstar_base->module~id_base matrix matrix module~utility->matrix module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures allocate_diffstar_memory deallocate_diffstar_memory Module Procedures module procedure allocate_diffstar_memory module module subroutine allocate_diffstar_memory(THIS, d) Interface → Allocate the memory to store the LORENE ID\n  in the member arrays Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: d Dimension of the arrays module procedure deallocate_diffstar_memory module module subroutine deallocate_diffstar_memory(THIS) Interface → Deallocate the memory for the member arrays Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of","tags":"","loc":"module/diffstar_lorene_memory.html"},{"title":"diffstar_lorene_access – SPHINCS_LORENE","text":"The module contains the implementation of the\n  methods of TYPE diffstar that allow to access PRIVATE\n  members. FT 25.10.2021 Uses Ancestors: diffstar_lorene module~~diffstar_lorene_access~~UsesGraph module~diffstar_lorene_access diffstar_lorene_access module~diffstar_lorene diffstar_lorene module~diffstar_lorene_access->module~diffstar_lorene module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base timing timing module~diffstar_lorene->timing module~utility utility module~diffstar_lorene->module~utility iso_c_binding iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base->module~utility module~id_base id_base module~diffstar_base->module~id_base matrix matrix module~utility->matrix module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures get_diffstar_identifier get_eos_loreneid get_eos_parameters get_field_array get_field_value Module Procedures module procedure get_diffstar_identifier module module function get_diffstar_identifier(THIS) Interface → Returns the value of [[diffstar_identifier]], the\n  integer identifier of the diffstar object Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value double precision module procedure get_eos_loreneid module module function get_eos_loreneid(THIS) Interface → Returns the \\texttt{LORENE} ID-number of the EOS of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of Return Value integer module procedure get_eos_parameters module module subroutine get_eos_parameters(THIS, i_matter, eos_params) Interface → Returns the EoS parameters of the DRS Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: i_matter Index of the matter object whose parameter is to return double precision, intent(out), DIMENSION(:), ALLOCATABLE :: eos_params Array containing the parameters of the EoS for the DRS module procedure get_field_array module module function get_field_array(THIS, field) result(field_array) Interface → Returns one of the member arrays, selected\n  with the string input. Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array Return Value double precision,\n  DIMENSION(:), ALLOCATABLE Desired diffstarlorene member array module procedure get_field_value module module function get_field_value(THIS, field, n) result(field_value) Interface → Returns the value of one of the member arrays,\n  selected with the string input, at the point\n  given as argument. Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of character(len=:), intent(in), ALLOCATABLE :: field Name of the desired diffstarlorene member array integer, intent(in) :: n Component of the desired diffstarlorene member array Return Value double precision Component n of the desired diffstarlorene member array","tags":"","loc":"module/diffstar_lorene_access.html"},{"title":"diffstar_lorene_params – SPHINCS_LORENE","text":"Implementation of the methods of TYPE diffstar\n  that import from \\texttt{LORENE} the\n  parameters of the binary system,\n  and print them to the standard output. FT 09.07.2021 Uses Ancestors: diffstar_lorene module~~diffstar_lorene_params~~UsesGraph module~diffstar_lorene_params diffstar_lorene_params module~diffstar_lorene diffstar_lorene module~diffstar_lorene_params->module~diffstar_lorene module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base timing timing module~diffstar_lorene->timing module~utility utility module~diffstar_lorene->module~utility iso_c_binding iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base->module~utility module~id_base id_base module~diffstar_base->module~id_base matrix matrix module~utility->matrix module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures import_diffstar_params print_diffstar_params Module Procedures module procedure import_diffstar_params module module subroutine import_diffstar_params(THIS) Interface → Store the parameters of the binary neutron\n  stars' \\texttt{LORENE} ID into member variables Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of module procedure print_diffstar_params module module subroutine print_diffstar_params(THIS) Interface → Print the parameters of the binary neutron\n  stars' initial data computed by \\texttt{LORENE} Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of","tags":"","loc":"module/diffstar_lorene_params.html"},{"title":"diffstar_lorene_import – SPHINCS_LORENE","text":"Implementation of the methods of TYPE bns that\n  import BNS data using \\texttt{LORENE} FT 25.10.2021 Uses iso_c_binding Ancestors: diffstar_lorene module~~diffstar_lorene_import~~UsesGraph module~diffstar_lorene_import diffstar_lorene_import module~diffstar_lorene diffstar_lorene module~diffstar_lorene_import->module~diffstar_lorene iso_c_binding iso_c_binding module~diffstar_lorene_import->iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base timing timing module~diffstar_lorene->timing module~utility utility module~diffstar_lorene->module~utility module~diffstar_base->module~utility module~id_base id_base module~diffstar_base->module~id_base matrix matrix module~utility->matrix module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures import_id_full import_id_hydro import_id_int import_id_k import_id_mass_b import_id_particles import_id_spacetime import_mass_density import_spatial_metric is_hydro_negative Module Procedures module procedure import_id_full module module subroutine import_id_full(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz, baryon_density, energy_density, specific_energy, u_euler_x, u_euler_y, u_euler_z) Interface → Stores the ID in non-[[diffstarlorene]]-member arrays\n  with the same shape as the [[diffstarlorene]] member arrays Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z module procedure import_id_hydro module module subroutine import_id_hydro(THIS, nx, ny, nz, pos, baryon_density, energy_density, specific_energy, pressure, u_euler) Interface → Stores the hydro ID in the arrays needed to compute\n  the constraints on the refined mesh Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: baryon_density double precision, intent(inout), DIMENSION(:,:,:) :: energy_density double precision, intent(inout), DIMENSION(:,:,:) :: specific_energy double precision, intent(inout), DIMENSION(:,:,:) :: pressure double precision, intent(inout), DIMENSION(:,:,:,:) :: u_euler module procedure import_id_int module module subroutine import_id_int(THIS, n, x, y, z) Interface → Stores the ID in the [[diffstarlorene]] member arrays Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z module procedure import_id_k module module subroutine import_id_k(THIS, n, x, y, z, k_xx, k_xy, k_xz, k_yy, k_yz, k_zz) Interface → Stores the components of the extrinsic curvature\n  in arrays Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n double precision, intent(in), DIMENSION(:) :: x double precision, intent(in), DIMENSION(:) :: y double precision, intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: k_xx double precision, intent(inout), DIMENSION(:) :: k_xy double precision, intent(inout), DIMENSION(:) :: k_xz double precision, intent(inout), DIMENSION(:) :: k_yy double precision, intent(inout), DIMENSION(:) :: k_yz double precision, intent(inout), DIMENSION(:) :: k_zz module procedure import_id_mass_b module module subroutine import_id_mass_b(THIS, x, y, z, g_xx, baryon_density, gamma_euler) Interface → Stores the hydro ID in the arrays needed to\n  compute the baryon mass, storing it to variables\n  (not arrays as the others SUBROUTINES in\n  the [[bns_import]] SUBMODULE). Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in) :: x double precision, intent(in) :: y double precision, intent(in) :: z double precision, intent(inout) :: g_xx double precision, intent(inout) :: baryon_density double precision, intent(inout) :: gamma_euler module procedure import_id_particles module module subroutine import_id_particles(THIS, n, x, y, z, lapse, shift_x, shift_y, shift_z, g_xx, g_xy, g_xz, g_yy, g_yz, g_zz, baryon_density, energy_density, specific_energy, pressure, u_euler_x, u_euler_y, u_euler_z) Interface → Stores the hydro ID in the arrays needed to\n  compute the SPH ID Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: n real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: x real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: y real(kind=C_DOUBLE), intent(in), DIMENSION(:) :: z double precision, intent(inout), DIMENSION(:) :: lapse double precision, intent(inout), DIMENSION(:) :: shift_x double precision, intent(inout), DIMENSION(:) :: shift_y double precision, intent(inout), DIMENSION(:) :: shift_z double precision, intent(inout), DIMENSION(:) :: g_xx double precision, intent(inout), DIMENSION(:) :: g_xy double precision, intent(inout), DIMENSION(:) :: g_xz double precision, intent(inout), DIMENSION(:) :: g_yy double precision, intent(inout), DIMENSION(:) :: g_yz double precision, intent(inout), DIMENSION(:) :: g_zz double precision, intent(inout), DIMENSION(:) :: baryon_density double precision, intent(inout), DIMENSION(:) :: energy_density double precision, intent(inout), DIMENSION(:) :: specific_energy double precision, intent(inout), DIMENSION(:) :: pressure double precision, intent(inout), DIMENSION(:) :: u_euler_x double precision, intent(inout), DIMENSION(:) :: u_euler_y double precision, intent(inout), DIMENSION(:) :: u_euler_z module procedure import_id_spacetime module module subroutine import_id_spacetime(THIS, nx, ny, nz, pos, lapse, shift, g, ek) Interface → Stores the spacetime ID in multi-dimensional arrays\n  needed to compute the BSSN variables and constraints Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of integer, intent(in) :: nx integer, intent(in) :: ny integer, intent(in) :: nz double precision, intent(in), DIMENSION(:,:,:,:) :: pos double precision, intent(inout), DIMENSION(:,:,:) :: lapse double precision, intent(inout), DIMENSION(:,:,:,:) :: shift double precision, intent(inout), DIMENSION(:,:,:,:) :: g double precision, intent(inout), DIMENSION(:,:,:,:) :: ek module procedure import_mass_density module module function import_mass_density(THIS, x, y, z) result(res) Interface → Returns the \\texttt{LORENE} mass density at the point\n  given as argument, in units of M_\\odot/L_\\odot&#94;3 . Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value double precision Baryon mass density at (x,y,z) module procedure import_spatial_metric module module function import_spatial_metric(THIS, x, y, z) result(res) Interface → Returns the \\texttt{LORENE} conformal factor to the\n  4th power, equal to the diagonal components\n  of the conformally flat spatial ADM metric. Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of real(kind=C_DOUBLE), intent(in), VALUE :: x x coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: y y coordinate of the desired point real(kind=C_DOUBLE), intent(in), VALUE :: z z coordinate of the desired point Return Value real(kind=C_DOUBLE) g_{xx}=g_{yy}=g_{zz} at (x,y,z) module procedure is_hydro_negative module module function is_hydro_negative(THIS, x, y, z) result(res) Interface → Return 1 if the energy density is nonpositive\n  or if the specific energy is nonpositive,\n  or if the pressure is nonpositive\n  at the specified point Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(in) :: THIS diffstarlorene object which this PROCEDURE is a member of double precision, intent(in), VALUE :: x x coordinate of the desired point double precision, intent(in), VALUE :: y y coordinate of the desired point double precision, intent(in), VALUE :: z z coordinate of the desired point Return Value integer 1 if the energy density or the specific energy or the pressure\n are negative, 0 otherwise","tags":"","loc":"module/diffstar_lorene_import.html"},{"title":"diffstar_lorene_constructor – SPHINCS_LORENE","text":"Implementation of the constructor and\n  destructor of TYPE diffstarlorene , and of the diffstarlorene -member\n  PROCEDURES that call the C-bound PROCEDURES\n  constructig and destructing the \\texttt{LORENE}\n  \\texttt{Et_diffrot} object FT 25.10.2021 Uses iso_c_binding Ancestors: diffstar_lorene module~~diffstar_lorene_constructor~~UsesGraph module~diffstar_lorene_constructor diffstar_lorene_constructor module~diffstar_lorene diffstar_lorene module~diffstar_lorene_constructor->module~diffstar_lorene iso_c_binding iso_c_binding module~diffstar_lorene_constructor->iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base timing timing module~diffstar_lorene->timing module~utility utility module~diffstar_lorene->module~utility module~diffstar_base->module~utility module~id_base id_base module~diffstar_base->module~id_base matrix matrix module~utility->matrix module~id_base->timing Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Module Procedures construct_diffstarlorene construct_drs destruct_diffstarlorene destruct_drs Module Procedures module procedure construct_diffstarlorene module module function construct_diffstarlorene(resu_file) result(drs) Interface → Constructs an object of TYPE [[diffstarlorene]] Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID Return Value type( diffstarlorene ) Constructed diffstarlorene object module procedure construct_drs module module subroutine construct_drs(THIS, resu_file) Interface → Construct the \\texttt{LORENE} \\texttt{Et_diffrot} object Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of character(kind=C_CHAR,len=*), intent(in), optional :: resu_file \\texttt{LORENE} binary file containing the spectral DRS ID module procedure destruct_diffstarlorene module module subroutine destruct_diffstarlorene(THIS) Interface → Destructs an object of TYPE [[diffstarlorene]] Read more… Arguments Type Intent Optional Attributes Name type( diffstarlorene ), intent(inout) :: THIS diffstarlorene object to be destructed module procedure destruct_drs module module subroutine destruct_drs(THIS) Interface → Destructs the \\texttt{LORENE} \\texttt{Et_diffrot} object and frees\n  the pointer [[diffstar:diffstar_ptr]] pointing to it Read more… Arguments Type Intent Optional Attributes Name class( diffstarlorene ), intent(inout) :: THIS diffstarlorene object which this PROCEDURE is a member of","tags":"","loc":"module/diffstar_lorene_constructor.html"},{"title":"convergence_test – SPHINCS_LORENE","text":"Uses sphincs_lorene program~~convergence_test~~UsesGraph program~convergence_test convergence_test module~sphincs_lorene sphincs_lorene program~convergence_test->module~sphincs_lorene module~formul_3p1_id formul_3p1_id module~sphincs_lorene->module~formul_3p1_id module~id_base id_base module~sphincs_lorene->module~id_base timing timing module~sphincs_lorene->timing module~utility utility module~sphincs_lorene->module~utility module~particles_id particles_id module~sphincs_lorene->module~particles_id module~diffstar_lorene diffstar_lorene module~sphincs_lorene->module~diffstar_lorene module~bns_lorene bns_lorene module~sphincs_lorene->module~bns_lorene module~formul_bssn_id formul_bssn_id module~sphincs_lorene->module~formul_bssn_id module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id mesh_refinement mesh_refinement module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility module~diffstar_lorene->timing module~diffstar_lorene->module~utility iso_c_binding iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base module~bns_lorene->module~id_base module~bns_lorene->timing module~bns_lorene->module~utility module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~formul_bssn_id->module~formul_3p1_id module~formul_bssn_id->module~id_base module~formul_bssn_id->timing module~formul_bssn_id->module~utility module~formul_bssn_id->module~particles_id module~formul_bssn_id->mesh_refinement module~diffstar_base->module~id_base module~diffstar_base->module~utility module~bns_base->module~id_base module~bns_base->module~utility var panprogramconvergence_testUsesGraph = svgPanZoom('#programconvergence_testUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~convergence_test~~CallsGraph program~convergence_test convergence_test proc~cauchy_convergence_test_unknown cauchy_convergence_test_unknown program~convergence_test->proc~cauchy_convergence_test_unknown interface~bnslorene bnslorene program~convergence_test->interface~bnslorene proc~read_bns_id_parameters read_bns_id_parameters program~convergence_test->proc~read_bns_id_parameters interface~particles particles program~convergence_test->interface~particles timer timer program~convergence_test->timer proc~cauchy_convergence_test_known cauchy_convergence_test_known program~convergence_test->proc~cauchy_convergence_test_known interface~bssn_id bssn_id program~convergence_test->interface~bssn_id interface~construct_bnslorene construct_bnslorene interface~bnslorene->interface~construct_bnslorene interface~construct_particles construct_particles interface~particles->interface~construct_particles interface~construct_bssn_id construct_bssn_id interface~bssn_id->interface~construct_bssn_id proc~construct_bnslorene construct_bnslorene interface~construct_bnslorene->proc~construct_bnslorene proc~construct_particles construct_particles interface~construct_particles->proc~construct_particles proc~construct_bssn_id construct_bssn_id interface~construct_bssn_id->proc~construct_bssn_id proc~construct_particles->timer proc~check_particle_positions check_particle_positions proc~construct_particles->proc~check_particle_positions read_options read_options proc~construct_particles->read_options set_units set_units proc~construct_particles->set_units ktable ktable proc~construct_particles->ktable alive alive proc~construct_particles->alive interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory proc~construct_particles->interface~allocate_lorene_id_parts_memory proc~construct_bnslorene->timer interface~import_id_params import_id_params proc~construct_bnslorene->interface~import_id_params proc~construct_bssn_id->timer initialize_bssn initialize_bssn proc~construct_bssn_id->initialize_bssn interface~allocate_bssn_fields allocate_bssn_fields proc~construct_bssn_id->interface~allocate_bssn_fields deallocate_bssn deallocate_bssn proc~construct_bssn_id->deallocate_bssn indexx indexx proc~check_particle_positions->indexx proc~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields->proc~allocate_bssn_fields proc~import_id_params import_id_params interface~import_id_params->proc~import_id_params proc~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory->proc~allocate_lorene_id_parts_memory interface~print_id_params print_id_params proc~import_id_params->interface~print_id_params k_lorene2hydrobase k_lorene2hydrobase proc~import_id_params->k_lorene2hydrobase interface~get_lorene_id_params get_lorene_id_params proc~import_id_params->interface~get_lorene_id_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_id_params->k_lorene2hydrobase_piecewisepolytrope allocate_grid_function allocate_grid_function proc~allocate_bssn_fields->allocate_grid_function proc~print_id_params print_id_params interface~print_id_params->proc~print_id_params proc~print_id_params->k_lorene2hydrobase var panprogramconvergence_testCallsGraph = svgPanZoom('#programconvergence_testCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables binary bssn_forms common_path compute_constraints compute_parts_constraints constraints_step debug denominator_ratio_dx execution_timer export_bin export_constraints export_constraints_details export_constraints_x export_constraints_xy export_form export_form_x export_form_xy filenames max_bssn max_length max_n_bns max_n_parts min_bssn n_bns name_logfile namefile_bssn namefile_parts namefile_sph numerator_ratio_dx one_lapse original_dx particles_dist placer ratio_dx ref_lev run_spacetime run_sph spacetime_path sph_path test_int zero_shift Subroutines cauchy_convergence_test_known cauchy_convergence_test_unknown read_bns_id_parameters Source Code convergence_test Variables Type Attributes Name Initial type( bnslorene ) :: binary type( bssn_id ), DIMENSION(3) :: bssn_forms character(len=max_length) :: common_path logical :: compute_constraints logical :: compute_parts_constraints integer :: constraints_step logical, parameter :: debug = .FALSE. double precision :: denominator_ratio_dx type(timer) :: execution_timer logical :: export_bin logical :: export_constraints logical :: export_constraints_details logical :: export_constraints_x logical :: export_constraints_xy logical :: export_form logical :: export_form_x logical :: export_form_xy character(len=max_length), DIMENSION( max_length ) :: filenames = \"0\" integer, parameter :: max_bssn = 3 integer, parameter :: max_length = 50 integer, parameter :: max_n_bns = 50 integer, parameter :: max_n_parts = 250 integer, parameter :: min_bssn = 1 integer :: n_bns character(len=500) :: name_logfile character(len=500) :: namefile_bssn character(len=500) :: namefile_parts character(len=500) :: namefile_sph double precision :: numerator_ratio_dx logical :: one_lapse double precision :: original_dx type( particles ) :: particles_dist integer, DIMENSION( max_n_bns, max_n_parts ) :: placer = test_int double precision :: ratio_dx integer :: ref_lev logical :: run_spacetime logical :: run_sph character(len=max_length) :: spacetime_path character(len=max_length) :: sph_path integer, parameter :: test_int = -112 logical :: zero_shift Subroutines subroutine cauchy_convergence_test_known (formul_dx, formul_dx2, use_constraints, ref_lev) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: formul_dx class( formul_3p1 ), intent(inout) :: formul_dx2 integer, intent(in) :: use_constraints integer, intent(in) :: ref_lev subroutine cauchy_convergence_test_unknown (formul_dx, formul_dx2, formul_dx4, use_constraints, ref_lev) Arguments Type Intent Optional Attributes Name class( formul_3p1 ), intent(inout) :: formul_dx class( formul_3p1 ), intent(inout) :: formul_dx2 class( formul_3p1 ), intent(inout) :: formul_dx4 integer, intent(in) :: use_constraints integer, intent(in) :: ref_lev subroutine read_bns_id_parameters () Arguments None Source Code PROGRAM convergence_test !***************************************************** !                                                    * ! Make a convergence test to check the validity of   * ! the code SPHINCS_LORENE.                           * !                                                    * ! FT 8.12.2020                                       * !                                                    * !***************************************************** USE sphincs_lorene IMPLICIT NONE ! Maximum length for strings, and for the number of imported binaries INTEGER , PARAMETER :: max_length = 50 ! Maximum number of binary systems INTEGER , PARAMETER :: max_n_bns = 50 ! Maximum number of particle distributions INTEGER , PARAMETER :: max_n_parts = 250 ! Loop limits for BSSN objects (for debugging; 3 is for production) INTEGER , PARAMETER :: min_bssn = 1 INTEGER , PARAMETER :: max_bssn = 3 ! Refinement level over which to compute contraints (make input parameter) INTEGER :: ref_lev ! Number of binary systems of neutron stars (BNS) to import INTEGER :: n_bns ! Export the constraints every constraints_step-th step INTEGER :: constraints_step ! Matrix storing the information on how to place particles for each bns ! object. Row i contains information about the i&#94;th bns object. INTEGER , PARAMETER :: test_int = - 112 INTEGER , DIMENSION ( max_n_bns , max_n_parts ) :: placer = test_int ! Grid spacing for the first BSSN object; the other two will have ! original_dx/2 and original_dx/4 as grid spacings DOUBLE PRECISION :: original_dx ! Rational ratio between the large grid spacing and the medium one, ! equal to the ratio between the medium grid spacing nd the small one DOUBLE PRECISION :: numerator_ratio_dx DOUBLE PRECISION :: denominator_ratio_dx DOUBLE PRECISION :: ratio_dx ! Strings storing different names for output files CHARACTER ( LEN = 500 ) :: namefile_parts , namefile_sph CHARACTER ( LEN = 500 ) :: namefile_bssn , name_logfile ! Array of strings storing the names of the LORENE BNS ID binary files CHARACTER ( LEN = max_length ), DIMENSION ( max_length ) :: filenames = \"0\" ! String storing the local path to the directory where the ! LORENE BNS ID files are stored CHARACTER ( LEN = max_length ) :: common_path ! String storing the local path to the directory where the ! SPH output is to be saved CHARACTER ( LEN = max_length ) :: sph_path ! String storing the local path to the directory where the ! spacetime output is to be saved CHARACTER ( LEN = max_length ) :: spacetime_path LOGICAL , PARAMETER :: debug = . FALSE . ! Logical variables to steer the execution LOGICAL :: export_bin , export_form , export_form_xy , export_form_x , & compute_constraints , export_constraints_xy , & export_constraints_x , export_constraints , & export_constraints_details , compute_parts_constraints , & one_lapse , zero_shift , run_sph , run_spacetime TYPE ( timer ) :: execution_timer ! Declaration of the bns (binary neutron star) object containing the ! LORENE ID TYPE ( bnslorene ) :: binary ! Declaration of the particles object containing the particle distribution TYPE ( particles ) :: particles_dist ! Declaration of the 3-component array storing the 3 bssn_id objects, ! containing the BSSN variables on the gravity grid TYPE ( bssn_id ), DIMENSION ( 3 ) :: bssn_forms ! Namelist containing parameters read from lorene_bns_id_parameters.par ! by the SUBROUTINE read_bns_id_parameters of this PROGRAM NAMELIST / bns_parameters / n_bns , common_path , filenames , placer , & export_bin , export_form , export_form_xy , & export_form_x , export_constraints_xy , & export_constraints_x , compute_constraints , & export_constraints , export_constraints_details , & constraints_step , compute_parts_constraints , & numerator_ratio_dx , denominator_ratio_dx , ref_lev , & one_lapse , zero_shift , show_progress , & run_sph , run_spacetime , sph_path , spacetime_path !---------------------------! !--  End of declarations  --! !---------------------------! ! Conversions of some polytropic constants from LORENE units to ! SPHINCS units, and vice versa !gamma= 2 !PRINT *, 0.0332278*k_lorene2hydrobase( gamma ) !PRINT * !gamma= 2.75 !PRINT *, 30000.0D0/k_lorene2hydrobase( gamma ) !gamma= 2.75 !PRINT *, 0.0332278*k_lorene2hydrobase( gamma ) !STOP CALL DATE_AND_TIME ( date , time , zone , values ) run_id = date // \"-\" // time !PRINT *, run_id !STOP execution_timer = timer ( \"execution_timer\" ) CALL execution_timer % start_timer () CALL read_bns_id_parameters () ratio_dx = numerator_ratio_dx / denominator_ratio_dx ! Check that ratio_dx > 1 IF ( ratio_dx <= 1.0D0 ) THEN PRINT * , \"** ERROR! numerator_ratio_dx has to be larger than \" , & \"denominator_ratio_dx. The current values are \" , & numerator_ratio_dx , \" and \" , denominator_ratio_dx , & \", respectively.\" PRINT * STOP ENDIF ! !-- Construct the bns object from the LORENE binary file ! binary = bnslorene ( TRIM ( common_path ) // \"/\" // TRIM ( filenames ( 1 )) ) ! Set the variables to decide on using the geodesic gauge or not ! (lapse=1, shift=0) CALL binary % set_one_lapse ( one_lapse ) CALL binary % set_zero_shift ( zero_shift ) ! !-- Construct the particles object from the bns object ! IF ( compute_parts_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Placing particles\" PRINT * , \"===================================================\" & // \"===============\" PRINT * particles_dist = particles ( binary , placer ( 1 , 1 ) ) ! !-- Compute the SPH variables ! PRINT * , \"===================================================\" & // \"=====================\" PRINT * , \" Computing SPH variables \" PRINT * , \"===================================================\" & // \"=====================\" PRINT * WRITE ( namefile_parts , \"(A1,I1,A1,I1,A1)\" ) & \"l\" , & 1 , \"-\" , 1 , \".\" particles_dist % export_bin = export_bin CALL particles_dist % compute_and_export_SPH_variables ( namefile_parts ) ! !-- Print the particle initial data to a formatted file ! IF ( export_form ) THEN WRITE ( namefile_parts , \"(A34)\" ) & \"lorene-bns-id-particles-form_1.dat\" particles_dist % export_form_xy = export_form_xy particles_dist % export_form_x = export_form_x CALL particles_dist % print_formatted_lorene_id_particles ( namefile_parts ) ENDIF ENDIF ! !-- Construct the bssn_id objects from the bns object ! construct_bssn_loop : DO itr3 = min_bssn , max_bssn , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Setting up BSSN object \" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * IF ( itr3 == 1 ) THEN bssn_forms ( itr3 ) = bssn_id ( binary ) original_dx = bssn_forms ( itr3 )% get_dx ( ref_lev ) ELSE IF ( itr3 == min_bssn ) THEN bssn_forms ( 1 ) = bssn_id ( binary ) original_dx = bssn_forms ( 1 )% get_dx ( ref_lev ) ENDIF bssn_forms ( itr3 ) = bssn_id ( binary , & original_dx / ( ratio_dx ** ( itr3 - 1 ) ), & original_dx / ( ratio_dx ** ( itr3 - 1 ) ), & original_dx / ( ratio_dx ** ( itr3 - 1 ) ) ) IF ( bssn_forms ( itr3 )% get_dx ( ref_lev ) /= & original_dx / ( ratio_dx ** ( itr3 - 1 ) ) ) THEN PRINT * , \" ** ERROR! The grid spacing #\" , itr3 , \",\" , & bssn_forms ( itr3 )% get_dx ( ref_lev ), & \" is not equal to dx/\" , ratio_dx ** ( itr3 - 1 ), \"= \" , & original_dx / ( ratio_dx ** ( itr3 - 1 ) ) STOP ENDIF ENDIF PRINT * , \"** The grid spacing is dx=\" , bssn_forms ( itr3 )% get_dx ( ref_lev ) PRINT * , \"** The number of grid points for dx is:\" , & bssn_forms ( itr3 )% get_ngrid_x ( ref_lev ), \"**3\" PRINT * ENDDO construct_bssn_loop IF ( debug ) THEN PRINT * , \"bssn_forms( 1 )% get_ngrid_x=\" , bssn_forms ( 1 )% get_ngrid_x ( ref_lev ) PRINT * , \"bssn_forms( 1 )% get_ngrid_y=\" , bssn_forms ( 1 )% get_ngrid_y ( ref_lev ) PRINT * , \"bssn_forms( 1 )% get_ngrid_z=\" , bssn_forms ( 1 )% get_ngrid_z ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_ngrid_x=\" , bssn_forms ( 2 )% get_ngrid_x ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_ngrid_y=\" , bssn_forms ( 2 )% get_ngrid_y ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_ngrid_z=\" , bssn_forms ( 2 )% get_ngrid_z ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_ngrid_x=\" , bssn_forms ( 3 )% get_ngrid_x ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_ngrid_y=\" , bssn_forms ( 3 )% get_ngrid_y ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_ngrid_z=\" , bssn_forms ( 3 )% get_ngrid_z ( ref_lev ) PRINT * PRINT * , \"bssn_forms( 1 )% get_dx \" , bssn_forms ( 1 )% get_dx ( ref_lev ) PRINT * , \"bssn_forms( 2 )% get_dy \" , bssn_forms ( 2 )% get_dx ( ref_lev ) PRINT * , \"bssn_forms( 3 )% get_dz \" , bssn_forms ( 3 )% get_dx ( ref_lev ) PRINT * !STOP ENDIF ! !-- Compute the BSSN variables ! compute_export_bssn_loop : DO itr3 = min_bssn , max_bssn , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN variables for BSSN formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A6,I1,A4)\" ) \"BSSN_l\" , itr3 , \".bin\" bssn_forms ( itr3 )% export_bin = export_bin bssn_forms ( itr3 )% export_form_xy = export_form_xy bssn_forms ( itr3 )% export_form_x = export_form_x CALL bssn_forms ( itr3 )% & compute_and_export_3p1_variables ( namefile_bssn ) ENDDO compute_export_bssn_loop ! !-- Print the BSSN initial data to a formatted file ! IF ( export_form ) THEN export_bssn_loop : DO itr3 = min_bssn , max_bssn , 1 WRITE ( namefile_bssn , \"(A24,I1,A4)\" ) & \"lorene-bns-id-bssn-form_\" , itr3 , \".dat\" bssn_forms ( itr3 )% export_form_xy = export_form_xy bssn_forms ( itr3 )% export_form_x = export_form_x CALL bssn_forms ( itr3 )% & print_formatted_lorene_id_3p1_variables ( namefile_bssn ) ENDDO export_bssn_loop ENDIF ! There doesn't seem to be a bug until here !STOP ! !-- Compute the BSSN constraints ! compute_export_bssn_constraints_loop : DO itr3 = min_bssn , max_bssn , 1 bssn_forms ( itr3 )% cons_step = constraints_step bssn_forms ( itr3 )% export_constraints = export_constraints bssn_forms ( itr3 )% export_constraints_details = & export_constraints_details bssn_forms ( itr3 )% export_constraints_xy = export_constraints_xy bssn_forms ( itr3 )% export_constraints_x = export_constraints_x IF ( compute_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN constraints for BSSN formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A17,I1,A4)\" ) \"bssn-constraints-\" , itr3 , \".dat\" WRITE ( name_logfile , \"(A28,I1,A4)\" ) & \"bssn-constraints-statistics-\" , itr3 CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( binary , & namefile_bssn , & name_logfile ) ENDIF IF ( compute_parts_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN constraints with particle data for BSSN\" , & \" formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A23,I1,A4)\" ) \"bssn-constraints-parts-\" , & itr3 , \".dat\" WRITE ( namefile_sph , \"(A12,I1,A4)\" ) \"sph-density-\" , itr3 , \".dat\" WRITE ( name_logfile , \"(A34,I1,A4)\" ) & \"bssn-constraints-parts-statistics-\" , itr3 , \".log\" CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( particles_dist , & namefile_bssn , & name_logfile ) ENDIF ENDDO compute_export_bssn_constraints_loop ! Here the bug appears. Since I am only computing the constraints with particles ! it must be in there !STOP ! !-- The BSSN formulations on grids with different resolutions are ready !-- to be used in a convergence test ! IF ( debug . AND . . FALSE . ) THEN PRINT * , bssn_forms ( 1 )% get_grid_point ( 1 + 1 , 1 + 2 , 1 + 1 , ref_lev ) PRINT * , bssn_forms ( 2 )% get_grid_point ( 1 + 2 , 1 + 4 , 1 + 2 , ref_lev ) PRINT * , bssn_forms ( 3 )% get_grid_point ( 1 + 4 , 1 + 8 , 1 + 4 , ref_lev ) PRINT * PRINT * , bssn_forms ( 1 )% get_grid_point ( 1 + 2 , 1 + 1 , 1 + 2 , ref_lev ) PRINT * , bssn_forms ( 2 )% get_grid_point ( 1 + 4 , 1 + 2 , 1 + 4 , ref_lev ) PRINT * , bssn_forms ( 3 )% get_grid_point ( 1 + 8 , 1 + 4 , 1 + 8 , ref_lev ) PRINT * PRINT * , ABS ( bssn_forms ( 1 )% get_HC ( 1 + 30 , 1 + 25 , 1 + 17 , ref_lev )) PRINT * , ABS ( bssn_forms ( 2 )% get_HC ( 1 + 2 * 30 , 1 + 2 * 25 , 1 + 2 * 17 , ref_lev )) PRINT * , ABS ( bssn_forms ( 3 )% get_HC ( 1 + 4 * 30 , 1 + 4 * 25 , 1 + 4 * 17 , ref_lev )) PRINT * PRINT * , ABS ( bssn_forms ( 1 )% get_HC ( 1 + 30 , 1 + 25 , 1 + 17 , ref_lev )) & - ABS ( bssn_forms ( 2 )% get_HC ( 1 + 2 * 30 , 1 + 2 * 25 , 1 + 2 * 17 , ref_lev )) PRINT * , ABS ( bssn_forms ( 2 )% get_HC ( 1 + 2 * 30 , 1 + 2 * 25 , 1 + 2 * 17 , ref_lev )) & - ABS ( bssn_forms ( 3 )% get_HC ( 1 + 4 * 30 , 1 + 4 * 25 , 1 + 4 * 17 , ref_lev )) STOP ENDIF ! !-- Perform the convergence test with the appropriate constraints ! IF ( compute_constraints ) THEN PRINT * , \"** Performing convergence test with constraints computed \" , & \"without particle data.\" PRINT * CALL cauchy_convergence_test_unknown ( bssn_forms ( 1 ), bssn_forms ( 2 ), & bssn_forms ( 3 ), 1 , ref_lev ) CALL cauchy_convergence_test_known ( bssn_forms ( 2 ), bssn_forms ( 3 ), 1 , ref_lev ) ENDIF IF ( compute_parts_constraints ) THEN PRINT * , \"** Performing convergence test with constraints computed \" , & \"with particle data.\" PRINT * CALL cauchy_convergence_test_unknown ( bssn_forms ( 1 ), bssn_forms ( 2 ), & bssn_forms ( 3 ), 2 , ref_lev ) CALL cauchy_convergence_test_known ( bssn_forms ( 2 ), bssn_forms ( 3 ), 2 , ref_lev ) ENDIF CALL execution_timer % stop_timer () CALL DATE_AND_TIME ( date , time , zone , values ) end_time = date // \"-\" // time !STOP ! !-- Print the timers ! PRINT * , \"** Timing.\" PRINT * PRINT * PRINT * , \" * BSSN formulation with uniform resolution:\" , & bssn_forms ( 1 )% get_dx ( ref_lev ) PRINT * , \"    and number of points:\" , bssn_forms ( 1 )% get_ngrid_x ( ref_lev ), & \"**3\" !original_dx CALL bssn_forms ( 1 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% bssn_computer_timer % print_timer ( 2 ) PRINT * PRINT * , \" * BSSN formulation with uniform resolution:\" , & bssn_forms ( 2 )% get_dx ( ref_lev ) PRINT * , \"    and number of points:\" , bssn_forms ( 2 )% get_ngrid_x ( ref_lev ), & \"**3\" !original_dx/2 CALL bssn_forms ( 2 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 2 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 2 )% bssn_computer_timer % print_timer ( 2 ) PRINT * PRINT * , \" * BSSN formulation with uniform resolution:\" , & bssn_forms ( 3 )% get_dx ( ref_lev ) PRINT * , \"    and number of points:\" , bssn_forms ( 3 )% get_ngrid_x ( ref_lev ), & \"**3\" !original_dx/4 CALL bssn_forms ( 3 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 3 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 3 )% bssn_computer_timer % print_timer ( 2 ) PRINT * PRINT * , \" * Total:\" CALL execution_timer % print_timer ( 2 ) PRINT * PRINT * PRINT * , \"** Run started on \" , run_id , \" and ended on \" , end_time PRINT * ! !-- Destruct the LORENE Bin_NS object by hand, since the pointer to it is !-- global (because it is bound to C++) and cannot be nullified by the !-- destructor of bns. In case of multiple bns objects, this would lead !-- to problems... !-- TODO: fix this ! CALL binary % destruct_binary () CONTAINS SUBROUTINE cauchy_convergence_test_known ( formul_dx , formul_dx2 , & use_constraints , ref_lev ) IMPLICIT NONE CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: formul_dx , formul_dx2 INTEGER , INTENT ( IN ) :: use_constraints , ref_lev INTEGER :: ix , iy , iz , nx , ny , nz , unit_cauchy_ct , unit_cauchy_parts_ct , & min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid DOUBLE PRECISION , PARAMETER :: tiny_real = 1 D - 30 DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: grid_dx DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx2 DOUBLE PRECISION , DIMENSION (:,:,:), ALLOCATABLE :: convergence_factor CHARACTER ( LEN = : ), ALLOCATABLE :: name_cauchy_ct , name_cauchy_parts_ct LOGICAL :: exist nx = formul_dx % get_ngrid_x ( ref_lev ) ny = formul_dx % get_ngrid_y ( ref_lev ) nz = formul_dx % get_ngrid_z ( ref_lev ) nx = FLOOR ( DBLE ( nx - 1 ) / denominator_ratio_dx ) + 1 ny = FLOOR ( DBLE ( ny - 1 ) / denominator_ratio_dx ) + 1 nz = FLOOR ( DBLE ( nz - 1 ) / denominator_ratio_dx ) + 1 ALLOCATE ( grid_dx ( 3 , nx , ny , nz ) ) ALLOCATE ( abs_grid ( 3 , nx , ny , nz ) ) ALLOCATE ( convergence_factor ( nx , ny , nz ) ) PRINT * , \"** Computing convergence factor...\" choose_constraints : SELECT CASE ( use_constraints ) CASE ( 1 ) shared_grid_loops1 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( formul_dx % get_HC ( 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ))& / ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) & + tiny_real ) & ) + tiny_real ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops1 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_ct = 3109 name_cauchy_ct = \"cauchy_convergence_test_known.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_ct) ) WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing he arrays in \" , & TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_ct ) PRINT * CASE ( 2 ) shared_grid_loops2 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( ABS ( & formul_dx % get_HC_parts ( 1 + INT ( denominator_ratio_dx ) * ix , & 1 + INT ( denominator_ratio_dx ) * iy , & 1 + INT ( denominator_ratio_dx ) * iz , ref_lev )& / ( formul_dx2 % get_HC_parts ( 1 + INT ( numerator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx ) * iz , ref_lev ) & + tiny_real ) & ) + tiny_real ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops2 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_parts_ct = 3111 name_cauchy_parts_ct = \"cauchy_convergence_test_known_parts.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_parts_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_parts_ct) ) WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing e arrays in \" , & TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_parts_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_parts_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_parts_ct ) PRINT * CASE DEFAULT PRINT * , \"** There is no well defined algorithm \" & // \"corresponding to the number\" , use_constraints PRINT * , \" * Please set use_constraints to 1 or 2.\" STOP END SELECT choose_constraints DEALLOCATE ( grid_dx ) END SUBROUTINE cauchy_convergence_test_known SUBROUTINE cauchy_convergence_test_unknown ( formul_dx , formul_dx2 , & formul_dx4 , use_constraints , & ref_lev ) IMPLICIT NONE CLASS ( formul_3p1 ), INTENT ( IN OUT ) :: formul_dx , formul_dx2 , formul_dx4 INTEGER , INTENT ( IN ) :: use_constraints , ref_lev INTEGER :: ix , iy , iz , nx , ny , nz , unit_cauchy_ct , unit_cauchy_parts_ct , & min_ix_y , min_iy_y , min_iz_y , & min_ix_z , min_iy_z , min_iz_z DOUBLE PRECISION :: min_abs_y , min_abs_z DOUBLE PRECISION , DIMENSION ( :, :, :, : ), ALLOCATABLE :: abs_grid DOUBLE PRECISION , PARAMETER :: tiny_real = 1 D - 30 DOUBLE PRECISION , DIMENSION (:,:,:,:), ALLOCATABLE :: grid_dx DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx2 DOUBLE PRECISION , DIMENSION ( 3 ) :: point_dx4 DOUBLE PRECISION , DIMENSION (:,:,:), ALLOCATABLE :: convergence_factor CHARACTER ( LEN = : ), ALLOCATABLE :: name_cauchy_ct , name_cauchy_parts_ct LOGICAL :: exist nx = formul_dx % get_ngrid_x ( ref_lev ) ny = formul_dx % get_ngrid_y ( ref_lev ) nz = formul_dx % get_ngrid_z ( ref_lev ) nx = FLOOR ( DBLE ( nx - 1 ) / denominator_ratio_dx ** 2 ) + 1 ny = FLOOR ( DBLE ( ny - 1 ) / denominator_ratio_dx ** 2 ) + 1 nz = FLOOR ( DBLE ( nz - 1 ) / denominator_ratio_dx ** 2 ) + 1 ALLOCATE ( grid_dx ( 3 , nx , ny , nz ) ) ALLOCATE ( abs_grid ( 3 , nx , ny , nz ) ) ALLOCATE ( convergence_factor ( nx , ny , nz ) ) PRINT * , \"** Computing convergence factor...\" IF ( debug ) THEN PRINT * , \"formul_dx%  get_ngrid_x=\" , formul_dx % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx%  get_ngrid_y=\" , formul_dx % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx%  get_ngrid_z=\" , formul_dx % get_ngrid_z ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_x=\" , formul_dx2 % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_y=\" , formul_dx2 % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx2% get_ngrid_z=\" , formul_dx2 % get_ngrid_z ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_x=\" , formul_dx4 % get_ngrid_x ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_y=\" , formul_dx4 % get_ngrid_y ( ref_lev ) PRINT * , \"formul_dx4% get_ngrid_z=\" , formul_dx4 % get_ngrid_z ( ref_lev ) PRINT * PRINT * , \"formul_dx%  get_dx=\" , formul_dx % get_dx ( ref_lev ) PRINT * , \"formul_dx2% get_dy=\" , formul_dx2 % get_dx ( ref_lev ) PRINT * , \"formul_dx4% get_dz=\" , formul_dx4 % get_dx ( ref_lev ) PRINT * !STOP ENDIF choose_constraints : SELECT CASE ( use_constraints ) CASE ( 1 ) shared_grid_loops3 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 ! grid_dx( :, 1 + ix, 1 + iy, 1 + iz ) = & !            formul_dx%  get_grid_point(  & !                             1 + ix,   1 + iy,   1 + iz   ) ! point_dx2= formul_dx2% get_grid_point( & !                             1 + 2*ix, 1 + 2*iy, 1 + 2*iz ) ! point_dx4= formul_dx4% get_grid_point( & !                             1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) ! ! IF( grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(1) & !.OR. grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(1) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(2) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(2) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(3) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(3) & grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ) point_dx4 = formul_dx4 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ), & point_dx4 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ), & point_dx4 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ), & point_dx4 ( 3 ) PRINT * STOP ENDIF !convergence_factor( 1 + ix, 1 + iy, 1 + iz )= & ! LOG( & ! ABS( & ! ( ABS(formul_dx%  get_HC( 1 + ix,   1 + iy,   1 + iz )) & ! - ABS(formul_dx2% get_HC( 1 + 2*ix, 1 + 2*iy, 1 + 2*iz )))& !/( ABS(formul_dx2% get_HC( 1 + 2*ix, 1 + 2*iy, 1 + 2*iz )) & ! - ABS(formul_dx4% get_HC( 1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) )& ! + 0*tiny_real ) & ! ) & ! )/ln2!/LOG(2.0) convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( ABS ( formul_dx % get_HC ( 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev )) & - ABS ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ))) & / ( ABS ( formul_dx2 % get_HC ( 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )) & - ABS ( formul_dx4 % get_HC ( 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) ) & + tiny_real ) & ) + tiny_real & ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops3 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_ct = 3108 name_cauchy_ct = \"cauchy_convergence_test_unknown.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_ct , FILE = TRIM ( name_cauchy_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_ct) ) WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , IOMSG = err_msg , FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( name_cauchy_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_ct ) PRINT * CASE ( 2 ) shared_grid_loops4 : DO iz = 0 , nz - 1 , 1 DO iy = 0 , ny - 1 , 1 DO ix = 0 , nx - 1 , 1 ! grid_dx( :, 1 + ix, 1 + iy, 1 + iz ) = & !            formul_dx%  get_grid_point(  & !                             1 + ix,   1 + iy,   1 + iz   ) ! point_dx2= formul_dx2% get_grid_point( & !                             1 + 2*ix, 1 + 2*iy, 1 + 2*iz ) ! point_dx4= formul_dx4% get_grid_point( & !                             1 + 4*ix, 1 + 4*iy, 1 + 4*iz ) ! ! IF( grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(1) & !.OR. grid_dx( 1, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(1) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(2) & !.OR. grid_dx( 2, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(2) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx2(3) & !.OR. grid_dx( 3, 1 + ix, 1 + iy, 1 + iz ) /= point_dx4(3) & grid_dx ( :, 1 + ix , 1 + iy , 1 + iz ) = & formul_dx % get_grid_point ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev ) point_dx2 = formul_dx2 % get_grid_point ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev ) point_dx4 = formul_dx4 % get_grid_point ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) IF ( ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 1 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 2 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx2 ( 3 )) > 1 D - 10 & . OR . ABS ( grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ) - point_dx4 ( 3 )) > 1 D - 10 & ) THEN PRINT * , \"**ERROR! The grid functions in the Cauchy \" , & \"convergence test are not evaluated at the \" , & \"same grid point at (ix,iy,iz)=(\" , & ix , iy , iz , \").\" PRINT * , grid_dx ( 1 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 1 ), & point_dx4 ( 1 ) PRINT * , grid_dx ( 2 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 2 ), & point_dx4 ( 2 ) PRINT * , grid_dx ( 3 , 1 + ix , 1 + iy , 1 + iz ), point_dx2 ( 3 ), & point_dx4 ( 3 ) PRINT * STOP ENDIF convergence_factor ( 1 + ix , 1 + iy , 1 + iz ) = & LOG ( & ABS ( & ( ABS ( formul_dx % get_HC_parts ( & 1 + INT ( denominator_ratio_dx ** 2 ) * ix , & 1 + INT ( denominator_ratio_dx ** 2 ) * iy , & 1 + INT ( denominator_ratio_dx ** 2 ) * iz , ref_lev )) & - ABS ( formul_dx2 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )))& / ( ABS ( formul_dx2 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * ix , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iy , & 1 + INT ( numerator_ratio_dx * & denominator_ratio_dx ) * iz , ref_lev )) & - ABS ( formul_dx4 % get_HC_parts ( & 1 + INT ( numerator_ratio_dx ** 2 ) * ix , & 1 + INT ( numerator_ratio_dx ** 2 ) * iy , & 1 + INT ( numerator_ratio_dx ** 2 ) * iz , ref_lev ) )& + tiny_real ) & ) + tiny_real & ) / LOG ( ratio_dx ) ENDDO ENDDO ENDDO shared_grid_loops4 PRINT * , \" * Convergence factor computed.\" PRINT * unit_cauchy_parts_ct = 3110 name_cauchy_parts_ct = \"cauchy_convergence_test_unknown_parts.dat\" INQUIRE ( FILE = TRIM ( name_cauchy_parts_ct ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"REPLACE\" , FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ELSE OPEN ( UNIT = unit_cauchy_parts_ct , FILE = TRIM ( name_cauchy_parts_ct ), & STATUS = \"NEW\" , FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" , TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error when opening \" & !         // TRIM(name_cauchy_parts_ct) ) WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# Run ID [ccyymmdd-hhmmss.sss]: \" // run_id WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * ) & \"# Cauchy convergence test. \" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"# column:      1        2       3       4\" WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , IOMSG = err_msg , & FMT = * ) & \"#      x [km]       y [km]       z [km]       \" & // \"convergence factor [pure number]\" DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 abs_grid ( 1 , ix , iy , iz ) = ABS ( grid_dx ( 1 , ix , iy , iz ) ) abs_grid ( 2 , ix , iy , iz ) = ABS ( grid_dx ( 2 , ix , iy , iz ) ) abs_grid ( 3 , ix , iy , iz ) = ABS ( grid_dx ( 3 , ix , iy , iz ) ) ENDDO ENDDO ENDDO min_abs_y = 1 D + 20 min_abs_z = 1 D + 20 DO iz = 1 , nx , 1 DO iy = 1 , ny , 1 DO ix = 1 , nz , 1 IF ( ABS ( grid_dx ( 2 , ix , iy , iz ) ) < min_abs_y ) THEN min_abs_y = ABS ( grid_dx ( 2 , ix , iy , iz ) ) min_ix_y = ix min_iy_y = iy min_iz_y = iz ENDIF IF ( ABS ( grid_dx ( 3 , ix , iy , iz ) ) < min_abs_z ) THEN min_abs_z = ABS ( grid_dx ( 3 , ix , iy , iz ) ) min_ix_z = ix min_iy_z = iy min_iz_z = iz ENDIF ENDDO ENDDO ENDDO DO iz = 1 , nz , 1 DO iy = 1 , ny , 1 DO ix = 1 , nx , 1 IF ( . FALSE . . AND . export_constraints_xy . AND . & grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) ) THEN CYCLE ENDIF IF ( . FALSE . . AND . export_constraints_x . AND . & ( grid_dx ( 3 , ix , iy , iz ) /= & grid_dx ( 3 , min_ix_z , min_iy_z , min_iz_z ) & . OR . & grid_dx ( 2 , ix , iy , iz ) /= & grid_dx ( 2 , min_ix_y , min_iy_y , min_iz_y ) ) ) THEN CYCLE ENDIF WRITE ( UNIT = unit_cauchy_parts_ct , IOSTAT = ios , & IOMSG = err_msg , FMT = * )& grid_dx ( 1 , ix , iy , iz ), & grid_dx ( 2 , ix , iy , iz ), & grid_dx ( 3 , ix , iy , iz ), & convergence_factor ( ix , iy , iz ) IF ( ios > 0 ) THEN PRINT * , \"...error when writing the arrays in \" , & TRIM ( name_cauchy_parts_ct ), & \". The error message is\" , err_msg STOP ENDIF !CALL test_status( ios, err_msg, \"...error in writing \" & !            // \"the arrays in \" // TRIM(name_cauchy_parts_ct) ) ENDDO ENDDO ENDDO CLOSE ( UNIT = unit_cauchy_parts_ct ) PRINT * , \" * Convergence factor exported to formatted file \" , & TRIM ( name_cauchy_parts_ct ) PRINT * CASE DEFAULT PRINT * , \"** There is no well defined algorithm \" & // \"corresponding to the number\" , use_constraints PRINT * , \" * Please set use_constraints to 1 or 2.\" STOP END SELECT choose_constraints DEALLOCATE ( grid_dx ) END SUBROUTINE cauchy_convergence_test_unknown SUBROUTINE read_bns_id_parameters () IMPLICIT NONE INTEGER :: stat INTEGER , PARAMETER :: unit_parameters = 17 CHARACTER ( LEN = : ), ALLOCATABLE :: lorene_bns_id_parameters CHARACTER ( LEN = : ), ALLOCATABLE :: msg lorene_bns_id_parameters = 'sphincs_lorene_bns_parameters.par' INQUIRE ( FILE = lorene_bns_id_parameters , EXIST = file_exists ) IF ( file_exists ) THEN OPEN ( UNIT = unit_parameters , FILE = lorene_bns_id_parameters , & STATUS = 'OLD' ) ELSE PRINT * PRINT * , '** ERROR: ' , lorene_bns_id_parameters , \" file not found!\" PRINT * STOP ENDIF READ ( UNIT = unit_parameters , NML = bns_parameters , IOSTAT = stat , & IOMSG = msg ) IF ( stat /= 0 ) THEN PRINT * , \"** ERROR: Error in reading \" , lorene_bns_id_parameters ,& \". The IOSTAT variable is \" , stat , & \"The error message is\" , msg STOP ENDIF CLOSE ( UNIT = unit_parameters ) DO itr = 1 , max_length , 1 IF ( TRIM ( filenames ( itr )). NE . \"0\" ) THEN cnt = cnt + 1 ENDIF ENDDO IF ( cnt . NE . n_bns ) THEN PRINT * , \"** ERROR! The number of file names is\" , cnt , & \"and n_bns=\" , n_bns , \". The two should be the same.\" PRINT * STOP ENDIF !DO itr= 1, n_bns, 1 !  DO itr2= 1, max_n_parts, 1 !    IF( placer( itr, itr2 ) == test_int )THEN !      PRINT * !      PRINT *, \"** ERROR! The array placer does not have \", & !               \"enough components to specify all the desired \", & !               \"particle distributions. Specify the \", & !               \"components in file lorene_bns_id_particles.par\" !      PRINT * !      STOP !    ENDIF !  ENDDO !ENDDO END SUBROUTINE read_bns_id_parameters END PROGRAM convergence_test","tags":"","loc":"program/convergence_test.html"},{"title":"write_par_eos – SPHINCS_LORENE","text":"Uses pwp_EOS constants program~~write_par_eos~~UsesGraph program~write_par_eos write_par_eos pwp_EOS pwp_EOS program~write_par_eos->pwp_EOS constants constants program~write_par_eos->constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~write_par_eos~~CallsGraph program~write_par_eos write_par_eos select_eos_parameters select_eos_parameters program~write_par_eos->select_eos_parameters get_gamma2 get_gamma2 program~write_par_eos->get_gamma2 get_rho_1 get_rho_1 program~write_par_eos->get_rho_1 get_rho_0 get_rho_0 program~write_par_eos->get_rho_0 get_rho_2 get_rho_2 program~write_par_eos->get_rho_2 get_gamma1 get_gamma1 program~write_par_eos->get_gamma1 k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope program~write_par_eos->k_lorene2hydrobase_piecewisepolytrope get_gamma3 get_gamma3 program~write_par_eos->get_gamma3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables eos err_msg exist ios kappa0_lorene log10_p0_lorene log10_rho0_lorene log10_rho1_lorene log10_rho2_lorene namefile npoly Source Code write_par_eos Variables Type Attributes Name Initial character(len=4) :: eos character(len=:), ALLOCATABLE :: err_msg logical :: exist integer :: ios double precision :: kappa0_lorene double precision :: log10_p0_lorene double precision :: log10_rho0_lorene double precision :: log10_rho1_lorene double precision :: log10_rho2_lorene character(len=:), ALLOCATABLE :: namefile integer, parameter :: npoly = 4 Source Code PROGRAM write_par_eos USE constants , ONLY : lorene2hydrobase , kg2g , m2cm , & k_lorene2hydrobase_piecewisepolytrope USE pwp_EOS , ONLY : Gamma0 , K0 , select_EOS_parameters , gen_pwp_eos , & get_rho_0 , get_rho_1 , get_rho_2 , & get_Gamma1 , get_Gamma2 , get_Gamma3 , & get_K1 , get_K2 , get_K3 IMPLICIT NONE INTEGER , PARAMETER :: npoly = 4 INTEGER :: ios !DOUBLE PRECISION:: gamma1_lorene, gamma2_lorene, gamma3_lorene DOUBLE PRECISION :: kappa0_lorene , log10_p0_lorene , log10_rho0_lorene , & log10_rho1_lorene , log10_rho2_lorene LOGICAL :: exist CHARACTER ( LEN = : ), ALLOCATABLE :: namefile CHARACTER ( LEN = : ), ALLOCATABLE :: err_msg CHARACTER ( LEN = 4 ) :: eos #ifdef __INTEL_COMPILER WRITE ( * , '(\"Please write a 4 character string containing the name of the piecewise polytropic EOS: \",' ) #endif #ifdef __GFORTRAN__ WRITE ( * , '(\"Please write a 4 character string containing the name of the piecewise polytropic EOS: \")' ) #endif READ ( * , '(A)' ) eos CALL select_EOS_parameters ( eos ) kappa0_lorene = K0 / k_lorene2hydrobase_piecewisepolytrope ( Gamma0 ) log10_p0_lorene = LOG10 ( K0 / k_lorene2hydrobase_piecewisepolytrope ( Gamma0 ) & * ( get_rho_0 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) ** ( Gamma0 ) ) log10_rho0_lorene = LOG10 ( get_rho_0 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) log10_rho1_lorene = LOG10 ( get_rho_1 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) log10_rho2_lorene = LOG10 ( get_rho_2 () / lorene2hydrobase * kg2g / ( m2cm ** 3.0D0 ) ) namefile = \"par_eos.d\" INQUIRE ( FILE = TRIM ( namefile ), EXIST = exist ) IF ( exist ) THEN OPEN ( UNIT = 2 , FILE = TRIM ( namefile ), STATUS = \"REPLACE\" , & FORM = \"FORMATTED\" , & POSITION = \"REWIND\" , ACTION = \"WRITE\" , IOSTAT = ios , & IOMSG = err_msg ) ELSE OPEN ( UNIT = 2 , FILE = TRIM ( namefile ), STATUS = \"NEW\" , & FORM = \"FORMATTED\" , & ACTION = \"WRITE\" , IOSTAT = ios , IOMSG = err_msg ) ENDIF IF ( ios > 0 ) THEN PRINT * , \"...error when opening \" // TRIM ( namefile ), & \". The error message is\" , err_msg STOP ENDIF WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(A69)\" ) & \"110        Type of the EOS (cf. documentation of Eos::eos_multi_poly)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(A16,A4,A4)\" ) & \"Multipolytropic \" , eos , \" EOS\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(I1,A52)\" ) & npoly , \"npoly,         number of polytropes\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A43)\" ) & Gamma0 , \"gamma_0,       crust (here from SLy)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A69)\" ) & get_Gamma1 (), \"gamma_1,       array of adiabatic indexes (from crust to core)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A14)\" ) & get_Gamma2 (), \"gamma_2\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F11.9,A14)\" ) & get_Gamma3 (), \"gamma_3\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(ES16.9E3,A73)\" ) & kappa0_lorene , & \"kappa0,        pressure coefficient for gam_0 polytrope (here from SLy)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A80)\" ) & log10_p0_lorene , & \"log10(P0/c&#94;2), log of pressure between gam_0 and gam_1 (dyne/cm&#94;2/c_cgs&#94;2)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A71)\" ) & log10_rho0_lorene , & \"log10(rho_0),  array of logs of the transition densities (g/cm&#94;3)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A18)\" ) & log10_rho1_lorene , \"log10(rho_1)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F12.9,A18)\" ) & log10_rho2_lorene , \"log10(rho_2)\" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F3.1,A79)\" ) & 0.0 , \"decInc,        array (size npoly-1) of percentages which change \" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F3.1,A71)\" ) & 0.0 , \" the transition densities by changing the \" WRITE ( UNIT = 2 , IOSTAT = ios , IOMSG = err_msg , FMT = \"(F3.1,A75)\" ) & 0.0 , \" transition enthalpies (set to 0. to disable)\" CLOSE ( UNIT = 2 ) PRINT * PRINT * , \"Parameter file \" , namefile , \" written.\" PRINT * END PROGRAM write_par_eos","tags":"","loc":"program/write_par_eos.html"},{"title":"sphincs_lorene_bns – SPHINCS_LORENE","text":"Uses sphincs_lorene constants IFPORT program~~sphincs_lorene_bns~~UsesGraph program~sphincs_lorene_bns sphincs_lorene_bns module~sphincs_lorene sphincs_lorene program~sphincs_lorene_bns->module~sphincs_lorene constants constants program~sphincs_lorene_bns->constants IFPORT IFPORT program~sphincs_lorene_bns->IFPORT module~formul_3p1_id formul_3p1_id module~sphincs_lorene->module~formul_3p1_id module~id_base id_base module~sphincs_lorene->module~id_base timing timing module~sphincs_lorene->timing module~utility utility module~sphincs_lorene->module~utility module~particles_id particles_id module~sphincs_lorene->module~particles_id module~diffstar_lorene diffstar_lorene module~sphincs_lorene->module~diffstar_lorene module~bns_lorene bns_lorene module~sphincs_lorene->module~bns_lorene module~formul_bssn_id formul_bssn_id module~sphincs_lorene->module~formul_bssn_id module~formul_3p1_id->module~id_base module~formul_3p1_id->timing module~formul_3p1_id->module~utility module~formul_3p1_id->module~particles_id mesh_refinement mesh_refinement module~formul_3p1_id->mesh_refinement module~id_base->timing matrix matrix module~utility->matrix module~particles_id->module~id_base module~particles_id->timing module~particles_id->module~utility module~diffstar_lorene->timing module~diffstar_lorene->module~utility iso_c_binding iso_c_binding module~diffstar_lorene->iso_c_binding module~diffstar_base diffstar_base module~diffstar_lorene->module~diffstar_base module~bns_lorene->module~id_base module~bns_lorene->timing module~bns_lorene->module~utility module~bns_lorene->iso_c_binding module~bns_base bns_base module~bns_lorene->module~bns_base module~formul_bssn_id->module~formul_3p1_id module~formul_bssn_id->module~id_base module~formul_bssn_id->timing module~formul_bssn_id->module~utility module~formul_bssn_id->module~particles_id module~formul_bssn_id->mesh_refinement module~diffstar_base->module~id_base module~diffstar_base->module~utility module~bns_base->module~id_base module~bns_base->module~utility var panprogramsphincs_lorene_bnsUsesGraph = svgPanZoom('#programsphincs_lorene_bnsUsesGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~sphincs_lorene_bns~~CallsGraph program~sphincs_lorene_bns sphincs_lorene_bns makedirqq makedirqq program~sphincs_lorene_bns->makedirqq interface~particles particles program~sphincs_lorene_bns->interface~particles proc~read_bns_id_parameters~2 read_bns_id_parameters program~sphincs_lorene_bns->proc~read_bns_id_parameters~2 timer timer program~sphincs_lorene_bns->timer interface~diffstarlorene diffstarlorene program~sphincs_lorene_bns->interface~diffstarlorene interface~bssn_id bssn_id program~sphincs_lorene_bns->interface~bssn_id interface~construct_particles construct_particles interface~particles->interface~construct_particles interface~construct_diffstarlorene construct_diffstarlorene interface~diffstarlorene->interface~construct_diffstarlorene interface~construct_bssn_id construct_bssn_id interface~bssn_id->interface~construct_bssn_id proc~construct_bssn_id construct_bssn_id interface~construct_bssn_id->proc~construct_bssn_id proc~construct_particles construct_particles interface~construct_particles->proc~construct_particles proc~construct_diffstarlorene construct_diffstarlorene interface~construct_diffstarlorene->proc~construct_diffstarlorene proc~construct_diffstarlorene->timer interface~import_diffstar_params import_diffstar_params proc~construct_diffstarlorene->interface~import_diffstar_params proc~construct_particles->timer ktable ktable proc~construct_particles->ktable proc~check_particle_positions check_particle_positions proc~construct_particles->proc~check_particle_positions read_options read_options proc~construct_particles->read_options set_units set_units proc~construct_particles->set_units alive alive proc~construct_particles->alive interface~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory proc~construct_particles->interface~allocate_lorene_id_parts_memory proc~construct_bssn_id->timer initialize_bssn initialize_bssn proc~construct_bssn_id->initialize_bssn interface~allocate_bssn_fields allocate_bssn_fields proc~construct_bssn_id->interface~allocate_bssn_fields deallocate_bssn deallocate_bssn proc~construct_bssn_id->deallocate_bssn indexx indexx proc~check_particle_positions->indexx proc~allocate_bssn_fields allocate_bssn_fields interface~allocate_bssn_fields->proc~allocate_bssn_fields proc~import_diffstar_params import_diffstar_params interface~import_diffstar_params->proc~import_diffstar_params proc~allocate_lorene_id_parts_memory allocate_lorene_id_parts_memory interface~allocate_lorene_id_parts_memory->proc~allocate_lorene_id_parts_memory allocate_grid_function allocate_grid_function proc~allocate_bssn_fields->allocate_grid_function interface~print_diffstar_params print_diffstar_params proc~import_diffstar_params->interface~print_diffstar_params k_lorene2hydrobase k_lorene2hydrobase proc~import_diffstar_params->k_lorene2hydrobase interface~get_diffstar_params get_diffstar_params proc~import_diffstar_params->interface~get_diffstar_params k_lorene2hydrobase_piecewisepolytrope k_lorene2hydrobase_piecewisepolytrope proc~import_diffstar_params->k_lorene2hydrobase_piecewisepolytrope proc~print_diffstar_params print_diffstar_params interface~print_diffstar_params->proc~print_diffstar_params proc~print_diffstar_params->k_lorene2hydrobase var panprogramsphincs_lorene_bnsCallsGraph = svgPanZoom('#programsphincs_lorene_bnsCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables binaries bssn_forms common_path compute_constraints compute_parts_constraints constraints_step denominator_ratio_dx dir_out execution_timer exist export_bin export_constraints export_constraints_details export_constraints_x export_constraints_xy export_form export_form_x export_form_xy filenames i_matter idata last_level max_length max_n_bns max_n_parts n_bns name_logfile namefile_bssn namefile_bssn_bin namefile_parts namefile_parts_bin namefile_sph numerator_ratio_dx one_lapse particles_dist placer ref_lev run_spacetime run_sph spacetime_path sph_path system test_int zero_shift Subroutines read_bns_id_parameters Source Code sphincs_lorene_bns Variables Type Attributes Name Initial type( bnslorene ), DIMENSION(:), ALLOCATABLE :: binaries type( bssn_id ), DIMENSION(:), ALLOCATABLE :: bssn_forms character(len=max_length) :: common_path logical :: compute_constraints logical :: compute_parts_constraints integer :: constraints_step double precision :: denominator_ratio_dx logical(kind=4) :: dir_out type(timer) :: execution_timer logical :: exist logical :: export_bin logical :: export_constraints logical :: export_constraints_details logical :: export_constraints_x logical :: export_constraints_xy logical :: export_form logical :: export_form_x logical :: export_form_xy character(len=max_length), DIMENSION( max_length ) :: filenames = \"0\" integer :: i_matter class( idbase ), DIMENSION(:), ALLOCATABLE :: idata integer :: last_level integer, parameter :: max_length = 50 integer, parameter :: max_n_bns = 50 integer, parameter :: max_n_parts = 250 integer :: n_bns character(len=500) :: name_logfile character(len=500) :: namefile_bssn character(len=500) :: namefile_bssn_bin character(len=500) :: namefile_parts character(len=500) :: namefile_parts_bin character(len=500) :: namefile_sph double precision :: numerator_ratio_dx logical :: one_lapse type( particles ), DIMENSION(:,:), ALLOCATABLE :: particles_dist integer, DIMENSION( max_n_bns, max_n_parts ) :: placer = test_int integer :: ref_lev logical :: run_spacetime logical :: run_sph character(len=max_length) :: spacetime_path character(len=max_length) :: sph_path character(len=max_length) :: system integer, parameter :: test_int = -112 logical :: zero_shift Subroutines subroutine read_bns_id_parameters () Arguments None Source Code PROGRAM sphincs_lorene_bns !***************************************************** !                                                    * ! Use the MODULE sphincs_lorene to export binary     * ! files containing the initial data (ID) required    * ! by the evolution code in SPHINCS, and built using  * ! the binary files produced by LORENE and containing * ! the binary neutron stars (BNS) ID.                 * !                                                    * ! FT 28.10.2020                                      * !                                                    * !***************************************************** #ifdef __INTEL_COMPILER USE IFPORT , ONLY : MAKEDIRQQ #endif USE sphincs_lorene USE constants , ONLY : lorene2hydrobase , c_light2 , k_lorene2hydrobase , & k_lorene2hydrobase_piecewisepolytrope , MSun_geo , & kg2g , m2cm , m0c2 IMPLICIT NONE ! Maximum length for strings, and for the number of imported binaries INTEGER , PARAMETER :: max_length = 50 ! Maximum number of binary systems INTEGER , PARAMETER :: max_n_bns = 50 ! Maximum number of particle distributions INTEGER , PARAMETER :: max_n_parts = 250 ! Number of binary systems of neutron stars (BNS) to import INTEGER :: n_bns , ref_lev , i_matter ! Export the constraints every constraints_step-th step INTEGER :: constraints_step , last_level ! Matrix storing the information on how to place particles for each bns ! object. Row i contains information about the i&#94;th bns object. INTEGER , PARAMETER :: test_int = - 112 INTEGER , DIMENSION ( max_n_bns , max_n_parts ) :: placer = test_int ! Rational ratio between the large grid spacing and the medium one, ! equal to the ratio between the medium grid spacing nd the small one ! Not used in this PROGRAM, but needed since the PROGRAM reads the same ! parameter ile as the convergence_test PROGRAM DOUBLE PRECISION :: numerator_ratio_dx DOUBLE PRECISION :: denominator_ratio_dx ! String storing the name of the phyical system CHARACTER ( LEN = max_length ) :: system ! Strings storing different names for output files CHARACTER ( LEN = 500 ) :: namefile_parts , namefile_parts_bin , namefile_sph CHARACTER ( LEN = 500 ) :: namefile_bssn , namefile_bssn_bin , name_logfile ! Array of strings storing the names of the LORENE BNS ID binary files CHARACTER ( LEN = max_length ), DIMENSION ( max_length ) :: filenames = \"0\" ! String storing the local path to the directory where the ! LORENE BNS ID files are stored CHARACTER ( LEN = max_length ) :: common_path ! String storing the local path to the directory where the ! SPH output is to be saved CHARACTER ( LEN = max_length ) :: sph_path ! String storing the local path to the directory where the ! spacetime output is to be saved CHARACTER ( LEN = max_length ) :: spacetime_path LOGICAL :: exist LOGICAL ( 4 ) :: dir_out ! Logical variables to steer the execution LOGICAL :: export_bin , export_form , export_form_xy , export_form_x , & compute_constraints , export_constraints_xy , & export_constraints_x , export_constraints , & export_constraints_details , compute_parts_constraints , & one_lapse , zero_shift , run_sph , run_spacetime TYPE ( timer ) :: execution_timer ! Declaration of the allocatable array storing the bns objects, ! containing the LORENE ID for different BNS TYPE ( bnslorene ), DIMENSION (:), ALLOCATABLE :: binaries CLASS ( idbase ), DIMENSION (:), ALLOCATABLE :: idata ! Declaration of the allocatable array storing the particles objects, ! containing the particle distributions for each bns object. ! Multiple particle objects can contain different particle distributions ! for the same bns object. TYPE ( particles ), DIMENSION (:,:), ALLOCATABLE :: particles_dist ! Declaration of the allocatable array storing the bssn_id objects, ! containing the BSSN variables on the gravity grid ofr each bns object TYPE ( bssn_id ), DIMENSION (:), ALLOCATABLE :: bssn_forms ! Namelist containing parameters read from lorene_bns_id_parameters.par ! by the SUBROUTINE read_bns_id_parameters of this PROGRAM NAMELIST / bns_parameters / system , n_bns , common_path , filenames , placer , & export_bin , export_form , export_form_xy , & export_form_x , export_constraints_xy , & export_constraints_x , compute_constraints , & export_constraints , export_constraints_details , & constraints_step , compute_parts_constraints , & numerator_ratio_dx , denominator_ratio_dx , ref_lev , & one_lapse , zero_shift , show_progress , & run_sph , run_spacetime , sph_path , spacetime_path !---------------------------! !--  End of declarations  --! !---------------------------! !PRINT *, lorene2hydrobase !PRINT *, 2.45191D-4/lorene2hydrobase/1000 !PRINT *, LOG10(2.45191D-4/lorene2hydrobase/1000) !PRINT * !PRINT *, LOG10(10**(34.616)/c_light2) !STOP !PRINT *, \"** Polytropic constant used for gamma= 2.75 single polytrope:\" !PRINT *, \"   k used in LORENE= \", 0.01691726009823966 !PRINT *, \"   k converted in SPHINCS units= \", & !                               0.01691726009823966*k_lorene2hydrobase(2.75D0) !PRINT * !PRINT *, \"** Polytropic constant used for gamma= 2 single polytrope:\" !PRINT *, \"   k used in LORENE= \", 0.02686965902663748 !PRINT *, \"   k converted in SPHINCS units= \", & !                               0.02686965902663748*k_lorene2hydrobase(2.0D0) !PRINT * !PRINT *, \"** Polytropic constant used for the crust in PWP:\" !PRINT *, \"   k used in LORENE= \", 3.99874D-8 !PRINT *, \"   k converted in SPHINCS units= \", & !                3.99874D-8*k_lorene2hydrobase_piecewisepolytrope(1.35692395D0) !PRINT * !PRINT *, \"** Polytropic constant used for the crust in PWP:\" !PRINT *, \"   k used in LORENE= \", 8.948185D-2 !PRINT *, \"   k converted in SPHINCS units= \", & !                               8.948185D-2*k_lorene2hydrobase(1.35692395D0) !PRINT * !PRINT *, \"   k used in LORENE, corresponding to k-100 in SPHINCS units= \", & !         100/k_lorene2hydrobase(2.0D0) ! Our testbed cases are gamma= 2.75, k= 30000; and gamma=2, k= 100 ! in SPHINCS units ! 7.901e+14 density for 1.4 GRAVITATIONAL mass, poly 2 ! 1.4-1.4 systems for both ; 1.6-1.6 ; 1.2-1.8 GRAVIATIONAL masses !STOP CALL DATE_AND_TIME ( date , time , zone , values ) run_id = date // \"-\" // time execution_timer = timer ( \"execution_timer\" ) CALL execution_timer % start_timer () CALL read_bns_id_parameters () ! !-- Check that the specified subdirectories exist. If not, create them !-- TODO: this compils with ifort, but not with gfortran ! #ifdef __INTEL_COMPILER INQUIRE ( DIRECTORY = TRIM ( sph_path ), EXIST = exist ) IF ( . NOT . exist ) THEN dir_out = MAKEDIRQQ ( TRIM ( sph_path ) ) ELSE dir_out = . TRUE . ENDIF IF ( . NOT . dir_out ) THEN PRINT * , \"** ERROR! Failed to create subdirectory \" , TRIM ( sph_path ) PRINT * , \"Stopping...\" PRINT * STOP ENDIF INQUIRE ( DIRECTORY = TRIM ( spacetime_path ), EXIST = exist ) IF ( . NOT . exist ) THEN dir_out = MAKEDIRQQ ( TRIM ( spacetime_path ) ) ELSE dir_out = . TRUE . ENDIF IF ( . NOT . dir_out ) THEN PRINT * , \"** ERROR! Failed to create subdirectory \" , TRIM ( sph_path ) PRINT * , \"Stopping...\" PRINT * STOP ENDIF #endif #ifdef __GFORTRAN__ INQUIRE ( FILE = TRIM ( sph_path ) // \"/.\" , EXIST = exist ) IF ( . NOT . exist ) THEN PRINT * , \"** ERROR! Directory \" , TRIM ( sph_path ), \" does not exist!\" PRINT * , \"   Please create it and re-run the executable. Stopping...\" STOP ENDIF INQUIRE ( FILE = TRIM ( spacetime_path ) // \"/.\" , EXIST = exist ) IF ( . NOT . exist ) THEN PRINT * , \"** ERROR! Directory \" , TRIM ( spacetime_path ), \" does not exist!\" PRINT * , \"   Please create it and re-run the executable. Stopping...\" STOP ENDIF #endif ! Allocate needed memory !ALLOCATE( binaries      ( n_bns ) ) !ALLOCATE( diffrotstars  ( n_bns ) ) IF ( TRIM ( system ) == \"BNS\" ) THEN ALLOCATE ( bnslorene :: idata ( n_bns ) ) ELSEIF ( TRIM ( system ) == \"DRS\" ) THEN ALLOCATE ( diffstarlorene :: idata ( n_bns ) ) ELSE PRINT * , \"** ERROR! Unknown name for the physical system: \" , TRIM ( system ) PRINT * , \"   Set the variable 'system' in the parameter file \" , & \"sphincs_lorene_parameters.par to one of the values listed there.\" PRINT * , \"   Stopping...\" PRINT * STOP ENDIF ALLOCATE ( particles_dist ( n_bns , max_n_parts ) ) ALLOCATE ( bssn_forms ( n_bns ) ) ! !-- Construct the LORENE ID from the LORENE binary files ! ! build_bns_loop: DO itr= 1, n_bns, 1 !   binaries( itr )= bnslorene( TRIM(common_path)//TRIM(filenames( itr )) ) !   ! Set the variables to decide on using the geodesic gauge or not !   ! (lapse=1, shift=0) !   binaries( itr )% one_lapse = one_lapse !   binaries( itr )% zero_shift= zero_shift ! ENDDO build_bns_loop build_drs_loop : DO itr = 1 , n_bns , 1 idata ( itr ) = diffstarlorene ( TRIM ( common_path ) // TRIM ( filenames ( itr )) ) ! Set the variables to decide on using the geodesic gauge or not ! (lapse=1, shift=0) CALL idata ( itr )% set_one_lapse ( one_lapse ) CALL idata ( itr )% set_zero_shift ( zero_shift ) ENDDO build_drs_loop !STOP IF ( run_sph ) THEN ! !-- Construct the particles objects from the bns objects ! place_hydro_id_loops : DO itr3 = 1 , n_bns , 1 part_distribution_loop : DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT part_distribution_loop ELSE PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Placing particles for \" // TRIM ( system ), itr3 , & \", distribution\" , itr4 PRINT * , \"===================================================\" & // \"===============\" PRINT * particles_dist ( itr3 , itr4 ) = particles ( idata ( itr3 ), & placer ( itr3 , itr4 ) ) ENDIF ENDDO part_distribution_loop ENDDO place_hydro_id_loops !STOP compute_export_sph_loops : DO itr3 = 1 , n_bns , 1 part_distribution_loop2 : DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT part_distribution_loop2 ! Experimental: empty particles object !particles_dist( itr, itr2 )= particles() ELSE PRINT * , \"===================================================\" & // \"=====================\" PRINT * , \" Computing SPH variables for \" // TRIM ( system ), itr3 , & \", distribution\" , itr4 PRINT * , \"===================================================\" & // \"=====================\" PRINT * !WRITE( namefile_parts_bin, \"(A1,I1,A1,I1,A1)\" ) & !                            \"l\", & !                            itr3, \"-\", itr4, \".\" IF ( TRIM ( system ) == \"BNS\" ) WRITE ( namefile_parts_bin , \"(A5)\" ) \"NSNS.\" IF ( TRIM ( system ) == \"DRS\" ) WRITE ( namefile_parts_bin , \"(A5)\" ) \"DRSx.\" namefile_parts_bin = TRIM ( sph_path ) // TRIM ( namefile_parts_bin ) particles_dist ( itr3 , itr4 )% export_bin = export_bin particles_dist ( itr3 , itr4 )% export_form_xy = export_form_xy particles_dist ( itr3 , itr4 )% export_form_x = export_form_x CALL particles_dist ( itr3 , itr4 )% & compute_and_export_SPH_variables ( namefile_parts_bin ) !IF( particles_dist( itr3, itr4 )% export_bin )THEN !  WRITE( namefile_parts, \"(A10,I1,A1,I1,A4)\" ) & !                  \"sph_vars-\", itr3, \"-\", itr4, \".dat\" !  CALL particles_dist( itr3, itr4 )% & !                  read_sphincs_dump_print_formatted( & !                                namefile_parts_bin, namefile_parts ) !ENDIF ENDIF ENDDO part_distribution_loop2 ENDDO compute_export_sph_loops ! !-- Print the particle initial data to a formatted file ! IF ( export_form ) THEN export_sph_loops : DO itr3 = 1 , n_bns , 1 DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT ! Experimental: empty particles object !particles_dist( itr, itr2 )= particles() ELSE WRITE ( namefile_parts , \"(A29,I1,A1,I1,A4)\" ) & \"lorene-bns-id-particles-form_\" , & itr3 , \"-\" , itr4 , \".dat\" namefile_parts = TRIM ( sph_path ) // TRIM ( namefile_parts ) CALL particles_dist ( itr3 , itr4 )% & print_formatted_lorene_id_particles ( namefile_parts ) ENDIF ENDDO ENDDO export_sph_loops ENDIF !PRINT *, \"===================================================\" & !         // \"================================================\" !PRINT *, \" Timing \" !PRINT *, \"===================================================\" & !         // \"================================================\" !PRINT * !PRINT * !PRINT *, \" * SPH:\" !CALL particles_dist( 1, 1 )% placer_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% apm1_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% apm2_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% importer_timer% print_timer( 2 ) !CALL particles_dist( 1, 1 )% sph_computer_timer% print_timer( 2 ) !PRINT * ENDIF IF ( run_spacetime ) THEN ! !-- Construct the bssn_id objects from the bns objects ! place_spacetime_id_loop : DO itr3 = 1 , n_bns , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Setting up BSSN object for \" // TRIM ( system ), itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * bssn_forms ( itr3 ) = bssn_id ( idata ( itr3 ) ) ENDDO place_spacetime_id_loop ! !-- Compute the BSSN initial data, optionally export it to a binary file !-- readable by SPHINCS_BSSN, and optionally read the content of such binary !-- file and print it to a formatted file (the latter for debugging) ! compute_export_bssn_loop : DO itr3 = 1 , n_bns , 1 PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN variables for \" // TRIM ( system ), itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn_bin , \"(A15)\" ) \"BSSN_vars.00000\" !\"BSSN_l\", itr3, \".bin\"\"(A6,I1,A4)\" namefile_bssn_bin = TRIM ( spacetime_path ) // TRIM ( namefile_bssn_bin ) bssn_forms ( itr3 )% export_form_xy = export_form_xy bssn_forms ( itr3 )% export_form_x = export_form_x bssn_forms ( itr3 )% export_bin = export_bin CALL bssn_forms ( itr3 )% & compute_and_export_3p1_variables ( namefile_bssn_bin ) !IF( bssn_forms( itr3 )% export_bin )THEN !  WRITE( namefile_bssn, \"(A10,I1,A4)\" ) \"bssn_vars-\", itr3, \".dat\" !  CALL bssn_forms( itr3 )% & !        read_bssn_dump_print_formatted( namefile_bssn_bin, namefile_bssn ) !ENDIF ENDDO compute_export_bssn_loop ! !-- Print the BSSN initial data to a formatted file ! IF ( export_form ) THEN export_bssn_loop : DO itr3 = 1 , n_bns , 1 WRITE ( namefile_bssn , \"(A24,I1,A4)\" ) & \"lorene-bns-id-bssn-form_\" , itr3 , \".dat\" namefile_bssn = TRIM ( spacetime_path ) // TRIM ( namefile_bssn ) CALL bssn_forms ( itr3 )% & print_formatted_lorene_id_3p1_variables ( namefile_bssn ) ENDDO export_bssn_loop ENDIF ! !-- Compute the BSSN constraints ! compute_export_bssn_constraints_loop : DO itr3 = 1 , n_bns , 1 bssn_forms ( itr3 )% cons_step = constraints_step bssn_forms ( itr3 )% export_constraints = export_constraints bssn_forms ( itr3 )% export_constraints_details = & export_constraints_details bssn_forms ( itr3 )% export_constraints_xy = export_constraints_xy bssn_forms ( itr3 )% export_constraints_x = export_constraints_x IF ( compute_constraints ) THEN PRINT * , \"===================================================\" & // \"===============\" PRINT * , \" Computing BSSN constraints for BSSN formulation\" , itr3 PRINT * , \"===================================================\" & // \"===============\" PRINT * WRITE ( namefile_bssn , \"(A17,I1,A4)\" ) \"bssn-constraints-\" , itr3 , & \".dat\" WRITE ( name_logfile , \"(A28,I1)\" ) & \"bssn-constraints-statistics-\" , itr3 namefile_bssn = TRIM ( spacetime_path ) // TRIM ( namefile_bssn ) name_logfile = TRIM ( spacetime_path ) // TRIM ( name_logfile ) CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( idata ( itr3 ), & namefile_bssn , & name_logfile ) ENDIF part_distribution_loop3 : DO itr4 = 1 , max_n_parts , 1 IF ( placer ( itr3 , itr4 ) == test_int ) THEN EXIT ! Experimental: empty particles object !particles_dist( itr, itr2 )= particles() ELSE IF ( compute_parts_constraints . AND . run_sph ) THEN PRINT * , \"===================================================\" & // \"================================================\" PRINT * , \" Computing BSSN constraints for BSSN\" , & \" formulation\" , itr3 , \"with particle distribution\" , itr4 PRINT * , \"===================================================\" & // \"================================================\" PRINT * WRITE ( namefile_bssn , \"(A23,I1,A1,I1,A4)\" ) & \"bssn-constraints-parts-\" , & itr3 , \"-\" , itr4 , \".dat\" WRITE ( namefile_sph , \"(A12,I1,A1,I1,A4)\" ) \"sph-density-\" , itr3 , & \"-\" , itr4 , \".dat\" WRITE ( name_logfile , \"(A34,I1,A1,I1,A4)\" ) & \"bssn-constraints-parts-statistics-\" , itr3 , & \"-\" , itr4 namefile_bssn = TRIM ( spacetime_path ) // TRIM ( namefile_bssn ) namefile_sph = TRIM ( sph_path ) // TRIM ( namefile_sph ) name_logfile = TRIM ( spacetime_path ) // TRIM ( name_logfile ) CALL bssn_forms ( itr3 )% & compute_and_export_3p1_constraints ( & particles_dist ( itr3 , itr4 ), & namefile_bssn , & name_logfile ) ENDIF ENDIF ENDDO part_distribution_loop3 ENDDO compute_export_bssn_constraints_loop ENDIF CALL execution_timer % stop_timer () CALL DATE_AND_TIME ( date , time , zone , values ) end_time = date // \"-\" // time ! !-- Print the timers ! PRINT * , \"===================================================\" & // \"================================================\" PRINT * , \" Timing \" PRINT * , \"===================================================\" & // \"================================================\" PRINT * PRINT * , \" * LORENE:\" CALL idata ( 1 )% construction_timer % print_timer ( 2 ) PRINT * IF ( run_sph ) THEN PRINT * , \" * SPH:\" CALL particles_dist ( 1 , 1 )% placer_timer % print_timer ( 2 ) CALL particles_dist ( 1 , 1 )% same_particle_timer % print_timer ( 2 ) DO i_matter = 1 , idata ( 1 )% get_n_matter (), 1 CALL particles_dist ( 1 , 1 )% apm_timers ( i_matter )% print_timer ( 2 ) ENDDO CALL particles_dist ( 1 , 1 )% importer_timer % print_timer ( 2 ) CALL particles_dist ( 1 , 1 )% sph_computer_timer % print_timer ( 2 ) PRINT * ENDIF IF ( run_spacetime ) THEN PRINT * , \" * Spacetime:\" CALL bssn_forms ( 1 )% grid_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% importer_timer % print_timer ( 2 ) CALL bssn_forms ( 1 )% bssn_computer_timer % print_timer ( 2 ) PRINT * ENDIF PRINT * , \" * Total:\" CALL execution_timer % print_timer ( 2 ) PRINT * ! !-- Print a summary ! PRINT * , \"===================================================\" & // \"================================================\" PRINT * , \" Summary \" PRINT * , \"===================================================\" & // \"================================================\" PRINT * PRINT * , \" * Binary system of neutron stars:\" PRINT * PRINT * , \"   Used binary file produced by LORENE: \" & // TRIM ( common_path ) // TRIM ( filenames ( 1 )) PRINT * !DO i_matter= 1, idata(1)% get_n_matter(), 1 !  PRINT *, \"   Baryon mass of matter object \", i_matter, \"=\", & !           idata( 1 )% return_mass(i_matter), \"Msun\" !  !PRINT *, \"   Gravitational mass of object \", i_matter, \"=\", & !  !         idata( 1 )% get_grav_mass(i_matter), \"Msun\" !ENDDO !PRINT * !PRINT *, \"   Equatorial (not areal) radius of neutron star 1 towards \" & !         // \"companion= \", & !             binaries( 1 )% get_radius1_x_comp(), \"Msun_geo\" !PRINT *, \"   Equatorial (not areal) radius of neutron star 2 towards \" & !         // \"companion= \", & !             binaries( 1 )% get_radius2_x_comp(), \"Msun_geo\" !PRINT *, \"   Equatorial (not areal) radius of neutron star 1 opposite to \" & !         // \"companion= \", & !             binaries( 1 )% get_radius1_x_opp(), \"Msun_geo\" !PRINT *, \"   Equatorial (not areal) radius of neutron star 2 opposite to \" & !         // \"companion= \", & !             binaries( 1 )% get_radius2_x_opp(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 1= \", & !             binaries( 1 )% get_radius1_y(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 2= \", & !             binaries( 1 )% get_radius2_y(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 1= \", & !             binaries( 1 )% get_radius1_z(), \"Msun_geo\" !PRINT *, \"   Radius (not areal) along y of neutron star 2= \", & !             binaries( 1 )% get_radius2_z(), \"Msun_geo\" !PRINT * !PRINT *, \"   EOS for neutron star 1= \", & !             binaries( 1 )% get_eos1() !PRINT *, \"   EOS for neutron star 2= \", & !             binaries( 1 )% get_eos2() !PRINT * !PRINT *, \"   Central baryon mass density for star 1= \", & !             binaries( 1 )% get_rho_center1(), \"Msun/Msun_geo**3= \", & !             binaries( 1 )% get_rho_center1() & !             /lorene2hydrobase*kg2g/(m2cm**3), \"g cm&#94;{-3}\" !PRINT *, \"   Central baryon mass density for star 2= \", & !             binaries( 1 )% get_rho_center2(), \"Msun/Msun_geo**3= \", & !             binaries( 1 )% get_rho_center2() & !             /lorene2hydrobase*kg2g/(m2cm**3), \"g cm&#94;{-3}\" !PRINT * IF ( run_sph ) THEN PRINT * , \" * SPH:\" PRINT * PRINT * , \"   Total particle number= \" , particles_dist ( 1 , 1 )% get_npart () ! PRINT *, \"   Particle number on star 1: npart1=\", & !                                       particles_dist( 1, 1 )% get_npart1() ! PRINT *, \"   Particle number on star 2: npart2=\", & !                                       particles_dist( 1, 1 )% get_npart2() ! PRINT *, \"   Particle number ratio: npart1/npart2= \", & !                         DBLE(particles_dist( 1, 1 )% get_npart1()) & !                        /DBLE(particles_dist( 1, 1 )% get_npart2()) ! PRINT *, \"   Star mass ratio: mass1/mass2= \", & !                        binaries( 1 )% get_mass1()/binaries( 1 )% get_mass2() ! PRINT * ! PRINT *, \"   Baryon number ratio over both stars=\", & !          particles_dist( 1, 1 )% get_nuratio() ! PRINT *, \"   Baryon number ratio on star 1=\", & !          particles_dist( 1, 1 )% get_nuratio1() ! PRINT *, \"   Baryon number ratio on star 2=\", & !          particles_dist( 1, 1 )% get_nuratio2() ! PRINT * ENDIF IF ( run_spacetime ) THEN PRINT * , \" * Spacetime:\" PRINT * PRINT * , \"   Number of refinement levels= \" , bssn_forms ( 1 )% get_nlevels () PRINT * PRINT * , \"   Number of grid points on each level= \" , & bssn_forms ( 1 )% get_ngrid_x ( 1 ), \"**3\" PRINT * DO itr = 1 , bssn_forms ( 1 )% get_nlevels (), 1 PRINT * , \"   Resolution on level \" , itr , \"= \" , & bssn_forms ( 1 )% get_dx ( itr ) ENDDO PRINT * DO itr = 1 , bssn_forms ( 1 )% get_nlevels (), 1 PRINT * , \"   x boundary of level \" , itr , \"= \" , & bssn_forms ( 1 )% get_xR ( itr ) PRINT * , \"   y boundary of level \" , itr , \"= \" , & bssn_forms ( 1 )% get_yR ( itr ) PRINT * , \"   z boundary of level \" , itr , \"= \" , & bssn_forms ( 1 )% get_zR ( itr ) !bssn_forms( 1 )% get_dx(itr)* & !(bssn_forms( 1 )% get_ngrid_x(itr)-2.0D0)/2.0D0, \"Msun_geo= \", & !bssn_forms( 1 )% get_dx(itr)* & !(bssn_forms( 1 )% get_ngrid_x(itr)-2.0D0)/2.0D0*Msun_geo, \"km \" ENDDO PRINT * last_level = bssn_forms ( 1 )% get_nlevels () !PRINT *, \"   Number of grid points across the x-axis-diameter of star 1=\", & !         FLOOR( ( binaries( 1 )% get_radius1_x_comp() + & !         binaries( 1 )% get_radius1_x_opp() ) & !         /bssn_forms( 1 )% get_dx( last_level ) ) !PRINT *, \"   Number of grid points across the x-axis-diameter of star 2=\", & !         FLOOR( ( binaries( 1 )% get_radius2_x_comp() + & !        binaries( 1 )% get_radius2_x_opp() ) & !        /bssn_forms( 1 )% get_dx( last_level ) ) !PRINT * ENDIF PRINT * , \"** Run started on \" , run_id , \" and ended on \" , end_time PRINT * ! !-- Deallocate memory ! DO itr = 1 , n_bns , 1 ! !-- Destruct the LORENE Bin_NS object by hand, since the pointer to it is !-- global (because it is bound to C++) and cannot be nullified by the !-- destructor of bns. In case of multiple bns objects, this would lead !-- to problems... !-- TODO: fix this ! !CALL binaries( itr )% destruct_binary() ENDDO IF ( ALLOCATED ( binaries ) ) THEN DEALLOCATE ( binaries ) ENDIF IF ( ALLOCATED ( idata ) ) THEN DEALLOCATE ( idata ) ENDIF IF ( ALLOCATED ( particles_dist ) ) THEN DEALLOCATE ( particles_dist ) ENDIF IF ( ALLOCATED ( bssn_forms ) ) THEN DEALLOCATE ( bssn_forms ) ENDIF CONTAINS SUBROUTINE read_bns_id_parameters () IMPLICIT NONE INTEGER :: stat CHARACTER ( LEN = : ), ALLOCATABLE :: lorene_bns_id_parameters CHARACTER ( LEN = 100 ) :: msg lorene_bns_id_parameters = 'sphincs_lorene_bns_parameters.par' INQUIRE ( FILE = lorene_bns_id_parameters , EXIST = file_exists ) IF ( file_exists ) THEN OPEN ( 17 , FILE = lorene_bns_id_parameters , STATUS = 'OLD' ) ELSE PRINT * PRINT * , '** ERROR: ' , lorene_bns_id_parameters , \" file not found!\" PRINT * STOP ENDIF READ ( 17 , NML = bns_parameters , IOSTAT = stat , IOMSG = msg ) IF ( stat /= 0 ) THEN PRINT * , \"** ERROR: Error in reading \" , lorene_bns_id_parameters ,& \". The IOSTAT variable is \" , stat , & \"The error message is\" , msg STOP ENDIF CLOSE ( 17 ) DO itr = 1 , max_length , 1 IF ( TRIM ( filenames ( itr )). NE . \"0\" ) THEN cnt = cnt + 1 ENDIF ENDDO IF ( cnt . NE . n_bns ) THEN PRINT * , \"** ERROR! The number of file names is\" , cnt , & \"and n_bns=\" , n_bns , \". The two should be the same.\" PRINT * STOP ENDIF !DO itr= 1, n_bns, 1 !  DO itr2= 1, max_n_parts, 1 !    IF( placer( itr, itr2 ) == test_int )THEN !      PRINT * !      PRINT *, \"** ERROR! The array placer does not have \", & !               \"enough components to specify all the desired \", & !               \"particle distributions. Specify the \", & !               \"components in file lorene_bns_id_particles.par\" !      PRINT * !      STOP !    ENDIF !  ENDDO !ENDDO END SUBROUTINE END PROGRAM sphincs_lorene_bns","tags":"","loc":"program/sphincs_lorene_bns.html"},{"title":"More – SPHINCS_LORENE","text":"Some introduction","tags":"","loc":"page//index.html"},{"title":"Definitions – SPHINCS_LORENE","text":"Some definitions","tags":"","loc":"page/./definitions.html"},{"title":"Theoretical background – SPHINCS_LORENE","text":"Some theoretical motivation","tags":"","loc":"page/theory/index.html"},{"title":"Smoothed particle hydrodynamics (SPH) – SPHINCS_LORENE","text":"Some theory about SPH","tags":"","loc":"page/theory/sph.html"},{"title":"Numerical Relativity (NR) – SPHINCS_LORENE","text":"Some theory about NR","tags":"","loc":"page/theory/numerical-relativity.html"}]}